/* Copyright 2025 The OpenXLA Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include <cstddef>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <memory>
#include <optional>
#include <sstream>
#include <string>
#include <utility>

#include "llvm/ADT/StringRef.h"
#include "llvm/Object/ObjectFile.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/MemoryBuffer.h"

namespace {

struct Args {
  std::string input_path;
  std::string output_path;
  std::string variable_name;
  std::string namespace_name;
};

std::optional<Args> ParseArgs(int argc, char* argv[]) {
  if (argc != 5) {
    return std::nullopt;
  }
  return Args{argv[1], argv[2], argv[3], argv[4]};
}

llvm::StringRef ExtractBitcodeContent(const llvm::MemoryBuffer& buffer) {
  llvm::StringRef content = buffer.getBuffer();

  // Try to parse as object file to find embedded bitcode
  llvm::Expected<std::unique_ptr<llvm::object::ObjectFile>> obj_or_err =
      llvm::object::ObjectFile::createObjectFile(buffer.getMemBufferRef());

  if (obj_or_err) {
    std::unique_ptr<llvm::object::ObjectFile> obj = std::move(obj_or_err.get());
    for (const auto& section : obj->sections()) {
      llvm::Expected<llvm::StringRef> name_or_err = section.getName();
      if (!name_or_err) {
        llvm::consumeError(name_or_err.takeError());
        continue;
      }
      if (*name_or_err == ".llvmbc") {
        llvm::Expected<llvm::StringRef> data_or_err = section.getContents();
        if (!data_or_err) {
          llvm::consumeError(data_or_err.takeError());
          continue;
        }
        content = *data_or_err;
        break;
      }
    }
  } else {
    // Not an object file, check if it's potentially an empty file produced by
    // conditional compilation (e.g. valid empty object).
    // If the input is indeed empty or not an object file, we treat it as
    // empty bitcode.
    llvm::consumeError(obj_or_err.takeError());
    if (content.size() > 0 && content.size() < 4) {
      // Too small to be valid bitcode or object file, ignore.
      content = llvm::StringRef();
    }
  }
  return content;
}

std::string GenerateOutputContent(llvm::StringRef content, const Args& args) {
  std::ostringstream os;

  os << "#pragma once\n\n";
  os << "// This file is generated by the cc_to_llvm_ir rule. "
        "Do not edit.\n\n";
  os << "#include <string>\n\n";
  os << "namespace " << args.namespace_name << " {\n\n";
  os << "// LLVM Bitcode compiled for the current architecture\n";

  std::string data_var = args.variable_name + "_data";
  os << "inline constexpr unsigned char " << data_var << "[] = {";

  // Output hex dump
  if (content.empty()) {
    // C++ doesn't allow zero-sized arrays, so we add a dummy byte.
    os << "0x00";
  } else {
    os << std::hex << std::setfill('0');
    // llvm::StringRef::iterator is char* or const char*
    size_t i = 0;
    for (unsigned char c : content) {
      if (i % 12 == 0) {
        os << "\n  ";
      }
      os << "0x" << std::setw(2) << (static_cast<unsigned int>(c) & 0xFF)
         << ", ";
      ++i;
    }
  }
  os << "\n};\n\n";

  // std::string wrapper (interpreting bytes as chars)
  // If content is empty, size is 0, so we construct an empty string.
  os << "inline const std::string " << args.variable_name
     << "(reinterpret_cast<const char*>(" << data_var << "), " << std::dec
     << content.size() << ");\n\n";  // Use actual content size (0 if empty)

  os << "}  // namespace " << args.namespace_name << "\n";

  return os.str();
}

}  // namespace

int main(int argc, char* argv[]) {
  std::optional<Args> args = ParseArgs(argc, argv);
  if (!args) {
    std::cerr
        << "Usage: " << argv[0]
        << " <input_file> <output_header_file> <variable_name> <namespace>"
        << std::endl;
    return 1;
  }

  auto buffer_or_err = llvm::MemoryBuffer::getFile(args->input_path);
  if (!buffer_or_err) {
    std::cerr << "Error: Could not open input file " << args->input_path << ": "
              << buffer_or_err.getError().message() << std::endl;
    return 1;
  }
  std::unique_ptr<llvm::MemoryBuffer> buffer = std::move(buffer_or_err.get());

  llvm::StringRef content = ExtractBitcodeContent(*buffer);

  std::string output_content = GenerateOutputContent(content, *args);

  std::ofstream output_file(args->output_path);
  if (!output_file) {
    std::cerr << "Error: Could not open output file " << args->output_path
              << std::endl;
    return 1;
  }

  output_file << output_content;
  output_file.close();

  return 0;
}
