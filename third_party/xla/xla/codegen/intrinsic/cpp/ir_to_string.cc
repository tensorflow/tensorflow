/* Copyright 2025 The OpenXLA Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include <cstddef>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

int main(int argc, char* argv[]) {
  if (argc != 5) {
    std::cerr
        << "Usage: " << argv[0]
        << " <input_file> <output_header_file> <variable_name> <namespace>"
        << std::endl;
    return 1;
  }

  const std::string input_path = argv[1];
  const std::string output_path = argv[2];
  const std::string variable_name = argv[3];
  const std::string namespace_name = argv[4];

  std::ifstream input_file(input_path, std::ios::binary);
  if (!input_file) {
    std::cerr << "Error: Could not open input file " << input_path << std::endl;
    return 1;
  }

  std::stringstream buffer;
  buffer << input_file.rdbuf();
  std::string content = buffer.str();
  input_file.close();

  std::ofstream output_file(output_path);
  if (!output_file) {
    std::cerr << "Error: Could not open output file " << output_path
              << std::endl;
    return 1;
  }

  output_file << "#pragma once\n\n";
  output_file << "// This file is generated by the cc_to_llvm_ir rule. "
                 "Do not edit.\n\n";
  output_file << "#include <string>\n\n";
  output_file << "namespace " << namespace_name << " {\n\n";
  output_file << "// LLVM Bitcode compiled for the current architecture\n";

  std::string data_var = variable_name + "_data";
  output_file << "inline constexpr unsigned char " << data_var << "[] = {";

  // Output hex dump
  if (content.empty()) {
    // C++ doesn't allow zero-sized arrays, so we add a dummy byte.
    output_file << "0x00";
  } else {
    output_file << std::hex << std::setfill('0');
    for (size_t i = 0; i < content.size(); ++i) {
      if (i % 12 == 0) {
        output_file << "\n  ";
      }
      output_file << "0x" << std::setw(2)
                  << (static_cast<unsigned int>(content[i]) & 0xFF) << ", ";
    }
  }
  output_file << "\n};\n\n";

  // std::string wrapper (interpreting bytes as chars)
  // If content is empty, size is 0, so we construct an empty string.
  output_file << "inline const std::string " << variable_name
              << "(reinterpret_cast<const char*>(" << data_var << "), "
              << std::dec << content.size()
              << ");\n\n";  // Use actual content size (0 if empty)

  output_file << "}  // namespace " << namespace_name << "\n";

  output_file.close();
  return 0;
}
