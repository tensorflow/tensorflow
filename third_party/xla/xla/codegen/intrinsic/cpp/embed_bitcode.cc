/* Copyright 2025 The OpenXLA Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include <cstdint>
#include <fstream>
#include <iostream>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <vector>

#include "absl/types/span.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Object/ObjectFile.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/TargetSelect.h"
#include "third_party/tensorflow/compiler/aot/embedded_constant_buffers.h"

namespace {

using tensorflow::tfcompile::ConstantToEmbed;
using tensorflow::tfcompile::CreateEmbeddedConstantBuffers;
using tensorflow::tfcompile::EmbeddedConstantBuffers;

struct Args {
  std::string input_path;
  std::string output_header_path;
  std::string output_object_path;
  std::string variable_name;
  std::string namespace_name;
  std::string target_triple;
};

std::optional<Args> ParseArgs(int argc, char* argv[]) {
  if (argc != 7) {
    return std::nullopt;
  }
  return Args{argv[1], argv[2], argv[3], argv[4], argv[5], argv[6]};
}

llvm::StringRef ExtractBitcodeContent(const llvm::MemoryBuffer& buffer) {
  llvm::StringRef content = buffer.getBuffer();

  // Try to parse as object file to find embedded bitcode
  llvm::Expected<std::unique_ptr<llvm::object::ObjectFile>> obj_or_err =
      llvm::object::ObjectFile::createObjectFile(buffer.getMemBufferRef());

  if (obj_or_err) {
    // Reset to empty to avoid returning a binary blob if we fail to parse.
    content = llvm::StringRef();

    std::unique_ptr<llvm::object::ObjectFile> obj = std::move(obj_or_err.get());
    for (const auto& section : obj->sections()) {
      llvm::Expected<llvm::StringRef> name_or_err = section.getName();
      if (!name_or_err) {
        llvm::consumeError(name_or_err.takeError());
        continue;
      }
      if (*name_or_err == ".llvmbc" || *name_or_err == "__LLVM,__bitcode") {
        llvm::Expected<llvm::StringRef> data_or_err = section.getContents();
        if (!data_or_err) {
          llvm::consumeError(data_or_err.takeError());
          continue;
        }
        content = *data_or_err;
        break;
      }
    }
  } else {
    // Not an object file, check if it's potentially an empty file produced by
    // conditional compilation (e.g. valid empty object).
    // If the input is indeed empty or not an object file, we treat it as
    // empty bitcode.
    llvm::consumeError(obj_or_err.takeError());
    if (content.size() > 0 && content.size() < 4) {
      // Too small to be valid bitcode or object file, ignore.
      content = llvm::StringRef();
    }
  }
  return content;
}

std::string GenerateHeaderContent(const EmbeddedConstantBuffers& buffers,
                                  const Args& args) {
  std::ostringstream os;

  os << "#pragma once\n\n";
  os << "// This file is generated by the cc_to_llvm_ir rule. "
        "Do not edit.\n\n";
  os << "#include <string>\n\n";
  os << "namespace " << args.namespace_name << " {\n\n";
  os << "// LLVM Bitcode compiled for the current architecture\n";

  // We should have exactly one variable.
  if (buffers.variable_decls.empty()) {
    // If empty bitcode, just provide an empty string wrapper.
    // But strictly speaking, the symbol won't exist in the object file?
    // Actually CreateEmbeddedConstantBuffers might return empty if no
    // constants. For now, let's assume if there's content, we get a variable.
    // If empty, we can just define the access shim to return empty.
    os << "inline const std::string " << args.variable_name
       << "(nullptr, 0);\n\n";
  } else {
    const auto& var = buffers.variable_decls[0];
    os << var.variable_decl << "\n\n";
    // The shim returns {size, ptr}. We want a string.
    // var.cpp_access_shim is a lambda call that returns pair<uint64_t, char*>.
    // We can wrap it.
    os << "inline const std::string " << args.variable_name << " = []() {\n";
    os << "  auto [size, ptr] = " << var.cpp_access_shim << ";\n";
    os << "  return std::string(ptr, size);\n";
    os << "}();\n\n";
  }

  os << "}  // namespace " << args.namespace_name << "\n";

  return os.str();
}

}  // namespace

int main(int argc, char* argv[]) {
  // Initialize X86
  LLVMInitializeX86Target();
  LLVMInitializeX86TargetInfo();
  LLVMInitializeX86TargetMC();
  LLVMInitializeX86AsmPrinter();
  LLVMInitializeX86AsmParser();

  // Initialize AArch64
  LLVMInitializeAArch64Target();
  LLVMInitializeAArch64TargetInfo();
  LLVMInitializeAArch64TargetMC();
  LLVMInitializeAArch64AsmPrinter();
  LLVMInitializeAArch64AsmParser();

  // Initialize ARM
  LLVMInitializeARMTarget();
  LLVMInitializeARMTargetInfo();
  LLVMInitializeARMTargetMC();
  LLVMInitializeARMAsmPrinter();
  LLVMInitializeARMAsmParser();

  std::optional<Args> args = ParseArgs(argc, argv);
  if (!args) {
    std::cerr << "Usage: " << argv[0]
              << " <input_file> <output_header_file> <output_object_file> "
                 "<variable_name> <namespace> <target_triple>"
              << std::endl;
    return 1;
  }

  auto buffer_or_err = llvm::MemoryBuffer::getFile(args->input_path);
  if (!buffer_or_err) {
    std::cerr << "Error: Could not open input file " << args->input_path << ": "
              << buffer_or_err.getError().message() << std::endl;
    return 1;
  }
  std::unique_ptr<llvm::MemoryBuffer> buffer = std::move(buffer_or_err.get());

  llvm::StringRef content = ExtractBitcodeContent(*buffer);

  std::vector<ConstantToEmbed> constants;
  if (!content.empty()) {
    ConstantToEmbed constant;
    constant.symbol_prefix =
        args->variable_name;  // Use variable name as prefix
    constant.SerializeIntoBuffer(absl::Span<const uint8_t>(
        reinterpret_cast<const uint8_t*>(content.data()), content.size()));
    constants.push_back(std::move(constant));
  }

  // Generate Object File
  auto buffers_or_err = CreateEmbeddedConstantBuffers(
      args->target_triple, absl::MakeSpan(constants));
  if (!buffers_or_err.ok()) {
    std::cerr << "Error creating embedded constant buffers: "
              << buffers_or_err.status() << std::endl;
    return 1;
  }
  const EmbeddedConstantBuffers& buffers = buffers_or_err.value();

  std::ofstream output_object_file(args->output_object_path, std::ios::binary);
  if (!output_object_file) {
    std::cerr << "Error: Could not open output object file "
              << args->output_object_path << std::endl;
    return 1;
  }
  output_object_file.write(buffers.object_file_data.data(),
                           buffers.object_file_data.size());
  output_object_file.close();

  // Generate Header File
  std::string header_content = GenerateHeaderContent(buffers, *args);
  std::ofstream output_header_file(args->output_header_path);
  if (!output_header_file) {
    std::cerr << "Error: Could not open output header file "
              << args->output_header_path << std::endl;
    return 1;
  }
  output_header_file << header_content;
  output_header_file.close();

  return 0;
}
