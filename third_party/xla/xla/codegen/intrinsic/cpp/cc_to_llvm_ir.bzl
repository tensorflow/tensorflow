"""
A rule to compile a C++ file to a header containing LLVM IR.
"""

load("@rules_cc//cc:find_cc_toolchain.bzl", "find_cc_toolchain", "use_cc_toolchain")
load("@rules_cc//cc/common:cc_common.bzl", "cc_common")
load("@rules_cc//cc/common:cc_info.bzl", "CcInfo")
load("//xla/tsl:package_groups.bzl", "DEFAULT_LOAD_VISIBILITY")
load("//xla/tsl/platform:rules_cc.bzl", "cc_library")

visibility(DEFAULT_LOAD_VISIBILITY)

def to_camel_case(s):
    """Converts a snake_case or kebab-case string to CamelCase."""
    s_with_underscores = s.replace("-", "_")
    return "".join([p.capitalize() for p in s_with_underscores.split("_")])

def _cc_ir_header_impl(ctx):
    """Rule implementation that generates IR for multiple features and embeds them in a header."""
    cc_toolchain = find_cc_toolchain(ctx)
    feature_configuration = cc_common.configure_features(
        ctx = ctx,
        cc_toolchain = cc_toolchain,
    )
    compilation_contexts = [dep[CcInfo].compilation_context for dep in ctx.attr.deps]
    output_header = ctx.outputs.out_header

    cxx_flags = [
        "-S",
        "-emit-llvm",
        "-O3",
        "-DNDEBUG",
        "-mprefer-vector-width=512",
        "-DEIGEN_VECTORIZE_GENERIC",
        "-fno-sanitize=all",
        "-fno-stack-protector",
        "-fno-coverage-mapping",
        "-fno-profile-instr-generate",
    ]

    compilation_outputs = cc_common.compile(
        actions = ctx.actions,
        feature_configuration = feature_configuration,
        cc_toolchain = cc_toolchain,
        srcs = ctx.files.src,
        compilation_contexts = compilation_contexts,
        cxx_flags = cxx_flags,
        name = "{}_compiler".format(ctx.label.name),
    )

    # Windows builds may produce objects and not pic_objects.
    # We accept either, preferring pic_objects if available.
    objs = compilation_outputs[1].pic_objects
    if not objs:
        objs = compilation_outputs[1].objects
        if not objs:
            objs_str = ""
            for objs in compilation_outputs:
                objs_str += "\n"
                for obj in objs:
                    objs_str += ", " + str(obj)
            fail("No objects found in compilation_outputs. Compilation outputs: {}".format(objs_str))

    temp_ir_output = objs[0]

    # Generate the final C++ header file.
    # We use a python one-liner to perform a binary-safe copy.
    # 1. 'wb' mode writes the C++ preamble.
    # 2. We read the input as binary ('rb').
    # 3. We check for the UTF-8 BOM (\xef\xbb\xbf) and strip it if present.
    #    NOTE: We use double backslashes (\\x) so Starlark passes the literal characters
    #    to Python, allowing Python to interpret the hex escape sequence.
    # 4. We append the rest of the file and the C++ closing syntax.
    ctx.actions.run_shell(
        inputs = [temp_ir_output],
        outputs = [output_header],
        mnemonic = "EmbeddingLLVMIR",
        command = """
set -e
input_path=$1
output_path=$2
variable_name=$3
namespace=$4

# 1. Write the header start
cat <<EOF > "$output_path"
#pragma once

// Generated by cc_ir_header rule. DO NOT EDIT.

namespace $namespace {

inline constexpr char ${variable_name}[] = R"IR(
EOF

# 2. Append the IR content using Python for binary safety and BOM stripping.
python -c "import sys; d = open(sys.argv[1], 'rb').read(); d = d[3:] if d.startswith(b'\\xef\\xbb\\xbf') else d; open(sys.argv[2], 'ab').write(d)" "$input_path" "$output_path"

# 3. Append the header end
cat <<EOF >> "$output_path"
)IR";

} // namespace $namespace
EOF
""",
        arguments = [
            temp_ir_output.path,
            output_header.path,
            "k{}Ir".format(to_camel_case(ctx.attr.base_name)),
            ctx.attr.namespace,
        ],
    )

    compilation_context = cc_common.create_compilation_context(headers = depset([output_header]))
    cc_info = CcInfo(compilation_context = compilation_context)

    return [DefaultInfo(files = depset([output_header])), cc_info]

_cc_ir_header_rule = rule(
    implementation = _cc_ir_header_impl,
    attrs = {
        "src": attr.label(
            allow_single_file = True,
            mandatory = True,
            doc = "The C++ source file to compile.",
        ),
        "deps": attr.label_list(providers = [CcInfo]),
        "out_header": attr.output(
            mandatory = True,
            doc = "The output header file.",
        ),
        "base_name": attr.string(
            mandatory = True,
            doc = "The base name of the generated IR variables.",
        ),
        "namespace": attr.string(
            default = "llvm_ir",
            doc = "The C++ namespace for the generated IR variables.",
        ),
        "_cc_toolchain": attr.label(default = "@bazel_tools//tools/cpp:current_cc_toolchain"),
    },
    toolchains = use_cc_toolchain(),
    fragments = ["cpp"],
)

def cc_ir_header(name, src, deps, **kwargs):
    """A macro that generates an IR header and wraps it in a cc_library.

    Args:
      name: The name of the generated cc_library.
      src: The C++ source file to compile.
      deps: The C++ dependencies of the source file.
      **kwargs: Additional arguments to pass to the generated cc_library.
    """
    out_header = name + ".h"
    generator_name = name + "_generator"

    _cc_ir_header_rule(
        base_name = name,
        name = generator_name,
        tags = ["manual"],
        src = src,
        deps = deps,
        out_header = out_header,
        # copybara_removed compatible_with = ["//buildenv/target:non_prod"],
        **kwargs
    )

    cc_library(
        name = name,
        hdrs = [":" + out_header],
        **kwargs
    )
