/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include "xla/service/gpu/mock_nccl_xml.h"

#include <cstring>
#include <string>
#include <tuple>
#include <utility>

#include "absl/container/flat_hash_map.h"
#include "absl/container/flat_hash_set.h"
#include "absl/log/check.h"
#include "absl/status/status.h"
#include "absl/strings/str_format.h"
#include "absl/strings/string_view.h"
#include "absl/types/span.h"
#include "xla/status.h"
#include "tsl/platform/errors.h"
#include "tsl/platform/regexp.h"
#if GOOGLE_CUDA
#include "third_party/gpus/nccl/graph/xml.h"
#endif

namespace xla {
namespace gpu {
namespace {

#if GOOGLE_CUDA

class NcclTopoXmlParser {
 public:
  NcclTopoXmlParser(absl::string_view src, ncclXml* xml)
      : src_(src), xml_(xml) {}
  // A simple xml parser to parse the NCCL_TOPO_DUMP_FILE (see
  // mock_nccl_topo_a3.xml) generated by the nccl library to the ncclXmlNode
  // struct.
  Status Parse(ncclXmlNode* head) {
    if (head && head->type == NODE_TYPE_SINGLE) return absl::OkStatus();
    while (true) {
      if (xml_->maxIndex == MAX_NODES) {
        return absl::InternalError("XML parser is limited to 1024 nodes");
      }
      ncclXmlNode* node = xml_->nodes + xml_->maxIndex;
      memset(node, 0, sizeof(ncclXmlNode));
      TF_RETURN_IF_ERROR(GetNode(node));
      if (node->type == NODE_TYPE_NONE) {
        if (head) {
          return absl::InternalError(
              absl::StrFormat("XML Parser : unterminated %s", head->name));
        } else {
          // All done
          return absl::OkStatus();
        }
      }
      if (head && node->type == NODE_TYPE_CLOSE) {
        if (strcmp(node->name, head->name) != 0) {
          return absl::InternalError(absl::StrFormat(
              "XML Parser Mismatch : %s / %s", head->name, node->name));
        }
        return absl::OkStatus();
      }
      if (!head || spec_[head->name].contains(node->name)) {
        if (head) head->subs[head->nSubs++] = node;
        node->parent = head;
        node->nSubs = 0;
        xml_->maxIndex++;
        TF_RETURN_IF_ERROR(Parse(node));
      } else {
        return absl::InternalError(
            absl::StrFormat("XML Parser : Unhandled element %s", node->name));
      }
    }
  }

 private:
  std::pair<bool, absl::string_view> GetAttr(absl::string_view src,
                                             std::string& name,
                                             std::string& value) {
    static const LazyRE2 attr_regex = {"\\s*([^=]+)=\"([^\"]*)\""};
    return {RE2::Consume(&src, *attr_regex, &name, &value), src};
  }

  std::pair<bool, absl::string_view> GetNodeName(absl::string_view src,
                                                 std::string& delimiter,
                                                 std::string& name) {
    static const LazyRE2 name_regex = {"(/?)(\\w+)"};
    return {RE2::Consume(&src, *name_regex, &delimiter, &name), src};
  }

  Status GetNode(ncclXmlNode* node) {
    static const LazyRE2 node_regex = {"\\s*<([^>]+)>"};
    std::string node_str;

    if (!RE2::Consume(&src_, *node_regex, &node_str)) return absl::OkStatus();
    absl::string_view node_str_view = absl::string_view(node_str);
    std::string delimiter;
    std::string name;
    bool found_name = false;
    std::tie(found_name, node_str_view) =
        GetNodeName(node_str_view, delimiter, name);
    CHECK(found_name) << "Fail to extract nccl topo node name";
    absl::SNPrintF(node->name, sizeof(node->name), "%s", name.c_str());

    if (delimiter[0] == '/') {
      node->type = NODE_TYPE_CLOSE;
      return absl::OkStatus();
    }
    node->type = NODE_TYPE_OPEN;
    int num_attrs = 0;
    bool found_attr = false;
    do {
      std::string key;
      std::string value;
      std::tie(found_attr, node_str_view) = GetAttr(node_str_view, key, value);
      if (found_attr) {
        absl::SNPrintF(node->attrs[num_attrs].key,
                       sizeof(node->attrs[num_attrs].key), "%s", key.c_str());
        absl::SNPrintF(node->attrs[num_attrs].value,
                       sizeof(node->attrs[num_attrs].value), "%s",
                       value.c_str());
        num_attrs++;
      }
    } while (found_attr);
    node->nAttrs = num_attrs;
    if (*node_str.rbegin() == '/') node->type = NODE_TYPE_SINGLE;
    return absl::OkStatus();
  }

  absl::string_view src_;
  ncclXml* xml_;
  absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>> spec_ = {
      {"system", {"cpu"}}, {"pci", {"pci", "gpu", "nic"}}, {"gpu", {"nvlink"}},
      {"nic", {"net"}},    {"cpu", {"pci", "nic"}},        {"nvlink", {}},
      {"net", {}}};
};

Status MockNcclTopoUpdateXmlRec(
    absl::Span<const std::pair<int, int>> local_ranks,
    struct ncclXmlNode* node) {
  if (strcmp(node->name, "gpu") == 0) {
    int rank;
    xmlGetAttrInt(node, "rank", &rank);
    for (auto p : local_ranks) {
      if (rank == p.second) {
        xmlSetAttrInt(node, "keep", 1);
        xmlSetAttrInt(node, "rank", p.first);
        break;
      }
    }
  } else if (strcmp(node->name, "net") == 0) {
    xmlSetAttrInt(node, "keep", 1);
  }

  for (int i = 0; i < node->nSubs; i++) {
    TF_RETURN_IF_ERROR(MockNcclTopoUpdateXmlRec(local_ranks, node->subs[i]));
  }
  return absl::OkStatus();
}

#endif

}  // namespace

Status MockTopoGetXml(absl::string_view xml_str_view, ncclXml* xml) {
#if GOOGLE_CUDA
  xml->maxIndex = 0;
  NcclTopoXmlParser parser(xml_str_view, xml);
  return parser.Parse(nullptr);
#else
  return absl::OkStatus();
#endif
}

Status MockNcclTopoUpdateXml(absl::Span<const std::pair<int, int>> local_ranks,
                             ncclXml* xml) {
#if GOOGLE_CUDA
  return MockNcclTopoUpdateXmlRec(local_ranks, xml->nodes);
#else
  return absl::OkStatus();
#endif
}

}  // namespace gpu
}  // namespace xla
