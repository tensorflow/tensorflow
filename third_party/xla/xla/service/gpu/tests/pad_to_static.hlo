// RUN: hlo-opt %s --platform=gpu --stage=llvm-before-optimizations --xla_gpu_target_config_filename=%S/../../../tools/hlo_opt/gpu_specs/%{GPU}.txtpb | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = getelementptr inbounds i8, ptr %[[VAL_1:.*]], i32 32
// CHECK:         %[[VAL_2:.*]] = load i32, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_3:.*]] = getelementptr inbounds i8, ptr %[[VAL_1]], i32 36
// CHECK:         %[[VAL_4:.*]] = load i32, ptr %[[VAL_3]], align 4
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds i8, ptr %[[VAL_1]], i32 40
// CHECK:         %[[VAL_6:.*]] = load i32, ptr %[[VAL_5]], align 4
// CHECK-PTX:     %[[VAL_7:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x
// CHECK-GCN:     %[[VAL_7:.*]] = call i32 @llvm.amdgcn.workitem.id.x
// CHECK:         %[[VAL_8:.*]] = icmp eq i32 0, %[[VAL_7]]
// CHECK-PTX:     %[[VAL_9:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x
// CHECK-GCN:     %[[VAL_9:.*]] = call i32 @llvm.amdgcn.workgroup.id.x
// CHECK:         %[[VAL_10:.*]] = icmp eq i32 0, %[[VAL_9]]
// CHECK:         %[[VAL_11:.*]] = and i1 %[[VAL_8]], %[[VAL_10]]
// CHECK:         br i1 %[[VAL_11]], label %[[VAL_12:.*]], label %[[VAL_13:.*]]
// CHECK:       is_thread_0-after:                                ; preds = %[[VAL_12]], %[[VAL_14:.*]]
// CHECK:         %[[VAL_15:.*]] = mul i32 1, %[[VAL_2]]
// CHECK:         %[[VAL_16:.*]] = mul i32 %[[VAL_15]], %[[VAL_4]]
// CHECK:         %[[VAL_17:.*]] = mul i32 %[[VAL_16]], %[[VAL_6]]
// CHECK-PTX:     %[[VAL_18:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x
// CHECK-GCN:     %[[VAL_18:.*]] = call i32 @llvm.amdgcn.workgroup.id.x
// CHECK-PTX:     %[[VAL_19:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x
// CHECK-GCN:     %[[VAL_19:.*]] = call i32 @llvm.amdgcn.workitem.id.x
// CHECK:         %[[VAL_20:.*]] = mul nuw nsw i32 %[[VAL_18]], 8
// CHECK:         %[[VAL_21:.*]] = add nuw nsw i32 %[[VAL_20]], %[[VAL_19]]
// CHECK:         %[[VAL_22:.*]] = icmp ult i32 %[[VAL_21]], 8
// CHECK:         call void @llvm.assume(i1 %[[VAL_22]])
// CHECK:         %[[VAL_23:.*]] = add nuw nsw i32 %[[VAL_21]], 0
// CHECK:         %[[VAL_24:.*]] = udiv i32 %[[VAL_23]], 1
// CHECK:         %[[VAL_25:.*]] = urem i32 %[[VAL_24]], 2
// CHECK:         %[[VAL_26:.*]] = udiv i32 %[[VAL_23]], 2
// CHECK:         %[[VAL_27:.*]] = urem i32 %[[VAL_26]], 2
// CHECK:         %[[VAL_28:.*]] = udiv i32 %[[VAL_23]], 4
// CHECK:         %[[VAL_29:.*]] = icmp ult i32 %[[VAL_21]], 8
// CHECK:         br i1 %[[VAL_29]], label %[[VAL_30:.*]], label %[[VAL_31:.*]]
// CHECK:       custom_call_2.in_bounds-after:                    ; preds = %[[VAL_32:.*]], %[[VAL_13]]
// CHECK:         ret void
// CHECK:       is_thread_0-true:                                 ; preds = %[[VAL_14]]
// CHECK:         store i32 %[[VAL_2]], ptr %[[VAL_33:.*]], align 4
// CHECK:         store i32 %[[VAL_4]], ptr %[[VAL_34:.*]], align 4
// CHECK:         store i32 %[[VAL_6]], ptr %[[VAL_35:.*]], align 4
// CHECK:         br label %[[VAL_13]]
// CHECK:       custom_call_2.in_bounds-true:                     ; preds = %[[VAL_13]]
// CHECK:         %[[VAL_36:.*]] = mul nuw nsw i32 %[[VAL_25]], 1
// CHECK:         %[[VAL_37:.*]] = add nuw nsw i32 0, %[[VAL_36]]
// CHECK:         %[[VAL_38:.*]] = mul nuw nsw i32 %[[VAL_27]], 2
// CHECK:         %[[VAL_39:.*]] = add nuw nsw i32 %[[VAL_37]], %[[VAL_38]]
// CHECK:         %[[VAL_40:.*]] = mul nuw nsw i32 %[[VAL_28]], 4
// CHECK:         %[[VAL_41:.*]] = add nuw nsw i32 %[[VAL_39]], %[[VAL_40]]
// CHECK:         %[[VAL_42:.*]] = icmp ult i32 %[[VAL_41]], %[[VAL_17]]
// CHECK:         br i1 %[[VAL_42]], label %[[VAL_43:.*]], label %[[VAL_32]]
// CHECK:       custom_call_2.in_dyn_bounds-after:                ; preds = %[[VAL_43]], %[[VAL_30]]
// CHECK:         br label %[[VAL_31]]
// CHECK:       custom_call_2.in_dyn_bounds-true:                 ; preds = %[[VAL_30]]
// CHECK:         %[[VAL_44:.*]] = udiv i32 %[[VAL_41]], 1
// CHECK:         %[[VAL_45:.*]] = urem i32 %[[VAL_44]], %[[VAL_6]]
// CHECK:         %[[VAL_46:.*]] = mul i32 1, %[[VAL_6]]
// CHECK:         %[[VAL_47:.*]] = udiv i32 %[[VAL_41]], %[[VAL_46]]
// CHECK:         %[[VAL_48:.*]] = urem i32 %[[VAL_47]], %[[VAL_4]]
// CHECK:         %[[VAL_49:.*]] = mul i32 %[[VAL_46]], %[[VAL_4]]
// CHECK:         %[[VAL_50:.*]] = udiv i32 %[[VAL_41]], %[[VAL_49]]
// CHECK:         %[[VAL_51:.*]] = getelementptr i32, ptr %[[VAL_1]], i32 %[[VAL_21]]
// CHECK:         %[[VAL_52:.*]] = getelementptr inbounds i32, ptr %[[VAL_51]], i32 0
// CHECK:         %[[VAL_53:.*]] = load i32, ptr %[[VAL_52]], align 4, !invariant.load
// CHECK:         %[[VAL_54:.*]] = getelementptr inbounds [2 x [2 x [2 x i32]]], ptr %[[VAL_55:.*]], i32 0, i32 %[[VAL_50]], i32 %[[VAL_48]], i32 %[[VAL_45]]
// CHECK:         store i32 %[[VAL_53]], ptr %[[VAL_54]], align 4
// CHECK:         br label %[[VAL_32]]


HloModule PadToStatic, is_scheduled=true

ENTRY main {
  %param = s32[2,<=2,2] parameter(0)
  ROOT %custom_call_2 = (s32[2,2,2], s32[], s32[], s32[])
             custom-call(s32[2,<=2,2] %param),
             custom_call_target="PadToStatic"
}
