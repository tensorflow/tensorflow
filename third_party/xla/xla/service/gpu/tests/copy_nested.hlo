// RUN: hlo_to_llvm_ir %s | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %{IR_SUBST} %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i32, align 4
// CHECK:         store i32 0, ptr [[ADDRSPACE_ANNOTATION]]%[[VAL_0]], align 4
// CHECK:         br label %[[VAL_1:.*]]
// CHECK:       loop.loop_header:                                 ; preds = %[[VAL_2:.*]], %[[VAL_3:.*]]
// CHECK:         %[[VAL_4:.*]] = load i32, ptr [[ADDRSPACE_ANNOTATION]]%[[VAL_0]], align 4
// CHECK:         %[[VAL_5:.*]] = icmp uge i32 %[[VAL_4]], 6000000
// CHECK:         br i1 %[[VAL_5]], label %[[VAL_6:.*]], label %[[VAL_7:.*]]
// CHECK:       loop.loop_body:                                   ; preds = %[[VAL_1]]
// CHECK-PTX:     %[[VAL_8:.*]] = add nuw nsw i32 %[[VAL_4]], 516096
// CHECK-GCN:     %[[VAL_8:.*]] = add nuw nsw i32 %[[VAL_4]], 851968
// CHECK:         store i32 %[[VAL_8]], ptr [[ADDRSPACE_ANNOTATION]]%[[VAL_0]], align 4
// CHECK:         %[[VAL_9:.*]] = icmp eq i32 %[[VAL_4]], 0
// CHECK:         %[[VAL_10:.*]] = call i32 [[CTAIDX]]
// CHECK:         %[[VAL_11:.*]] = call i32 [[TIDX]]
// CHECK:         %[[VAL_12:.*]] = mul nuw nsw i32 %[[VAL_10]], 128
// CHECK:         %[[VAL_13:.*]] = add nuw nsw i32 %[[VAL_12]], %[[VAL_11]]
// CHECK-PTX:     %[[VAL_14:.*]] = icmp ult i32 %[[VAL_13]], 129024
// CHECK-GCN:     %[[VAL_14:.*]] = icmp ult i32 %[[VAL_13]], 212992
// CHECK:         call void @llvm.assume(i1 %[[VAL_14]])
// CHECK:         %[[VAL_15:.*]] = mul nuw nsw i32 %[[VAL_13]], 4
// CHECK:         %[[VAL_16:.*]] = add nuw nsw i32 %[[VAL_15]], %[[VAL_4]]
// CHECK:         %[[VAL_17:.*]] = add nuw nsw i32 %[[VAL_16]], 0
// CHECK:         %[[VAL_18:.*]] = udiv i32 %[[VAL_17]], 1
// CHECK:         %[[VAL_19:.*]] = urem i32 %[[VAL_18]], 300
// CHECK:         %[[VAL_20:.*]] = udiv i32 %[[VAL_17]], 300
// CHECK:         %[[VAL_21:.*]] = urem i32 %[[VAL_20]], 100
// CHECK:         %[[VAL_22:.*]] = udiv i32 %[[VAL_17]], 30000
// CHECK:         %[[VAL_23:.*]] = add nuw nsw i32 %[[VAL_16]], 1
// CHECK:         %[[VAL_24:.*]] = udiv i32 %[[VAL_23]], 1
// CHECK:         %[[VAL_25:.*]] = urem i32 %[[VAL_24]], 300
// CHECK:         %[[VAL_26:.*]] = udiv i32 %[[VAL_23]], 300
// CHECK:         %[[VAL_27:.*]] = urem i32 %[[VAL_26]], 100
// CHECK:         %[[VAL_28:.*]] = udiv i32 %[[VAL_23]], 30000
// CHECK:         %[[VAL_29:.*]] = add nuw nsw i32 %[[VAL_16]], 2
// CHECK:         %[[VAL_30:.*]] = udiv i32 %[[VAL_29]], 1
// CHECK:         %[[VAL_31:.*]] = urem i32 %[[VAL_30]], 300
// CHECK:         %[[VAL_32:.*]] = udiv i32 %[[VAL_29]], 300
// CHECK:         %[[VAL_33:.*]] = urem i32 %[[VAL_32]], 100
// CHECK:         %[[VAL_34:.*]] = udiv i32 %[[VAL_29]], 30000
// CHECK:         %[[VAL_35:.*]] = add nuw nsw i32 %[[VAL_16]], 3
// CHECK:         %[[VAL_36:.*]] = udiv i32 %[[VAL_35]], 1
// CHECK:         %[[VAL_37:.*]] = urem i32 %[[VAL_36]], 300
// CHECK:         %[[VAL_38:.*]] = udiv i32 %[[VAL_35]], 300
// CHECK:         %[[VAL_39:.*]] = urem i32 %[[VAL_38]], 100
// CHECK:         %[[VAL_40:.*]] = udiv i32 %[[VAL_35]], 30000
// CHECK:         %[[VAL_41:.*]] = icmp ult i32 %[[VAL_16]], 6000000
// CHECK:         br i1 %[[VAL_41]], label %[[VAL_42:.*]], label %[[VAL_2]]
// CHECK:       wrapped_b.in_bounds-after:                        ; preds = %[[VAL_42]], %[[VAL_7]]
// CHECK:         br label %[[VAL_1]], !llvm.loop
// CHECK:       loop.loop_exit:                                   ; preds = %[[VAL_1]]
// CHECK:         ret void
// CHECK:       wrapped_b.in_bounds-true:                         ; preds = %[[VAL_7]]
// CHECK:         %[[VAL_43:.*]] = getelementptr inbounds [100 x [200 x [300 x float]]], ptr %[[VAL_44:.*]], i32 0, i32 %[[VAL_21]], i32 %[[VAL_22]], i32 %[[VAL_19]]
// CHECK:         %[[VAL_45:.*]] = load float, ptr %[[VAL_43]], align 4, !invariant.load
// CHECK:         %[[VAL_46:.*]] = getelementptr float, ptr %[[VAL_47:.*]], i32 %[[VAL_16]]
// CHECK:         %[[VAL_48:.*]] = getelementptr inbounds float, ptr %[[VAL_46]], i32 0
// CHECK:         store float %[[VAL_45]], ptr %[[VAL_48]], align 4
// CHECK:         %[[VAL_49:.*]] = getelementptr inbounds [100 x [200 x [300 x float]]], ptr %[[VAL_44]], i32 0, i32 %[[VAL_27]], i32 %[[VAL_28]], i32 %[[VAL_25]]
// CHECK:         %[[VAL_50:.*]] = load float, ptr %[[VAL_49]], align 4, !invariant.load
// CHECK:         %[[VAL_51:.*]] = getelementptr float, ptr %[[VAL_47]], i32 %[[VAL_16]]
// CHECK:         %[[VAL_52:.*]] = getelementptr inbounds float, ptr %[[VAL_51]], i32 1
// CHECK:         store float %[[VAL_50]], ptr %[[VAL_52]], align 4
// CHECK:         %[[VAL_53:.*]] = getelementptr inbounds [100 x [200 x [300 x float]]], ptr %[[VAL_44]], i32 0, i32 %[[VAL_33]], i32 %[[VAL_34]], i32 %[[VAL_31]]
// CHECK:         %[[VAL_54:.*]] = load float, ptr %[[VAL_53]], align 4, !invariant.load
// CHECK:         %[[VAL_55:.*]] = getelementptr float, ptr %[[VAL_47]], i32 %[[VAL_16]]
// CHECK:         %[[VAL_56:.*]] = getelementptr inbounds float, ptr %[[VAL_55]], i32 2
// CHECK:         store float %[[VAL_54]], ptr %[[VAL_56]], align 4
// CHECK:         %[[VAL_57:.*]] = getelementptr inbounds [100 x [200 x [300 x float]]], ptr %[[VAL_44]], i32 0, i32 %[[VAL_39]], i32 %[[VAL_40]], i32 %[[VAL_37]]
// CHECK:         %[[VAL_58:.*]] = load float, ptr %[[VAL_57]], align 4, !invariant.load
// CHECK:         %[[VAL_59:.*]] = getelementptr float, ptr %[[VAL_47]], i32 %[[VAL_16]]
// CHECK:         %[[VAL_60:.*]] = getelementptr inbounds float, ptr %[[VAL_59]], i32 3
// CHECK:         store float %[[VAL_58]], ptr %[[VAL_60]], align 4
// CHECK:         br label %[[VAL_2]]

HloModule Test, is_scheduled=true

fused_computation {
  param_0 = f32[100,200,300]{2,1,0} parameter(0)
  ROOT b.1 = f32[100,200,300]{2,0,1} copy(f32[100,200,300]{2,1,0} param_0)
}

ENTRY main {
  a = f32[100, 200, 300]{2,1,0} parameter(0)
  ROOT wrapped_b = f32[100,200,300]{2,0,1} fusion(f32[100,200,300]{2,1,0} %a), kind=kLoop, calls=fused_computation
}
