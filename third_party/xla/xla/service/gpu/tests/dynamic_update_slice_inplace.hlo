// RUN: hlo_to_llvm_ir %s | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %{IR_SUBST} %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_1:.*]] = icmp sge i32 0, %[[VAL_0]]
// CHECK:         %[[VAL_2:.*]] = select i1 %[[VAL_1]], i32 0, i32 %[[VAL_0]]
// CHECK:         %[[VAL_3:.*]] = icmp sle i32 49, %[[VAL_2]]
// CHECK:         %[[VAL_4:.*]] = select i1 %[[VAL_3]], i32 49, i32 %[[VAL_2]]
// CHECK:         %[[VAL_5:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_6:.*]] = icmp sge i32 0, %[[VAL_5]]
// CHECK:         %[[VAL_7:.*]] = select i1 %[[VAL_6]], i32 0, i32 %[[VAL_5]]
// CHECK:         %[[VAL_8:.*]] = icmp sle i32 0, %[[VAL_7]]
// CHECK:         %[[VAL_9:.*]] = select i1 %[[VAL_8]], i32 0, i32 %[[VAL_7]]
// CHECK:         %[[VAL_10:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_11:.*]] = icmp sge i32 0, %[[VAL_10]]
// CHECK:         %[[VAL_12:.*]] = select i1 %[[VAL_11]], i32 0, i32 %[[VAL_10]]
// CHECK:         %[[VAL_13:.*]] = icmp sle i32 0, %[[VAL_12]]
// CHECK:         %[[VAL_14:.*]] = select i1 %[[VAL_13]], i32 0, i32 %[[VAL_12]]
// CHECK:         %[[VAL_15:.*]] = call i32 [[CTAIDX]]
// CHECK:         %[[VAL_16:.*]] = zext i32 %[[VAL_15]] to i64
// CHECK:         %[[VAL_17:.*]] = call i32 [[TIDX]]
// CHECK:         %[[VAL_18:.*]] = zext i32 %[[VAL_17]] to i64
// CHECK-PTX:     %[[VAL_19:.*]] = mul nuw nsw i64 %[[VAL_16]], 128
// CHECK-GCN:     %[[VAL_19:.*]] = mul nuw nsw i64 %[[VAL_16]], 256
// CHECK:         %[[VAL_20:.*]] = add nuw nsw i64 %[[VAL_19]], %[[VAL_18]]
// CHECK:         %[[VAL_21:.*]] = icmp ult i64 %[[VAL_20]], 98304
// CHECK:         call void @llvm.assume(i1 %[[VAL_21]])
// CHECK:         %[[VAL_22:.*]] = udiv i64 %[[VAL_20]], 1
// CHECK:         %[[VAL_23:.*]] = urem i64 %[[VAL_22]], 1024
// CHECK:         %[[VAL_24:.*]] = udiv i64 %[[VAL_20]], 1024
// CHECK:         %[[VAL_25:.*]] = urem i64 %[[VAL_24]], 96
// CHECK:         %[[VAL_26:.*]] = udiv i64 %[[VAL_20]], 98304
// CHECK:         %[[VAL_27:.*]] = icmp ult i64 %[[VAL_20]], 98304
// CHECK:         br i1 %[[VAL_27]], label %[[VAL_28:.*]], label %[[VAL_29:.*]]
// CHECK:       dynamic-update-slice.in_bounds-after:             ; preds = %[[VAL_28]], %[[VAL_30:.*]]
// CHECK:         ret void
// CHECK:       dynamic-update-slice.in_bounds-true:              ; preds = %[[VAL_30]]
// CHECK:         %[[VAL_31:.*]] = sext i32 %[[VAL_4]] to i64
// CHECK:         %[[VAL_32:.*]] = add i64 %[[VAL_31]], %[[VAL_26]]
// CHECK:         %[[VAL_33:.*]] = sext i32 %[[VAL_9]] to i64
// CHECK:         %[[VAL_34:.*]] = add i64 %[[VAL_33]], %[[VAL_25]]
// CHECK:         %[[VAL_35:.*]] = sext i32 %[[VAL_14]] to i64
// CHECK:         %[[VAL_36:.*]] = add i64 %[[VAL_35]], %[[VAL_23]]
// CHECK:         %[[VAL_37:.*]] = getelementptr inbounds half, ptr %[[VAL_38:.*]], i64 %[[VAL_20]]
// CHECK:         %[[VAL_39:.*]] = load half, ptr %[[VAL_37]], align 2, !invariant.load
// CHECK:         %[[VAL_40:.*]] = getelementptr inbounds [50 x [96 x [1024 x half]]], ptr %[[VAL_41:.*]], i64 0, i64 %[[VAL_32]], i64 %[[VAL_34]], i64 %[[VAL_36]]
// CHECK:         store half %[[VAL_39]], ptr %[[VAL_40]], align 2
// CHECK:         br label %[[VAL_29]]

HloModule TestModule

fusion.1 {
  p.0 = f16[50,96,1024]{2,1,0} parameter(0)
  p.1 = f16[1,96,1024]{2,1,0} parameter(1)
  c.0 = s32[] constant(0)
  ROOT %dynamic-update-slice = f16[50,96,1024]{2,1,0} dynamic-update-slice(p.0, p.1, c.0, c.0, c.0)
}

ENTRY entry {
  p.0 = f16[50,96,1024]{2,1,0} parameter(0)
  p.1 = f16[1,96,1024]{2,1,0} parameter(1)
  ROOT f1 = f16[50,96,1024] fusion(p.0, p.1), kind=kLoop, calls=fusion.1
}

// -----

// CHECK-LABEL: @fusion
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]]
// CHECK:         call void @llvm.assume
// CHECK:         %[[COND:.*]] = icmp ult i32 %[[LINEAR_INDEX:.*]], 6
// CHECK:         br i1 %[[COND]], label %[[FUSION:.*]].in_bounds-true, label %[[FUSION]].in_bounds-after
// CHECK:       [[FUSION]].in_bounds-after:
// CHECK:         ret void
// CHECK:       [[FUSION]].in_bounds-true:
// CHECK:         br i1 %{{.*}}, label %[[SLICE:.*]]-true, label %[[SLICE]]-false
// CHECK:       [[SLICE]]-after:
// CHECK:         %[[VAL_82:.*]] = load i32, ptr [[ADDRSPACE_ANNOTATION]]%[[RET_VALUE_ADDR:.*]], align 4
// CHECK:         %[[VAL_83:.*]] = getelementptr inbounds i32, ptr %[[ARG2]], i32 %[[LINEAR_INDEX]]
// CHECK:         store i32 %[[VAL_82]], ptr %[[VAL_83]], align 4
// CHECK:         br label %[[FUSION]].in_bounds-after
// CHECK:       [[SLICE]]-true:
// CHECK:         %[[VAL_104:.*]] = getelementptr inbounds [6 x i32], ptr %[[ARG0]], i32 0, i32 %[[VAL_102:.*]]
// CHECK:         %[[VAL_106:.*]] = load i32, ptr %[[VAL_104]], align 4, !invariant.load
// CHECK:         %[[VAL_107:.*]] = load i32, ptr @1, align 4
// CHECK:         %[[VAL_108:.*]] = add i32 %[[VAL_106]], %[[VAL_107]]
// CHECK:         store i32 %[[VAL_108]], ptr [[ADDRSPACE_ANNOTATION]]%[[RET_VALUE_ADDR]], align 4
// CHECK:         br label %[[SLICE]]-after
// CHECK:       [[SLICE]]-false:
// CHECK:         %[[VAL_114:.*]] = getelementptr inbounds i32, ptr %[[ARG0]], i32 %[[LINEAR_INDEX]]
// CHECK:         %[[VAL_115:.*]] = load i32, ptr %[[VAL_114]], align 4, !invariant.load
// CHECK:         store i32 %[[VAL_115]], ptr [[ADDRSPACE_ANNOTATION]]%[[RET_VALUE_ADDR]], align 4
// CHECK:         br label %[[SLICE]]-after

HloModule fusion

fused_computation {
  param_0.1 = s32[6]{0} parameter(0)
  bitcast = s32[2,3]{1,0} bitcast(param_0.1)
  zero = s32[] constant(0)
  param_1.1 = s32[] parameter(1)
  dynamic-slice = s32[1,1]{1,0} dynamic-slice(bitcast, param_1.1, zero), dynamic_slice_sizes={1,1}
  one = s32[] constant(1)
  bitcasted_one = s32[1,1]{1,0} bitcast(one)
  add = s32[1,1] add(dynamic-slice, bitcasted_one)
  dynamic-update-slice = s32[2,3]{1,0} dynamic-update-slice(bitcast, add, param_1.1, zero)
  ROOT bitcast.1 = s32[6]{0} bitcast(dynamic-update-slice)
}

ENTRY main {
  param_0 = s32[6]{0} parameter(0)
  param_1 = s32[] parameter(1)
  ROOT fusion = s32[6]{0} fusion(param_0, param_1), kind=kInput, calls=fused_computation
}

// -----

// CHECK-LABEL: @fusion_root_multiple
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG4:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK:        %[[COND2:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND2]], label %[[DUS1:.*]].in_bounds-true, label %[[DUS1]].in_bounds-after
// CHECK:      [[DUS1]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG1]]
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG3]]
// CHECK-DAG:    getelementptr inbounds [10 x [11 x [12 x i16]]], ptr %[[ARG0]]
// CHECK:      [[DUS1]].in_bounds-true
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG1]]
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG3]]
// CHECK-DAG:    getelementptr inbounds [8 x [11 x [12 x i16]]], ptr %[[ARG2]]

HloModule MultipleInplaceDus, input_output_alias={ {0}: (0, {}), {1}: (2, {}) }

fused_computation {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[8,11,12] parameter(2)
  p3 = bf16[1,11,12] parameter(3)
  p4 = s32[] parameter(4)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p4, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p3)
  dus0 = bf16[10,11,12] dynamic-update-slice(p0, select, c0, c0, c0)
  dus1 = bf16[8,11,12] dynamic-update-slice(p2, select, c0, c0, c0)
  ROOT tuple = (bf16[10,11,12], bf16[8,11,12]) tuple(dus0, dus1)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[8,11,12] parameter(2)
  p3 = bf16[1,11,12] parameter(3)
  p4 = s32[] parameter(4)
  ROOT fusion_root_multiple = (bf16[10,11,12], bf16[8,11,12]) fusion(p0, p1, p2, p3, p4), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-LABEL: @fusion_root_multiple_transpose_bitcast
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG4:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK:        %[[COND2:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND2]], label %[[DUS1:.*]].in_bounds-true, label %[[DUS1]].in_bounds-after
// CHECK:      [[DUS1]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG1]]
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG3]]
// CHECK-DAG:    getelementptr inbounds [10 x [11 x [12 x i16]]], ptr %[[ARG0]]
// CHECK:      [[DUS1]].in_bounds-true
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG1]]
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG3]]
// CHECK-DAG:    getelementptr inbounds [8 x [11 x [12 x i16]]], ptr %[[ARG2]]

HloModule MultipleInplaceDusWithTransposeBitcastToTheRoot, input_output_alias={ {0}: (0, {}), {1}: (2, {}) }

fused_computation {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[8,11,12] parameter(2)
  p3 = bf16[1,11,12] parameter(3)
  p4 = s32[] parameter(4)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p4, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p3)
  dus0 = bf16[10,11,12] dynamic-update-slice(p0, select, c0, c0, c0)
  bitcasted_dus0 = bf16[11,10,12] bitcast(dus0)
  dus1 = bf16[8,11,12] dynamic-update-slice(p2, select, c0, c0, c0)
  ROOT tuple = (bf16[11,10,12], bf16[8,11,12]) tuple(bitcasted_dus0, dus1)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[8,11,12] parameter(2)
  p3 = bf16[1,11,12] parameter(3)
  p4 = s32[] parameter(4)
  ROOT fusion_root_multiple_transpose_bitcast = (bf16[11,10,12], bf16[8,11,12]) fusion(p0, p1, p2, p3, p4), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-LABEL: @fusion_root_transpose_bitcast
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG1]]
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG2]]
// CHECK-DAG:    getelementptr inbounds [10 x [11 x [12 x i16]]], ptr %[[ARG0]]

HloModule SingleInplaceDusWithTransposeBitcastToTheRoot, input_output_alias={ {}: (0, {}) }

single_inplace_dus_with_transpose_bitcast {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p3, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p2)
  dus0 = bf16[10,11,12] dynamic-update-slice(p0, select, c0, c0, c0)
  ROOT bitcasted_dus0 = bf16[11,10,12] bitcast(dus0)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  ROOT fusion_root_transpose_bitcast = bf16[11,10,12] fusion(p0, p1, p2, p3), kind=kLoop, calls=single_inplace_dus_with_transpose_bitcast
}

// -----

// CHECK-LABEL: @fusion_root_reshape_bitcast
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG1]]
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG2]]
// CHECK-DAG:    getelementptr inbounds [10 x [11 x [12 x i16]]], ptr %[[ARG0]]

HloModule SingleInplaceDusWithReshapeBitcastToTheRoot, input_output_alias={ {}: (0, {}) }

single_inplace_dus_with_reshape_bitcast {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p3, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p2)
  dus0 = bf16[10,11,12] dynamic-update-slice(p0, select, c0, c0, c0)
  ROOT bitcasted_dus0 = bf16[10,11,6,2] bitcast(dus0)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  ROOT fusion_root_reshape_bitcast = bf16[10,11,6,2] fusion(p0, p1, p2, p3), kind=kLoop, calls=single_inplace_dus_with_reshape_bitcast
}

// -----

// CHECK-LABEL: @fusion_root_bitcast_both_ways
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG1]]
// CHECK-DAG:    getelementptr inbounds i16, ptr %[[ARG2]]
// CHECK-DAG:    getelementptr inbounds [10 x [6 x [2 x [11 x i16]]]], ptr %[[ARG0]]

HloModule SingleInplaceDusWithBitcastToTheRootAndFromTheParameter, input_output_alias={ {}: (0, {}) }

single_inplace_dus_with_bitcast_to_the_root_and_from_the_parameter {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p3, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p2)
  bitcasted_p0 = bf16[10,6,2,11] bitcast(p0)
  bitcasted_select = bf16[1,6,2,11] bitcast(select)
  dus0 = bf16[10,6,2,11] dynamic-update-slice(bitcasted_p0, bitcasted_select, c0, c0, c0, c0)
  ROOT bitcasted_dus0 = bf16[10,11,6,2] bitcast(dus0)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  ROOT fusion_root_bitcast_both_ways = bf16[10,11,6,2] fusion(p0, p1, p2, p3), kind=kLoop, calls=single_inplace_dus_with_bitcast_to_the_root_and_from_the_parameter
}
