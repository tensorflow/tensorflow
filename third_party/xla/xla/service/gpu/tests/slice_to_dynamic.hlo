// RUN: hlo-opt %s --platform=gpu --stage=llvm-before-optimizations --xla_gpu_target_config_filename=%S/../../../tools/hlo_opt/gpu_specs/%{GPU}.txtpb | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = load i32, ptr %[[VAL_1:.*]], align 4
// CHECK:         %[[VAL_2:.*]] = load i32, ptr %[[VAL_3:.*]], align 4
// CHECK:         %[[VAL_4:.*]] = load i32, ptr %[[VAL_1]], align 4
// CHECK-PTX:     %[[VAL_5:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x
// CHECK-GCN:     %[[VAL_5:.*]] = call i32 @llvm.amdgcn.workitem.id.x
// CHECK:         %[[VAL_6:.*]] = icmp eq i32 0, %[[VAL_5]]
// CHECK-PTX:     %[[VAL_7:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x
// CHECK-GCN:     %[[VAL_7:.*]] = call i32 @llvm.amdgcn.workgroup.id.x
// CHECK:         %[[VAL_8:.*]] = icmp eq i32 0, %[[VAL_7]]
// CHECK:         %[[VAL_9:.*]] = and i1 %[[VAL_6]], %[[VAL_8]]
// CHECK:         br i1 %[[VAL_9]], label %[[VAL_10:.*]], label %[[VAL_11:.*]]
// CHECK:       is_thread_0-after:                                ; preds = %[[VAL_10]], %[[VAL_12:.*]]
// CHECK:         %[[VAL_13:.*]] = mul i32 1, %[[VAL_0]]
// CHECK:         %[[VAL_14:.*]] = mul i32 %[[VAL_13]], %[[VAL_2]]
// CHECK:         %[[VAL_15:.*]] = mul i32 %[[VAL_14]], %[[VAL_4]]
// CHECK-PTX:     %[[VAL_16:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x
// CHECK-GCN:      %[[VAL_16:.*]] = call i32 @llvm.amdgcn.workgroup.id.x
// CHECK-PTX:     %[[VAL_17:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x
// CHECK-GCN:     %[[VAL_17:.*]] = call i32 @llvm.amdgcn.workitem.id.x
// CHECK:         %[[VAL_18:.*]] = mul nuw nsw i32 %[[VAL_16]], 8
// CHECK:         %[[VAL_19:.*]] = add nuw nsw i32 %[[VAL_18]], %[[VAL_17]]
// CHECK:         %[[VAL_20:.*]] = icmp ult i32 %[[VAL_19]], 8
// CHECK:         call void @llvm.assume(i1 %[[VAL_20]])
// CHECK:         %[[VAL_21:.*]] = add nuw nsw i32 %[[VAL_19]], 0
// CHECK:         %[[VAL_22:.*]] = udiv i32 %[[VAL_21]], 1
// CHECK:         %[[VAL_23:.*]] = urem i32 %[[VAL_22]], 2
// CHECK:         %[[VAL_24:.*]] = udiv i32 %[[VAL_21]], 2
// CHECK:         %[[VAL_25:.*]] = urem i32 %[[VAL_24]], 2
// CHECK:         %[[VAL_26:.*]] = udiv i32 %[[VAL_21]], 4
// CHECK:         %[[VAL_27:.*]] = icmp ult i32 %[[VAL_19]], 8
// CHECK:         br i1 %[[VAL_27]], label %[[VAL_28:.*]], label %[[VAL_29:.*]]
// CHECK:       custom-call.in_bounds-after:                      ; preds = %[[VAL_30:.*]], %[[VAL_11]]
// CHECK:         ret void
// CHECK:       is_thread_0-true:                                 ; preds = %[[VAL_12]]
// CHECK:         %[[VAL_31:.*]] = getelementptr inbounds i8, ptr %[[VAL_32:.*]], i32 32
// CHECK:         store i32 %[[VAL_0]], ptr %[[VAL_31]], align 4
// CHECK:         %[[VAL_33:.*]] = getelementptr inbounds i8, ptr %[[VAL_32]], i32 36
// CHECK:         store i32 %[[VAL_2]], ptr %[[VAL_33]], align 4
// CHECK:         %[[VAL_34:.*]] = getelementptr inbounds i8, ptr %[[VAL_32]], i32 40
// CHECK:         store i32 %[[VAL_4]], ptr %[[VAL_34]], align 4
// CHECK:         br label %[[VAL_11]]
// CHECK:       custom-call.in_bounds-true:                       ; preds = %[[VAL_11]]
// CHECK:         %[[VAL_35:.*]] = mul nuw nsw i32 %[[VAL_23]], 1
// CHECK:         %[[VAL_36:.*]] = add nuw nsw i32 0, %[[VAL_35]]
// CHECK:         %[[VAL_37:.*]] = mul nuw nsw i32 %[[VAL_25]], 2
// CHECK:         %[[VAL_38:.*]] = add nuw nsw i32 %[[VAL_36]], %[[VAL_37]]
// CHECK:         %[[VAL_39:.*]] = mul nuw nsw i32 %[[VAL_26]], 4
// CHECK:         %[[VAL_40:.*]] = add nuw nsw i32 %[[VAL_38]], %[[VAL_39]]
// CHECK:         %[[VAL_41:.*]] = icmp ult i32 %[[VAL_40]], %[[VAL_15]]
// CHECK:         br i1 %[[VAL_41]], label %[[VAL_42:.*]], label %[[VAL_30]]
// CHECK:       custom-call.in_dyn_bounds-after:                  ; preds = %[[VAL_42]], %[[VAL_28]]
// CHECK:         br label %[[VAL_29]]
// CHECK:       custom-call.in_dyn_bounds-true:                   ; preds = %[[VAL_28]]
// CHECK:         %[[VAL_43:.*]] = udiv i32 %[[VAL_40]], 1
// CHECK:         %[[VAL_44:.*]] = urem i32 %[[VAL_43]], %[[VAL_4]]
// CHECK:         %[[VAL_45:.*]] = mul i32 1, %[[VAL_4]]
// CHECK:         %[[VAL_46:.*]] = udiv i32 %[[VAL_40]], %[[VAL_45]]
// CHECK:         %[[VAL_47:.*]] = urem i32 %[[VAL_46]], %[[VAL_0]]
// CHECK:         %[[VAL_48:.*]] = mul i32 %[[VAL_45]], %[[VAL_0]]
// CHECK:         %[[VAL_49:.*]] = udiv i32 %[[VAL_40]], %[[VAL_48]]
// CHECK:         %[[VAL_50:.*]] = getelementptr inbounds [2 x [2 x [2 x i32]]], ptr %[[VAL_51:.*]], i32 0, i32 %[[VAL_49]], i32 %[[VAL_47]], i32 %[[VAL_44]]
// CHECK:         %[[VAL_52:.*]] = load i32, ptr %[[VAL_50]], align 4, !invariant.load
// CHECK:         %[[VAL_53:.*]] = getelementptr i32, ptr %[[VAL_32]], i32 %[[VAL_19]]
// CHECK:         %[[VAL_54:.*]] = getelementptr inbounds i32, ptr %[[VAL_53]], i32 0
// CHECK:         store i32 %[[VAL_52]], ptr %[[VAL_54]], align 4
// CHECK:         br label %[[VAL_30]]


HloModule SliceToDynamic, is_scheduled=true

ENTRY main {
  %param = s32[2,2,2]{2,0,1} parameter(0)
  %static = s32[] constant(2)
  %dynamic = s32[] constant(1)
  ROOT %custom-call = s32[2,<=2, 2]{2,0,1} custom-call(s32[2,2,2]{2,0,1} %param,
                                                  s32[] %static,
                                                  s32[] %dynamic,
                                                  s32[] %static),
                                      custom_call_target="SliceToDynamic",
                                      backend_config=""
}
