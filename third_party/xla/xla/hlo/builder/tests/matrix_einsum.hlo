// NOTE: Assertions have been autogenerated by hlo/tools/generate_hlo_test_checks.py
// RUN: hlo-opt --passes=test-only-xla-builder --split-input-file %s | FileCheck %s

// CHECK-LABEL: HloModule einsum_diag, entry_computation_layout={(f32[3,3]{1,0})->f32[3]{0}}

// CHECK:       %[[$add_F32_13:[^ ]+]]
// CHECK-NEXT:  %[[lhs_14:[^ ]+]] = f32[] parameter(0)
// CHECK-NEXT:  %[[rhs_15:[^ ]+]] = f32[] parameter(1)
// CHECK-NEXT:  ROOT %[[add_16:[^ ]+]] = f32[] add(%[[lhs_14]], %[[rhs_15]])

// CHECK:       %[[$add_F32_28:[^ ]+]]
// CHECK-NEXT:  %[[lhs_29:[^ ]+]] = f32[] parameter(0)
// CHECK-NEXT:  %[[rhs_30:[^ ]+]] = f32[] parameter(1)
// CHECK-NEXT:  ROOT %[[add_31:[^ ]+]] = f32[] add(%[[lhs_29]], %[[rhs_30]])

// CHECK:       %[[$xla_builder_matrix_Einsum_35:[^ ]+]]
// CHECK-NEXT:  %[[constant_4:[^ ]+]] = pred[] constant(true)
// CHECK-NEXT:  %[[broadcast_8:[^ ]+]] = pred[3,3]{1,0} broadcast(%[[constant_4]]), dimensions={}
// CHECK-NEXT:  %[[iota_5:[^ ]+]] = s32[3,3]{1,0} iota(), iota_dimension=0
// CHECK-NEXT:  %[[iota_6:[^ ]+]] = s32[3,3]{1,0} iota(), iota_dimension=1
// CHECK-NEXT:  %[[compare_7:[^ ]+]] = pred[3,3]{1,0} compare(%[[iota_5]], %[[iota_6]]), direction=EQ
// CHECK-NEXT:  %[[and_9:[^ ]+]] = pred[3,3]{1,0} and(%[[broadcast_8]], %[[compare_7]])
// CHECK-NEXT:  %[[arg0_1:[^ ]+]] = f32[3,3]{1,0} parameter(0)
// CHECK-NEXT:  %[[constant_10:[^ ]+]] = f32[] constant(0)
// CHECK-NEXT:  %[[broadcast_11:[^ ]+]] = f32[3,3]{1,0} broadcast(%[[constant_10]]), dimensions={}
// CHECK-NEXT:  %[[select_12:[^ ]+]] = f32[3,3]{1,0} select(%[[and_9]], %[[arg0_1]], %[[broadcast_11]])
// CHECK-NEXT:  %[[constant_3:[^ ]+]] = f32[] constant(0)
// CHECK-NEXT:  %[[reduce_17:[^ ]+]] = f32[3]{0} reduce(%[[select_12]], %[[constant_3]]), dimensions={1}, to_apply=%[[$add_F32_13]]
// CHECK-NEXT:  %[[constant_19:[^ ]+]] = pred[] constant(true)
// CHECK-NEXT:  %[[broadcast_23:[^ ]+]] = pred[3,3]{1,0} broadcast(%[[constant_19]]), dimensions={}
// CHECK-NEXT:  %[[iota_20:[^ ]+]] = s32[3,3]{1,0} iota(), iota_dimension=0
// CHECK-NEXT:  %[[iota_21:[^ ]+]] = s32[3,3]{1,0} iota(), iota_dimension=1
// CHECK-NEXT:  %[[compare_22:[^ ]+]] = pred[3,3]{1,0} compare(%[[iota_20]], %[[iota_21]]), direction=EQ
// CHECK-NEXT:  %[[and_24:[^ ]+]] = pred[3,3]{1,0} and(%[[broadcast_23]], %[[compare_22]])
// CHECK-NEXT:  %[[arg1_2:[^ ]+]] = f32[3,3]{1,0} parameter(1)
// CHECK-NEXT:  %[[constant_25:[^ ]+]] = f32[] constant(0)
// CHECK-NEXT:  %[[broadcast_26:[^ ]+]] = f32[3,3]{1,0} broadcast(%[[constant_25]]), dimensions={}
// CHECK-NEXT:  %[[select_27:[^ ]+]] = f32[3,3]{1,0} select(%[[and_24]], %[[arg1_2]], %[[broadcast_26]])
// CHECK-NEXT:  %[[constant_18:[^ ]+]] = f32[] constant(0)
// CHECK-NEXT:  %[[reduce_32:[^ ]+]] = f32[3]{0} reduce(%[[select_27]], %[[constant_18]]), dimensions={1}, to_apply=%[[$add_F32_28]]
// CHECK-NEXT:  %[[dot_33:[^ ]+]] = f32[3]{0} dot(%[[reduce_17]], %[[reduce_32]]), lhs_batch_dims={0}, lhs_contracting_dims={}, rhs_batch_dims={0}, rhs_contracting_dims={}, frontend_attributes={grad_x="false",grad_y="false"}
// CHECK-NEXT:  ROOT %[[transpose_34:[^ ]+]] = f32[3]{0} transpose(%[[dot_33]]), dimensions={0}

// CHECK:       ENTRY %[[$main_3:[^ ]+]]
// CHECK-NEXT:  %[[Arg_0_1:[^ ]+]] = f32[3,3]{1,0} parameter(0)
// CHECK-NEXT:  %[[cst:[^ ]+]] = f32[3,3]{1,0} constant({ { 1, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } })
// CHECK-NEXT:  %[[custom_call_2:[^ ]+]] = f32[3]{0} custom-call(%[[Arg_0_1]], %[[cst]]), custom_call_target="xla_builder.matrix.Einsum", backend_config="ii,ii->i"
// CHECK-NEXT:  ROOT %[[custom_call:[^ ]+]] = f32[3]{0} custom-call(%[[Arg_0_1]], %[[cst]]), custom_call_target="xla_builder.matrix.Einsum", called_computations={%[[$xla_builder_matrix_Einsum_35]]}

HloModule einsum_diag, entry_computation_layout={(f32[3,3])->f32[3]}

ENTRY %main.3 (Arg_0.1: f32[3,3]) -> f32[3] {
  %Arg_0.1 = f32[3,3] parameter(0)
  %cst = f32[3,3] constant(1)
  ROOT %custom-call.2 = f32[3] custom-call(%Arg_0.1, %cst), custom_call_target="xla_builder.matrix.Einsum", backend_config="ii,ii->i"
}

// -----

// CHECK-LABEL: HloModule einsum_inverse_diag, entry_computation_layout={(f32[3,3]{1,0})->f32[3,3]{1,0}}

// CHECK:       %[[$add_F32_4:[^ ]+]]
// CHECK-NEXT:  %[[lhs_5:[^ ]+]] = f32[] parameter(0)
// CHECK-NEXT:  %[[rhs_6:[^ ]+]] = f32[] parameter(1)
// CHECK-NEXT:  ROOT %[[add_7:[^ ]+]] = f32[] add(%[[lhs_5]], %[[rhs_6]])

// CHECK:       %[[$xla_builder_matrix_Einsum_21:[^ ]+]]
// CHECK-NEXT:  %[[constant_12:[^ ]+]] = pred[] constant(true)
// CHECK-NEXT:  %[[broadcast_16:[^ ]+]] = pred[3,3]{1,0} broadcast(%[[constant_12]]), dimensions={}
// CHECK-NEXT:  %[[iota_13:[^ ]+]] = s32[3,3]{1,0} iota(), iota_dimension=0
// CHECK-NEXT:  %[[iota_14:[^ ]+]] = s32[3,3]{1,0} iota(), iota_dimension=1
// CHECK-NEXT:  %[[compare_15:[^ ]+]] = pred[3,3]{1,0} compare(%[[iota_13]], %[[iota_14]]), direction=EQ
// CHECK-NEXT:  %[[and_17:[^ ]+]] = pred[3,3]{1,0} and(%[[broadcast_16]], %[[compare_15]])
// CHECK-NEXT:  %[[arg0_1:[^ ]+]] = f32[3]{0} parameter(0)
// CHECK-NEXT:  %[[arg1_2:[^ ]+]] = f32[3,3]{1,0} parameter(1)
// CHECK-NEXT:  %[[constant_3:[^ ]+]] = f32[] constant(0)
// CHECK-NEXT:  %[[reduce_8:[^ ]+]] = f32[3]{0} reduce(%[[arg1_2]], %[[constant_3]]), dimensions={1}, to_apply=%[[$add_F32_4]]
// CHECK-NEXT:  %[[dot_9:[^ ]+]] = f32[3]{0} dot(%[[arg0_1]], %[[reduce_8]]), lhs_batch_dims={0}, lhs_contracting_dims={}, rhs_batch_dims={0}, rhs_contracting_dims={}, frontend_attributes={grad_x="false",grad_y="false"}
// CHECK-NEXT:  %[[transpose_10:[^ ]+]] = f32[3]{0} transpose(%[[dot_9]]), dimensions={0}
// CHECK-NEXT:  %[[broadcast_11:[^ ]+]] = f32[3,3]{1,0} broadcast(%[[transpose_10]]), dimensions={0}
// CHECK-NEXT:  %[[constant_18:[^ ]+]] = f32[] constant(0)
// CHECK-NEXT:  %[[broadcast_19:[^ ]+]] = f32[3,3]{1,0} broadcast(%[[constant_18]]), dimensions={}
// CHECK-NEXT:  ROOT %[[select_20:[^ ]+]] = f32[3,3]{1,0} select(%[[and_17]], %[[broadcast_11]], %[[broadcast_19]])

// CHECK:       ENTRY %[[$main_3:[^ ]+]]
// CHECK-NEXT:  %[[cst:[^ ]+]] = f32[3]{0} constant({1, 0, 0})
// CHECK-NEXT:  %[[Arg_0_1:[^ ]+]] = f32[3,3]{1,0} parameter(0)
// CHECK-NEXT:  %[[custom_call_2:[^ ]+]] = f32[3,3]{1,0} custom-call(%[[cst]], %[[Arg_0_1]]), custom_call_target="xla_builder.matrix.Einsum", backend_config="i,ij->ii"
// CHECK-NEXT:  ROOT %[[custom_call:[^ ]+]] = f32[3,3]{1,0} custom-call(%[[cst]], %[[Arg_0_1]]), custom_call_target="xla_builder.matrix.Einsum", called_computations={%[[$xla_builder_matrix_Einsum_21]]}

HloModule einsum_inverse_diag, entry_computation_layout={(f32[3,3])->f32[3,3]}

ENTRY %main.3 (Arg_0.1: f32[3,3]) -> f32[3,3] {
  %Arg_0.1 = f32[3,3] parameter(0)
  %cst = f32[3] constant(1)
  ROOT %custom-call.2 = f32[3,3] custom-call(%cst, %Arg_0.1), custom_call_target="xla_builder.matrix.Einsum", backend_config="i,ij->ii"
}
