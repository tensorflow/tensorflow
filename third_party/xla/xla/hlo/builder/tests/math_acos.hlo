// NOTE: Assertions have been autogenerated by hlo/tools/generate_hlo_test_checks.py
// RUN: hlo-opt --passes=test-only-xla-builder --split-input-file %s | FileCheck %s

// CHECK-LABEL: HloModule acos_f32, entry_computation_layout={(f32[])->f32[]}

// CHECK:       %[[$xla_builder_math_Acos_17:[^ ]+]]
// CHECK-NEXT:  %[[arg0_1:[^ ]+]] = f32[] parameter(0)
// CHECK-NEXT:  %[[constant_2:[^ ]+]] = f32[] constant(-1)
// CHECK-NEXT:  %[[broadcast_3:[^ ]+]] = f32[] broadcast(%[[constant_2]]), dimensions={}
// CHECK-NEXT:  %[[compare_4:[^ ]+]] = pred[] compare(%[[arg0_1]], %[[broadcast_3]]), direction=NE
// CHECK-NEXT:  %[[constant_5:[^ ]+]] = f32[] constant(2)
// CHECK-NEXT:  %[[constant_6:[^ ]+]] = f32[] constant(1)
// CHECK-NEXT:  %[[multiply_7:[^ ]+]] = f32[] multiply(%[[arg0_1]], %[[arg0_1]])
// CHECK-NEXT:  %[[subtract_8:[^ ]+]] = f32[] subtract(%[[constant_6]], %[[multiply_7]])
// CHECK-NEXT:  %[[sqrt_9:[^ ]+]] = f32[] sqrt(%[[subtract_8]])
// CHECK-NEXT:  %[[constant_10:[^ ]+]] = f32[] constant(1)
// CHECK-NEXT:  %[[add_11:[^ ]+]] = f32[] add(%[[constant_10]], %[[arg0_1]])
// CHECK-NEXT:  %[[atan2_12:[^ ]+]] = f32[] atan2(%[[sqrt_9]], %[[add_11]])
// CHECK-NEXT:  %[[multiply_13:[^ ]+]] = f32[] multiply(%[[constant_5]], %[[atan2_12]])
// CHECK-NEXT:  %[[constant_14:[^ ]+]] = f32[] constant(3.14159274)
// CHECK-NEXT:  %[[broadcast_15:[^ ]+]] = f32[] broadcast(%[[constant_14]]), dimensions={}
// CHECK-NEXT:  ROOT %[[select_16:[^ ]+]] = f32[] select(%[[compare_4]], %[[multiply_13]], %[[broadcast_15]])

// CHECK:       ENTRY %[[$main_3:[^ ]+]]
// CHECK-NEXT:  %[[Arg_0_1:[^ ]+]] = f32[] parameter(0)
// CHECK-NEXT:  %[[custom_call_2:[^ ]+]] = f32[] custom-call(%[[Arg_0_1]]), custom_call_target="xla_builder.math.Acos"
// CHECK-NEXT:  ROOT %[[custom_call:[^ ]+]] = f32[] custom-call(%[[Arg_0_1]]), custom_call_target="xla_builder.math.Acos", called_computations={%[[$xla_builder_math_Acos_17]]}

HloModule acos_f32, entry_computation_layout={(f32[])->f32[]}

ENTRY %main.3 (Arg_0.1: f32[]) -> f32[] {
  %Arg_0.1 = f32[] parameter(0)
  ROOT %custom-call.2 = f32[] custom-call(%Arg_0.1), custom_call_target="xla_builder.math.Acos"
}

// -----

// CHECK-LABEL: HloModule acos_f64, entry_computation_layout={(f64[])->f64[]}

// CHECK:       %[[$xla_builder_math_Acos_17:[^ ]+]]
// CHECK-NEXT:  %[[arg0_1:[^ ]+]] = f64[] parameter(0)
// CHECK-NEXT:  %[[constant_2:[^ ]+]] = f64[] constant(-1)
// CHECK-NEXT:  %[[broadcast_3:[^ ]+]] = f64[] broadcast(%[[constant_2]]), dimensions={}
// CHECK-NEXT:  %[[compare_4:[^ ]+]] = pred[] compare(%[[arg0_1]], %[[broadcast_3]]), direction=NE
// CHECK-NEXT:  %[[constant_5:[^ ]+]] = f64[] constant(2)
// CHECK-NEXT:  %[[constant_6:[^ ]+]] = f64[] constant(1)
// CHECK-NEXT:  %[[multiply_7:[^ ]+]] = f64[] multiply(%[[arg0_1]], %[[arg0_1]])
// CHECK-NEXT:  %[[subtract_8:[^ ]+]] = f64[] subtract(%[[constant_6]], %[[multiply_7]])
// CHECK-NEXT:  %[[sqrt_9:[^ ]+]] = f64[] sqrt(%[[subtract_8]])
// CHECK-NEXT:  %[[constant_10:[^ ]+]] = f64[] constant(1)
// CHECK-NEXT:  %[[add_11:[^ ]+]] = f64[] add(%[[constant_10]], %[[arg0_1]])
// CHECK-NEXT:  %[[atan2_12:[^ ]+]] = f64[] atan2(%[[sqrt_9]], %[[add_11]])
// CHECK-NEXT:  %[[multiply_13:[^ ]+]] = f64[] multiply(%[[constant_5]], %[[atan2_12]])
// CHECK-NEXT:  %[[constant_14:[^ ]+]] = f64[] constant(3.1415926535897931)
// CHECK-NEXT:  %[[broadcast_15:[^ ]+]] = f64[] broadcast(%[[constant_14]]), dimensions={}
// CHECK-NEXT:  ROOT %[[select_16:[^ ]+]] = f64[] select(%[[compare_4]], %[[multiply_13]], %[[broadcast_15]])

// CHECK:       ENTRY %[[$main_3:[^ ]+]]
// CHECK-NEXT:  %[[Arg_0_1:[^ ]+]] = f64[] parameter(0)
// CHECK-NEXT:  %[[custom_call_2:[^ ]+]] = f64[] custom-call(%[[Arg_0_1]]), custom_call_target="xla_builder.math.Acos"
// CHECK-NEXT:  ROOT %[[custom_call:[^ ]+]] = f64[] custom-call(%[[Arg_0_1]]), custom_call_target="xla_builder.math.Acos", called_computations={%[[$xla_builder_math_Acos_17]]}

HloModule acos_f64, entry_computation_layout={(f64[])->f64[]}

ENTRY %main.3 (Arg_0.1: f64[]) -> f64[] {
  %Arg_0.1 = f64[] parameter(0)
  ROOT %custom-call.2 = f64[] custom-call(%Arg_0.1), custom_call_target="xla_builder.math.Acos"
}

// -----

// CHECK-LABEL: HloModule acos_complex64, entry_computation_layout={(c64[])->c64[]}

// CHECK:       %[[$xla_builder_math_Acos_15:[^ ]+]]
// CHECK-NEXT:  %[[constant_3:[^ ]+]] = f32[] constant(0)
// CHECK-NEXT:  %[[constant_4:[^ ]+]] = f32[] constant(1)
// CHECK-NEXT:  %[[complex_5:[^ ]+]] = c64[] complex(%[[constant_3]], %[[constant_4]])
// CHECK-NEXT:  %[[arg0_1:[^ ]+]] = c64[] parameter(0)
// CHECK-NEXT:  %[[constant_2:[^ ]+]] = c64[] constant((1, 0))
// CHECK-NEXT:  %[[add_6:[^ ]+]] = c64[] add(%[[constant_2]], %[[arg0_1]])
// CHECK-NEXT:  %[[subtract_7:[^ ]+]] = c64[] subtract(%[[constant_2]], %[[arg0_1]])
// CHECK-NEXT:  %[[multiply_8:[^ ]+]] = c64[] multiply(%[[add_6]], %[[subtract_7]])
// CHECK-NEXT:  %[[sqrt_9:[^ ]+]] = c64[] sqrt(%[[multiply_8]])
// CHECK-NEXT:  %[[multiply_10:[^ ]+]] = c64[] multiply(%[[complex_5]], %[[sqrt_9]])
// CHECK-NEXT:  %[[add_11:[^ ]+]] = c64[] add(%[[arg0_1]], %[[multiply_10]])
// CHECK-NEXT:  %[[log_12:[^ ]+]] = c64[] log(%[[add_11]])
// CHECK-NEXT:  %[[multiply_13:[^ ]+]] = c64[] multiply(%[[complex_5]], %[[log_12]])
// CHECK-NEXT:  ROOT %[[negate_14:[^ ]+]] = c64[] negate(%[[multiply_13]])

// CHECK:       ENTRY %[[$main_3:[^ ]+]]
// CHECK-NEXT:  %[[Arg_0_1:[^ ]+]] = c64[] parameter(0)
// CHECK-NEXT:  %[[custom_call_2:[^ ]+]] = c64[] custom-call(%[[Arg_0_1]]), custom_call_target="xla_builder.math.Acos"
// CHECK-NEXT:  ROOT %[[custom_call:[^ ]+]] = c64[] custom-call(%[[Arg_0_1]]), custom_call_target="xla_builder.math.Acos", called_computations={%[[$xla_builder_math_Acos_15]]}

HloModule acos_complex64, entry_computation_layout={(c64[])->c64[]}

ENTRY %main.3 (Arg_0.1: c64[]) -> c64[] {
  %Arg_0.1 = c64[] parameter(0)
  ROOT %custom-call.2 = c64[] custom-call(%Arg_0.1), custom_call_target="xla_builder.math.Acos"
}

// -----

// CHECK-LABEL: HloModule acos_complex128, entry_computation_layout={(c128[])->c128[]}

// CHECK:       %[[$xla_builder_math_Acos_15:[^ ]+]]
// CHECK-NEXT:  %[[constant_3:[^ ]+]] = f64[] constant(0)
// CHECK-NEXT:  %[[constant_4:[^ ]+]] = f64[] constant(1)
// CHECK-NEXT:  %[[complex_5:[^ ]+]] = c128[] complex(%[[constant_3]], %[[constant_4]])
// CHECK-NEXT:  %[[arg0_1:[^ ]+]] = c128[] parameter(0)
// CHECK-NEXT:  %[[constant_2:[^ ]+]] = c128[] constant((1, 0))
// CHECK-NEXT:  %[[add_6:[^ ]+]] = c128[] add(%[[constant_2]], %[[arg0_1]])
// CHECK-NEXT:  %[[subtract_7:[^ ]+]] = c128[] subtract(%[[constant_2]], %[[arg0_1]])
// CHECK-NEXT:  %[[multiply_8:[^ ]+]] = c128[] multiply(%[[add_6]], %[[subtract_7]])
// CHECK-NEXT:  %[[sqrt_9:[^ ]+]] = c128[] sqrt(%[[multiply_8]])
// CHECK-NEXT:  %[[multiply_10:[^ ]+]] = c128[] multiply(%[[complex_5]], %[[sqrt_9]])
// CHECK-NEXT:  %[[add_11:[^ ]+]] = c128[] add(%[[arg0_1]], %[[multiply_10]])
// CHECK-NEXT:  %[[log_12:[^ ]+]] = c128[] log(%[[add_11]])
// CHECK-NEXT:  %[[multiply_13:[^ ]+]] = c128[] multiply(%[[complex_5]], %[[log_12]])
// CHECK-NEXT:  ROOT %[[negate_14:[^ ]+]] = c128[] negate(%[[multiply_13]])

// CHECK:       ENTRY %[[$main_3:[^ ]+]]
// CHECK-NEXT:  %[[Arg_0_1:[^ ]+]] = c128[] parameter(0)
// CHECK-NEXT:  %[[custom_call_2:[^ ]+]] = c128[] custom-call(%[[Arg_0_1]]), custom_call_target="xla_builder.math.Acos"
// CHECK-NEXT:  ROOT %[[custom_call:[^ ]+]] = c128[] custom-call(%[[Arg_0_1]]), custom_call_target="xla_builder.math.Acos", called_computations={%[[$xla_builder_math_Acos_15]]}

HloModule acos_complex128, entry_computation_layout={(c128[])->c128[]}

ENTRY %main.3 (Arg_0.1: c128[]) -> c128[] {
  %Arg_0.1 = c128[] parameter(0)
  ROOT %custom-call.2 = c128[] custom-call(%Arg_0.1), custom_call_target="xla_builder.math.Acos"
}
