// NOTE: Assertions have been autogenerated by hlo/tools/generate_hlo_test_checks.py
// RUN: hlo-opt %s --split-input-file --passes=logistic-expander,reshape-mover | FileCheck %s
// RUN: echo 'Preexisting "RUN:" lines should be moved to the top of the file.'
// RUN: echo "Test the tool's handling of a weirdly placed RUN line."
// RUN: echo "Another weirdly placed RUN line."
// RUN: echo "Yet another weirdly placed RUN line."

// CHECK-LABEL: HloModule TestRemovalOfOldFileCheckLines, entry_computation_layout={()->()}

// CHECK-LABEL: ENTRY %no_op
// CHECK-NEXT:  ROOT %no_op = () tuple()

// The next line of the output file should be a comment, but not a "DIRECTIVE:".
// The next two lines of the output file should be [empty line, comment line].

// The next line of the output file should be an HloModule declaration.
HloModule TestRemovalOfOldFileCheckLines

ENTRY no_op {
  ROOT no_op = () tuple()
}

// -----

// CHECK-LABEL: HloModule TestBasicFunctionality, entry_computation_layout={(u8[], u8[], u8[], u8[])->u8[]}

// CHECK-LABEL: ENTRY %test_case
// CHECK-NEXT:  %[[foo:[^ ]+]] = u8[] parameter(0)
// CHECK-NEXT:  %[[bar:[^ ]+]] = u8[] parameter(1)
// CHECK-NEXT:  %[[foobar:[^ ]+]] = u8[] add(%[[foo]], %[[bar]])
// CHECK-NEXT:  %[[baz:[^ ]+]] = u8[] parameter(2)
// CHECK-NEXT:  %[[qux:[^ ]+]] = u8[] parameter(3)
// CHECK-NEXT:  %[[bazqux:[^ ]+]] = u8[] add(%[[baz]], %[[qux]])
// CHECK-NEXT:  ROOT %[[foobarbazqux:[^ ]+]] = u8[] add(%[[foobar]], %[[bazqux]])

HloModule TestBasicFunctionality

ENTRY test_case {
  foo = u8[] parameter(0)
  bar = u8[] parameter(1)
  baz = u8[] parameter(2)
  qux = u8[] parameter(3)
  foobar = u8[] add(foo, bar)
  bazqux = u8[] add(baz, qux)
  ROOT foobarbazqux = u8[] add(foobar, bazqux)
}

// -----

// CHECK-LABEL: HloModule TestWithRelevantOptimizationPasses, entry_computation_layout={(f32[1,8,1,7]{3,2,1,0}, f32[1,8,1,7]{3,2,1,0})->f32[8,7]{1,0}}

// CHECK-LABEL: ENTRY %test_case
// CHECK-NEXT:  %[[constant:[^ ]+]] = f32[] constant(1)
// CHECK-NEXT:  %[[broadcast:[^ ]+]] = f32[8,7]{1,0} broadcast(%[[constant]]), dimensions={}
// CHECK-NEXT:  %[[parameter_anon:[^ ]+]] = f32[1,8,1,7]{3,2,1,0} parameter(0)
// CHECK-NEXT:  %[[reshape0:[^ ]+]] = f32[8,7]{1,0} reshape(%[[parameter_anon]])
// CHECK-NEXT:  %[[reshape:[^ ]+]] = f32[1,8,1,7]{3,2,1,0} reshape(%[[reshape0]])
// CHECK-NEXT:  %[[negate_1:[^ ]+]] = f32[1,8,1,7]{3,2,1,0} negate(%[[reshape]])
// CHECK-NEXT:  %[[reshape_1:[^ ]+]] = f32[8,7]{1,0} reshape(%[[negate_1]])
// CHECK-NEXT:  %[[exponential:[^ ]+]] = f32[8,7]{1,0} exponential(%[[reshape_1]])
// CHECK-NEXT:  %[[add_1:[^ ]+]] = f32[8,7]{1,0} add(%[[broadcast]], %[[exponential]])
// CHECK-NEXT:  %[[divide:[^ ]+]] = f32[8,7]{1,0} divide(%[[broadcast]], %[[add_1]])
// CHECK-NEXT:  %[[parameter_anon_1:[^ ]+]] = f32[1,8,1,7]{3,2,1,0} parameter(1)
// CHECK-NEXT:  %[[reshape1:[^ ]+]] = f32[8,7]{1,0} reshape(%[[parameter_anon_1]])
// CHECK-NEXT:  ROOT %[[add:[^ ]+]] = f32[8,7]{1,0} add(%[[divide]], %[[reshape1]])

HloModule TestWithRelevantOptimizationPasses

ENTRY test_case {
  reshape0 = f32[8,7] reshape(f32[1,8,1,7] parameter(0))
  reshape1 = f32[8,7] reshape(f32[1,8,1,7] parameter(1))
  logistic = f32[8,7] logistic(reshape0)
  ROOT add = f32[8,7] add(logistic, reshape1)
}

// -----

// CHECK-LABEL: HloModule TestRunDirectivesInMiddleOfTestFile, entry_computation_layout={()->()}

// CHECK-LABEL: ENTRY %no_op
// CHECK-NEXT:  ROOT %no_op = () tuple()

HloModule TestRunDirectivesInMiddleOfTestFile

ENTRY no_op {
  ROOT no_op = () tuple()
}

// -----

// CHECK-LABEL: HloModule TestSymbolNameDisambiguation, entry_computation_layout={()->f32[]}

// CHECK:       %[[$foo_bar_baz_0:[^ ]+]]
// CHECK-NEXT:  %[[foo_bar_baz_0_1:[^ ]+]] = f32[] parameter(0)
// CHECK-NEXT:  %[[foo_bar_baz_0_2:[^ ]+]] = f32[] parameter(1)
// CHECK-NEXT:  %[[foo_bar_baz_0_3:[^ ]+]] = f32[] multiply(%[[foo_bar_baz_0_1]], %[[foo_bar_baz_0_2]])
// CHECK-NEXT:  ROOT %[[foobarbaz:[^ ]+]] = f32[] add(%[[foo_bar_baz_0_1]], %[[foo_bar_baz_0_3]])

// CHECK-LABEL: %foo.bar.baz_0
// CHECK-NEXT:  %[[foo_bar_baz_0_4:[^ ]+]] = f32[] parameter(0)
// CHECK-NEXT:  %[[foo_bar_baz_0_5:[^ ]+]] = f32[] parameter(1)
// CHECK-NEXT:  %[[foo_bar_baz_0_6:[^ ]+]] = f32[] add(%[[foo_bar_baz_0_4]], %[[foo_bar_baz_0_5]])
// CHECK-NEXT:  ROOT %[[foobarbaz_1:[^ ]+]] = f32[] multiply(%[[foo_bar_baz_0_4]], %[[foo_bar_baz_0_6]])

// CHECK-LABEL: ENTRY %foobarbaz
// CHECK-NEXT:  %[[constant_0:[^ ]+]] = f32[4]{0} constant({8.7, 6.5, 4.3, 2.1})
// CHECK-NEXT:  %[[constant_0_1:[^ ]+]] = f32[4]{0} constant({1.2, 3.4, 5.6, 7.8})
// CHECK-NEXT:  %[[call_foo_bar_baz_0:[^ ]+]] = f32[] call(%[[constant_0]], %[[constant_0_1]]), to_apply=%foo.bar.baz_0
// CHECK-NEXT:  %[[call_foo_bar_baz_0_1:[^ ]+]] = f32[] call(%[[constant_0_1]], %[[constant_0]]), to_apply=%[[$foo_bar_baz_0]]
// CHECK-NEXT:  ROOT %[[sum:[^ ]+]] = f32[] add(%[[call_foo_bar_baz_0_1]], %[[call_foo_bar_baz_0_1]])

// Test the tool's ability to disambiguate symbols with extremely similar names.
HloModule TestSymbolNameDisambiguation

// Check generated functions (whose names end with ".<line>") using "CHECK".
foo.bar.baz.0 {
  foo_bar.baz.0 = f32[] parameter(0)
  foo.bar_baz.0 = f32[] parameter(1)
  foo_bar_baz.0 = f32[] multiply(foo_bar.baz.0, foo.bar_baz.0)
  ROOT foobarbaz = f32[] add(foo_bar.baz.0, foo_bar_baz.0)
}

// Check explicitly named functions (no ".<line>" suffixes) using "CHECK-LABEL".
foo.bar.baz_0 {
  foo_bar.baz_0 = f32[] parameter(0)
  foo.bar_baz_0 = f32[] parameter(1)
  foo_bar_baz_0 = f32[] add(foo_bar.baz_0, foo.bar_baz_0)
  ROOT foobarbaz = f32[] multiply(foo_bar.baz_0, foo_bar_baz_0)
}

// Check explicitly named functions (no ".<line>" suffixes) using "CHECK-LABEL".
ENTRY foobarbaz {
  constant.0 = f32[4] constant({1.2, 3.4, 5.6, 7.8})
  constant_0 = f32[4] constant({8.7, 6.5, 4.3, 2.1})
  call-foo.bar.baz.0 = f32[] call(f32[4] constant.0, f32[4] constant_0), to_apply=foo.bar.baz.0
  call-foo.bar.baz_0 = f32[] call(f32[4] constant_0, f32[4] constant.0), to_apply=foo.bar.baz_0
  ROOT sum = f32[] add(f32[] call-foo.bar.baz.0, f32[] call-foo.bar.baz.0)
}
