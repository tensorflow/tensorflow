diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index dd1ead4..ff478d6 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,429 +1,240 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/libcxx/include/__algorithm/find_if.h b/libcxx/include/__algorithm/find_if.h
---- a/libcxx/include/__algorithm/find_if.h
-+++ b/libcxx/include/__algorithm/find_if.h
-@@ -11,7 +11,6 @@
- #define _LIBCPP___ALGORITHM_FIND_IF_H
+diff -ruN --strip-trailing-cr a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
+--- a/clang/lib/Driver/ToolChains/Clang.cpp
++++ b/clang/lib/Driver/ToolChains/Clang.cpp
+@@ -1065,10 +1065,6 @@
+     A->render(Args, CmdArgs);
+   }
  
- #include <__config>
--#include <__memory/valid_range.h>
- 
- #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
- #  pragma GCC system_header
-@@ -22,8 +21,6 @@
- template <class _InputIterator, class _Predicate>
- [[__nodiscard__]] inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 _InputIterator
- find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
--  std::__assume_valid_range(__first, __last);
+-  Args.addAllArgs(CmdArgs,
+-                  {options::OPT_D, options::OPT_U, options::OPT_I_Group,
+-                   options::OPT_F, options::OPT_embed_dir_EQ});
 -
-   for (; __first != __last; ++__first)
-     if (__pred(*__first))
-       break;
-diff -ruN --strip-trailing-cr a/libcxx/include/CMakeLists.txt b/libcxx/include/CMakeLists.txt
---- a/libcxx/include/CMakeLists.txt
-+++ b/libcxx/include/CMakeLists.txt
-@@ -607,7 +607,6 @@
-   __memory/unique_temporary_buffer.h
-   __memory/uses_allocator.h
-   __memory/uses_allocator_construction.h
--  __memory/valid_range.h
-   __memory_resource/memory_resource.h
-   __memory_resource/monotonic_buffer_resource.h
-   __memory_resource/polymorphic_allocator.h
-@@ -932,6 +931,7 @@
-   __utility/in_place.h
-   __utility/integer_sequence.h
-   __utility/is_pointer_in_range.h
-+  __utility/is_valid_range.h
-   __utility/lazy_synth_three_way_comparator.h
-   __utility/move.h
-   __utility/no_destroy.h
-diff -ruN --strip-trailing-cr a/libcxx/include/__memory/valid_range.h b/libcxx/include/__memory/valid_range.h
---- a/libcxx/include/__memory/valid_range.h
-+++ b/libcxx/include/__memory/valid_range.h
-@@ -1,74 +0,0 @@
--//===----------------------------------------------------------------------===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
+   if (C.isOffloadingHostKind(Action::OFK_Cuda) ||
+       JA.isDeviceOffloading(Action::OFK_Cuda)) {
+     // Collect all enabled NVPTX architectures.
+@@ -1091,6 +1087,10 @@
+     }
+   }
+ 
++  Args.addAllArgs(CmdArgs,
++                  {options::OPT_D, options::OPT_U, options::OPT_I_Group,
++                   options::OPT_F, options::OPT_embed_dir_EQ});
++
+   // Add -Wp, and -Xpreprocessor if using the preprocessor.
+ 
+   // FIXME: There is a very unfortunate problem here, some troubled
+diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReaderDecl.cpp b/clang/lib/Serialization/ASTReaderDecl.cpp
+--- a/clang/lib/Serialization/ASTReaderDecl.cpp
++++ b/clang/lib/Serialization/ASTReaderDecl.cpp
+@@ -3642,9 +3642,23 @@
+ void ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader,
+                                            Redeclarable<VarDecl> *D,
+                                            Decl *Previous, Decl *Canon) {
++  auto *VD = static_cast<VarDecl *>(D);
+   auto *PrevVD = cast<VarDecl>(Previous);
+   D->RedeclLink.setPrevious(PrevVD);
+   D->First = PrevVD->First;
++
++  // We should keep at most one definition on the chain.
++  // FIXME: Cache the definition once we've found it. Building a chain with
++  // N definitions currently takes O(N^2) time here.
++  if (VD->isThisDeclarationADefinition() == VarDecl::Definition) {
++    for (VarDecl *CurD = PrevVD; CurD; CurD = CurD->getPreviousDecl()) {
++      if (CurD->isThisDeclarationADefinition() == VarDecl::Definition) {
++        Reader.mergeDefinitionVisibility(CurD, VD);
++        VD->demoteThisDefinitionToDeclaration();
++        break;
++      }
++    }
++  }
+ }
+ 
+ static bool isUndeducedReturnType(QualType T) {
+diff -ruN --strip-trailing-cr a/clang/test/Driver/cuda-arch-list.cu b/clang/test/Driver/cuda-arch-list.cu
+--- a/clang/test/Driver/cuda-arch-list.cu
++++ b/clang/test/Driver/cuda-arch-list.cu
+@@ -23,6 +23,11 @@
+ // RUN:   --offload-arch=sm_60 --offload-arch=sm_70 --no-offload-arch=sm_60 %s 2>&1 \
+ // RUN: | FileCheck -check-prefixes=DEVICE70-ONLY,HOST70-ONLY %s
+ 
++// Verify that user-specified -D__CUDA_ARCH_LIST__ overrides the driver-generated one
++// RUN: %clang -### --target=x86_64-unknown-linux-gnu -nocudainc -nocudalib \
++// RUN:   --offload-arch=sm_60 -D__CUDA_ARCH_LIST__=999 %s 2>&1 \
++// RUN: | FileCheck -check-prefixes=DEVICE-OVERRIDE,HOST-OVERRIDE %s
++
+ // DEVICE60: "-cc1" "-triple" "nvptx64-nvidia-cuda"
+ // DEVICE60-SAME: "-target-cpu" "sm_60"
+ // DEVICE60-SAME: "-D__CUDA_ARCH_LIST__=600"
+@@ -54,3 +59,12 @@
+ 
+ // HOST70-ONLY: "-cc1" "-triple" "x86_64-unknown-linux-gnu"
+ // HOST70-ONLY-SAME: "-D__CUDA_ARCH_LIST__=700"
++
++// DEVICE-OVERRIDE: "-cc1" "-triple" "nvptx64-nvidia-cuda"
++// DEVICE-OVERRIDE-SAME: "-target-cpu" "sm_60"
++// DEVICE-OVERRIDE-SAME: "-D__CUDA_ARCH_LIST__=600"
++// DEVICE-OVERRIDE-SAME: "-D" "__CUDA_ARCH_LIST__=999"
++
++// HOST-OVERRIDE: "-cc1" "-triple" "x86_64-unknown-linux-gnu"
++// HOST-OVERRIDE-SAME: "-D__CUDA_ARCH_LIST__=600"
++// HOST-OVERRIDE-SAME: "-D" "__CUDA_ARCH_LIST__=999"
+diff -ruN --strip-trailing-cr a/clang/test/Modules/pr149404-02.cppm b/clang/test/Modules/pr149404-02.cppm
+--- a/clang/test/Modules/pr149404-02.cppm
++++ b/clang/test/Modules/pr149404-02.cppm
+@@ -1,104 +0,0 @@
+-// RUN: rm -rf %t
+-// RUN: mkdir -p %t
+-// RUN: split-file %s %t
 -
--#ifndef _LIBCPP___MEMORY_VALID_RANGE_H
--#define _LIBCPP___MEMORY_VALID_RANGE_H
+-// RUN: %clang_cc1 -std=c++20 -emit-module-interface -o %t/format.pcm %t/format.cppm
+-// RUN: %clang_cc1 -std=c++20  -emit-module-interface -o %t/includes_in_gmf.pcm %t/includes_in_gmf.cppm
+-// RUN: %clang_cc1 -std=c++20 -fprebuilt-module-path=%t %t/test.cpp -verify -fsyntax-only
 -
--#include <__algorithm/comp.h>
--#include <__assert>
--#include <__config>
--#include <__iterator/iterator_traits.h>
--#include <__memory/assume_aligned.h>
--#include <__memory/pointer_traits.h>
--#include <__type_traits/is_constant_evaluated.h>
--#include <__type_traits/is_same.h>
--#include <__type_traits/remove_cvref.h>
+-// RUN: %clang_cc1 -std=c++20 -emit-reduced-module-interface -o %t/format.pcm %t/format.cppm
+-// RUN: %clang_cc1 -std=c++20  -emit-reduced-module-interface -o %t/includes_in_gmf.pcm %t/includes_in_gmf.cppm
+-// RUN: %clang_cc1 -std=c++20 -fprebuilt-module-path=%t %t/test.cpp -verify -fsyntax-only
 -
--#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
--#  pragma GCC system_header
--#endif
+-//--- format.h
+-#pragma once
 -
--_LIBCPP_BEGIN_NAMESPACE_STD
+-namespace test {
 -
--// A valid range as defined by the C++ Standard has the following constraints:
--// - [__first, __last) is dereferenceable
--// - __last is reachable from __first
--// - if __first and __last are contiguous iterators, the pointers they "decay to" are correctly aligned according to the
--// language rules for pointers
+-template <class _Tp>
+-struct type_identity {
+-    typedef _Tp type;
+-};
 -
--// This function attempts to detect invalid ranges as defined above. Specifically, it checks bullet (2). This also means
--// that it doesn't return whether a range is actually valid, but only whether a range is definitely not valid.
--// The checks may be extended in the future.
 -template <class _Tp>
--_LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_SANITIZE("address") bool
--__is_valid_range(const _Tp* __first, const _Tp* __last) {
--  if (__libcpp_is_constant_evaluated()) {
--    // If this is not a constant during constant evaluation, that is because __first and __last are not
--    // part of the same allocation. If they are part of the same allocation, we must still make sure they
--    // are ordered properly.
--    return __builtin_constant_p(__first <= __last) && __first <= __last;
--  }
+-using type_identity_t = typename type_identity<_Tp>::type;
+-
+-
+-template <class _Tp, class _CharT>
+-struct formatter
+-{
+-    formatter() = delete;
+-};
+-
+-template <>
+-struct formatter<char, char>
+-{};
+-
+-template <class _CharT, class... _Args>
+-struct basic_format_string {
+-    static inline const int __handles_{ [] {
+-        formatter<char, _CharT> f;
+-        (void)f;
+-        return 0;
+-        }() };
+-    
+-    consteval basic_format_string(const _CharT*) {
+-        (void)__handles_;
+-    }
+-};
+-
+-template <class... _Args>
+-using wformat_string = basic_format_string<wchar_t, type_identity_t<_Args>...>;
+-
+-template <class... _Args>
+-using format_string = basic_format_string<char, type_identity_t<_Args>...>;
+-
+-template <class... _Args>
+-void format(format_string<_Args...> __fmt, _Args&&... __args) {}
+-
+-template <class... _Args>
+-void format(wformat_string<_Args...> __fmt, _Args&&... __args) {}
+-
+-}
+-
+-//--- format.cppm
+-module;
+-#include "format.h"
+-export module format;
+-
+-export namespace test {
+-	using test::format;
+-	using test::formatter;
+-	using test::format_string;
+-}
+-
+-auto something() -> void
+-{
+-	auto a = 'a';
+-	test::format("{}", a);
+-}
 -
--  return !__less<>()(__last, __first);
+-//--- includes_in_gmf.cppm
+-module;
+-#include "format.h"
+-export module includes_in_gmf;
+-
+-namespace test {
+-	using test::format;
+-	using test::formatter;
+-	using test::format_string;
 -}
 -
--// This function allows the compiler to assume that [__first, __last) is a valid range as defined above.
+-//--- test.cpp
+-// expected-no-diagnostics
+-import format;
+-import includes_in_gmf;
+-
+-auto what() -> void
+-{
+-    auto a = 'a';
+-    test::format("{}", a);
+-
+-    constexpr auto fs = "{}"; // test::format_string<char>{ "{}" }; // <- same result even passing exact param type
+-    test::format(fs, 'r');
+-}
+diff -ruN --strip-trailing-cr a/clang/test/Modules/pr172241.cppm b/clang/test/Modules/pr172241.cppm
+--- a/clang/test/Modules/pr172241.cppm
++++ b/clang/test/Modules/pr172241.cppm
+@@ -1,47 +0,0 @@
+-// RUN: rm -rf %t
+-// RUN: mkdir -p %t
+-// RUN: split-file %s %t
 -//
--// In practice, we only add explicit assumptions for bullets (1) and (3). These assumptions allow (currently only
--// clang-based compilers) to auto-vectorize algorithms that contain early returns.
--template <class _Iter, class _Sent>
--_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
--__assume_valid_range([[__maybe_unused__]] _Iter&& __first, [[__maybe_unused__]] _Sent&& __last) {
--#if defined(_LIBCPP_CLANG_VER) && _LIBCPP_CLANG_VER >= 2200 && !defined(_LIBCPP_CXX03_LANG)
--  if constexpr (__libcpp_is_contiguous_iterator<__remove_cvref_t<_Iter>>::value &&
--                is_same<__remove_cvref_t<_Iter>, __remove_cvref_t<_Sent>>::value) {
--    _LIBCPP_ASSERT_INTERNAL(std::__is_valid_range(std::__to_address(__first), std::__to_address(__last)),
--                            "Valid range assumption does not hold");
--    if (!__libcpp_is_constant_evaluated()) {
--      using __value_type = typename iterator_traits<__remove_cvref_t<_Iter>>::value_type;
--      __builtin_assume_dereferenceable(std::__to_address(__first), (__last - __first) * sizeof(__value_type));
--      (void)std::__assume_aligned<_LIBCPP_ALIGNOF(__value_type)>(std::__to_address(__first));
--      (void)std::__assume_aligned<_LIBCPP_ALIGNOF(__value_type)>(std::__to_address(__last));
+-// RUN: %clang_cc1 -std=c++20 -triple %itanium_abi_triple %t/m.cppm -emit-module-interface -o %t/m.pcm
+-// RUN: %clang_cc1 -std=c++20 -triple %itanium_abi_triple %t/use.cpp -fmodule-file=m=%t/m.pcm -emit-llvm -o - | FileCheck %t/use.cpp
+-//
+-// RUN: %clang_cc1 -std=c++20 -triple %itanium_abi_triple %t/m.cppm -emit-reduced-module-interface -o %t/m.pcm
+-// RUN: %clang_cc1 -std=c++20 -triple %itanium_abi_triple %t/use.cpp -fmodule-file=m=%t/m.pcm -emit-llvm -o - | FileCheck %t/use.cpp
+-
+-//--- header.h
+-#pragma once
+-
+-template <unsigned T>
+-class Templ {
+-public:
+-    void lock() { __set_locked_bit(); }
+-
+-private:
+-    static constexpr auto __set_locked_bit = [](){};
+-};
+-
+-class JT {
+-public:
+-    ~JT() {
+-        Templ<4> state;
+-        state.lock();
 -    }
--  }
--#endif
--}
+-};
 -
--_LIBCPP_END_NAMESPACE_STD
+-//--- m.cppm
+-module;
+-#include "header.h"
+-export module m;
+-export struct M {
+-    JT jt;
+-};
+-//--- use.cpp
+-#include "header.h"
+-import m;
 -
--#endif // _LIBCPP___MEMORY_VALID_RANGE_H
-diff -ruN --strip-trailing-cr a/libcxx/include/module.modulemap.in b/libcxx/include/module.modulemap.in
---- a/libcxx/include/module.modulemap.in
-+++ b/libcxx/include/module.modulemap.in
-@@ -1690,7 +1690,6 @@
-     }
-     module uses_allocator                     { header "__memory/uses_allocator.h" }
-     module uses_allocator_construction        { header "__memory/uses_allocator_construction.h" }
--    module valid_range                        { header "__memory/valid_range.h" }
- 
-     header "memory"
-     export *
-@@ -2173,6 +2172,7 @@
-     }
-     module integer_sequence                { header "__utility/integer_sequence.h" }
-     module is_pointer_in_range             { header "__utility/is_pointer_in_range.h" }
-+    module is_valid_range                  { header "__utility/is_valid_range.h" }
-     module lazy_synth_three_way_comparator { header "__utility/lazy_synth_three_way_comparator.h" }
-     module move                            { header "__utility/move.h" }
-     module no_destroy                      { header "__utility/no_destroy.h" }
-diff -ruN --strip-trailing-cr a/libcxx/include/streambuf b/libcxx/include/streambuf
---- a/libcxx/include/streambuf
-+++ b/libcxx/include/streambuf
-@@ -117,8 +117,8 @@
- #    include <__assert>
- #    include <__fwd/streambuf.h>
- #    include <__locale>
--#    include <__memory/valid_range.h>
- #    include <__type_traits/is_same.h>
-+#    include <__utility/is_valid_range.h>
- #    include <__utility/scope_guard.h>
- #    include <climits>
- #    include <ios>
-diff -ruN --strip-trailing-cr a/libcxx/include/__utility/is_pointer_in_range.h b/libcxx/include/__utility/is_pointer_in_range.h
---- a/libcxx/include/__utility/is_pointer_in_range.h
-+++ b/libcxx/include/__utility/is_pointer_in_range.h
-@@ -12,12 +12,12 @@
- #include <__algorithm/comp.h>
- #include <__assert>
- #include <__config>
--#include <__memory/valid_range.h>
- #include <__type_traits/enable_if.h>
- #include <__type_traits/integral_constant.h>
- #include <__type_traits/is_constant_evaluated.h>
- #include <__type_traits/void_t.h>
- #include <__utility/declval.h>
-+#include <__utility/is_valid_range.h>
- 
- #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
- #  pragma GCC system_header
-diff -ruN --strip-trailing-cr a/libcxx/include/__utility/is_valid_range.h b/libcxx/include/__utility/is_valid_range.h
---- a/libcxx/include/__utility/is_valid_range.h
-+++ b/libcxx/include/__utility/is_valid_range.h
-@@ -0,0 +1,37 @@
-+//===----------------------------------------------------------------------===//
-+//
-+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-+// See https://llvm.org/LICENSE.txt for license information.
-+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-+//
-+//===----------------------------------------------------------------------===//
-+
-+#ifndef _LIBCPP___UTILITY_IS_VALID_RANGE_H
-+#define _LIBCPP___UTILITY_IS_VALID_RANGE_H
-+
-+#include <__algorithm/comp.h>
-+#include <__config>
-+#include <__type_traits/is_constant_evaluated.h>
-+
-+#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-+#  pragma GCC system_header
-+#endif
-+
-+_LIBCPP_BEGIN_NAMESPACE_STD
-+
-+template <class _Tp>
-+_LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_SANITIZE("address") bool
-+__is_valid_range(const _Tp* __first, const _Tp* __last) {
-+  if (__libcpp_is_constant_evaluated()) {
-+    // If this is not a constant during constant evaluation, that is because __first and __last are not
-+    // part of the same allocation. If they are part of the same allocation, we must still make sure they
-+    // are ordered properly.
-+    return __builtin_constant_p(__first <= __last) && __first <= __last;
-+  }
-+
-+  return !__less<>()(__last, __first);
-+}
-+
-+_LIBCPP_END_NAMESPACE_STD
-+
-+#endif // _LIBCPP___UTILITY_IS_VALID_RANGE_H
-diff -ruN --strip-trailing-cr a/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp b/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
---- a/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
-+++ b/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
-@@ -22,18 +22,30 @@
- int main(int argc, char** argv) {
-   auto std_find    = [](auto first, auto last, auto const& value) { return std::find(first, last, value); };
-   auto std_find_if = [](auto first, auto last, auto const& value) {
--    return std::find_if(first, last, [&](auto element) { return element == value; });
-+    return std::find_if(first, last, [&](auto element) {
-+      benchmark::DoNotOptimize(element);
-+      return element == value;
-+    });
-   };
-   auto std_find_if_not = [](auto first, auto last, auto const& value) {
--    return std::find_if_not(first, last, [&](auto element) { return element != value; });
-+    return std::find_if_not(first, last, [&](auto element) {
-+      benchmark::DoNotOptimize(element);
-+      return element != value;
-+    });
-   };
- 
-   auto ranges_find    = [](auto first, auto last, auto const& value) { return std::ranges::find(first, last, value); };
-   auto ranges_find_if = [](auto first, auto last, auto const& value) {
--    return std::ranges::find_if(first, last, [&](auto element) { return element == value; });
-+    return std::ranges::find_if(first, last, [&](auto element) {
-+      benchmark::DoNotOptimize(element);
-+      return element == value;
-+    });
-   };
-   auto ranges_find_if_not = [](auto first, auto last, auto const& value) {
--    return std::ranges::find_if_not(first, last, [&](auto element) { return element != value; });
-+    return std::ranges::find_if_not(first, last, [&](auto element) {
-+      benchmark::DoNotOptimize(element);
-+      return element != value;
-+    });
-   };
- 
-   auto register_benchmarks = [&](auto bm, std::string comment) {
-diff -ruN --strip-trailing-cr a/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp b/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
---- a/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
-+++ b/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
-@@ -6,7 +6,7 @@
- //
- //===----------------------------------------------------------------------===//
- 
--#include <__memory/valid_range.h>
-+#include <__utility/is_valid_range.h>
- #include <cassert>
- 
- #include "test_macros.h"
-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
---- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
-+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
-@@ -16573,7 +16573,15 @@
-   bool Changed = false;
-   while (!Worklist.empty() && Worklist.top().second.first > 0) {
-     TreeEntry *TE = Worklist.top().first;
--    if (TE->isGather() || TE->Idx == 0 || DeletedNodes.contains(TE)) {
-+    if (TE->isGather() || TE->Idx == 0 || DeletedNodes.contains(TE) ||
-+        // Exit early if the parent node is split node and any of scalars is
-+        // used in other split nodes.
-+        (TE->UserTreeIndex &&
-+         TE->UserTreeIndex.UserTE->State == TreeEntry::SplitVectorize &&
-+         any_of(TE->Scalars, [&](Value *V) {
-+           ArrayRef<TreeEntry *> Entries = getSplitTreeEntries(V);
-+           return Entries.size() > 1;
-+         }))) {
-       Worklist.pop();
-       continue;
-     }
-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SLPVectorizer/X86/split-node-throttled.ll b/llvm/test/Transforms/SLPVectorizer/X86/split-node-throttled.ll
---- a/llvm/test/Transforms/SLPVectorizer/X86/split-node-throttled.ll
-+++ b/llvm/test/Transforms/SLPVectorizer/X86/split-node-throttled.ll
-@@ -0,0 +1,147 @@
-+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
-+; RUN: opt -S --passes=slp-vectorizer -mtriple=x86_64-grtev4-linux-gnu -mcpu=haswell < %s | FileCheck %s
-+
-+define fastcc void @test(i32 %arg) {
-+; CHECK-LABEL: define fastcc void @test(
-+; CHECK-SAME: i32 [[ARG:%.*]]) #[[ATTR0:[0-9]+]] {
-+; CHECK-NEXT:  [[BB:.*:]]
-+; CHECK-NEXT:    [[SELECT:%.*]] = select i1 false, i32 0, i32 0
-+; CHECK-NEXT:    [[GETELEMENTPTR:%.*]] = getelementptr i8, ptr poison, i64 16
-+; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> poison, i32 [[ARG]], i32 1
-+; CHECK-NEXT:    [[TMP0:%.*]] = insertelement <2 x i32> [[TMP3]], i32 [[SELECT]], i32 0
-+; CHECK-NEXT:    [[TMP1:%.*]] = zext <2 x i32> [[TMP0]] to <2 x i64>
-+; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <2 x i64> [[TMP1]], <2 x i64> poison, <4 x i32> <i32 0, i32 1, i32 0, i32 1>
-+; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x i64> [[TMP2]], <4 x i64> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
-+; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i64> [[TMP6]], <8 x i64> <i64 0, i64 0, i64 0, i64 0, i64 undef, i64 undef, i64 undef, i64 undef>, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>
-+; CHECK-NEXT:    [[TMP24:%.*]] = shufflevector <2 x i32> [[TMP0]], <2 x i32> <i32 0, i32 poison>, <2 x i32> <i32 2, i32 0>
-+; CHECK-NEXT:    [[TMP25:%.*]] = zext <2 x i32> [[TMP24]] to <2 x i64>
-+; CHECK-NEXT:    [[TMP26:%.*]] = shufflevector <2 x i64> [[TMP25]], <2 x i64> poison, <4 x i32> <i32 0, i32 1, i32 0, i32 1>
-+; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x i64> [[TMP26]], <4 x i64> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
-+; CHECK-NEXT:    [[TMP9:%.*]] = shufflevector <8 x i64> [[TMP8]], <8 x i64> <i64 0, i64 0, i64 0, i64 0, i64 undef, i64 undef, i64 undef, i64 undef>, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>
-+; CHECK-NEXT:    [[TMP10:%.*]] = mul <8 x i64> zeroinitializer, [[TMP7]]
-+; CHECK-NEXT:    [[TMP11:%.*]] = trunc <8 x i64> [[TMP10]] to <8 x i1>
-+; CHECK-NEXT:    [[TMP12:%.*]] = or <8 x i1> zeroinitializer, [[TMP11]]
-+; CHECK-NEXT:    [[TMP13:%.*]] = or <8 x i1> [[TMP12]], zeroinitializer
-+; CHECK-NEXT:    [[TMP14:%.*]] = shufflevector <8 x i1> [[TMP13]], <8 x i1> poison, <8 x i32> <i32 0, i32 4, i32 2, i32 6, i32 1, i32 5, i32 3, i32 7>
-+; CHECK-NEXT:    [[TMP15:%.*]] = mul <8 x i64> zeroinitializer, [[TMP9]]
-+; CHECK-NEXT:    [[TMP16:%.*]] = trunc <8 x i64> [[TMP15]] to <8 x i1>
-+; CHECK-NEXT:    [[TMP17:%.*]] = or <8 x i1> [[TMP14]], [[TMP16]]
-+; CHECK-NEXT:    [[TMP18:%.*]] = lshr <8 x i1> [[TMP17]], zeroinitializer
-+; CHECK-NEXT:    [[TMP19:%.*]] = zext <8 x i1> [[TMP18]] to <8 x i32>
-+; CHECK-NEXT:    [[TMP20:%.*]] = call <8 x i32> @llvm.smax.v8i32(<8 x i32> [[TMP19]], <8 x i32> zeroinitializer)
-+; CHECK-NEXT:    [[TMP21:%.*]] = call <8 x i32> @llvm.smin.v8i32(<8 x i32> [[TMP20]], <8 x i32> zeroinitializer)
-+; CHECK-NEXT:    [[TMP22:%.*]] = trunc <8 x i32> [[TMP21]] to <8 x i16>
-+; CHECK-NEXT:    [[TMP23:%.*]] = shufflevector <8 x i16> [[TMP22]], <8 x i16> poison, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>
-+; CHECK-NEXT:    store <8 x i16> [[TMP23]], ptr [[GETELEMENTPTR]], align 2
-+; CHECK-NEXT:    ret void
-+;
-+bb:
-+  %zext = zext i32 %arg to i64
-+  %sext = sext i32 0 to i64
-+  %select = select i1 false, i32 0, i32 0
-+  %zext1 = zext i32 %select to i64
-+  %mul = mul i64 0, %zext1
-+  %or = or i64 0, %mul
-+  %or2 = or i64 %or, 0
-+  %zext3 = zext i32 0 to i64
-+  %mul4 = mul i64 0, %zext3
-+  %or5 = or i64 %or2, %mul4
-+  %lshr = lshr i64 %or5, 0
-+  %trunc = trunc i64 %lshr to i32
-+  %call = tail call i32 @llvm.smax.i32(i32 %trunc, i32 0)
-+  %call6 = tail call i32 @llvm.smin.i32(i32 %call, i32 0)
-+  %trunc7 = trunc i32 %call6 to i16
-+  %getelementptr = getelementptr i8, ptr poison, i64 16
-+  store i16 %trunc7, ptr %getelementptr, align 2
-+  %mul8 = mul i64 0, %zext
-+  %or9 = or i64 0, %mul8
-+  %or10 = or i64 %or9, 0
-+  %sext11 = sext i32 0 to i64
-+  %mul12 = mul i64 0, %sext11
-+  %or13 = or i64 %or10, %mul12
-+  %lshr14 = lshr i64 %or13, 0
-+  %trunc15 = trunc i64 %lshr14 to i32
-+  %call16 = tail call i32 @llvm.smax.i32(i32 %trunc15, i32 0)
-+  %call17 = tail call i32 @llvm.smin.i32(i32 %call16, i32 0)
-+  %trunc18 = trunc i32 %call17 to i16
-+  %getelementptr19 = getelementptr i8, ptr poison, i64 18
-+  store i16 %trunc18, ptr %getelementptr19, align 2
-+  %sext20 = sext i32 0 to i64
-+  %mul21 = mul i64 0, %sext20
-+  %or22 = or i64 %zext3, %mul21
-+  %or23 = or i64 %or22, 0
-+  %mul24 = mul i64 0, %zext1
-+  %or25 = or i64 %or23, %mul24
-+  %lshr26 = lshr i64 %or25, 0
-+  %trunc27 = trunc i64 %lshr26 to i32
-+  %call28 = tail call i32 @llvm.smax.i32(i32 %trunc27, i32 0)
-+  %call29 = tail call i32 @llvm.smin.i32(i32 %call28, i32 0)
-+  %trunc30 = trunc i32 %call29 to i16
-+  %getelementptr31 = getelementptr i8, ptr poison, i64 20
-+  store i16 %trunc30, ptr %getelementptr31, align 2
-+  %sext32 = sext i32 0 to i64
-+  %mul33 = mul i64 0, %sext32
-+  %or34 = or i64 0, %mul33
-+  %or35 = or i64 %or34, 0
-+  %mul36 = mul i64 0, %sext
-+  %or37 = or i64 %or35, %mul36
-+  %lshr38 = lshr i64 %or37, 0
-+  %trunc39 = trunc i64 %lshr38 to i32
-+  %call40 = tail call i32 @llvm.smax.i32(i32 %trunc39, i32 0)
-+  %call41 = tail call i32 @llvm.smin.i32(i32 %call40, i32 0)
-+  %trunc42 = trunc i32 %call41 to i16
-+  %getelementptr43 = getelementptr i8, ptr poison, i64 22
-+  store i16 %trunc42, ptr %getelementptr43, align 2
-+  %mul44 = mul i64 0, %zext1
-+  %or45 = or i64 0, %mul44
-+  %or46 = or i64 %or45, 0
-+  %mul47 = mul i64 0, %zext3
-+  %or48 = or i64 %or46, %mul47
-+  %lshr49 = lshr i64 %or48, 0
-+  %trunc50 = trunc i64 %lshr49 to i32
-+  %call51 = tail call i32 @llvm.smax.i32(i32 %trunc50, i32 0)
-+  %call52 = tail call i32 @llvm.smin.i32(i32 %call51, i32 0)
-+  %trunc53 = trunc i32 %call52 to i16
-+  %getelementptr54 = getelementptr i8, ptr poison, i64 24
-+  store i16 %trunc53, ptr %getelementptr54, align 2
-+  %mul55 = mul i64 0, %zext
-+  %or56 = or i64 0, %mul55
-+  %or57 = or i64 %or56, 0
-+  %mul58 = mul i64 0, %sext11
-+  %or59 = or i64 %or57, %mul58
-+  %lshr60 = lshr i64 %or59, 0
-+  %trunc61 = trunc i64 %lshr60 to i32
-+  %call62 = tail call i32 @llvm.smax.i32(i32 %trunc61, i32 0)
-+  %call63 = tail call i32 @llvm.smin.i32(i32 %call62, i32 0)
-+  %trunc64 = trunc i32 %call63 to i16
-+  %getelementptr65 = getelementptr i8, ptr poison, i64 26
-+  store i16 %trunc64, ptr %getelementptr65, align 2
-+  %mul66 = mul i64 0, %sext20
-+  %or67 = or i64 0, %mul66
-+  %or68 = or i64 %or67, 0
-+  %mul69 = mul i64 0, %zext1
-+  %or70 = or i64 %or68, %mul69
-+  %lshr71 = lshr i64 %or70, 0
-+  %trunc72 = trunc i64 %lshr71 to i32
-+  %call73 = tail call i32 @llvm.smax.i32(i32 %trunc72, i32 0)
-+  %call74 = tail call i32 @llvm.smin.i32(i32 %call73, i32 0)
-+  %trunc75 = trunc i32 %call74 to i16
-+  %getelementptr76 = getelementptr i8, ptr poison, i64 28
-+  store i16 %trunc75, ptr %getelementptr76, align 2
-+  %mul77 = mul i64 0, %sext32
-+  %or78 = or i64 0, %mul77
-+  %or79 = or i64 %or78, 0
-+  %mul80 = mul i64 0, %sext
-+  %or81 = or i64 %or79, %mul80
-+  %lshr82 = lshr i64 %or81, 0
-+  %trunc83 = trunc i64 %lshr82 to i32
-+  %call84 = tail call i32 @llvm.smax.i32(i32 %trunc83, i32 0)
-+  %call85 = tail call i32 @llvm.smin.i32(i32 %call84, i32 0)
-+  %trunc86 = trunc i32 %call85 to i16
-+  %getelementptr87 = getelementptr i8, ptr poison, i64 30
-+  store i16 %trunc86, ptr %getelementptr87, align 2
-+  ret void
-+}
-+
-+declare i32 @llvm.smin.i32(i32, i32)
-+declare i32 @llvm.smax.i32(i32, i32)
+-int main() {
+-    M m;
+-    return 0;
+-}
+-
+-// CHECK: @_ZN5TemplILj4EE16__set_locked_bitE = {{.*}}linkonce_odr
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 1a81c35..9e70e35 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "95da1354d03bf66594d0bd1763b9c9c5fbcf8843"
-    LLVM_SHA256 = "455bf49a264ec2d8648fe348c377b94bddf73a868bc9d0b636e937ff45885823"
+    LLVM_COMMIT = "01e6245af481dac4604e8a25be6bec0dbe36f99d"
+    LLVM_SHA256 = "3387b340f1734dca6544e043c53c9964545e2a4b6e9c426c84a23ad914b7047c"
 
     tf_http_archive(
         name = name,
