diff --git a/docs/sdy_import_passes.md b/docs/sdy_import_passes.md
index b8c9e37..4668c6b 100755
--- a/docs/sdy_import_passes.md
+++ b/docs/sdy_import_passes.md
@@ -44,10 +44,9 @@ satisfy all of the following:
   type `ShardingConstraintOp` or `ManualComputationOp` (otherwise it's not
   the last in the chain).
 
-then this pass replaces all other uses of the input of the chain, that are
-defined after the last `ShardingConstraintOp` in the chain (and within the
-same block), with the result of the chain, as it should dictate the sharding
-of those uses.
+then this pass replaces all other uses of the input of the chain with the
+result of the last `ShardingConstraintOp` in the chain, as it should
+dictate the sharding of those uses.
 
 NOTE: The `in_shardings` of a `ManualComputationOp` are in essense sharding
 constraints on the corresponding operands, so this pass will also apply
diff --git a/third_party/llvm/intrinsic_memcpy.patch b/third_party/llvm/intrinsic_memcpy.patch
new file mode 100644
index 0000000..0697b66
--- /dev/null
+++ b/third_party/llvm/intrinsic_memcpy.patch
@@ -0,0 +1,247 @@
+diff --git a/llvm/lib/IR/Intrinsics.cpp b/llvm/lib/IR/Intrinsics.cpp
+index 459b4d2f6227..3130a0bd2955 100644
+--- a/llvm/lib/IR/Intrinsics.cpp
++++ b/llvm/lib/IR/Intrinsics.cpp
+@@ -32,7 +32,6 @@
+ #include "llvm/IR/Type.h"
+ 
+ using namespace llvm;
+-using namespace Intrinsic;
+ 
+ /// Table of string intrinsic names indexed by enum value.
+ static constexpr const char *const IntrinsicNameTable[] = {
+@@ -49,7 +48,7 @@ StringRef Intrinsic::getBaseName(ID id) {
+ 
+ StringRef Intrinsic::getName(ID id) {
+   assert(id < num_intrinsics && "Invalid intrinsic ID!");
+-  assert(!isOverloaded(id) &&
++  assert(!Intrinsic::isOverloaded(id) &&
+          "This version of getName does not support overloading");
+   return getBaseName(id);
+ }
+@@ -152,27 +151,27 @@ static std::string getMangledTypeStr(Type *Ty, bool &HasUnnamedType) {
+   return Result;
+ }
+ 
+-static std::string getIntrinsicNameImpl(ID Id, ArrayRef<Type *> Tys, Module *M,
+-                                        FunctionType *FT,
++static std::string getIntrinsicNameImpl(Intrinsic::ID Id, ArrayRef<Type *> Tys,
++                                        Module *M, FunctionType *FT,
+                                         bool EarlyModuleCheck) {
+ 
+-  assert(Id < num_intrinsics && "Invalid intrinsic ID!");
+-  assert((Tys.empty() || isOverloaded(Id)) &&
++  assert(Id < Intrinsic::num_intrinsics && "Invalid intrinsic ID!");
++  assert((Tys.empty() || Intrinsic::isOverloaded(Id)) &&
+          "This version of getName is for overloaded intrinsics only");
+   (void)EarlyModuleCheck;
+   assert((!EarlyModuleCheck || M ||
+           !any_of(Tys, [](Type *T) { return isa<PointerType>(T); })) &&
+          "Intrinsic overloading on pointer types need to provide a Module");
+   bool HasUnnamedType = false;
+-  std::string Result(getBaseName(Id));
++  std::string Result(Intrinsic::getBaseName(Id));
+   for (Type *Ty : Tys)
+     Result += "." + getMangledTypeStr(Ty, HasUnnamedType);
+   if (HasUnnamedType) {
+     assert(M && "unnamed types need a module");
+     if (!FT)
+-      FT = getType(M->getContext(), Id, Tys);
++      FT = Intrinsic::getType(M->getContext(), Id, Tys);
+     else
+-      assert((FT == getType(M->getContext(), Id, Tys)) &&
++      assert((FT == Intrinsic::getType(M->getContext(), Id, Tys)) &&
+              "Provided FunctionType must match arguments");
+     return M->getUniqueIntrinsicName(Result, Id, FT);
+   }
+@@ -199,10 +198,13 @@ enum IIT_Info {
+ #undef GET_INTRINSIC_IITINFO
+ };
+ 
+-static void DecodeIITType(unsigned &NextElt, ArrayRef<unsigned char> Infos,
+-                          IIT_Info LastInfo,
+-                          SmallVectorImpl<IITDescriptor> &OutputTable) {
+-  bool IsScalableVector = LastInfo == IIT_SCALABLE_VEC;
++static void
++DecodeIITType(unsigned &NextElt, ArrayRef<unsigned char> Infos,
++              IIT_Info LastInfo,
++              SmallVectorImpl<Intrinsic::IITDescriptor> &OutputTable) {
++  using namespace Intrinsic;
++
++  bool IsScalableVector = (LastInfo == IIT_SCALABLE_VEC);
+ 
+   IIT_Info Info = IIT_Info(Infos[NextElt++]);
+   unsigned StructElts = 2;
+@@ -479,8 +481,10 @@ void Intrinsic::getIntrinsicInfoTableEntries(
+     DecodeIITType(NextElt, IITEntries, IIT_Done, T);
+ }
+ 
+-static Type *DecodeFixedType(ArrayRef<IITDescriptor> &Infos,
++static Type *DecodeFixedType(ArrayRef<Intrinsic::IITDescriptor> &Infos,
+                              ArrayRef<Type *> Tys, LLVMContext &Context) {
++  using namespace Intrinsic;
++
+   IITDescriptor D = Infos.front();
+   Infos = Infos.slice(1);
+ 
+@@ -613,10 +617,13 @@ bool Intrinsic::isOverloaded(ID id) {
+ #include "llvm/IR/IntrinsicImpl.inc"
+ #undef GET_INTRINSIC_TARGET_DATA
+ 
+-bool Intrinsic::isTargetIntrinsic(ID IID) { return IID > TargetInfos[0].Count; }
++bool Intrinsic::isTargetIntrinsic(Intrinsic::ID IID) {
++  return IID > TargetInfos[0].Count;
++}
+ 
+-int Intrinsic::lookupLLVMIntrinsicByName(ArrayRef<const char *> NameTable,
+-                                         StringRef Name, StringRef Target) {
++int llvm::Intrinsic::lookupLLVMIntrinsicByName(ArrayRef<const char *> NameTable,
++                                               StringRef Name,
++                                               StringRef Target) {
+   assert(Name.starts_with("llvm.") && "Unexpected intrinsic prefix");
+   assert(Name.drop_front(5).starts_with(Target) && "Unexpected target");
+ 
+@@ -678,23 +685,24 @@ findTargetSubtable(StringRef Name) {
+ 
+ /// This does the actual lookup of an intrinsic ID which matches the given
+ /// function name.
+-ID Intrinsic::lookupIntrinsicID(StringRef Name) {
++Intrinsic::ID Intrinsic::lookupIntrinsicID(StringRef Name) {
+   auto [NameTable, Target] = findTargetSubtable(Name);
+-  int Idx = lookupLLVMIntrinsicByName(NameTable, Name, Target);
++  int Idx = Intrinsic::lookupLLVMIntrinsicByName(NameTable, Name, Target);
+   if (Idx == -1)
+-    return not_intrinsic;
++    return Intrinsic::not_intrinsic;
+ 
+   // Intrinsic IDs correspond to the location in IntrinsicNameTable, but we have
+   // an index into a sub-table.
+   int Adjust = NameTable.data() - IntrinsicNameTable;
+-  ID Id = static_cast<ID>(Idx + Adjust);
++  Intrinsic::ID ID = static_cast<Intrinsic::ID>(Idx + Adjust);
+ 
+   // If the intrinsic is not overloaded, require an exact match. If it is
+   // overloaded, require either exact or prefix match.
+   const auto MatchSize = strlen(NameTable[Idx]);
+   assert(Name.size() >= MatchSize && "Expected either exact or prefix match");
+   bool IsExactMatch = Name.size() == MatchSize;
+-  return IsExactMatch || isOverloaded(Id) ? Id : not_intrinsic;
++  return IsExactMatch || Intrinsic::isOverloaded(ID) ? ID
++                                                     : Intrinsic::not_intrinsic;
+ }
+ 
+ /// This defines the "Intrinsic::getAttributes(ID id)" method.
+@@ -735,7 +743,8 @@ Function *Intrinsic::getDeclarationIfExists(Module *M, ID id,
+ 
+ bool Intrinsic::isConstrainedFPIntrinsic(ID QID) {
+   switch (QID) {
+-#define INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC) case INTRINSIC:
++#define INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC)                         \
++  case Intrinsic::INTRINSIC:
+ #include "llvm/IR/ConstrainedOps.def"
+ #undef INSTRUCTION
+     return true;
+@@ -744,10 +753,10 @@ bool Intrinsic::isConstrainedFPIntrinsic(ID QID) {
+   }
+ }
+ 
+-bool Intrinsic::hasConstrainedFPRoundingModeOperand(ID QID) {
++bool Intrinsic::hasConstrainedFPRoundingModeOperand(Intrinsic::ID QID) {
+   switch (QID) {
+ #define INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC)                         \
+-  case INTRINSIC:                                                              \
++  case Intrinsic::INTRINSIC:                                                   \
+     return ROUND_MODE == 1;
+ #include "llvm/IR/ConstrainedOps.def"
+ #undef INSTRUCTION
+@@ -756,13 +765,16 @@ bool Intrinsic::hasConstrainedFPRoundingModeOperand(ID QID) {
+   }
+ }
+ 
+-using DeferredIntrinsicMatchPair = std::pair<Type *, ArrayRef<IITDescriptor>>;
++using DeferredIntrinsicMatchPair =
++    std::pair<Type *, ArrayRef<Intrinsic::IITDescriptor>>;
+ 
+ static bool
+-matchIntrinsicType(Type *Ty, ArrayRef<IITDescriptor> &Infos,
++matchIntrinsicType(Type *Ty, ArrayRef<Intrinsic::IITDescriptor> &Infos,
+                    SmallVectorImpl<Type *> &ArgTys,
+                    SmallVectorImpl<DeferredIntrinsicMatchPair> &DeferredChecks,
+                    bool IsDeferredCheck) {
++  using namespace Intrinsic;
++
+   // If we ran out of descriptors, there are too many arguments.
+   if (Infos.empty())
+     return true;
+@@ -981,9 +993,9 @@ matchIntrinsicType(Type *Ty, ArrayRef<IITDescriptor> &Infos,
+   llvm_unreachable("unhandled");
+ }
+ 
+-MatchIntrinsicTypesResult
++Intrinsic::MatchIntrinsicTypesResult
+ Intrinsic::matchIntrinsicSignature(FunctionType *FTy,
+-                                   ArrayRef<IITDescriptor> &Infos,
++                                   ArrayRef<Intrinsic::IITDescriptor> &Infos,
+                                    SmallVectorImpl<Type *> &ArgTys) {
+   SmallVector<DeferredIntrinsicMatchPair, 2> DeferredChecks;
+   if (matchIntrinsicType(FTy->getReturnType(), Infos, ArgTys, DeferredChecks,
+@@ -1007,8 +1019,8 @@ Intrinsic::matchIntrinsicSignature(FunctionType *FTy,
+   return MatchIntrinsicTypes_Match;
+ }
+ 
+-bool Intrinsic::matchIntrinsicVarArg(bool isVarArg,
+-                                     ArrayRef<IITDescriptor> &Infos) {
++bool Intrinsic::matchIntrinsicVarArg(
++    bool isVarArg, ArrayRef<Intrinsic::IITDescriptor> &Infos) {
+   // If there are no descriptors left, then it can't be a vararg.
+   if (Infos.empty())
+     return isVarArg;
+@@ -1026,20 +1038,20 @@ bool Intrinsic::matchIntrinsicVarArg(bool isVarArg,
+   return true;
+ }
+ 
+-bool Intrinsic::getIntrinsicSignature(ID ID, FunctionType *FT,
++bool Intrinsic::getIntrinsicSignature(Intrinsic::ID ID, FunctionType *FT,
+                                       SmallVectorImpl<Type *> &ArgTys) {
+   if (!ID)
+     return false;
+ 
+-  SmallVector<IITDescriptor, 8> Table;
++  SmallVector<Intrinsic::IITDescriptor, 8> Table;
+   getIntrinsicInfoTableEntries(ID, Table);
+-  ArrayRef<IITDescriptor> TableRef = Table;
++  ArrayRef<Intrinsic::IITDescriptor> TableRef = Table;
+ 
+-  if (matchIntrinsicSignature(FT, TableRef, ArgTys) !=
+-      MatchIntrinsicTypesResult::MatchIntrinsicTypes_Match) {
++  if (Intrinsic::matchIntrinsicSignature(FT, TableRef, ArgTys) !=
++      Intrinsic::MatchIntrinsicTypesResult::MatchIntrinsicTypes_Match) {
+     return false;
+   }
+-  if (matchIntrinsicVarArg(FT->isVarArg(), TableRef))
++  if (Intrinsic::matchIntrinsicVarArg(FT->isVarArg(), TableRef))
+     return false;
+   return true;
+ }
+@@ -1055,10 +1067,10 @@ std::optional<Function *> Intrinsic::remangleIntrinsicFunction(Function *F) {
+   if (!getIntrinsicSignature(F, ArgTys))
+     return std::nullopt;
+ 
+-  ID ID = F->getIntrinsicID();
++  Intrinsic::ID ID = F->getIntrinsicID();
+   StringRef Name = F->getName();
+   std::string WantedName =
+-      getName(ID, ArgTys, F->getParent(), F->getFunctionType());
++      Intrinsic::getName(ID, ArgTys, F->getParent(), F->getFunctionType());
+   if (Name == WantedName)
+     return std::nullopt;
+ 
+@@ -1074,7 +1086,7 @@ std::optional<Function *> Intrinsic::remangleIntrinsicFunction(Function *F) {
+       // invalid and we'll get an error.
+       ExistingGV->setName(WantedName + ".renamed");
+     }
+-    return getOrInsertDeclaration(F->getParent(), ID, ArgTys);
++    return Intrinsic::getOrInsertDeclaration(F->getParent(), ID, ArgTys);
+   }();
+ 
+   NewDecl->setCallingConv(F->getCallingConv());
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 729501c..5ccdc6b 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "fb4f426c81d7e87dbb30df7abeba15ffc2f9f41a"
-    LLVM_SHA256 = "d6851f851b95004f9c0c08bfc1fa0da47149409e9dd229a44a8783f734dc0ae9"
+    LLVM_COMMIT = "a7b249e4708d61e491390773d3bb1ee88db91a57"
+    LLVM_SHA256 = "ea23ffd007114631937bff6a2c8e2b1880906a295f1f81ad71859e9b284bcee7"
 
     tf_http_archive(
         name = name,
