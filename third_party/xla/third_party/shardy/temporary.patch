diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 7972fe3..eb55274 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,1794 +1,2487 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/mlir/include/mlir/Dialect/OpenACC/Transforms/ACCSpecializePatterns.h b/mlir/include/mlir/Dialect/OpenACC/Transforms/ACCSpecializePatterns.h
---- a/mlir/include/mlir/Dialect/OpenACC/Transforms/ACCSpecializePatterns.h
-+++ b/mlir/include/mlir/Dialect/OpenACC/Transforms/ACCSpecializePatterns.h
-@@ -1,122 +0,0 @@
--//===- ACCSpecializePatterns.h - Common ACC Specialization Patterns ------===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
--//
--// This file contains common rewrite pattern templates used by both
--// ACCSpecializeForHost and ACCSpecializeForDevice passes.
--//
--// The patterns provide the following transformations:
--//
--// - ACCOpReplaceWithVarConversion<OpTy>: Replaces a data entry operation
--//   with its var operand. Used for ops like acc.copyin, acc.create, etc.
--//
--// - ACCOpEraseConversion<OpTy>: Simply erases an operation. Used for
--//   data exit ops like acc.copyout, acc.delete, and runtime ops.
--//
--// - ACCRegionUnwrapConversion<OpTy>: Inlines the region of an operation
--//   and erases the wrapper. Used for structured data constructs
--//   (acc.data, acc.host_data) and compute constructs (acc.parallel, etc.)
--//
--// - ACCDeclareEnterOpConversion: Erases acc.declare_enter and its
--//   associated acc.declare_exit operation.
--//
--//===----------------------------------------------------------------------===//
--
--#ifndef MLIR_DIALECT_OPENACC_TRANSFORMS_ACCSPECIALIZEPATTERNS_H
--#define MLIR_DIALECT_OPENACC_TRANSFORMS_ACCSPECIALIZEPATTERNS_H
--
--#include "mlir/Dialect/OpenACC/OpenACC.h"
--#include "mlir/IR/PatternMatch.h"
--
--namespace mlir {
--namespace acc {
--
--//===----------------------------------------------------------------------===//
--// Generic pattern templates for ACC specialization
--//===----------------------------------------------------------------------===//
--
--/// Pattern to replace an ACC op with its var operand.
--/// Used for data entry ops like acc.copyin, acc.create, acc.attach, etc.
--template <typename OpTy>
--class ACCOpReplaceWithVarConversion : public OpRewritePattern<OpTy> {
--  using OpRewritePattern<OpTy>::OpRewritePattern;
--
--public:
--  LogicalResult matchAndRewrite(OpTy op,
--                                PatternRewriter &rewriter) const override {
--    // Replace this op with its var operand; it's possible the op has no uses
--    // if the op that had previously used it was already converted.
--    if (op->use_empty())
--      rewriter.eraseOp(op);
--    else
--      rewriter.replaceOp(op, op.getVar());
--    return success();
--  }
--};
--
--/// Pattern to simply erase an ACC op (for ops with no results).
--/// Used for data exit ops like acc.copyout, acc.delete, acc.detach, etc.
--template <typename OpTy>
--class ACCOpEraseConversion : public OpRewritePattern<OpTy> {
--  using OpRewritePattern<OpTy>::OpRewritePattern;
--
--public:
--  LogicalResult matchAndRewrite(OpTy op,
--                                PatternRewriter &rewriter) const override {
--    assert(op->getNumResults() == 0 && "expected op with no results");
--    rewriter.eraseOp(op);
--    return success();
--  }
--};
--
--/// Pattern to unwrap a region from an ACC op and erase the wrapper.
--/// Moves the region's contents to the parent block and removes the wrapper op.
--/// Used for structured data constructs (acc.data, acc.host_data,
--/// acc.kernel_environment, acc.declare) and compute constructs (acc.parallel,
--/// acc.serial, acc.kernels).
--template <typename OpTy>
--class ACCRegionUnwrapConversion : public OpRewritePattern<OpTy> {
--  using OpRewritePattern<OpTy>::OpRewritePattern;
--
--public:
--  LogicalResult matchAndRewrite(OpTy op,
--                                PatternRewriter &rewriter) const override {
--    assert(op.getRegion().hasOneBlock() && "expected one block");
--    Block *block = &op.getRegion().front();
--    // Erase the terminator (acc.yield or acc.terminator) before unwrapping
--    rewriter.eraseOp(block->getTerminator());
--    rewriter.inlineBlockBefore(block, op);
--    rewriter.eraseOp(op);
--    return success();
--  }
--};
--
--/// Pattern to erase acc.declare_enter and its associated acc.declare_exit.
--/// The declare_enter produces a token that is consumed by declare_exit.
--class ACCDeclareEnterOpConversion
--    : public OpRewritePattern<acc::DeclareEnterOp> {
--  using OpRewritePattern<acc::DeclareEnterOp>::OpRewritePattern;
--
--public:
--  LogicalResult matchAndRewrite(acc::DeclareEnterOp op,
--                                PatternRewriter &rewriter) const override {
--    // If the enter token is used by an exit, erase exit first.
--    if (!op->use_empty()) {
--      assert(op->hasOneUse() && "expected one use");
--      auto exitOp = dyn_cast<acc::DeclareExitOp>(*op->getUsers().begin());
--      assert(exitOp && "expected declare exit op");
--      rewriter.eraseOp(exitOp);
--    }
--    rewriter.eraseOp(op);
--    return success();
+diff -ruN --strip-trailing-cr a/clang/test/Headers/__clang_hip_math.hip b/clang/test/Headers/__clang_hip_math.hip
+--- a/clang/test/Headers/__clang_hip_math.hip
++++ b/clang/test/Headers/__clang_hip_math.hip
+@@ -179,7 +179,7 @@
+ // CHECK-NEXT:    [[OR_COND34_I:%.*]] = icmp ult i8 [[TMP4]], 6
+ // CHECK-NEXT:    br i1 [[OR_COND34_I]], label %[[IF_END31_I]], label %[[_ZL22__MAKE_MANTISSA_BASE16PKC_EXIT]]
+ // CHECK:       [[IF_END31_I]]:
+-// CHECK-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I]] ], [ -48, %[[WHILE_BODY_I]] ], [ -55, %[[IF_ELSE17_I]] ]
++// CHECK-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I]] ], [ -87, %[[IF_ELSE_I]] ], [ -55, %[[IF_ELSE17_I]] ]
+ // CHECK-NEXT:    [[MUL24_I:%.*]] = shl i64 [[__R_0_I3]], 4
+ // CHECK-NEXT:    [[CONV25_I:%.*]] = zext nneg i8 [[TMP1]] to i64
+ // CHECK-NEXT:    [[ADD26_I:%.*]] = add i64 [[MUL24_I]], [[DOTSINK]]
+@@ -214,7 +214,7 @@
+ // AMDGCNSPIRV-NEXT:    [[OR_COND34_I:%.*]] = icmp ult i8 [[TMP4]], 6
+ // AMDGCNSPIRV-NEXT:    br i1 [[OR_COND34_I]], label %[[IF_END31_I]], label %[[_ZL22__MAKE_MANTISSA_BASE16PKC_EXIT]]
+ // AMDGCNSPIRV:       [[IF_END31_I]]:
+-// AMDGCNSPIRV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I]] ], [ -48, %[[WHILE_BODY_I]] ], [ -55, %[[IF_ELSE17_I]] ]
++// AMDGCNSPIRV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I]] ], [ -87, %[[IF_ELSE_I]] ], [ -55, %[[IF_ELSE17_I]] ]
+ // AMDGCNSPIRV-NEXT:    [[MUL24_I:%.*]] = shl i64 [[__R_0_I3]], 4
+ // AMDGCNSPIRV-NEXT:    [[CONV25_I:%.*]] = zext nneg i8 [[TMP1]] to i64
+ // AMDGCNSPIRV-NEXT:    [[ADD26_I:%.*]] = add i64 [[MUL24_I]], [[DOTSINK]]
+@@ -269,7 +269,7 @@
+ // CHECK-NEXT:    [[OR_COND34_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // CHECK-NEXT:    br i1 [[OR_COND34_I_I]], label %[[IF_END31_I_I]], label %[[_ZL15__MAKE_MANTISSAPKC_EXIT]]
+ // CHECK:       [[IF_END31_I_I]]:
+-// CHECK-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I]] ], [ -48, %[[WHILE_BODY_I31_I]] ], [ -55, %[[IF_ELSE17_I_I]] ]
++// CHECK-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I31_I]] ], [ -87, %[[IF_ELSE_I_I]] ], [ -55, %[[IF_ELSE17_I_I]] ]
+ // CHECK-NEXT:    [[MUL24_I_I:%.*]] = shl i64 [[__R_0_I29_I11]], 4
+ // CHECK-NEXT:    [[CONV25_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // CHECK-NEXT:    [[ADD26_I_I:%.*]] = add i64 [[MUL24_I_I]], [[DOTSINK]]
+@@ -311,7 +311,7 @@
+ // CHECK-NEXT:    [[CMP_NOT_I17_I:%.*]] = icmp eq i8 [[TMP13]], 0
+ // CHECK-NEXT:    br i1 [[CMP_NOT_I17_I]], label %[[_ZL15__MAKE_MANTISSAPKC_EXIT]], label %[[WHILE_BODY_I18_I]], !llvm.loop [[LOOP12]]
+ // CHECK:       [[_ZL15__MAKE_MANTISSAPKC_EXIT]]:
+-// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I]] ], [ 0, %[[WHILE_COND_I14_I_PREHEADER]] ], [ 0, %[[WHILE_COND_I_I_PREHEADER]] ], [ [[SUB_I_I]], %[[IF_THEN_I_I]] ], [ [[ADD28_I_I]], %[[IF_END31_I_I]] ], [ 0, %[[WHILE_BODY_I_I]] ], [ 0, %[[IF_ELSE17_I_I]] ], [ [[SUB_I25_I]], %[[IF_THEN_I21_I]] ], [ 0, %[[WHILE_BODY_I18_I]] ]
++// CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi i64 [ 0, %[[WHILE_COND_I_I_PREHEADER]] ], [ 0, %[[IF_THEN5_I]] ], [ 0, %[[WHILE_COND_I14_I_PREHEADER]] ], [ [[SUB_I_I]], %[[IF_THEN_I_I]] ], [ 0, %[[WHILE_BODY_I_I]] ], [ [[ADD28_I_I]], %[[IF_END31_I_I]] ], [ 0, %[[IF_ELSE17_I_I]] ], [ [[SUB_I25_I]], %[[IF_THEN_I21_I]] ], [ 0, %[[WHILE_BODY_I18_I]] ]
+ // CHECK-NEXT:    ret i64 [[RETVAL_0_I]]
+ //
+ // AMDGCNSPIRV-LABEL: define spir_func i64 @test___make_mantissa(
+@@ -347,7 +347,7 @@
+ // AMDGCNSPIRV-NEXT:    [[OR_COND34_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // AMDGCNSPIRV-NEXT:    br i1 [[OR_COND34_I_I]], label %[[IF_END31_I_I]], label %[[_ZL15__MAKE_MANTISSAPKC_EXIT]]
+ // AMDGCNSPIRV:       [[IF_END31_I_I]]:
+-// AMDGCNSPIRV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I]] ], [ -48, %[[WHILE_BODY_I32_I]] ], [ -55, %[[IF_ELSE17_I_I]] ]
++// AMDGCNSPIRV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I32_I]] ], [ -87, %[[IF_ELSE_I_I]] ], [ -55, %[[IF_ELSE17_I_I]] ]
+ // AMDGCNSPIRV-NEXT:    [[MUL24_I_I:%.*]] = shl i64 [[__R_0_I30_I7]], 4
+ // AMDGCNSPIRV-NEXT:    [[CONV25_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // AMDGCNSPIRV-NEXT:    [[ADD26_I_I:%.*]] = add i64 [[MUL24_I_I]], [[DOTSINK]]
+@@ -391,7 +391,7 @@
+ // AMDGCNSPIRV-NEXT:    [[__R_1_I26_I]] = select i1 [[OR_COND_I19_I]], i64 [[SUB_I23_I]], i64 [[__R_0_I16_I]]
+ // AMDGCNSPIRV-NEXT:    br i1 [[OR_COND_I19_I]], label %[[WHILE_COND_I14_I]], label %[[_ZL15__MAKE_MANTISSAPKC_EXIT]], !llvm.loop [[LOOP13]]
+ // AMDGCNSPIRV:       [[_ZL15__MAKE_MANTISSAPKC_EXIT]]:
+-// AMDGCNSPIRV-NEXT:    [[RETVAL_0_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I]] ], [ [[ADD28_I_I]], %[[IF_END31_I_I]] ], [ [[__R_0_I_I]], %[[WHILE_COND_I_I]] ], [ 0, %[[WHILE_BODY_I_I]] ], [ 0, %[[IF_ELSE17_I_I]] ], [ 0, %[[WHILE_BODY_I18_I]] ], [ [[__R_0_I16_I]], %[[WHILE_COND_I14_I]] ]
++// AMDGCNSPIRV-NEXT:    [[RETVAL_0_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I]] ], [ 0, %[[WHILE_BODY_I_I]] ], [ [[__R_0_I_I]], %[[WHILE_COND_I_I]] ], [ [[ADD28_I_I]], %[[IF_END31_I_I]] ], [ 0, %[[IF_ELSE17_I_I]] ], [ 0, %[[WHILE_BODY_I18_I]] ], [ [[__R_0_I16_I]], %[[WHILE_COND_I14_I]] ]
+ // AMDGCNSPIRV-NEXT:    ret i64 [[RETVAL_0_I]]
+ //
+ extern "C" __device__ uint64_t test___make_mantissa(const char *p) {
+@@ -4357,7 +4357,7 @@
+ // DEFAULT-NEXT:    [[OR_COND34_I_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // DEFAULT-NEXT:    br i1 [[OR_COND34_I_I_I]], label %[[IF_END31_I_I_I]], label %[[_ZL4NANFPKC_EXIT]]
+ // DEFAULT:       [[IF_END31_I_I_I]]:
+-// DEFAULT-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I_I]] ], [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
++// DEFAULT-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -87, %[[IF_ELSE_I_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
+ // DEFAULT-NEXT:    [[MUL24_I_I_I:%.*]] = shl i64 [[__R_0_I29_I_I11]], 4
+ // DEFAULT-NEXT:    [[CONV25_I_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // DEFAULT-NEXT:    [[ADD26_I_I_I:%.*]] = add i64 [[MUL24_I_I_I]], [[DOTSINK]]
+@@ -4399,7 +4399,7 @@
+ // DEFAULT-NEXT:    [[CMP_NOT_I17_I_I:%.*]] = icmp eq i8 [[TMP13]], 0
+ // DEFAULT-NEXT:    br i1 [[CMP_NOT_I17_I_I]], label %[[_ZL4NANFPKC_EXIT]], label %[[WHILE_BODY_I18_I_I]], !llvm.loop [[LOOP12]]
+ // DEFAULT:       [[_ZL4NANFPKC_EXIT]]:
+-// DEFAULT-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
++// DEFAULT-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
+ // DEFAULT-NEXT:    [[CONV_I:%.*]] = trunc i64 [[RETVAL_0_I_I]] to i32
+ // DEFAULT-NEXT:    [[BF_VALUE_I:%.*]] = and i32 [[CONV_I]], 4194303
+ // DEFAULT-NEXT:    [[BF_SET9_I:%.*]] = or disjoint i32 [[BF_VALUE_I]], 2143289344
+@@ -4449,7 +4449,7 @@
+ // APPROX-NEXT:    [[OR_COND34_I_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // APPROX-NEXT:    br i1 [[OR_COND34_I_I_I]], label %[[IF_END31_I_I_I]], label %[[_ZL4NANFPKC_EXIT]]
+ // APPROX:       [[IF_END31_I_I_I]]:
+-// APPROX-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I_I]] ], [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
++// APPROX-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -87, %[[IF_ELSE_I_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
+ // APPROX-NEXT:    [[MUL24_I_I_I:%.*]] = shl i64 [[__R_0_I29_I_I11]], 4
+ // APPROX-NEXT:    [[CONV25_I_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // APPROX-NEXT:    [[ADD26_I_I_I:%.*]] = add i64 [[MUL24_I_I_I]], [[DOTSINK]]
+@@ -4491,7 +4491,7 @@
+ // APPROX-NEXT:    [[CMP_NOT_I17_I_I:%.*]] = icmp eq i8 [[TMP13]], 0
+ // APPROX-NEXT:    br i1 [[CMP_NOT_I17_I_I]], label %[[_ZL4NANFPKC_EXIT]], label %[[WHILE_BODY_I18_I_I]], !llvm.loop [[LOOP12]]
+ // APPROX:       [[_ZL4NANFPKC_EXIT]]:
+-// APPROX-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
++// APPROX-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
+ // APPROX-NEXT:    [[CONV_I:%.*]] = trunc i64 [[RETVAL_0_I_I]] to i32
+ // APPROX-NEXT:    [[BF_VALUE_I:%.*]] = and i32 [[CONV_I]], 4194303
+ // APPROX-NEXT:    [[BF_SET9_I:%.*]] = or disjoint i32 [[BF_VALUE_I]], 2143289344
+@@ -4536,7 +4536,7 @@
+ // NCRDIV-NEXT:    [[OR_COND34_I_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // NCRDIV-NEXT:    br i1 [[OR_COND34_I_I_I]], label %[[IF_END31_I_I_I]], label %[[_ZL4NANFPKC_EXIT]]
+ // NCRDIV:       [[IF_END31_I_I_I]]:
+-// NCRDIV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I_I]] ], [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
++// NCRDIV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -87, %[[IF_ELSE_I_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
+ // NCRDIV-NEXT:    [[MUL24_I_I_I:%.*]] = shl i64 [[__R_0_I29_I_I11]], 4
+ // NCRDIV-NEXT:    [[CONV25_I_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // NCRDIV-NEXT:    [[ADD26_I_I_I:%.*]] = add i64 [[MUL24_I_I_I]], [[DOTSINK]]
+@@ -4578,7 +4578,7 @@
+ // NCRDIV-NEXT:    [[CMP_NOT_I17_I_I:%.*]] = icmp eq i8 [[TMP13]], 0
+ // NCRDIV-NEXT:    br i1 [[CMP_NOT_I17_I_I]], label %[[_ZL4NANFPKC_EXIT]], label %[[WHILE_BODY_I18_I_I]], !llvm.loop [[LOOP12]]
+ // NCRDIV:       [[_ZL4NANFPKC_EXIT]]:
+-// NCRDIV-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
++// NCRDIV-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
+ // NCRDIV-NEXT:    [[CONV_I:%.*]] = trunc i64 [[RETVAL_0_I_I]] to i32
+ // NCRDIV-NEXT:    [[BF_VALUE_I:%.*]] = and i32 [[CONV_I]], 4194303
+ // NCRDIV-NEXT:    [[BF_SET9_I:%.*]] = or disjoint i32 [[BF_VALUE_I]], 2143289344
+@@ -4618,7 +4618,7 @@
+ // AMDGCNSPIRV-NEXT:    [[OR_COND34_I_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // AMDGCNSPIRV-NEXT:    br i1 [[OR_COND34_I_I_I]], label %[[IF_END31_I_I_I]], label %[[_ZL4NANFPKC_EXIT]]
+ // AMDGCNSPIRV:       [[IF_END31_I_I_I]]:
+-// AMDGCNSPIRV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I_I]] ], [ -48, %[[WHILE_BODY_I32_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
++// AMDGCNSPIRV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I32_I_I]] ], [ -87, %[[IF_ELSE_I_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
+ // AMDGCNSPIRV-NEXT:    [[MUL24_I_I_I:%.*]] = shl i64 [[__R_0_I30_I_I7]], 4
+ // AMDGCNSPIRV-NEXT:    [[CONV25_I_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // AMDGCNSPIRV-NEXT:    [[ADD26_I_I_I:%.*]] = add i64 [[MUL24_I_I_I]], [[DOTSINK]]
+@@ -4662,7 +4662,7 @@
+ // AMDGCNSPIRV-NEXT:    [[__R_1_I26_I_I]] = select i1 [[OR_COND_I19_I_I]], i64 [[SUB_I23_I_I]], i64 [[__R_0_I16_I_I]]
+ // AMDGCNSPIRV-NEXT:    br i1 [[OR_COND_I19_I_I]], label %[[WHILE_COND_I14_I_I]], label %[[_ZL4NANFPKC_EXIT]], !llvm.loop [[LOOP13]]
+ // AMDGCNSPIRV:       [[_ZL4NANFPKC_EXIT]]:
+-// AMDGCNSPIRV-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ [[__R_0_I_I_I]], %[[WHILE_COND_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ], [ [[__R_0_I16_I_I]], %[[WHILE_COND_I14_I_I]] ]
++// AMDGCNSPIRV-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ [[__R_0_I_I_I]], %[[WHILE_COND_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ], [ [[__R_0_I16_I_I]], %[[WHILE_COND_I14_I_I]] ]
+ // AMDGCNSPIRV-NEXT:    [[CONV_I:%.*]] = trunc i64 [[RETVAL_0_I_I]] to i32
+ // AMDGCNSPIRV-NEXT:    [[BF_VALUE_I:%.*]] = and i32 [[CONV_I]], 4194303
+ // AMDGCNSPIRV-NEXT:    [[BF_SET9_I:%.*]] = or disjoint i32 [[BF_VALUE_I]], 2143289344
+@@ -4711,7 +4711,7 @@
+ // DEFAULT-NEXT:    [[OR_COND34_I_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // DEFAULT-NEXT:    br i1 [[OR_COND34_I_I_I]], label %[[IF_END31_I_I_I]], label %[[_ZL3NANPKC_EXIT]]
+ // DEFAULT:       [[IF_END31_I_I_I]]:
+-// DEFAULT-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I_I]] ], [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
++// DEFAULT-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -87, %[[IF_ELSE_I_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
+ // DEFAULT-NEXT:    [[MUL24_I_I_I:%.*]] = shl i64 [[__R_0_I29_I_I11]], 4
+ // DEFAULT-NEXT:    [[CONV25_I_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // DEFAULT-NEXT:    [[ADD26_I_I_I:%.*]] = add i64 [[MUL24_I_I_I]], [[DOTSINK]]
+@@ -4753,7 +4753,7 @@
+ // DEFAULT-NEXT:    [[CMP_NOT_I17_I_I:%.*]] = icmp eq i8 [[TMP13]], 0
+ // DEFAULT-NEXT:    br i1 [[CMP_NOT_I17_I_I]], label %[[_ZL3NANPKC_EXIT]], label %[[WHILE_BODY_I18_I_I]], !llvm.loop [[LOOP12]]
+ // DEFAULT:       [[_ZL3NANPKC_EXIT]]:
+-// DEFAULT-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
++// DEFAULT-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
+ // DEFAULT-NEXT:    [[BF_VALUE_I:%.*]] = and i64 [[RETVAL_0_I_I]], 2251799813685247
+ // DEFAULT-NEXT:    [[BF_SET9_I:%.*]] = or disjoint i64 [[BF_VALUE_I]], 9221120237041090560
+ // DEFAULT-NEXT:    [[TMP14:%.*]] = bitcast i64 [[BF_SET9_I]] to double
+@@ -4802,7 +4802,7 @@
+ // APPROX-NEXT:    [[OR_COND34_I_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // APPROX-NEXT:    br i1 [[OR_COND34_I_I_I]], label %[[IF_END31_I_I_I]], label %[[_ZL3NANPKC_EXIT]]
+ // APPROX:       [[IF_END31_I_I_I]]:
+-// APPROX-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I_I]] ], [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
++// APPROX-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -87, %[[IF_ELSE_I_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
+ // APPROX-NEXT:    [[MUL24_I_I_I:%.*]] = shl i64 [[__R_0_I29_I_I11]], 4
+ // APPROX-NEXT:    [[CONV25_I_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // APPROX-NEXT:    [[ADD26_I_I_I:%.*]] = add i64 [[MUL24_I_I_I]], [[DOTSINK]]
+@@ -4844,7 +4844,7 @@
+ // APPROX-NEXT:    [[CMP_NOT_I17_I_I:%.*]] = icmp eq i8 [[TMP13]], 0
+ // APPROX-NEXT:    br i1 [[CMP_NOT_I17_I_I]], label %[[_ZL3NANPKC_EXIT]], label %[[WHILE_BODY_I18_I_I]], !llvm.loop [[LOOP12]]
+ // APPROX:       [[_ZL3NANPKC_EXIT]]:
+-// APPROX-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
++// APPROX-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
+ // APPROX-NEXT:    [[BF_VALUE_I:%.*]] = and i64 [[RETVAL_0_I_I]], 2251799813685247
+ // APPROX-NEXT:    [[BF_SET9_I:%.*]] = or disjoint i64 [[BF_VALUE_I]], 9221120237041090560
+ // APPROX-NEXT:    [[TMP14:%.*]] = bitcast i64 [[BF_SET9_I]] to double
+@@ -4888,7 +4888,7 @@
+ // NCRDIV-NEXT:    [[OR_COND34_I_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // NCRDIV-NEXT:    br i1 [[OR_COND34_I_I_I]], label %[[IF_END31_I_I_I]], label %[[_ZL3NANPKC_EXIT]]
+ // NCRDIV:       [[IF_END31_I_I_I]]:
+-// NCRDIV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I_I]] ], [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
++// NCRDIV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I31_I_I]] ], [ -87, %[[IF_ELSE_I_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
+ // NCRDIV-NEXT:    [[MUL24_I_I_I:%.*]] = shl i64 [[__R_0_I29_I_I11]], 4
+ // NCRDIV-NEXT:    [[CONV25_I_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // NCRDIV-NEXT:    [[ADD26_I_I_I:%.*]] = add i64 [[MUL24_I_I_I]], [[DOTSINK]]
+@@ -4930,7 +4930,7 @@
+ // NCRDIV-NEXT:    [[CMP_NOT_I17_I_I:%.*]] = icmp eq i8 [[TMP13]], 0
+ // NCRDIV-NEXT:    br i1 [[CMP_NOT_I17_I_I]], label %[[_ZL3NANPKC_EXIT]], label %[[WHILE_BODY_I18_I_I]], !llvm.loop [[LOOP12]]
+ // NCRDIV:       [[_ZL3NANPKC_EXIT]]:
+-// NCRDIV-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
++// NCRDIV-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[WHILE_COND_I_I_I_PREHEADER]] ], [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_COND_I14_I_I_PREHEADER]] ], [ [[SUB_I_I_I]], %[[IF_THEN_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ [[SUB_I25_I_I]], %[[IF_THEN_I21_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ]
+ // NCRDIV-NEXT:    [[BF_VALUE_I:%.*]] = and i64 [[RETVAL_0_I_I]], 2251799813685247
+ // NCRDIV-NEXT:    [[BF_SET9_I:%.*]] = or disjoint i64 [[BF_VALUE_I]], 9221120237041090560
+ // NCRDIV-NEXT:    [[TMP14:%.*]] = bitcast i64 [[BF_SET9_I]] to double
+@@ -4969,7 +4969,7 @@
+ // AMDGCNSPIRV-NEXT:    [[OR_COND34_I_I_I:%.*]] = icmp ult i8 [[TMP6]], 6
+ // AMDGCNSPIRV-NEXT:    br i1 [[OR_COND34_I_I_I]], label %[[IF_END31_I_I_I]], label %[[_ZL3NANPKC_EXIT]]
+ // AMDGCNSPIRV:       [[IF_END31_I_I_I]]:
+-// AMDGCNSPIRV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -87, %[[IF_ELSE_I_I_I]] ], [ -48, %[[WHILE_BODY_I32_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
++// AMDGCNSPIRV-NEXT:    [[DOTSINK:%.*]] = phi i64 [ -48, %[[WHILE_BODY_I32_I_I]] ], [ -87, %[[IF_ELSE_I_I_I]] ], [ -55, %[[IF_ELSE17_I_I_I]] ]
+ // AMDGCNSPIRV-NEXT:    [[MUL24_I_I_I:%.*]] = shl i64 [[__R_0_I30_I_I7]], 4
+ // AMDGCNSPIRV-NEXT:    [[CONV25_I_I_I:%.*]] = zext nneg i8 [[TMP3]] to i64
+ // AMDGCNSPIRV-NEXT:    [[ADD26_I_I_I:%.*]] = add i64 [[MUL24_I_I_I]], [[DOTSINK]]
+@@ -5013,7 +5013,7 @@
+ // AMDGCNSPIRV-NEXT:    [[__R_1_I26_I_I]] = select i1 [[OR_COND_I19_I_I]], i64 [[SUB_I23_I_I]], i64 [[__R_0_I16_I_I]]
+ // AMDGCNSPIRV-NEXT:    br i1 [[OR_COND_I19_I_I]], label %[[WHILE_COND_I14_I_I]], label %[[_ZL3NANPKC_EXIT]], !llvm.loop [[LOOP13]]
+ // AMDGCNSPIRV:       [[_ZL3NANPKC_EXIT]]:
+-// AMDGCNSPIRV-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ [[__R_0_I_I_I]], %[[WHILE_COND_I_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ], [ [[__R_0_I16_I_I]], %[[WHILE_COND_I14_I_I]] ]
++// AMDGCNSPIRV-NEXT:    [[RETVAL_0_I_I:%.*]] = phi i64 [ 0, %[[IF_THEN5_I_I]] ], [ 0, %[[WHILE_BODY_I_I_I]] ], [ [[__R_0_I_I_I]], %[[WHILE_COND_I_I_I]] ], [ [[ADD28_I_I_I]], %[[IF_END31_I_I_I]] ], [ 0, %[[IF_ELSE17_I_I_I]] ], [ 0, %[[WHILE_BODY_I18_I_I]] ], [ [[__R_0_I16_I_I]], %[[WHILE_COND_I14_I_I]] ]
+ // AMDGCNSPIRV-NEXT:    [[BF_VALUE_I:%.*]] = and i64 [[RETVAL_0_I_I]], 2251799813685247
+ // AMDGCNSPIRV-NEXT:    [[BF_SET9_I:%.*]] = or disjoint i64 [[BF_VALUE_I]], 9221120237041090560
+ // AMDGCNSPIRV-NEXT:    [[TMP12:%.*]] = bitcast i64 [[BF_SET9_I]] to double
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/IR/Instructions.h b/llvm/include/llvm/IR/Instructions.h
+--- a/llvm/include/llvm/IR/Instructions.h
++++ b/llvm/include/llvm/IR/Instructions.h
+@@ -2787,6 +2787,7 @@
+   /// is true), the PHI node is destroyed and any uses of it are replaced with
+   /// dummy values.  The only time there should be zero incoming values to a PHI
+   /// node is when the block is dead, so this strategy is sound.
++  ///
+   LLVM_ABI Value *removeIncomingValue(unsigned Idx,
+                                       bool DeletePHIIfEmpty = true);
+ 
+diff -ruN --strip-trailing-cr a/llvm/lib/IR/Instructions.cpp b/llvm/lib/IR/Instructions.cpp
+--- a/llvm/lib/IR/Instructions.cpp
++++ b/llvm/lib/IR/Instructions.cpp
+@@ -137,12 +137,14 @@
+ // predecessor basic block is deleted.
+ Value *PHINode::removeIncomingValue(unsigned Idx, bool DeletePHIIfEmpty) {
+   Value *Removed = getIncomingValue(Idx);
+-  // Swap with the end of the list.
+-  unsigned Last = getNumOperands() - 1;
+-  if (Idx != Last) {
+-    setIncomingValue(Idx, getIncomingValue(Last));
+-    setIncomingBlock(Idx, getIncomingBlock(Last));
 -  }
--};
--
--} // namespace acc
--} // namespace mlir
--
--#endif // MLIR_DIALECT_OPENACC_TRANSFORMS_ACCSPECIALIZEPATTERNS_H
-diff -ruN --strip-trailing-cr a/mlir/include/mlir/Dialect/OpenACC/Transforms/Passes.h b/mlir/include/mlir/Dialect/OpenACC/Transforms/Passes.h
---- a/mlir/include/mlir/Dialect/OpenACC/Transforms/Passes.h
-+++ b/mlir/include/mlir/Dialect/OpenACC/Transforms/Passes.h
-@@ -12,7 +12,6 @@
- #include "mlir/Dialect/Arith/IR/Arith.h"
- #include "mlir/Dialect/MemRef/IR/MemRef.h"
- #include "mlir/Dialect/OpenACC/OpenACC.h"
--#include "mlir/Dialect/SCF/IR/SCF.h"
- #include "mlir/Pass/Pass.h"
++
++  // Move everything after this operand down.
++  //
++  // FIXME: we could just swap with the end of the list, then erase.  However,
++  // clients might not expect this to happen.  The code as it is thrashes the
++  // use/def lists, which is kinda lame.
++  std::copy(op_begin() + Idx + 1, op_end(), op_begin() + Idx);
++  copyIncomingBlocks(drop_begin(blocks(), Idx + 1), Idx);
  
- namespace mlir {
-@@ -23,40 +22,9 @@
+   // Nuke the last value.
+   Op<-1>().set(nullptr);
+@@ -160,21 +162,26 @@
+ void PHINode::removeIncomingValueIf(function_ref<bool(unsigned)> Predicate,
+                                     bool DeletePHIIfEmpty) {
+   unsigned NumOps = getNumIncomingValues();
+-
+-  // Loop backwards in case the predicate is purely index based.
+-  for (unsigned Idx = NumOps; Idx-- > 0;) {
+-    if (Predicate(Idx)) {
+-      unsigned LastIdx = NumOps - 1;
+-      if (Idx != LastIdx) {
+-        setIncomingValue(Idx, getIncomingValue(LastIdx));
+-        setIncomingBlock(Idx, getIncomingBlock(LastIdx));
+-      }
+-      getOperandUse(LastIdx).set(nullptr);
+-      NumOps--;
++  unsigned NewNumOps = 0;
++  for (unsigned Idx = 0; Idx < NumOps; ++Idx) {
++    if (Predicate(Idx))
++      continue;
++
++    if (Idx != NewNumOps) {
++      setIncomingValue(NewNumOps, getIncomingValue(Idx));
++      setIncomingBlock(NewNumOps, getIncomingBlock(Idx));
+     }
++    ++NewNumOps;
+   }
  
- namespace acc {
+-  setNumHungOffUseOperands(NumOps);
++  if (NewNumOps == NumOps)
++    return;
++
++  // Remove operands.
++  for (unsigned Idx = NewNumOps; Idx < NumOps; ++Idx)
++    getOperandUse(Idx).set(nullptr);
++
++  setNumHungOffUseOperands(NewNumOps);
  
--class OpenACCSupport;
--
- #define GEN_PASS_DECL
- #include "mlir/Dialect/OpenACC/Transforms/Passes.h.inc"
+   // If the PHI node is dead, because it has zero entries, nuke it now.
+   if (getNumOperands() == 0 && DeletePHIIfEmpty) {
+diff -ruN --strip-trailing-cr a/llvm/lib/SandboxIR/Tracker.cpp b/llvm/lib/SandboxIR/Tracker.cpp
+--- a/llvm/lib/SandboxIR/Tracker.cpp
++++ b/llvm/lib/SandboxIR/Tracker.cpp
+@@ -95,16 +95,24 @@
+ }
  
--//===----------------------------------------------------------------------===//
--// ACCSpecializeForDevice patterns
--//===----------------------------------------------------------------------===//
--
--/// Populates all patterns for device specialization.
--/// In specialized device code (such as specialized acc routine), many ACC
--/// operations do not make sense because they are host-side constructs. This
--/// function adds patterns to remove or transform them.
--void populateACCSpecializeForDevicePatterns(RewritePatternSet &patterns);
--
--//===----------------------------------------------------------------------===//
--// ACCSpecializeForHost patterns
--//===----------------------------------------------------------------------===//
--
--/// Populates patterns for converting orphan ACC operations to host.
--/// All patterns check that the operation is NOT inside or associated with a
--/// compute region before converting.
--/// @param enableLoopConversion Whether to convert orphan acc.loop operations.
--void populateACCOrphanToHostPatterns(RewritePatternSet &patterns,
--                                     OpenACCSupport &accSupport,
--                                     bool enableLoopConversion = true);
--
--/// Populates all patterns for host fallback path (when `if` clause evaluates
--/// to false). In this mode, ALL ACC operations should be converted or removed.
--/// @param enableLoopConversion Whether to convert orphan acc.loop operations.
--void populateACCHostFallbackPatterns(RewritePatternSet &patterns,
--                                     OpenACCSupport &accSupport,
--                                     bool enableLoopConversion = true);
--
- /// Generate the code for registering conversion passes.
- #define GEN_PASS_REGISTRATION
- #include "mlir/Dialect/OpenACC/Transforms/Passes.h.inc"
-diff -ruN --strip-trailing-cr a/mlir/include/mlir/Dialect/OpenACC/Transforms/Passes.td b/mlir/include/mlir/Dialect/OpenACC/Transforms/Passes.td
---- a/mlir/include/mlir/Dialect/OpenACC/Transforms/Passes.td
-+++ b/mlir/include/mlir/Dialect/OpenACC/Transforms/Passes.td
-@@ -194,62 +194,4 @@
-   ];
+ void PHIRemoveIncoming::revert(Tracker &Tracker) {
+-  // Special case: if the removed incoming value is the last.
++  // Special case: if the PHI is now empty, as we don't need to care about the
++  // order of the incoming values.
+   unsigned NumIncoming = PHI->getNumIncomingValues();
+-  if (NumIncoming == RemovedIdx) {
++  if (NumIncoming == 0) {
+     PHI->addIncoming(RemovedV, RemovedBB);
+     return;
+   }
+-  // Move the incoming value currently at `RemovedIdx` to the end, restore the
+-  // old incoming value back to `RemovedIdx`.
+-  PHI->addIncoming(PHI->getIncomingValue(RemovedIdx),
+-                   PHI->getIncomingBlock(RemovedIdx));
++  // Shift all incoming values by one starting from the end until `Idx`.
++  // Start by adding a copy of the last incoming values.
++  unsigned LastIdx = NumIncoming - 1;
++  PHI->addIncoming(PHI->getIncomingValue(LastIdx),
++                   PHI->getIncomingBlock(LastIdx));
++  for (unsigned Idx = LastIdx; Idx > RemovedIdx; --Idx) {
++    auto *PrevV = PHI->getIncomingValue(Idx - 1);
++    auto *PrevBB = PHI->getIncomingBlock(Idx - 1);
++    PHI->setIncomingValue(Idx, PrevV);
++    PHI->setIncomingBlock(Idx, PrevBB);
++  }
+   PHI->setIncomingValue(RemovedIdx, RemovedV);
+   PHI->setIncomingBlock(RemovedIdx, RemovedBB);
  }
+diff -ruN --strip-trailing-cr a/llvm/lib/Target/X86/X86ISelLowering.cpp b/llvm/lib/Target/X86/X86ISelLowering.cpp
+--- a/llvm/lib/Target/X86/X86ISelLowering.cpp
++++ b/llvm/lib/Target/X86/X86ISelLowering.cpp
+@@ -48471,8 +48471,9 @@
+                           MaskVal->getAPIntValue().exactLogBase2());
+       }
+       // vsel ((X & C) == 0), LHS, RHS --> vsel ((shl X, C') < 0), RHS, LHS
+-      SDValue ShlAmt = getConstVector(ShlVals, VT.getSimpleVT(), DAG, DL);
+-      SDValue Shl = DAG.getNode(ISD::SHL, DL, VT, And.getOperand(0), ShlAmt);
++      MVT MskVT = Mask.getSimpleValueType();
++      SDValue ShlAmt = getConstVector(ShlVals, MskVT, DAG, DL);
++      SDValue Shl = DAG.getNode(ISD::SHL, DL, MskVT, And.getOperand(0), ShlAmt);
+       SDValue NewCond =
+           DAG.getSetCC(DL, CondVT, Shl, Cond.getOperand(1), ISD::SETLT);
+       return DAG.getSelect(DL, VT, NewCond, RHS, LHS);
+diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/WinEH/wineh-no-demotion.ll b/llvm/test/CodeGen/WinEH/wineh-no-demotion.ll
+--- a/llvm/test/CodeGen/WinEH/wineh-no-demotion.ll
++++ b/llvm/test/CodeGen/WinEH/wineh-no-demotion.ll
+@@ -120,7 +120,7 @@
+   call void @h(i32 %phi)
+   unreachable
  
--def ACCSpecializeForDevice : Pass<"acc-specialize-for-device", "mlir::func::FuncOp"> {
--  let summary = "Strip OpenACC constructs inside device code";
--  let description = [{
--    In a specialized acc routine or compute construct, many OpenACC operations
--    do not make sense because they are host-side constructs. This pass removes
--    or transforms these operations appropriately.
--
--    The following operations are handled:
--    - Data entry ops (replaced with var): acc.attach, acc.copyin, acc.create,
--      acc.declare_device_resident, acc.declare_link, acc.deviceptr,
--      acc.get_deviceptr, acc.nocreate, acc.present, acc.update_device,
--      acc.use_device
--    - Data exit ops (erased): acc.copyout, acc.delete, acc.detach,
--      acc.update_host
--    - Structured data (inline region): acc.data, acc.host_data,
--      acc.kernel_environment
--    - Unstructured data (erased): acc.enter_data, acc.exit_data, acc.update,
--      acc.declare_enter, acc.declare_exit
--    - Compute constructs (inline region): acc.parallel, acc.serial, acc.kernels
--    - Runtime ops (erased): acc.init, acc.shutdown, acc.set, acc.wait
--  }];
--  let dependentDialects = ["mlir::acc::OpenACCDialect"];
--}
--
--def ACCSpecializeForHost : Pass<"acc-specialize-for-host", "mlir::func::FuncOp"> {
--  let summary = "Convert OpenACC operations for host execution";
--  let description = [{
--    This pass converts OpenACC operations to host-compatible representations.
--    It serves as a conversion pass that transforms ACC constructs to enable
--    execution on the host rather than on accelerator devices.
--
--    There are two modes of operation:
--
--    1. Default mode (orphan operations only): Only orphan operations that are
--       not allowed outside compute regions are converted. Structured/unstructured
--       data constructs, compute constructs, and their associated data operations
--       are NOT removed.
--
--    2. Host fallback mode (enableHostFallback=true): ALL ACC operations within
--       the region are converted to host equivalents. This is used when the `if`
--       clause evaluates to false at runtime.
--
--    The following operations are handled:
--    - Atomic ops: converted to load/store operations
--    - Loop ops: converted to scf.for or scf.execute_region
--    - Data entry ops (orphan): replaced with var operand
--    - In host fallback mode: all data, compute, and runtime ops are removed
--  }];
--  let dependentDialects = ["mlir::acc::OpenACCDialect",
--      "mlir::scf::SCFDialect"];
--  let options = [
--    Option<"enableHostFallback", "enable-host-fallback", "bool", "false",
--           "Enable host fallback mode which converts ALL ACC operations, "
--           "not just orphan operations. Use this when the `if` clause "
--           "evaluates to false.">
--  ];
--}
--
- #endif // MLIR_DIALECT_OPENACC_TRANSFORMS_PASSES
-diff -ruN --strip-trailing-cr a/mlir/lib/Dialect/OpenACC/Transforms/ACCSpecializeForDevice.cpp b/mlir/lib/Dialect/OpenACC/Transforms/ACCSpecializeForDevice.cpp
---- a/mlir/lib/Dialect/OpenACC/Transforms/ACCSpecializeForDevice.cpp
-+++ b/mlir/lib/Dialect/OpenACC/Transforms/ACCSpecializeForDevice.cpp
-@@ -1,172 +0,0 @@
--//===- ACCSpecializeForDevice.cpp -----------------------------------------===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
--//
--// This pass strips OpenACC constructs that are invalid or unnecessary inside
--// device code (specialized acc routines or compute construct regions).
--//
--// Overview:
--// ---------
--// In a specialized acc routine or compute construct, many OpenACC operations
--// do not make sense because they are host-side constructs. This pass removes
--// or transforms these operations appropriately:
--//
--// - Data operations that manage device memory from host perspective
--// - Compute constructs that launch kernels (we're already on device)
--// - Runtime operations like init/shutdown/set/wait
--//
--// Transformations:
--// ----------------
--// The pass applies the following transformations:
--//
--// 1. Data Entry Ops (replaced with var operand):
--//    acc.attach, acc.copyin, acc.create, acc.declare_device_resident,
--//    acc.declare_link, acc.deviceptr, acc.get_deviceptr, acc.nocreate,
--//    acc.present, acc.update_device, acc.use_device
--//
--// 2. Data Exit Ops (erased):
--//    acc.copyout, acc.delete, acc.detach, acc.update_host
--//
--// 3. Structured Data/Compute Constructs (region inlined):
--//    acc.data, acc.host_data, acc.kernel_environment, acc.parallel,
--//    acc.serial, acc.kernels
--//
--// 4. Unstructured Data Ops (erased):
--//    acc.enter_data, acc.exit_data, acc.update, acc.declare_enter,
--//    acc.declare_exit
--//
--// 5. Runtime Ops (erased):
--//    acc.init, acc.shutdown, acc.set, acc.wait
--//
--// Scope of Application:
--// ---------------------
--// - For functions with `acc.specialized_routine` attribute: patterns are
--//   applied to the entire function body.
--// - For non-specialized functions: patterns are applied only to ACC
--//   operations INSIDE compute constructs (parallel, serial, kernels),
--//   not to the compute constructs themselves or their data operands.
--//
--// Note: acc.cache, acc.private, acc.reduction, acc.firstprivate are NOT
--// transformed by this pass as they are valid in device code.
--//
--//===----------------------------------------------------------------------===//
--
--#include "mlir/Dialect/OpenACC/Transforms/Passes.h"
--
--#include "mlir/Dialect/Func/IR/FuncOps.h"
--#include "mlir/Dialect/OpenACC/OpenACC.h"
--#include "mlir/Dialect/OpenACC/Transforms/ACCSpecializePatterns.h"
--#include "mlir/IR/PatternMatch.h"
--#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
--
--namespace mlir {
--namespace acc {
--#define GEN_PASS_DEF_ACCSPECIALIZEFORDEVICE
--#include "mlir/Dialect/OpenACC/Transforms/Passes.h.inc"
--} // namespace acc
--} // namespace mlir
--
--using namespace mlir;
--using namespace mlir::acc;
--
--namespace {
--
--class ACCSpecializeForDevice
--    : public acc::impl::ACCSpecializeForDeviceBase<ACCSpecializeForDevice> {
--public:
--  using ACCSpecializeForDeviceBase<
--      ACCSpecializeForDevice>::ACCSpecializeForDeviceBase;
--
--  void runOnOperation() override {
--    func::FuncOp func = getOperation();
--
--    RewritePatternSet patterns(&getContext());
--    acc::populateACCSpecializeForDevicePatterns(patterns);
--    GreedyRewriteConfig config;
--    config.setUseTopDownTraversal(true);
--
--    if (acc::isSpecializedAccRoutine(func)) {
--      // For specialized acc routines, apply patterns to the entire function
--      (void)applyPatternsGreedily(func, std::move(patterns), config);
--    } else {
--      // For non-specialized functions, apply patterns only to ACC operations
--      // inside compute constructs (not to the compute constructs themselves).
--      SmallVector<Operation *> opsToTransform;
--      func.walk([&](Operation *op) {
--        if (isa<ACC_COMPUTE_CONSTRUCT_OPS>(op)) {
--          // Walk inside the compute construct and collect ACC ops
--          op->walk([&](Operation *innerOp) {
--            // Skip the compute construct itself
--            if (innerOp == op)
--              return;
--            if (isa<acc::OpenACCDialect>(innerOp->getDialect()))
--              opsToTransform.push_back(innerOp);
--          });
--        }
--      });
--      if (!opsToTransform.empty())
--        (void)applyOpPatternsGreedily(opsToTransform, std::move(patterns),
--                                      config);
--    }
--  }
--};
--
--} // namespace
--
--//===----------------------------------------------------------------------===//
--// Pattern population functions
--//===----------------------------------------------------------------------===//
--
--void mlir::acc::populateACCSpecializeForDevicePatterns(
--    RewritePatternSet &patterns) {
--  MLIRContext *context = patterns.getContext();
--
--  // Declare patterns - erase declare_enter and its associated declare_exit
--  patterns.insert<ACCDeclareEnterOpConversion>(context);
--
--  // Data entry ops - replaced with their var operand
--  // Note: acc.cache, acc.private, acc.reduction, acc.firstprivate are NOT
--  // included here - they are valid in device code
--  patterns.insert<ACCOpReplaceWithVarConversion<acc::AttachOp>,
--                  ACCOpReplaceWithVarConversion<acc::CopyinOp>,
--                  ACCOpReplaceWithVarConversion<acc::CreateOp>,
--                  ACCOpReplaceWithVarConversion<acc::DeclareDeviceResidentOp>,
--                  ACCOpReplaceWithVarConversion<acc::DeclareLinkOp>,
--                  ACCOpReplaceWithVarConversion<acc::DevicePtrOp>,
--                  ACCOpReplaceWithVarConversion<acc::GetDevicePtrOp>,
--                  ACCOpReplaceWithVarConversion<acc::NoCreateOp>,
--                  ACCOpReplaceWithVarConversion<acc::PresentOp>,
--                  ACCOpReplaceWithVarConversion<acc::UpdateDeviceOp>,
--                  ACCOpReplaceWithVarConversion<acc::UseDeviceOp>>(context);
--
--  // Data exit ops - simply erased (no results)
--  patterns.insert<ACCOpEraseConversion<acc::CopyoutOp>,
--                  ACCOpEraseConversion<acc::DeleteOp>,
--                  ACCOpEraseConversion<acc::DetachOp>,
--                  ACCOpEraseConversion<acc::UpdateHostOp>>(context);
--
--  // Structured data constructs - unwrap their regions
--  patterns.insert<ACCRegionUnwrapConversion<acc::DataOp>,
--                  ACCRegionUnwrapConversion<acc::HostDataOp>,
--                  ACCRegionUnwrapConversion<acc::KernelEnvironmentOp>>(context);
--
--  // Compute constructs - unwrap their regions
--  patterns.insert<ACCRegionUnwrapConversion<acc::ParallelOp>,
--                  ACCRegionUnwrapConversion<acc::SerialOp>,
--                  ACCRegionUnwrapConversion<acc::KernelsOp>>(context);
--
--  // Unstructured data operations - erase them
--  patterns.insert<ACCOpEraseConversion<acc::EnterDataOp>,
--                  ACCOpEraseConversion<acc::ExitDataOp>,
--                  ACCOpEraseConversion<acc::UpdateOp>>(context);
--
--  // Runtime operations - erase them
--  patterns.insert<
--      ACCOpEraseConversion<acc::InitOp>, ACCOpEraseConversion<acc::ShutdownOp>,
--      ACCOpEraseConversion<acc::SetOp>, ACCOpEraseConversion<acc::WaitOp>>(
--      context);
--}
-diff -ruN --strip-trailing-cr a/mlir/lib/Dialect/OpenACC/Transforms/ACCSpecializeForHost.cpp b/mlir/lib/Dialect/OpenACC/Transforms/ACCSpecializeForHost.cpp
---- a/mlir/lib/Dialect/OpenACC/Transforms/ACCSpecializeForHost.cpp
-+++ b/mlir/lib/Dialect/OpenACC/Transforms/ACCSpecializeForHost.cpp
-@@ -1,471 +0,0 @@
--//===- ACCSpecializeForHost.cpp -------------------------------------------===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
--//
--// This pass converts OpenACC operations to host-compatible representations,
--// enabling execution on the host rather than on accelerator devices.
--//
--// Overview:
--// ---------
--// The pass operates in two modes depending on the `enableHostFallback` option:
--//
--// 1. Default Mode (Orphan Operations Only):
--//    Only converts "orphan" ACC operations that are not inside or attached to
--//    compute regions. This is used for host routines (acc routine marked for
--//    host) where structured/unstructured data constructs, compute constructs,
--//    and their associated data operations should be preserved.
--//
--// 2. Host Fallback Mode (enableHostFallback=true):
--//    Converts ALL ACC operations within the region to host equivalents. This
--//    is used when the `if` clause evaluates to false at runtime and the
--//    entire ACC region needs to fall back to host execution.
--//
--// Transformations (Orphan Mode):
--// ------------------------------
--// The following orphan operations are converted:
--//
--// 1. Atomic Ops (converted to load/store):
--//    acc.atomic.update -> load + compute + store
--//    acc.atomic.read -> load + store (copy)
--//    acc.atomic.write -> store
--//    acc.atomic.capture -> inline region contents
--//
--// 2. Loop Ops (converted to SCF):
--//    acc.loop (structured) -> scf.for
--//    acc.loop (unstructured) -> scf.execute_region
--//
--// 3. Orphan Data Entry Ops (replaced with var operand):
--//    acc.cache, acc.private, acc.firstprivate, acc.reduction
--//    (only if NOT connected to compute constructs or loop)
--//
--// Transformations (Host Fallback Mode):
--// -------------------------------------
--// In addition to orphan transformations, ALL of the following are converted:
--//
--// 1. Data Entry Ops (replaced with var operand):
--//    acc.copyin, acc.create, acc.attach, acc.present, acc.deviceptr,
--//    acc.get_deviceptr, acc.nocreate, acc.declare_device_resident,
--//    acc.declare_link, acc.use_device, acc.update_device
--//
--// 2. Data Exit Ops (erased):
--//    acc.copyout, acc.delete, acc.detach, acc.update_host
--//
--// 3. Structured Data/Compute Constructs (region inlined):
--//    acc.data, acc.host_data, acc.kernel_environment, acc.declare,
--//    acc.parallel, acc.serial, acc.kernels
--//
--// 4. Unstructured Data Ops (erased):
--//    acc.enter_data, acc.exit_data, acc.update
--//
--// 5. Declare Ops (erased):
--//    acc.declare_enter, acc.declare_exit
--//
--// 6. Runtime Ops (erased):
--//    acc.init, acc.shutdown, acc.set, acc.wait, acc.terminator
--//
--// Requirements:
--// -------------
--// For atomic operation conversion, variables must implement the
--// `acc::PointerLikeType` interface to enable generating load/store operations.
--//
--// The pass uses `OpenACCSupport::emitNYI()` to report unsupported cases.
--//
--//===----------------------------------------------------------------------===//
--
--#include "mlir/Dialect/OpenACC/Transforms/Passes.h"
--
--#include "mlir/Dialect/Func/IR/FuncOps.h"
--#include "mlir/Dialect/OpenACC/Analysis/OpenACCSupport.h"
--#include "mlir/Dialect/OpenACC/OpenACC.h"
--#include "mlir/Dialect/OpenACC/OpenACCUtilsLoop.h"
--#include "mlir/Dialect/OpenACC/Transforms/ACCSpecializePatterns.h"
--#include "mlir/IR/BuiltinAttributes.h"
--#include "mlir/IR/BuiltinOps.h"
--#include "mlir/IR/BuiltinTypes.h"
--#include "mlir/IR/Operation.h"
--#include "mlir/IR/PatternMatch.h"
--#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
--
--namespace mlir {
--namespace acc {
--#define GEN_PASS_DEF_ACCSPECIALIZEFORHOST
--#include "mlir/Dialect/OpenACC/Transforms/Passes.h.inc"
--} // namespace acc
--} // namespace mlir
--
--#define DEBUG_TYPE "acc-specialize-for-host"
--
--using namespace mlir;
--using namespace mlir::acc;
--
--/// Check if an operation is inside an ACC compute construct.
--static bool isInsideACCComputeConstruct(Operation *op) {
--  while ((op = op->getParentOp()))
--    if (isa<ACC_COMPUTE_CONSTRUCT_OPS>(op))
--      return true;
--  return false;
--}
--
--namespace {
--
--// Lower orphan acc.atomic.update by: load from addr, clone region expr with
--// the loaded value, then store the computed result back to addr.
--// Only matches if NOT inside a compute region.
--class ACCOrphanAtomicUpdateOpConversion
--    : public OpRewritePattern<acc::AtomicUpdateOp> {
--public:
--  ACCOrphanAtomicUpdateOpConversion(MLIRContext *ctx, OpenACCSupport &support)
--      : OpRewritePattern<acc::AtomicUpdateOp>(ctx), accSupport(support) {}
--
--  LogicalResult matchAndRewrite(acc::AtomicUpdateOp atomicUpdateOp,
--                                PatternRewriter &rewriter) const override {
--    // Only convert if this op is not inside an ACC compute construct
--    if (isInsideACCComputeConstruct(atomicUpdateOp))
--      return failure();
--
--    Value x = atomicUpdateOp.getX();
--    Type type = x.getType();
--    auto ptrLikeType = dyn_cast<acc::PointerLikeType>(type);
--    if (ptrLikeType) {
--      auto xTyped = cast<TypedValue<acc::PointerLikeType>>(x);
--      rewriter.setInsertionPointAfter(atomicUpdateOp);
--      Value loadOp =
--          ptrLikeType.genLoad(rewriter, atomicUpdateOp.getLoc(), xTyped, {});
--      if (!loadOp) {
--        accSupport.emitNYI(atomicUpdateOp.getLoc(),
--                           "failed to generate load for atomic update");
--        return failure();
--      }
--      IRMapping mapping;
--      mapping.map(atomicUpdateOp.getRegion().front().getArgument(0), loadOp);
--      Operation *expr = rewriter.clone(*atomicUpdateOp.getFirstOp(), mapping);
--      if (!ptrLikeType.genStore(rewriter, atomicUpdateOp.getLoc(),
--                                expr->getResult(0), xTyped)) {
--        accSupport.emitNYI(atomicUpdateOp.getLoc(),
--                           "failed to generate store for atomic update");
--        return failure();
--      }
--      rewriter.eraseOp(atomicUpdateOp);
--    } else {
--      accSupport.emitNYI(atomicUpdateOp.getLoc(),
--                         "unsupported type for atomic update");
--      return failure();
--    }
--    return success();
--  }
--
--private:
--  OpenACCSupport &accSupport;
--};
--
--// Lower orphan acc.atomic.read by: load from src, then store into dst.
--// Only matches if NOT inside an ACC compute construct.
--class ACCOrphanAtomicReadOpConversion
--    : public OpRewritePattern<acc::AtomicReadOp> {
--public:
--  ACCOrphanAtomicReadOpConversion(MLIRContext *ctx, OpenACCSupport &support)
--      : OpRewritePattern<acc::AtomicReadOp>(ctx), accSupport(support) {}
--
--  LogicalResult matchAndRewrite(acc::AtomicReadOp readOp,
--                                PatternRewriter &rewriter) const override {
--    // Only convert if this op is not inside an ACC compute construct
--    if (isInsideACCComputeConstruct(readOp))
--      return failure();
--
--    Value x = readOp.getX();
--    Value v = readOp.getV();
--    auto xPtrType = dyn_cast<acc::PointerLikeType>(x.getType());
--    auto vPtrType = dyn_cast<acc::PointerLikeType>(v.getType());
--    if (xPtrType && vPtrType) {
--      auto xTyped = cast<TypedValue<acc::PointerLikeType>>(x);
--      auto vTyped = cast<TypedValue<acc::PointerLikeType>>(v);
--      rewriter.setInsertionPointAfter(readOp);
--
--      // Use genCopy which does load + store
--      if (!xPtrType.genCopy(rewriter, readOp.getLoc(), vTyped, xTyped, {})) {
--        accSupport.emitNYI(readOp.getLoc(),
--                           "failed to generate copy for atomic read");
--        return failure();
--      }
--      rewriter.eraseOp(readOp);
--    } else {
--      accSupport.emitNYI(readOp.getLoc(), "unsupported type for atomic read");
--      return failure();
--    }
--    return success();
--  }
--
--private:
--  OpenACCSupport &accSupport;
--};
--
--// Lower orphan acc.atomic.write by: store value into addr.
--// Only matches if NOT inside an ACC compute construct.
--class ACCOrphanAtomicWriteOpConversion
--    : public OpRewritePattern<acc::AtomicWriteOp> {
--public:
--  ACCOrphanAtomicWriteOpConversion(MLIRContext *ctx, OpenACCSupport &support)
--      : OpRewritePattern<acc::AtomicWriteOp>(ctx), accSupport(support) {}
--
--  LogicalResult matchAndRewrite(acc::AtomicWriteOp writeOp,
--                                PatternRewriter &rewriter) const override {
--    // Only convert if this op is not inside an ACC compute construct
--    if (isInsideACCComputeConstruct(writeOp))
--      return failure();
--
--    Value x = writeOp.getX();
--    Value expr = writeOp.getExpr();
--    auto ptrLikeType = dyn_cast<acc::PointerLikeType>(x.getType());
--    if (ptrLikeType) {
--      auto xTyped = cast<TypedValue<acc::PointerLikeType>>(x);
--      rewriter.setInsertionPointAfter(writeOp);
--      if (!ptrLikeType.genStore(rewriter, writeOp.getLoc(), expr, xTyped)) {
--        accSupport.emitNYI(writeOp.getLoc(),
--                           "failed to generate store for atomic write");
--        return failure();
--      }
--      rewriter.eraseOp(writeOp);
--    } else {
--      accSupport.emitNYI(writeOp.getLoc(), "unsupported type for atomic write");
--      return failure();
--    }
--    return success();
--  }
--
--private:
--  OpenACCSupport &accSupport;
--};
--
--// Lower orphan acc.atomic.capture by: unwrap the capture region and erase the
--// wrapper; inner ops are lowered in-order (e.g., read+update becomes load/store
--// to dst then load/compute/store to addr).
--// Only matches if NOT inside an ACC compute construct.
--class ACCOrphanAtomicCaptureOpConversion
--    : public OpRewritePattern<acc::AtomicCaptureOp> {
--  using OpRewritePattern<acc::AtomicCaptureOp>::OpRewritePattern;
--
--  LogicalResult matchAndRewrite(acc::AtomicCaptureOp captureOp,
--                                PatternRewriter &rewriter) const override {
--    // Only convert if this op is not inside an ACC compute construct
--    if (isInsideACCComputeConstruct(captureOp))
--      return failure();
--
--    assert(captureOp.getRegion().hasOneBlock() && "expected one block");
--    Block *block = &captureOp.getRegion().front();
--    // Remove the terminator before inlining
--    rewriter.eraseOp(block->getTerminator());
--    rewriter.inlineBlockBefore(block, captureOp);
--    rewriter.eraseOp(captureOp);
--    return success();
--  }
--};
--
--// Convert orphan acc.loop to scf.for or scf.execute_region.
--// Only matches if NOT inside an ACC compute construct.
--class ACCOrphanLoopOpConversion : public OpRewritePattern<acc::LoopOp> {
--  using OpRewritePattern<acc::LoopOp>::OpRewritePattern;
--
--  LogicalResult matchAndRewrite(acc::LoopOp loopOp,
--                                PatternRewriter &rewriter) const override {
--    // Only convert if this op is not inside an ACC compute construct
--    if (isInsideACCComputeConstruct(loopOp))
--      return failure();
--
--    if (loopOp.getUnstructured()) {
--      auto executeRegion =
--          acc::convertUnstructuredACCLoopToSCFExecuteRegion(loopOp, rewriter);
--      if (!executeRegion)
--        return failure();
--      rewriter.replaceOp(loopOp, executeRegion);
--    } else {
--      auto forOp =
--          acc::convertACCLoopToSCFFor(loopOp, /*enableCollapse=*/false);
--      if (!forOp)
--        return failure();
--      rewriter.replaceOp(loopOp, forOp);
--    }
--    return success();
--  }
--};
--
--/// Check if an operation is used by a compute construct or loop op
--static bool isUsedByComputeOrLoop(Operation *op) {
--  for (auto *user : op->getUsers())
--    if (isa<acc::ParallelOp, acc::SerialOp, acc::KernelsOp, acc::LoopOp>(user))
--      return true;
--  return false;
--}
--
--/// Orphan data entry ops - only match if NOT connected to compute/loop and
--/// NOT inside a compute region. Used for acc.cache, acc.private,
--/// acc.firstprivate, acc.reduction.
--template <typename OpTy>
--class ACCOrphanDataEntryConversion : public OpRewritePattern<OpTy> {
--  using OpRewritePattern<OpTy>::OpRewritePattern;
--
--  LogicalResult matchAndRewrite(OpTy op,
--                                PatternRewriter &rewriter) const override {
--    // Only convert if this op is not used by a compute construct or loop,
--    // and not inside an ACC compute construct.
--    if (isUsedByComputeOrLoop(op) || isInsideACCComputeConstruct(op))
--      return failure();
--
--    if (op->use_empty())
--      rewriter.eraseOp(op);
--    else
--      rewriter.replaceOp(op, op.getVar());
--    return success();
--  }
--};
--
--class ACCSpecializeForHost
--    : public acc::impl::ACCSpecializeForHostBase<ACCSpecializeForHost> {
--public:
--  using ACCSpecializeForHostBase<
--      ACCSpecializeForHost>::ACCSpecializeForHostBase;
--
--  void runOnOperation() override {
--    LLVM_DEBUG(llvm::dbgs() << "Enter ACCSpecializeForHost()\n");
--
--    func::FuncOp funcOp = getOperation();
--    if (!acc::isSpecializedAccRoutine(funcOp)) {
--      // Convert orphan operations to host, or all ACC operations if
--      // host fallback patterns are enabled.
--      auto *context = &getContext();
--      RewritePatternSet patterns(context);
--      OpenACCSupport &accSupport = getAnalysis<OpenACCSupport>();
--      if (enableHostFallback)
--        populateACCHostFallbackPatterns(patterns, accSupport);
--      else
--        populateACCOrphanToHostPatterns(patterns, accSupport);
--      GreedyRewriteConfig config;
--      config.setUseTopDownTraversal(true);
--      if (failed(applyPatternsGreedily(funcOp, std::move(patterns), config)))
--        signalPassFailure();
--    }
--
--    LLVM_DEBUG(llvm::dbgs() << "Exit ACCSpecializeForHost()\n");
--  }
--};
--} // namespace
--
--//===----------------------------------------------------------------------===//
--// Pattern population functions
--//===----------------------------------------------------------------------===//
--
--void mlir::acc::populateACCOrphanToHostPatterns(RewritePatternSet &patterns,
--                                                OpenACCSupport &accSupport,
--                                                bool enableLoopConversion) {
--  MLIRContext *context = patterns.getContext();
--
--  // For host routines (acc routine marked for host), we only convert orphan
--  // operations that are not allowed outside compute regions. All patterns
--  // here check that the operation is NOT inside a compute region before
--  // converting:
--  // - acc.atomic.* -> load/store operations
--  // - acc.loop -> scf.for or scf.execute_region
--  // - acc.cache -> replaced with var
--  // - acc.private, acc.reduction, acc.firstprivate -> replaced with var
--  //   (only if NOT connected to compute constructs or loop)
--  //
--  // We do NOT remove structured/unstructured data constructs, compute
--  // constructs, or their associated data operations - those are valid
--  // in host routines and will be processed by other passes.
--
--  // Loop conversion (orphan only)
--  if (enableLoopConversion)
--    patterns.insert<ACCOrphanLoopOpConversion>(context);
--
--  // Atomic operations - convert to non-atomic load/store (orphan only)
--  patterns.insert<ACCOrphanAtomicUpdateOpConversion>(context, accSupport);
--  patterns.insert<ACCOrphanAtomicReadOpConversion>(context, accSupport);
--  patterns.insert<ACCOrphanAtomicWriteOpConversion>(context, accSupport);
--  patterns.insert<ACCOrphanAtomicCaptureOpConversion>(context);
--
--  // Orphan data entry ops - only convert if NOT connected to compute/loop
--  // and NOT inside a compute region
--  patterns.insert<ACCOrphanDataEntryConversion<acc::CacheOp>,
--                  ACCOrphanDataEntryConversion<acc::PrivateOp>,
--                  ACCOrphanDataEntryConversion<acc::FirstprivateOp>,
--                  ACCOrphanDataEntryConversion<acc::ReductionOp>>(context);
--}
--
--void mlir::acc::populateACCHostFallbackPatterns(RewritePatternSet &patterns,
--                                                OpenACCSupport &accSupport,
--                                                bool enableLoopConversion) {
--  MLIRContext *context = patterns.getContext();
--
--  // For host fallback path (when `if` clause evaluates to false), ALL ACC
--  // operations within the region should be converted to host equivalents.
--  // This includes structured/unstructured data, compute constructs, and
--  // their associated data operations.
--
--  // Loop conversion - OK to use the orphan loop conversion pattern here
--  // because the parent compute constructs will also be converted.
--  if (enableLoopConversion)
--    patterns.insert<ACCOrphanLoopOpConversion>(context);
--
--  // Atomic operations - convert to non-atomic load/store. OK to use the orphan
--  // atomic conversion patterns here because the parent compute constructs will
--  // also be converted.
--  patterns.insert<ACCOrphanAtomicUpdateOpConversion>(context, accSupport);
--  patterns.insert<ACCOrphanAtomicReadOpConversion>(context, accSupport);
--  patterns.insert<ACCOrphanAtomicWriteOpConversion>(context, accSupport);
--  patterns.insert<ACCOrphanAtomicCaptureOpConversion>(context);
--
--  // acc.cache - convert ALL cache ops (including those inside compute regions)
--  patterns.insert<ACCOpReplaceWithVarConversion<acc::CacheOp>>(context);
--
--  // Privatization ops - convert ALL (including those attached to compute/loop)
--  patterns.insert<ACCOpReplaceWithVarConversion<acc::PrivateOp>,
--                  ACCOpReplaceWithVarConversion<acc::FirstprivateOp>,
--                  ACCOpReplaceWithVarConversion<acc::ReductionOp>>(context);
--
--  // Data entry ops - replaced with their var operand
--  patterns.insert<ACCOpReplaceWithVarConversion<acc::CopyinOp>,
--                  ACCOpReplaceWithVarConversion<acc::CreateOp>,
--                  ACCOpReplaceWithVarConversion<acc::AttachOp>,
--                  ACCOpReplaceWithVarConversion<acc::PresentOp>,
--                  ACCOpReplaceWithVarConversion<acc::DevicePtrOp>,
--                  ACCOpReplaceWithVarConversion<acc::GetDevicePtrOp>,
--                  ACCOpReplaceWithVarConversion<acc::NoCreateOp>,
--                  ACCOpReplaceWithVarConversion<acc::DeclareDeviceResidentOp>,
--                  ACCOpReplaceWithVarConversion<acc::DeclareLinkOp>,
--                  ACCOpReplaceWithVarConversion<acc::UseDeviceOp>,
--                  ACCOpReplaceWithVarConversion<acc::UpdateDeviceOp>>(context);
--
--  // Data exit ops - simply erased (no results)
--  patterns.insert<ACCOpEraseConversion<acc::CopyoutOp>,
--                  ACCOpEraseConversion<acc::DeleteOp>,
--                  ACCOpEraseConversion<acc::DetachOp>,
--                  ACCOpEraseConversion<acc::UpdateHostOp>>(context);
--
--  // Structured data constructs - unwrap their regions
--  patterns.insert<ACCRegionUnwrapConversion<acc::DataOp>,
--                  ACCRegionUnwrapConversion<acc::HostDataOp>,
--                  ACCRegionUnwrapConversion<acc::KernelEnvironmentOp>>(context);
--
--  // Declare ops
--  patterns.insert<ACCDeclareEnterOpConversion,
--                  ACCRegionUnwrapConversion<acc::DeclareOp>>(context);
--
--  // Unstructured data operations - erase them
--  patterns.insert<ACCOpEraseConversion<acc::EnterDataOp>,
--                  ACCOpEraseConversion<acc::ExitDataOp>,
--                  ACCOpEraseConversion<acc::UpdateOp>>(context);
--
--  // Runtime operations - erase them
--  patterns.insert<
--      ACCOpEraseConversion<acc::InitOp>, ACCOpEraseConversion<acc::ShutdownOp>,
--      ACCOpEraseConversion<acc::SetOp>, ACCOpEraseConversion<acc::WaitOp>,
--      ACCOpEraseConversion<acc::TerminatorOp>>(context);
--
--  // Compute constructs - unwrap their regions
--  patterns.insert<ACCRegionUnwrapConversion<acc::ParallelOp>,
--                  ACCRegionUnwrapConversion<acc::SerialOp>,
--                  ACCRegionUnwrapConversion<acc::KernelsOp>>(context);
--}
-diff -ruN --strip-trailing-cr a/mlir/lib/Dialect/OpenACC/Transforms/CMakeLists.txt b/mlir/lib/Dialect/OpenACC/Transforms/CMakeLists.txt
---- a/mlir/lib/Dialect/OpenACC/Transforms/CMakeLists.txt
-+++ b/mlir/lib/Dialect/OpenACC/Transforms/CMakeLists.txt
-@@ -4,8 +4,6 @@
-   ACCImplicitDeclare.cpp
-   ACCImplicitRoutine.cpp
-   ACCLegalizeSerial.cpp
--  ACCSpecializeForDevice.cpp
--  ACCSpecializeForHost.cpp
-   LegalizeDataValues.cpp
+-; CHECK: %phi = phi i32 [ -1, %right.other ], [ 0, %right ]
++; CHECK: %phi = phi i32 [ 0, %right ], [ -1, %right.other ]
+ ; CHECK: call void @h(i32 %phi)
  
-   ADDITIONAL_HEADER_DIRS
-@@ -28,7 +26,6 @@
-   MLIRFuncDialect
-   MLIRIR
-   MLIRPass
--  MLIRSCFDialect
-   MLIRSupport
-   MLIRTransforms
- )
-diff -ruN --strip-trailing-cr a/mlir/lib/Dialect/Tensor/IR/ValueBoundsOpInterfaceImpl.cpp b/mlir/lib/Dialect/Tensor/IR/ValueBoundsOpInterfaceImpl.cpp
---- a/mlir/lib/Dialect/Tensor/IR/ValueBoundsOpInterfaceImpl.cpp
-+++ b/mlir/lib/Dialect/Tensor/IR/ValueBoundsOpInterfaceImpl.cpp
-@@ -31,27 +31,6 @@
-   }
- };
+ ; CHECK: %phi.for.left = phi i32 [ 1, %left ]
+diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/pr173794.ll b/llvm/test/CodeGen/X86/pr173794.ll
+--- a/llvm/test/CodeGen/X86/pr173794.ll
++++ b/llvm/test/CodeGen/X86/pr173794.ll
+@@ -0,0 +1,43 @@
++; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
++; RUN: llc < %s -mtriple=x86_64-- -mcpu=x86-64    | FileCheck %s --check-prefix=SSE2
++; RUN: llc < %s -mtriple=x86_64-- -mcpu=x86-64-v2 | FileCheck %s --check-prefix=SSE42
++; RUN: llc < %s -mtriple=x86_64-- -mcpu=x86-64-v3 | FileCheck %s --check-prefix=AVX2
++; RUN: llc < %s -mtriple=x86_64-- -mcpu=x86-64-v4 | FileCheck %s --check-prefix=AVX512
++
++define <2 x double> @PR173794(<2 x i64> %a0) {
++; SSE2-LABEL: PR173794:
++; SSE2:       # %bb.0:
++; SSE2-NEXT:    pshufd {{.*#+}} xmm1 = xmm0[1,0,3,2]
++; SSE2-NEXT:    pand {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1
++; SSE2-NEXT:    pxor %xmm0, %xmm0
++; SSE2-NEXT:    pcmpeqd %xmm1, %xmm0
++; SSE2-NEXT:    pand {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
++; SSE2-NEXT:    retq
++;
++; SSE42-LABEL: PR173794:
++; SSE42:       # %bb.0:
++; SSE42-NEXT:    pand {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
++; SSE42-NEXT:    pxor %xmm1, %xmm1
++; SSE42-NEXT:    pcmpeqq %xmm1, %xmm0
++; SSE42-NEXT:    pand {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
++; SSE42-NEXT:    retq
++;
++; AVX2-LABEL: PR173794:
++; AVX2:       # %bb.0:
++; AVX2-NEXT:    vpsllvq {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
++; AVX2-NEXT:    vpxor %xmm1, %xmm1, %xmm1
++; AVX2-NEXT:    vpcmpgtq %xmm0, %xmm1, %xmm0
++; AVX2-NEXT:    vpandn {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
++; AVX2-NEXT:    retq
++;
++; AVX512-LABEL: PR173794:
++; AVX512:       # %bb.0:
++; AVX512-NEXT:    vptestnmq {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %k1
++; AVX512-NEXT:    vmovddup {{.*#+}} xmm0 {%k1} {z} = [1.0E+0,1.0E+0]
++; AVX512-NEXT:    # xmm0 {%k1} {z} = mem[0,0]
++; AVX512-NEXT:    retq
++  %m = and <2 x i64> %a0, <i64 1, i64 2>
++  %c = icmp eq <2 x i64> %m, zeroinitializer
++  %r = select <2 x i1> %c, <2 x double> splat (double 1.000000e+00), <2 x double> zeroinitializer
++  ret <2 x double> %r
++}
+diff -ruN --strip-trailing-cr a/llvm/test/Examples/IRTransforms/SimplifyCFG/tut-simplify-cfg5-del-phis-for-dead-block.ll b/llvm/test/Examples/IRTransforms/SimplifyCFG/tut-simplify-cfg5-del-phis-for-dead-block.ll
+--- a/llvm/test/Examples/IRTransforms/SimplifyCFG/tut-simplify-cfg5-del-phis-for-dead-block.ll
++++ b/llvm/test/Examples/IRTransforms/SimplifyCFG/tut-simplify-cfg5-del-phis-for-dead-block.ll
+@@ -53,7 +53,7 @@
+ ; CHECK:       sw.default23:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       sw.epilog24:
+-; CHECK-NEXT:    [[PREVIOUS_3:%.*]] = phi i32 [ 401, [[ENTRY:%.*]] ], [ undef, [[SW_BB1]] ]
++; CHECK-NEXT:    [[PREVIOUS_3:%.*]] = phi i32 [ undef, [[SW_BB1]] ], [ 401, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    unreachable
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/CodeGenPrepare/X86/sink-addrmode-base.ll b/llvm/test/Transforms/CodeGenPrepare/X86/sink-addrmode-base.ll
+--- a/llvm/test/Transforms/CodeGenPrepare/X86/sink-addrmode-base.ll
++++ b/llvm/test/Transforms/CodeGenPrepare/X86/sink-addrmode-base.ll
+@@ -847,7 +847,7 @@
+ ; CHECK-YES:       [[IF_THEN2]]:
+ ; CHECK-YES-NEXT:    br label %[[FALLTHROUGH]]
+ ; CHECK-YES:       [[FALLTHROUGH]]:
+-; CHECK-YES-NEXT:    [[SUNK_PHI:%.*]] = phi ptr [ [[B1]], %[[IF_THEN1]] ], [ [[B2]], %[[IF_THEN2]] ]
++; CHECK-YES-NEXT:    [[SUNK_PHI:%.*]] = phi ptr [ [[B2]], %[[IF_THEN2]] ], [ [[B1]], %[[IF_THEN1]] ]
+ ; CHECK-YES-NEXT:    [[SUNKADDR:%.*]] = getelementptr inbounds i8, ptr [[SUNK_PHI]], i64 40
+ ; CHECK-YES-NEXT:    [[V1:%.*]] = load i32, ptr [[SUNKADDR]], align 4
+ ; CHECK-YES-NEXT:    [[G1_1:%.*]] = getelementptr inbounds i64, ptr [[B2]], i64 5
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/Coroutines/coro-catchswitch.ll b/llvm/test/Transforms/Coroutines/coro-catchswitch.ll
+--- a/llvm/test/Transforms/Coroutines/coro-catchswitch.ll
++++ b/llvm/test/Transforms/Coroutines/coro-catchswitch.ll
+@@ -29,7 +29,7 @@
+ ; added a cleanuppad spill cleanupret unwinding into the catchswitch.
  
--struct CollapseShapeOpInterface
--    : public ValueBoundsOpInterface::ExternalModel<CollapseShapeOpInterface,
--                                                   CollapseShapeOp> {
--  void populateBoundsForShapedValueDim(Operation *op, Value value, int64_t dim,
--                                       ValueBoundsConstraintSet &cstr) const {
--    auto collapseOp = cast<CollapseShapeOp>(op);
--    assert(value == collapseOp.getResult() && "invalid value");
--
--    // Multiply the expressions for the dimensions in the reassociation group.
--    const ReassociationIndices &reassocIndices =
--        collapseOp.getReassociationIndices()[dim];
--    AffineExpr productExpr =
--        cstr.getExpr(collapseOp.getSrc(), reassocIndices[0]);
--    for (size_t i = 1; i < reassocIndices.size(); ++i) {
--      productExpr =
--          productExpr * cstr.getExpr(collapseOp.getSrc(), reassocIndices[i]);
--    }
--    cstr.bound(value)[dim] == productExpr;
--  }
--};
--
- struct DimOpInterface
-     : public ValueBoundsOpInterface::ExternalModel<DimOpInterface, DimOp> {
-   void populateBoundsForIndexValue(Operation *op, Value value,
-@@ -78,17 +57,6 @@
-   }
- };
+ ; CHECK: catch.dispatch:
+-; CHECK:  %val = phi i32 [ 1, %if.then ], [ 2, %if.else ]
++; CHECK:  %val = phi i32 [ 2, %if.else ], [ 1, %if.then ]
+ ; CHECK:  %[[Pad:.+]] = cleanuppad within none []
+ ; CHECK:  %val.spill.addr = getelementptr inbounds %f.Frame, ptr %hdl, i32 0, i32 2
+ ; CHECK:  store i32 %val, ptr %val.spill.addr
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/DFAJumpThreading/dfa-jump-threading-transform.ll b/llvm/test/Transforms/DFAJumpThreading/dfa-jump-threading-transform.ll
+--- a/llvm/test/Transforms/DFAJumpThreading/dfa-jump-threading-transform.ll
++++ b/llvm/test/Transforms/DFAJumpThreading/dfa-jump-threading-transform.ll
+@@ -42,7 +42,7 @@
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT]], label [[FOR_BODY]], label [[FOR_END:%.*]]
+ ; CHECK:       for.inc.jt2:
+ ; CHECK-NEXT:    [[COUNT4:%.*]] = phi i32 [ [[COUNT1]], [[SEL_SI_UNFOLD_FALSE_JT2]] ], [ [[COUNT2]], [[CASE1]] ]
+-; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ [[DOTSI_UNFOLD_PHI_JT2]], [[SEL_SI_UNFOLD_FALSE_JT2]] ], [ 2, [[CASE1]] ]
++; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ 2, [[CASE1]] ], [ [[DOTSI_UNFOLD_PHI_JT2]], [[SEL_SI_UNFOLD_FALSE_JT2]] ]
+ ; CHECK-NEXT:    [[INC_JT2]] = add nsw i32 [[COUNT4]], 1
+ ; CHECK-NEXT:    [[CMP_EXIT_JT2:%.*]] = icmp slt i32 [[INC_JT2]], [[NUM]]
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT_JT2]], label [[FOR_BODY_JT2]], label [[FOR_END]]
+@@ -103,7 +103,7 @@
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI:%.*]] = phi i32 [ 2, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    br label [[LOOP_1]]
+ ; CHECK:       loop.1:
+-; CHECK-NEXT:    [[STATE_1:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[DOTSI_UNFOLD_PHI]], [[SEL_SI_UNFOLD_FALSE]] ], [ [[STATE_1_BE_SI_UNFOLD_PHI]], [[STATE_1_BE2_SI_UNFOLD_FALSE:%.*]] ]
++; CHECK-NEXT:    [[STATE_1:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[STATE_1_BE_SI_UNFOLD_PHI]], [[STATE_1_BE2_SI_UNFOLD_FALSE:%.*]] ], [ [[DOTSI_UNFOLD_PHI]], [[SEL_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    br label [[LOOP_2:%.*]]
+ ; CHECK:       loop.1.jt4:
+ ; CHECK-NEXT:    [[STATE_1_JT4:%.*]] = phi i32 [ [[STATE_1_BE_SI_UNFOLD_PHI_JT4]], [[STATE_1_BE2_SI_UNFOLD_FALSE_JT4:%.*]] ]
+@@ -112,7 +112,7 @@
+ ; CHECK-NEXT:    [[STATE_1_JT2:%.*]] = phi i32 [ [[STATE_1_BE_SI_UNFOLD_PHI_JT2]], [[STATE_1_BE2_SI_UNFOLD_FALSE_JT2:%.*]] ]
+ ; CHECK-NEXT:    br label [[LOOP_2_JT2:%.*]]
+ ; CHECK:       loop.1.jt1:
+-; CHECK-NEXT:    [[STATE_1_JT1:%.*]] = phi i32 [ 1, [[LOOP_1_BACKEDGE_JT4]] ], [ 1, [[LOOP_1_BACKEDGE]] ], [ 1, [[LOOP_1_BACKEDGE_JT2]] ]
++; CHECK-NEXT:    [[STATE_1_JT1:%.*]] = phi i32 [ 1, [[LOOP_1_BACKEDGE]] ], [ 1, [[LOOP_1_BACKEDGE_JT2]] ], [ 1, [[LOOP_1_BACKEDGE_JT4]] ]
+ ; CHECK-NEXT:    br label [[LOOP_2_JT1:%.*]]
+ ; CHECK:       loop.2:
+ ; CHECK-NEXT:    [[STATE_2:%.*]] = phi i32 [ [[STATE_1]], [[LOOP_1]] ], [ poison, [[LOOP_2_BACKEDGE:%.*]] ]
+@@ -145,7 +145,7 @@
+ ; CHECK-NEXT:    [[STATE_JT0:%.*]] = phi i32 [ [[STATE_2_JT0]], [[LOOP_2_JT0:%.*]] ]
+ ; CHECK-NEXT:    br label [[CASE0]]
+ ; CHECK:       loop.3.jt3:
+-; CHECK-NEXT:    [[STATE_JT3:%.*]] = phi i32 [ [[STATE_2_JT3]], [[LOOP_2_JT3:%.*]] ], [ 3, [[CASE2]] ]
++; CHECK-NEXT:    [[STATE_JT3:%.*]] = phi i32 [ 3, [[CASE2]] ], [ [[STATE_2_JT3]], [[LOOP_2_JT3:%.*]] ]
+ ; CHECK-NEXT:    br label [[CASE3]]
+ ; CHECK:       loop.3.jt4:
+ ; CHECK-NEXT:    [[STATE_JT4:%.*]] = phi i32 [ [[STATE_2_JT4]], [[LOOP_2_JT4]] ]
+@@ -320,15 +320,16 @@
+ ; CHECK-NEXT:    br i1 [[CMP1:%.*]], label [[BB9]], label [[SEL_SI_UNFOLD_FALSE_JT1:%.*]]
+ ; CHECK:       sel.si.unfold.true.jt0:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1:%.*]] = phi i32 [ 0, [[BB2]] ]
+-; CHECK-NEXT:    br i1 [[CMP1]], label [[BB7_JT0]], label [[SEL_SI_UNFOLD_FALSE_JT1]]
++; CHECK-NEXT:    br i1 [[CMP1]], label [[BB7_JT0]], label [[SEL_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       sel.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2:%.*]] = phi i32 [ 1, [[BB7]] ]
+ ; CHECK-NEXT:    br label [[BB9]]
+ ; CHECK:       sel.si.unfold.false.jt1:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2_JT1:%.*]] = phi i32 [ 1, [[SPEC_SELECT_SI_UNFOLD_FALSE:%.*]] ], [ 1, [[BB7]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2_JT1:%.*]] = phi i32 [ 1, [[SEL_SI_UNFOLD_TRUE:%.*]] ]
+ ; CHECK-NEXT:    br label [[BB7_JT1:%.*]]
+ ; CHECK:       BB7:
+-; CHECK-NEXT:    [[D_PROMOTED4:%.*]] = phi i16 [ 1, [[SPEC_SELECT_SI_UNFOLD_FALSE]] ], [ 1, [[SEL_SI_UNFOLD_TRUE:%.*]] ], [ 1, [[SEL_SI_UNFOLD_FALSE:%.*]] ]
+-; CHECK-NEXT:    [[_3:%.*]] = phi i32 [ poison, [[SPEC_SELECT_SI_UNFOLD_FALSE]] ], [ poison, [[SEL_SI_UNFOLD_TRUE]] ], [ poison, [[SEL_SI_UNFOLD_FALSE]] ]
++; CHECK-NEXT:    [[D_PROMOTED4:%.*]] = phi i16 [ 1, [[SPEC_SELECT_SI_UNFOLD_FALSE:%.*]] ], [ 1, [[SEL_SI_UNFOLD_TRUE]] ], [ 1, [[SEL_SI_UNFOLD_FALSE]] ]
++; CHECK-NEXT:    [[_3:%.*]] = phi i32 [ poison, [[SPEC_SELECT_SI_UNFOLD_FALSE]] ], [ poison, [[SEL_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI2]], [[SEL_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    switch i32 [[_3]], label [[BB1_BACKEDGE]] [
+ ; CHECK-NEXT:      i32 0, label [[BB1]]
+ ; CHECK-NEXT:      i32 1, label [[BB8:%.*]]
+@@ -338,8 +339,8 @@
+ ; CHECK-NEXT:    [[_3_JT1:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI2_JT1]], [[SEL_SI_UNFOLD_FALSE_JT1]] ]
+ ; CHECK-NEXT:    br label [[BB8]]
+ ; CHECK:       BB7.jt0:
+-; CHECK-NEXT:    [[D_PROMOTED4_JT0:%.*]] = phi i16 [ 0, [[BB1]] ], [ 1, [[BB7]] ], [ 1, [[SPEC_SELECT_SI_UNFOLD_FALSE_JT0]] ]
+-; CHECK-NEXT:    [[_3_JT0:%.*]] = phi i32 [ 0, [[BB1]] ], [ [[DOTSI_UNFOLD_PHI1]], [[BB7]] ], [ [[DOTSI_UNFOLD_PHI_JT0]], [[SPEC_SELECT_SI_UNFOLD_FALSE_JT0]] ]
++; CHECK-NEXT:    [[D_PROMOTED4_JT0:%.*]] = phi i16 [ 0, [[BB1]] ], [ 1, [[SPEC_SELECT_SI_UNFOLD_FALSE_JT0]] ], [ 1, [[BB7]] ]
++; CHECK-NEXT:    [[_3_JT0:%.*]] = phi i32 [ 0, [[BB1]] ], [ [[DOTSI_UNFOLD_PHI_JT0]], [[SPEC_SELECT_SI_UNFOLD_FALSE_JT0]] ], [ [[DOTSI_UNFOLD_PHI1]], [[BB7]] ]
+ ; CHECK-NEXT:    br label [[BB1]]
+ ; CHECK:       BB1.backedge:
+ ; CHECK-NEXT:    br label [[BB1]]
+@@ -393,14 +394,15 @@
+ ; CHECK-NEXT:    br i1 [[CMP1:%.*]], label [[SELECT_UNFOLD1]], label [[SPEC_SELECT_SI_UNFOLD_FALSE_JT1:%.*]]
+ ; CHECK:       spec.select.si.unfold.true.jt0:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1:%.*]] = phi i32 [ 0, [[BB1]] ]
+-; CHECK-NEXT:    br i1 [[CMP1]], label [[SELECT_UNFOLD_JT0]], label [[SPEC_SELECT_SI_UNFOLD_FALSE_JT1]]
++; CHECK-NEXT:    br i1 [[CMP1]], label [[SELECT_UNFOLD_JT0]], label [[SPEC_SELECT_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       spec.select.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2:%.*]] = phi i32 [ 1, [[SELECT_UNFOLD]] ]
+ ; CHECK-NEXT:    br label [[SELECT_UNFOLD1]]
+ ; CHECK:       spec.select.si.unfold.false.jt1:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2_JT1:%.*]] = phi i32 [ 1, [[SPEC_SELECT_SI_UNFOLD_TRUE:%.*]] ], [ 1, [[SELECT_UNFOLD]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2_JT1:%.*]] = phi i32 [ 1, [[SPEC_SELECT_SI_UNFOLD_TRUE:%.*]] ]
+ ; CHECK-NEXT:    br label [[SELECT_UNFOLD_JT1:%.*]]
+ ; CHECK:       select.unfold:
+-; CHECK-NEXT:    [[_2:%.*]] = phi i32 [ poison, [[SPEC_SELECT_SI_UNFOLD_TRUE]] ], [ poison, [[SPEC_SELECT_SI_UNFOLD_FALSE:%.*]] ], [ poison, [[SPEC_SELECT7_SI_UNFOLD_FALSE:%.*]] ]
++; CHECK-NEXT:    [[_2:%.*]] = phi i32 [ poison, [[SPEC_SELECT7_SI_UNFOLD_FALSE:%.*]] ], [ poison, [[SPEC_SELECT_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI2]], [[SPEC_SELECT_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    switch i32 [[_2]], label [[BB2:%.*]] [
+ ; CHECK-NEXT:      i32 0, label [[DOTPREHEADER_PREHEADER:%.*]]
+ ; CHECK-NEXT:      i32 1, label [[DOTLOOPEXIT6]]
+@@ -409,7 +411,7 @@
+ ; CHECK-NEXT:    [[_2_JT1:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI2_JT1]], [[SPEC_SELECT_SI_UNFOLD_FALSE_JT1]] ]
+ ; CHECK-NEXT:    br label [[DOTLOOPEXIT6]]
+ ; CHECK:       select.unfold.jt0:
+-; CHECK-NEXT:    [[_2_JT0:%.*]] = phi i32 [ 0, [[DOTLOOPEXIT6]] ], [ [[DOTSI_UNFOLD_PHI1]], [[SELECT_UNFOLD]] ], [ [[DOTSI_UNFOLD_PHI_JT0]], [[SPEC_SELECT7_SI_UNFOLD_FALSE_JT0]] ]
++; CHECK-NEXT:    [[_2_JT0:%.*]] = phi i32 [ 0, [[DOTLOOPEXIT6]] ], [ [[DOTSI_UNFOLD_PHI_JT0]], [[SPEC_SELECT7_SI_UNFOLD_FALSE_JT0]] ], [ [[DOTSI_UNFOLD_PHI1]], [[SELECT_UNFOLD]] ]
+ ; CHECK-NEXT:    br label [[DOTPREHEADER_PREHEADER]]
+ ; CHECK:       .preheader.preheader:
+ ; CHECK-NEXT:    ret void
+@@ -594,7 +596,7 @@
+ ; CHECK:       sw.default.i:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       bb.exit:
+-; CHECK-NEXT:    [[RETVAL_SROA_6_0_I]] = phi i16 [ 0, [[IF_END5_JT1:%.*]] ], [ 0, [[IF_END5]] ], [ 0, [[IF_END5_JT0:%.*]] ]
++; CHECK-NEXT:    [[RETVAL_SROA_6_0_I]] = phi i16 [ 0, [[IF_END5]] ], [ 0, [[IF_END5_JT1:%.*]] ], [ 0, [[IF_END5_JT0:%.*]] ]
+ ; CHECK-NEXT:    call void (...) @llvm.fake.use(i32 2)
+ ; CHECK-NEXT:    br label [[IF_END5]]
+ ; CHECK:       bb.exit.jt0:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/DFAJumpThreading/dfa-unfold-select.ll b/llvm/test/Transforms/DFAJumpThreading/dfa-unfold-select.ll
+--- a/llvm/test/Transforms/DFAJumpThreading/dfa-unfold-select.ll
++++ b/llvm/test/Transforms/DFAJumpThreading/dfa-unfold-select.ll
+@@ -45,7 +45,7 @@
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT]], label [[FOR_BODY]], label [[FOR_END:%.*]]
+ ; CHECK:       for.inc.jt2:
+ ; CHECK-NEXT:    [[COUNT4:%.*]] = phi i32 [ [[COUNT1]], [[SEL_SI_UNFOLD_FALSE_JT2]] ], [ [[COUNT2]], [[CASE1]] ]
+-; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ [[DOTSI_UNFOLD_PHI_JT2]], [[SEL_SI_UNFOLD_FALSE_JT2]] ], [ 2, [[CASE1]] ]
++; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ 2, [[CASE1]] ], [ [[DOTSI_UNFOLD_PHI_JT2]], [[SEL_SI_UNFOLD_FALSE_JT2]] ]
+ ; CHECK-NEXT:    [[INC_JT2]] = add nsw i32 [[COUNT4]], 1
+ ; CHECK-NEXT:    [[CMP_EXIT_JT2:%.*]] = icmp slt i32 [[INC_JT2]], [[NUM]]
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT_JT2]], label [[FOR_BODY_JT2]], label [[FOR_END]]
+@@ -98,6 +98,10 @@
+ ; CHECK-NEXT:      i32 1, label [[CASE1:%.*]]
+ ; CHECK-NEXT:      i32 2, label [[CASE2:%.*]]
+ ; CHECK-NEXT:    ]
++; CHECK:       for.body.jt2:
++; CHECK-NEXT:    [[COUNT_JT2:%.*]] = phi i32 [ [[INC_JT2:%.*]], [[FOR_INC_JT2:%.*]] ]
++; CHECK-NEXT:    [[STATE_JT2:%.*]] = phi i32 [ [[STATE_NEXT_JT2:%.*]], [[FOR_INC_JT2]] ]
++; CHECK-NEXT:    br label [[CASE2]]
+ ; CHECK:       for.body.jt1:
+ ; CHECK-NEXT:    [[COUNT_JT1:%.*]] = phi i32 [ [[INC_JT1:%.*]], [[FOR_INC_JT1]] ]
+ ; CHECK-NEXT:    [[STATE_JT1:%.*]] = phi i32 [ [[STATE_NEXT_JT1:%.*]], [[FOR_INC_JT1]] ]
+@@ -106,39 +110,35 @@
+ ; CHECK-NEXT:    [[COUNT_JT3:%.*]] = phi i32 [ [[INC_JT3:%.*]], [[FOR_INC_JT3:%.*]] ]
+ ; CHECK-NEXT:    [[STATE_JT3:%.*]] = phi i32 [ [[STATE_NEXT_JT3:%.*]], [[FOR_INC_JT3]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC]]
+-; CHECK:       for.body.jt2:
+-; CHECK-NEXT:    [[COUNT_JT2:%.*]] = phi i32 [ [[INC_JT2:%.*]], [[FOR_INC_JT2:%.*]] ]
+-; CHECK-NEXT:    [[STATE_JT2:%.*]] = phi i32 [ [[STATE_NEXT_JT2:%.*]], [[FOR_INC_JT2]] ]
+-; CHECK-NEXT:    br label [[CASE2]]
+ ; CHECK:       case1:
+ ; CHECK-NEXT:    [[COUNT6:%.*]] = phi i32 [ [[COUNT_JT1]], [[FOR_BODY_JT1:%.*]] ], [ [[COUNT]], [[FOR_BODY]] ]
+ ; CHECK-NEXT:    [[CMP_C1:%.*]] = icmp slt i32 [[COUNT6]], 50
+ ; CHECK-NEXT:    [[CMP2_C1:%.*]] = icmp slt i32 [[COUNT6]], 100
+ ; CHECK-NEXT:    br i1 [[CMP2_C1]], label [[STATE1_1_SI_UNFOLD_TRUE_JT1:%.*]], label [[STATE1_2_SI_UNFOLD_FALSE_JT3:%.*]]
+ ; CHECK:       case2:
+-; CHECK-NEXT:    [[COUNT5:%.*]] = phi i32 [ [[COUNT_JT2]], [[FOR_BODY_JT2:%.*]] ], [ [[COUNT]], [[FOR_BODY]] ]
+-; CHECK-NEXT:    [[CMP_C2:%.*]] = icmp slt i32 [[COUNT5]], 50
+-; CHECK-NEXT:    [[CMP2_C2:%.*]] = icmp sgt i32 [[COUNT5]], 100
++; CHECK-NEXT:    [[CMP_C2:%.*]] = icmp slt i32 [[COUNT]], 50
++; CHECK-NEXT:    [[CMP2_C2:%.*]] = icmp sgt i32 [[COUNT]], 100
+ ; CHECK-NEXT:    br i1 [[CMP2_C2]], label [[FOR_INC_JT3]], label [[STATE2_1_SI_UNFOLD_TRUE_JT1:%.*]]
+ ; CHECK:       state2.1.si.unfold.true:
+ ; CHECK-NEXT:    br i1 [[CMP_C2]], label [[STATE2_2_SI_UNFOLD_FALSE:%.*]], label [[STATE2_1_SI_UNFOLD_FALSE_JT2:%.*]]
+ ; CHECK:       state2.1.si.unfold.true.jt1:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI_JT1:%.*]] = phi i32 [ 1, [[CASE2]] ]
+-; CHECK-NEXT:    br i1 [[CMP_C2]], label [[STATE2_2_SI_UNFOLD_FALSE_JT1:%.*]], label [[STATE2_1_SI_UNFOLD_FALSE_JT2]]
++; CHECK-NEXT:    br i1 [[CMP_C2]], label [[STATE2_2_SI_UNFOLD_FALSE_JT1:%.*]], label [[STATE2_1_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       state2.1.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1:%.*]] = phi i32 [ 2, [[STATE2_1_SI_UNFOLD_TRUE_JT1]] ]
+ ; CHECK-NEXT:    br label [[STATE2_2_SI_UNFOLD_FALSE]]
+ ; CHECK:       state2.1.si.unfold.false.jt2:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1_JT2:%.*]] = phi i32 [ 2, [[STATE2_1_SI_UNFOLD_TRUE:%.*]] ], [ 2, [[STATE2_1_SI_UNFOLD_TRUE_JT1]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1_JT2:%.*]] = phi i32 [ 2, [[STATE2_1_SI_UNFOLD_TRUE:%.*]] ]
+ ; CHECK-NEXT:    br label [[STATE2_2_SI_UNFOLD_FALSE_JT2:%.*]]
+ ; CHECK:       state2.2.si.unfold.false:
+-; CHECK-NEXT:    [[STATE2_1_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[STATE2_1_SI_UNFOLD_FALSE:%.*]] ], [ poison, [[STATE2_1_SI_UNFOLD_TRUE]] ]
++; CHECK-NEXT:    [[STATE2_1_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[STATE2_1_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI1]], [[STATE2_1_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC]]
+-; CHECK:       state2.2.si.unfold.false.jt1:
+-; CHECK-NEXT:    [[STATE2_1_SI_UNFOLD_PHI_JT1:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI_JT1]], [[STATE2_1_SI_UNFOLD_TRUE_JT1]] ]
+-; CHECK-NEXT:    br label [[FOR_INC_JT1]]
+ ; CHECK:       state2.2.si.unfold.false.jt2:
+ ; CHECK-NEXT:    [[STATE2_1_SI_UNFOLD_PHI_JT2:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI1_JT2]], [[STATE2_1_SI_UNFOLD_FALSE_JT2]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC_JT2]]
++; CHECK:       state2.2.si.unfold.false.jt1:
++; CHECK-NEXT:    [[STATE2_1_SI_UNFOLD_PHI_JT1:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI_JT1]], [[STATE2_1_SI_UNFOLD_TRUE_JT1]] ]
++; CHECK-NEXT:    br label [[FOR_INC_JT1]]
+ ; CHECK:       state1.2.si.unfold.false:
+ ; CHECK-NEXT:    br label [[FOR_INC]]
+ ; CHECK:       state1.2.si.unfold.false.jt3:
+@@ -148,35 +148,36 @@
+ ; CHECK-NEXT:    br i1 [[CMP_C1]], label [[FOR_INC]], label [[STATE1_1_SI_UNFOLD_FALSE_JT2:%.*]]
+ ; CHECK:       state1.1.si.unfold.true.jt1:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI3_JT1:%.*]] = phi i32 [ 1, [[CASE1]] ]
+-; CHECK-NEXT:    br i1 [[CMP_C1]], label [[FOR_INC_JT1]], label [[STATE1_1_SI_UNFOLD_FALSE_JT2]]
++; CHECK-NEXT:    br i1 [[CMP_C1]], label [[FOR_INC_JT1]], label [[STATE1_1_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       state1.1.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI4:%.*]] = phi i32 [ 2, [[STATE1_1_SI_UNFOLD_TRUE_JT1]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC]]
+ ; CHECK:       state1.1.si.unfold.false.jt2:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI4_JT2:%.*]] = phi i32 [ 2, [[STATE1_1_SI_UNFOLD_TRUE:%.*]] ], [ 2, [[STATE1_1_SI_UNFOLD_TRUE_JT1]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI4_JT2:%.*]] = phi i32 [ 2, [[STATE1_1_SI_UNFOLD_TRUE:%.*]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC_JT2]]
+ ; CHECK:       for.inc:
+-; CHECK-NEXT:    [[STATE_NEXT]] = phi i32 [ poison, [[STATE1_1_SI_UNFOLD_FALSE:%.*]] ], [ poison, [[STATE1_1_SI_UNFOLD_TRUE]] ], [ 1, [[FOR_BODY_JT3:%.*]] ], [ [[STATE2_1_SI_UNFOLD_PHI]], [[STATE2_2_SI_UNFOLD_FALSE]] ], [ poison, [[STATE1_2_SI_UNFOLD_FALSE:%.*]] ]
+-; CHECK-NEXT:    [[INC]] = add nsw i32 [[COUNT_JT3]], 1
++; CHECK-NEXT:    [[COUNT5:%.*]] = phi i32 [ [[COUNT_JT3]], [[FOR_BODY_JT3:%.*]] ], [ undef, [[STATE1_1_SI_UNFOLD_TRUE]] ], [ [[COUNT6]], [[STATE1_1_SI_UNFOLD_FALSE]] ], [ undef, [[STATE1_2_SI_UNFOLD_FALSE:%.*]] ], [ [[COUNT]], [[STATE2_2_SI_UNFOLD_FALSE]] ]
++; CHECK-NEXT:    [[STATE_NEXT]] = phi i32 [ [[STATE2_1_SI_UNFOLD_PHI]], [[STATE2_2_SI_UNFOLD_FALSE]] ], [ poison, [[STATE1_2_SI_UNFOLD_FALSE]] ], [ poison, [[STATE1_1_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI4]], [[STATE1_1_SI_UNFOLD_FALSE]] ], [ 1, [[FOR_BODY_JT3]] ]
++; CHECK-NEXT:    [[INC]] = add nsw i32 [[COUNT5]], 1
+ ; CHECK-NEXT:    [[CMP_EXIT:%.*]] = icmp slt i32 [[INC]], [[NUM:%.*]]
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT]], label [[FOR_BODY]], label [[FOR_END:%.*]]
++; CHECK:       for.inc.jt2:
++; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ [[STATE2_1_SI_UNFOLD_PHI_JT2]], [[STATE2_2_SI_UNFOLD_FALSE_JT2]] ], [ [[DOTSI_UNFOLD_PHI4_JT2]], [[STATE1_1_SI_UNFOLD_FALSE_JT2]] ]
++; CHECK-NEXT:    [[INC_JT2]] = add nsw i32 undef, 1
++; CHECK-NEXT:    [[CMP_EXIT_JT2:%.*]] = icmp slt i32 [[INC_JT2]], [[NUM]]
++; CHECK-NEXT:    br i1 [[CMP_EXIT_JT2]], label [[FOR_BODY_JT2:%.*]], label [[FOR_END]]
+ ; CHECK:       for.inc.jt1:
+-; CHECK-NEXT:    [[COUNT7:%.*]] = phi i32 [ [[COUNT6]], [[STATE1_1_SI_UNFOLD_TRUE_JT1]] ], [ [[COUNT5]], [[STATE2_2_SI_UNFOLD_FALSE_JT1]] ], [ [[COUNT]], [[FOR_BODY]] ]
+-; CHECK-NEXT:    [[STATE_NEXT_JT1]] = phi i32 [ [[DOTSI_UNFOLD_PHI3_JT1]], [[STATE1_1_SI_UNFOLD_TRUE_JT1]] ], [ [[STATE2_1_SI_UNFOLD_PHI_JT1]], [[STATE2_2_SI_UNFOLD_FALSE_JT1]] ], [ 1, [[FOR_BODY]] ]
++; CHECK-NEXT:    [[COUNT7:%.*]] = phi i32 [ [[COUNT6]], [[STATE1_1_SI_UNFOLD_TRUE_JT1]] ], [ [[COUNT]], [[STATE2_2_SI_UNFOLD_FALSE_JT1]] ], [ [[COUNT]], [[FOR_BODY]] ]
++; CHECK-NEXT:    [[STATE_NEXT_JT1]] = phi i32 [ 1, [[FOR_BODY]] ], [ [[STATE2_1_SI_UNFOLD_PHI_JT1]], [[STATE2_2_SI_UNFOLD_FALSE_JT1]] ], [ [[DOTSI_UNFOLD_PHI3_JT1]], [[STATE1_1_SI_UNFOLD_TRUE_JT1]] ]
+ ; CHECK-NEXT:    [[INC_JT1]] = add nsw i32 [[COUNT7]], 1
+ ; CHECK-NEXT:    [[CMP_EXIT_JT1:%.*]] = icmp slt i32 [[INC_JT1]], [[NUM]]
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT_JT1]], label [[FOR_BODY_JT1]], label [[FOR_END]]
+ ; CHECK:       for.inc.jt3:
+-; CHECK-NEXT:    [[COUNT8:%.*]] = phi i32 [ [[COUNT6]], [[STATE1_2_SI_UNFOLD_FALSE_JT3]] ], [ [[COUNT5]], [[CASE2]] ]
+-; CHECK-NEXT:    [[STATE_NEXT_JT3]] = phi i32 [ [[DOTSI_UNFOLD_PHI2_JT3]], [[STATE1_2_SI_UNFOLD_FALSE_JT3]] ], [ 3, [[CASE2]] ]
++; CHECK-NEXT:    [[COUNT8:%.*]] = phi i32 [ [[COUNT6]], [[STATE1_2_SI_UNFOLD_FALSE_JT3]] ], [ [[COUNT]], [[CASE2]] ]
++; CHECK-NEXT:    [[STATE_NEXT_JT3]] = phi i32 [ 3, [[CASE2]] ], [ [[DOTSI_UNFOLD_PHI2_JT3]], [[STATE1_2_SI_UNFOLD_FALSE_JT3]] ]
+ ; CHECK-NEXT:    [[INC_JT3]] = add nsw i32 [[COUNT8]], 1
+ ; CHECK-NEXT:    [[CMP_EXIT_JT3:%.*]] = icmp slt i32 [[INC_JT3]], [[NUM]]
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT_JT3]], label [[FOR_BODY_JT3]], label [[FOR_END]]
+-; CHECK:       for.inc.jt2:
+-; CHECK-NEXT:    [[COUNT9:%.*]] = phi i32 [ [[COUNT5]], [[STATE2_2_SI_UNFOLD_FALSE_JT2]] ], [ [[COUNT6]], [[STATE1_1_SI_UNFOLD_FALSE_JT2]] ]
+-; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ [[DOTSI_UNFOLD_PHI4_JT2]], [[STATE1_1_SI_UNFOLD_FALSE_JT2]] ], [ [[STATE2_1_SI_UNFOLD_PHI_JT2]], [[STATE2_2_SI_UNFOLD_FALSE_JT2]] ]
+-; CHECK-NEXT:    [[INC_JT2]] = add nsw i32 [[COUNT9]], 1
+-; CHECK-NEXT:    [[CMP_EXIT_JT2:%.*]] = icmp slt i32 [[INC_JT2]], [[NUM]]
+-; CHECK-NEXT:    br i1 [[CMP_EXIT_JT2]], label [[FOR_BODY_JT2]], label [[FOR_END]]
+ ; CHECK:       for.end:
+ ; CHECK-NEXT:    ret i32 0
+ ;
+@@ -226,18 +227,18 @@
+ ; CHECK-NEXT:      i32 1, label [[CASE1:%.*]]
+ ; CHECK-NEXT:      i32 2, label [[CASE2:%.*]]
+ ; CHECK-NEXT:    ]
+-; CHECK:       for.body.jt4:
++; CHECK:       for.body.jt3:
+ ; CHECK-NEXT:    [[COUNT_JT3:%.*]] = phi i32 [ [[INC_JT3:%.*]], [[FOR_INC_JT3:%.*]] ]
+ ; CHECK-NEXT:    [[STATE_JT3:%.*]] = phi i32 [ [[STATE_NEXT_JT3:%.*]], [[FOR_INC_JT3]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC_JT1]]
+-; CHECK:       for.body.jt1:
+-; CHECK-NEXT:    [[COUNT_JT1:%.*]] = phi i32 [ [[INC_JT1:%.*]], [[FOR_INC_JT1]] ]
+-; CHECK-NEXT:    [[STATE_JT1:%.*]] = phi i32 [ [[STATE_NEXT_JT1:%.*]], [[FOR_INC_JT1]] ]
+-; CHECK-NEXT:    br label [[CASE1]]
+ ; CHECK:       for.body.jt2:
+ ; CHECK-NEXT:    [[COUNT_JT2:%.*]] = phi i32 [ [[INC_JT2:%.*]], [[FOR_INC_JT2:%.*]] ]
+ ; CHECK-NEXT:    [[STATE_JT2:%.*]] = phi i32 [ [[STATE_NEXT_JT2:%.*]], [[FOR_INC_JT2]] ]
+ ; CHECK-NEXT:    br label [[CASE2]]
++; CHECK:       for.body.jt1:
++; CHECK-NEXT:    [[COUNT_JT1:%.*]] = phi i32 [ [[INC_JT1:%.*]], [[FOR_INC_JT1]] ]
++; CHECK-NEXT:    [[STATE_JT1:%.*]] = phi i32 [ [[STATE_NEXT_JT1:%.*]], [[FOR_INC_JT1]] ]
++; CHECK-NEXT:    br label [[CASE1]]
+ ; CHECK:       case1:
+ ; CHECK-NEXT:    [[COUNT6:%.*]] = phi i32 [ [[COUNT_JT1]], [[FOR_BODY_JT1:%.*]] ], [ [[COUNT]], [[FOR_BODY]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC_JT2]]
+@@ -250,52 +251,53 @@
+ ; CHECK-NEXT:    br i1 [[CMP_3]], label [[SEL_1_SI_UNFOLD_TRUE_JT1:%.*]], label [[SEL_2_SI_UNFOLD_TRUE_JT3:%.*]]
+ ; CHECK:       sel.2.si.unfold.true:
+ ; CHECK-NEXT:    br i1 [[CMP_2]], label [[SEL_3_SI_UNFOLD_FALSE:%.*]], label [[SEL_2_SI_UNFOLD_FALSE_JT4:%.*]]
+-; CHECK:       sel.2.si.unfold.true.jt4:
++; CHECK:       sel.2.si.unfold.true.jt3:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI_JT3:%.*]] = phi i32 [ 3, [[CASE2]] ]
+-; CHECK-NEXT:    br i1 [[CMP_2]], label [[SEL_3_SI_UNFOLD_FALSE_JT3:%.*]], label [[SEL_2_SI_UNFOLD_FALSE_JT4]]
++; CHECK-NEXT:    br i1 [[CMP_2]], label [[SEL_3_SI_UNFOLD_FALSE_JT3:%.*]], label [[SEL_2_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       sel.2.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1:%.*]] = phi i32 [ 4, [[SEL_2_SI_UNFOLD_TRUE_JT3]] ]
+ ; CHECK-NEXT:    br label [[SEL_3_SI_UNFOLD_FALSE]]
+-; CHECK:       sel.2.si.unfold.false.jt4:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1_JT4:%.*]] = phi i32 [ 4, [[SEL_2_SI_UNFOLD_TRUE:%.*]] ], [ 4, [[SEL_2_SI_UNFOLD_TRUE_JT3]] ]
++; CHECK:       sel.2.si.unfold.false.jt3:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1_JT4:%.*]] = phi i32 [ 4, [[SEL_2_SI_UNFOLD_TRUE:%.*]] ]
+ ; CHECK-NEXT:    br label [[SEL_3_SI_UNFOLD_FALSE_JT3]]
+ ; CHECK:       sel.3.si.unfold.false:
+-; CHECK-NEXT:    [[SEL_2_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[SEL_2_SI_UNFOLD_FALSE:%.*]] ], [ poison, [[SEL_2_SI_UNFOLD_TRUE]] ]
++; CHECK-NEXT:    [[SEL_2_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[SEL_2_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI1]], [[SEL_2_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC]]
+-; CHECK:       sel.3.si.unfold.false.jt4:
+-; CHECK-NEXT:    [[SEL_2_SI_UNFOLD_PHI_JT3:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI1_JT4]], [[SEL_2_SI_UNFOLD_FALSE_JT4]] ], [ [[DOTSI_UNFOLD_PHI_JT3]], [[SEL_2_SI_UNFOLD_TRUE_JT3]] ]
++; CHECK:       sel.3.si.unfold.false.jt3:
++; CHECK-NEXT:    [[SEL_2_SI_UNFOLD_PHI_JT3:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI_JT3]], [[SEL_2_SI_UNFOLD_TRUE_JT3]] ], [ [[DOTSI_UNFOLD_PHI1_JT4]], [[SEL_2_SI_UNFOLD_FALSE_JT4]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC_JT3]]
+ ; CHECK:       sel.1.si.unfold.true:
+ ; CHECK-NEXT:    br i1 [[CMP_1]], label [[FOR_INC]], label [[SEL_1_SI_UNFOLD_FALSE_JT2:%.*]]
+ ; CHECK:       sel.1.si.unfold.true.jt1:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2_JT1:%.*]] = phi i32 [ 1, [[CASE2]] ]
+-; CHECK-NEXT:    br i1 [[CMP_1]], label [[FOR_INC_JT1]], label [[SEL_1_SI_UNFOLD_FALSE_JT2]]
++; CHECK-NEXT:    br i1 [[CMP_1]], label [[FOR_INC_JT1]], label [[SEL_1_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       sel.1.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI3:%.*]] = phi i32 [ 2, [[SEL_1_SI_UNFOLD_TRUE_JT1]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC]]
+ ; CHECK:       sel.1.si.unfold.false.jt2:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI3_JT2:%.*]] = phi i32 [ 2, [[SEL_1_SI_UNFOLD_TRUE:%.*]] ], [ 2, [[SEL_1_SI_UNFOLD_TRUE_JT1]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI3_JT2:%.*]] = phi i32 [ 2, [[SEL_1_SI_UNFOLD_TRUE:%.*]] ]
+ ; CHECK-NEXT:    br label [[FOR_INC_JT2]]
+ ; CHECK:       for.inc:
+-; CHECK-NEXT:    [[STATE_NEXT]] = phi i32 [ poison, [[SEL_1_SI_UNFOLD_FALSE:%.*]] ], [ poison, [[SEL_1_SI_UNFOLD_TRUE]] ], [ [[SEL_2_SI_UNFOLD_PHI]], [[SEL_3_SI_UNFOLD_FALSE]] ]
+-; CHECK-NEXT:    [[INC]] = add nsw i32 undef, 1
++; CHECK-NEXT:    [[STATE_NEXT]] = phi i32 [ [[SEL_2_SI_UNFOLD_PHI]], [[SEL_3_SI_UNFOLD_FALSE]] ], [ poison, [[SEL_1_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI3]], [[SEL_1_SI_UNFOLD_FALSE]] ]
++; CHECK-NEXT:    [[INC]] = add nsw i32 [[COUNT5]], 1
+ ; CHECK-NEXT:    [[CMP_EXIT:%.*]] = icmp slt i32 [[INC]], [[NUM:%.*]]
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT]], label [[FOR_BODY]], label [[FOR_END:%.*]]
+-; CHECK:       for.inc.jt4:
++; CHECK:       for.inc.jt3:
+ ; CHECK-NEXT:    [[STATE_NEXT_JT3]] = phi i32 [ [[SEL_2_SI_UNFOLD_PHI_JT3]], [[SEL_3_SI_UNFOLD_FALSE_JT3]] ]
+ ; CHECK-NEXT:    [[INC_JT3]] = add nsw i32 [[COUNT5]], 1
+ ; CHECK-NEXT:    [[CMP_EXIT_JT3:%.*]] = icmp slt i32 [[INC_JT3]], [[NUM]]
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT_JT3]], label [[FOR_BODY_JT3:%.*]], label [[FOR_END]]
++; CHECK:       for.inc.jt2:
++; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ 2, [[CASE1]] ], [ [[DOTSI_UNFOLD_PHI3_JT2]], [[SEL_1_SI_UNFOLD_FALSE_JT2]] ]
++; CHECK-NEXT:    [[INC_JT2]] = add nsw i32 [[COUNT6]], 1
++; CHECK-NEXT:    [[CMP_EXIT_JT2:%.*]] = icmp slt i32 [[INC_JT2]], [[NUM]]
++; CHECK-NEXT:    br i1 [[CMP_EXIT_JT2]], label [[FOR_BODY_JT2]], label [[FOR_END]]
+ ; CHECK:       for.inc.jt1:
+ ; CHECK-NEXT:    [[COUNT4:%.*]] = phi i32 [ [[COUNT_JT3]], [[FOR_BODY_JT3]] ], [ [[COUNT5]], [[SEL_1_SI_UNFOLD_TRUE_JT1]] ], [ [[COUNT]], [[FOR_BODY]] ]
+-; CHECK-NEXT:    [[STATE_NEXT_JT1]] = phi i32 [ 1, [[FOR_BODY_JT3]] ], [ 1, [[FOR_BODY]] ], [ [[DOTSI_UNFOLD_PHI2_JT1]], [[SEL_1_SI_UNFOLD_TRUE_JT1]] ]
++; CHECK-NEXT:    [[STATE_NEXT_JT1]] = phi i32 [ 1, [[FOR_BODY]] ], [ 1, [[FOR_BODY_JT3]] ], [ [[DOTSI_UNFOLD_PHI2_JT1]], [[SEL_1_SI_UNFOLD_TRUE_JT1]] ]
+ ; CHECK-NEXT:    [[INC_JT1]] = add nsw i32 [[COUNT4]], 1
+ ; CHECK-NEXT:    [[CMP_EXIT_JT1:%.*]] = icmp slt i32 [[INC_JT1]], [[NUM]]
+ ; CHECK-NEXT:    br i1 [[CMP_EXIT_JT1]], label [[FOR_BODY_JT1]], label [[FOR_END]]
+-; CHECK:       for.inc.jt2:
+-; CHECK-NEXT:    [[COUNT7:%.*]] = phi i32 [ [[COUNT6]], [[CASE1]] ], [ [[COUNT5]], [[SEL_1_SI_UNFOLD_FALSE_JT2]] ]
+-; CHECK-NEXT:    [[STATE_NEXT_JT2]] = phi i32 [ 2, [[CASE1]] ], [ [[DOTSI_UNFOLD_PHI3_JT2]], [[SEL_1_SI_UNFOLD_FALSE_JT2]] ]
+-; CHECK-NEXT:    [[INC_JT2]] = add nsw i32 [[COUNT7]], 1
+-; CHECK-NEXT:    [[CMP_EXIT_JT2:%.*]] = icmp slt i32 [[INC_JT2]], [[NUM]]
+-; CHECK-NEXT:    br i1 [[CMP_EXIT_JT2]], label [[FOR_BODY_JT2]], label [[FOR_END]]
+ ; CHECK:       for.end:
+ ; CHECK-NEXT:    ret i32 0
+ ;
+@@ -368,36 +370,38 @@
+ ; CHECK-NEXT:    br i1 [[TOBOOL_NOT:%.*]], label [[COND1_SI_UNFOLD_TRUE:%.*]], label [[COND_SI_UNFOLD_TRUE:%.*]]
+ ; CHECK:       cond.si.unfold.true:
+ ; CHECK-NEXT:    br i1 [[CMP]], label [[TOUNFOLD_SI_UNFOLD_FALSE1:%.*]], label [[COND_SI_UNFOLD_FALSE_JT0:%.*]]
+-; CHECK:       cond.si.unfold.true.jt1:
++; CHECK:       cond.si.unfold.true.jt2:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI:%.*]] = phi i32 [ 2, [[THEN]] ]
+-; CHECK-NEXT:    br i1 [[CMP]], label [[TOUNFOLD_SI_UNFOLD_FALSE_JT1:%.*]], label [[COND_SI_UNFOLD_FALSE_JT0]]
++; CHECK-NEXT:    br i1 [[CMP]], label [[TOUNFOLD_SI_UNFOLD_FALSE:%.*]], label [[COND_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       cond.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1:%.*]] = phi i32 [ 0, [[COND_SI_UNFOLD_TRUE]] ]
+ ; CHECK-NEXT:    br label [[TOUNFOLD_SI_UNFOLD_FALSE1]]
+ ; CHECK:       cond.si.unfold.false.jt0:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1_JT0:%.*]] = phi i32 [ 0, [[COND_SI_UNFOLD_TRUE1:%.*]] ], [ 0, [[COND_SI_UNFOLD_TRUE]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1_JT0:%.*]] = phi i32 [ 0, [[COND_SI_UNFOLD_TRUE1:%.*]] ]
+ ; CHECK-NEXT:    br label [[TOUNFOLD_SI_UNFOLD_FALSE_JT0:%.*]]
+ ; CHECK:       tounfold.si.unfold.false:
+-; CHECK-NEXT:    [[COND_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[COND_SI_UNFOLD_FALSE:%.*]] ], [ poison, [[COND_SI_UNFOLD_TRUE1]] ]
++; CHECK-NEXT:    [[COND_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[COND_SI_UNFOLD_TRUE1]] ], [ [[DOTSI_UNFOLD_PHI1]], [[COND_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    br label [[IF_END]]
+-; CHECK:       tounfold.si.unfold.false.jt1:
+-; CHECK-NEXT:    [[COND_SI_UNFOLD_PHI_JT1:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI]], [[COND_SI_UNFOLD_TRUE]] ]
+-; CHECK-NEXT:    br label [[IF_END_JT0:%.*]]
+ ; CHECK:       tounfold.si.unfold.false.jt0:
+ ; CHECK-NEXT:    [[COND_SI_UNFOLD_PHI_JT0:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI1_JT0]], [[COND_SI_UNFOLD_FALSE_JT0]] ]
++; CHECK-NEXT:    br label [[IF_END_JT0:%.*]]
++; CHECK:       tounfold.si.unfold.false.jt2:
++; CHECK-NEXT:    [[COND_SI_UNFOLD_PHI_JT2:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI]], [[COND_SI_UNFOLD_TRUE]] ]
+ ; CHECK-NEXT:    br label [[IF_END_JT2:%.*]]
+ ; CHECK:       cond1.si.unfold.true:
+ ; CHECK-NEXT:    br i1 [[CMP]], label [[IF_END]], label [[COND1_SI_UNFOLD_FALSE_JT1:%.*]]
+-; CHECK:       cond1.si.unfold.true.jt1:
++; CHECK:       cond1.si.unfold.true.jt2:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2:%.*]] = phi i32 [ 3, [[THEN]] ]
+-; CHECK-NEXT:    br i1 [[CMP]], label [[IF_END_JT0]], label [[COND1_SI_UNFOLD_FALSE_JT1]]
++; CHECK-NEXT:    br i1 [[CMP]], label [[IF_END_JT2]], label [[COND1_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       cond1.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI3:%.*]] = phi i32 [ 1, [[COND1_SI_UNFOLD_TRUE]] ]
+ ; CHECK-NEXT:    br label [[IF_END]]
+-; CHECK:       cond1.si.unfold.false.jt1:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI3_JT1:%.*]] = phi i32 [ 1, [[COND1_SI_UNFOLD_TRUE1:%.*]] ], [ 1, [[COND1_SI_UNFOLD_TRUE]] ]
+-; CHECK-NEXT:    br label [[IF_END_JT0]]
++; CHECK:       cond1.si.unfold.false.jt2:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI3_JT1:%.*]] = phi i32 [ 1, [[COND1_SI_UNFOLD_TRUE1:%.*]] ]
++; CHECK-NEXT:    br label [[IF_END_JT2]]
+ ; CHECK:       if.end:
+-; CHECK-NEXT:    [[UNFOLDED:%.*]] = phi i32 [ poison, [[COND1_SI_UNFOLD_FALSE:%.*]] ], [ [[FLAGS:%.*]], [[WHILE_COND]] ], [ [[COND_SI_UNFOLD_PHI]], [[TOUNFOLD_SI_UNFOLD_FALSE1]] ], [ poison, [[COND1_SI_UNFOLD_TRUE1]] ]
+-; CHECK-NEXT:    [[OTHER:%.*]] = phi i32 [ 0, [[COND1_SI_UNFOLD_FALSE]] ], [ [[FLAGS]], [[WHILE_COND]] ], [ 0, [[TOUNFOLD_SI_UNFOLD_FALSE1]] ], [ 0, [[COND1_SI_UNFOLD_TRUE1]] ]
++; CHECK-NEXT:    [[UNFOLDED:%.*]] = phi i32 [ [[FLAGS:%.*]], [[WHILE_COND]] ], [ [[COND_SI_UNFOLD_PHI]], [[TOUNFOLD_SI_UNFOLD_FALSE1]] ], [ poison, [[COND1_SI_UNFOLD_TRUE1]] ], [ [[DOTSI_UNFOLD_PHI3]], [[COND1_SI_UNFOLD_FALSE]] ]
++; CHECK-NEXT:    [[OTHER:%.*]] = phi i32 [ [[FLAGS]], [[WHILE_COND]] ], [ 0, [[TOUNFOLD_SI_UNFOLD_FALSE1]] ], [ 0, [[COND1_SI_UNFOLD_TRUE1]] ], [ 0, [[COND1_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    switch i32 [[UNFOLDED]], label [[UNREACHABLE:%.*]] [
+ ; CHECK-NEXT:      i32 0, label [[SW_BB:%.*]]
+ ; CHECK-NEXT:    ]
+@@ -405,9 +409,9 @@
+ ; CHECK-NEXT:    [[UNFOLDED_JT0:%.*]] = phi i32 [ [[COND_SI_UNFOLD_PHI_JT0]], [[TOUNFOLD_SI_UNFOLD_FALSE_JT0]] ]
+ ; CHECK-NEXT:    [[OTHER_JT0:%.*]] = phi i32 [ 0, [[TOUNFOLD_SI_UNFOLD_FALSE_JT0]] ]
+ ; CHECK-NEXT:    br label [[SW_BB]]
+-; CHECK:       if.end.jt1:
+-; CHECK-NEXT:    [[UNFOLDED_JT1:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI2]], [[COND1_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI3_JT1]], [[COND1_SI_UNFOLD_FALSE_JT1]] ], [ [[COND_SI_UNFOLD_PHI_JT1]], [[TOUNFOLD_SI_UNFOLD_FALSE_JT1]] ]
+-; CHECK-NEXT:    [[OTHER_JT1:%.*]] = phi i32 [ 0, [[COND1_SI_UNFOLD_TRUE]] ], [ 0, [[COND1_SI_UNFOLD_FALSE_JT1]] ], [ 0, [[TOUNFOLD_SI_UNFOLD_FALSE_JT1]] ]
++; CHECK:       if.end.jt2:
++; CHECK-NEXT:    [[UNFOLDED_JT2:%.*]] = phi i32 [ [[COND_SI_UNFOLD_PHI_JT2]], [[TOUNFOLD_SI_UNFOLD_FALSE]] ], [ [[DOTSI_UNFOLD_PHI2]], [[COND1_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI3_JT1]], [[COND1_SI_UNFOLD_FALSE_JT1]] ]
++; CHECK-NEXT:    [[OTHER_JT2:%.*]] = phi i32 [ 0, [[TOUNFOLD_SI_UNFOLD_FALSE]] ], [ 0, [[COND1_SI_UNFOLD_TRUE]] ], [ 0, [[COND1_SI_UNFOLD_FALSE_JT1]] ]
+ ; CHECK-NEXT:    br label [[UNREACHABLE]]
+ ; CHECK:       unreachable:
+ ; CHECK-NEXT:    unreachable
+@@ -452,47 +456,50 @@
+ ; CHECK-NEXT:    br i1 false, label [[SPEC_SELECT1_SI_UNFOLD_TRUE1:%.*]], label [[DOT5_SI_UNFOLD_FALSE_JT0:%.*]]
+ ; CHECK:       .5.si.unfold.true.jt0:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI1:%.*]] = phi i32 [ 0, [[IF_ELSE]] ]
+-; CHECK-NEXT:    br i1 false, label [[SPEC_SELECT1_SI_UNFOLD_TRUE:%.*]], label [[DOT5_SI_UNFOLD_FALSE_JT0]]
++; CHECK-NEXT:    br i1 false, label [[SPEC_SELECT1_SI_UNFOLD_TRUE:%.*]], label [[DOT5_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       .5.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2:%.*]] = phi i32 [ 0, [[DOT5_SI_UNFOLD_TRUE]] ]
+ ; CHECK-NEXT:    br label [[SPEC_SELECT1_SI_UNFOLD_TRUE1]]
+ ; CHECK:       .5.si.unfold.false.jt0:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2_JT0:%.*]] = phi i32 [ 0, [[DOT5_SI_UNFOLD_TRUE1:%.*]] ], [ 0, [[DOT5_SI_UNFOLD_TRUE]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI2_JT0:%.*]] = phi i32 [ 0, [[DOT5_SI_UNFOLD_TRUE1:%.*]] ]
+ ; CHECK-NEXT:    br label [[SPEC_SELECT1_SI_UNFOLD_TRUE]]
+ ; CHECK:       spec.select1.si.unfold.true:
+-; CHECK-NEXT:    [[DOT5_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[DOT5_SI_UNFOLD_FALSE:%.*]] ], [ poison, [[DOT5_SI_UNFOLD_TRUE1]] ]
++; CHECK-NEXT:    [[DOT5_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[DOT5_SI_UNFOLD_TRUE1]] ], [ [[DOTSI_UNFOLD_PHI2]], [[DOT5_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    br i1 false, label [[SPEC_SELECT_SI_UNFOLD_FALSE1:%.*]], label [[SPEC_SELECT1_SI_UNFOLD_FALSE_JT1:%.*]]
+ ; CHECK:       spec.select1.si.unfold.true.jt0:
+-; CHECK-NEXT:    [[DOT5_SI_UNFOLD_PHI_JT0:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI2_JT0]], [[DOT5_SI_UNFOLD_FALSE_JT0]] ], [ [[DOTSI_UNFOLD_PHI1]], [[DOT5_SI_UNFOLD_TRUE]] ]
+-; CHECK-NEXT:    br i1 false, label [[SPEC_SELECT_SI_UNFOLD_FALSE:%.*]], label [[SPEC_SELECT1_SI_UNFOLD_FALSE_JT1]]
++; CHECK-NEXT:    [[DOT5_SI_UNFOLD_PHI_JT0:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI1]], [[DOT5_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI2_JT0]], [[DOT5_SI_UNFOLD_FALSE_JT0]] ]
++; CHECK-NEXT:    br i1 false, label [[SPEC_SELECT_SI_UNFOLD_FALSE:%.*]], label [[SPEC_SELECT1_SI_UNFOLD_FALSE_JT0:%.*]]
+ ; CHECK:       spec.select1.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI:%.*]] = phi i32 [ 0, [[SPEC_SELECT1_SI_UNFOLD_TRUE]] ]
+ ; CHECK-NEXT:    br label [[SPEC_SELECT_SI_UNFOLD_FALSE1]]
+ ; CHECK:       spec.select1.si.unfold.false.jt0:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI_JT0:%.*]] = phi i32 [ 0, [[SPEC_SELECT1_SI_UNFOLD_TRUE1]] ], [ 0, [[SPEC_SELECT1_SI_UNFOLD_TRUE]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI_JT0:%.*]] = phi i32 [ 0, [[SPEC_SELECT1_SI_UNFOLD_TRUE1]] ]
+ ; CHECK-NEXT:    br label [[SPEC_SELECT_SI_UNFOLD_FALSE]]
+ ; CHECK:       spec.select.si.unfold.false:
+-; CHECK-NEXT:    [[SPEC_SELECT1_SI_UNFOLD_PHI:%.*]] = phi i32 [ poison, [[SPEC_SELECT1_SI_UNFOLD_FALSE:%.*]] ], [ [[DOT5_SI_UNFOLD_PHI]], [[SPEC_SELECT1_SI_UNFOLD_TRUE1]] ]
++; CHECK-NEXT:    [[SPEC_SELECT1_SI_UNFOLD_PHI:%.*]] = phi i32 [ [[DOT5_SI_UNFOLD_PHI]], [[SPEC_SELECT1_SI_UNFOLD_TRUE1]] ], [ [[DOTSI_UNFOLD_PHI]], [[SPEC_SELECT1_SI_UNFOLD_FALSE_JT0]] ]
+ ; CHECK-NEXT:    br label [[CLEANUP87:%.*]]
+ ; CHECK:       spec.select.si.unfold.false.jt0:
+-; CHECK-NEXT:    [[SPEC_SELECT1_SI_UNFOLD_PHI_JT0:%.*]] = phi i32 [ [[DOTSI_UNFOLD_PHI_JT0]], [[SPEC_SELECT1_SI_UNFOLD_FALSE_JT1]] ], [ [[DOT5_SI_UNFOLD_PHI_JT0]], [[SPEC_SELECT1_SI_UNFOLD_TRUE]] ]
++; CHECK-NEXT:    [[SPEC_SELECT1_SI_UNFOLD_PHI_JT0:%.*]] = phi i32 [ [[DOT5_SI_UNFOLD_PHI_JT0]], [[SPEC_SELECT1_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI_JT0]], [[SPEC_SELECT1_SI_UNFOLD_FALSE_JT1]] ]
+ ; CHECK-NEXT:    br label [[CLEANUP87_JT0]]
+ ; CHECK:       .6.si.unfold.true:
+ ; CHECK-NEXT:    br i1 false, label [[CLEANUP87]], label [[DOT6_SI_UNFOLD_FALSE_JT0:%.*]]
+ ; CHECK:       .6.si.unfold.true.jt0:
+ ; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI3:%.*]] = phi i32 [ 0, [[IF_ELSE]] ]
+-; CHECK-NEXT:    br i1 false, label [[CLEANUP87_JT0]], label [[DOT6_SI_UNFOLD_FALSE_JT0]]
++; CHECK-NEXT:    br i1 false, label [[CLEANUP87_JT0]], label [[DOT6_SI_UNFOLD_FALSE:%.*]]
+ ; CHECK:       .6.si.unfold.false:
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI4:%.*]] = phi i32 [ 0, [[DOT6_SI_UNFOLD_TRUE]] ]
+ ; CHECK-NEXT:    br label [[CLEANUP87]]
+ ; CHECK:       .6.si.unfold.false.jt0:
+-; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI4_JT0:%.*]] = phi i32 [ 0, [[DOT6_SI_UNFOLD_TRUE1:%.*]] ], [ 0, [[DOT6_SI_UNFOLD_TRUE]] ]
++; CHECK-NEXT:    [[DOTSI_UNFOLD_PHI4_JT0:%.*]] = phi i32 [ 0, [[DOT6_SI_UNFOLD_TRUE1:%.*]] ]
+ ; CHECK-NEXT:    br label [[CLEANUP87_JT0]]
+ ; CHECK:       cleanup87:
+-; CHECK-NEXT:    [[CLEANUP_DEST_SLOT_3:%.*]] = phi i32 [ poison, [[DOT6_SI_UNFOLD_TRUE1]] ], [ poison, [[DOT6_SI_UNFOLD_FALSE:%.*]] ], [ [[SPEC_SELECT1_SI_UNFOLD_PHI]], [[SPEC_SELECT_SI_UNFOLD_FALSE1]] ]
++; CHECK-NEXT:    [[CLEANUP_DEST_SLOT_3:%.*]] = phi i32 [ [[SPEC_SELECT1_SI_UNFOLD_PHI]], [[SPEC_SELECT_SI_UNFOLD_FALSE1]] ], [ poison, [[DOT6_SI_UNFOLD_TRUE1]] ], [ [[DOTSI_UNFOLD_PHI4]], [[DOT6_SI_UNFOLD_FALSE]] ]
+ ; CHECK-NEXT:    switch i32 [[CLEANUP_DEST_SLOT_3]], label [[FOR_COND48_BACKEDGE:%.*]] [
+ ; CHECK-NEXT:      i32 0, label [[FOR_COND48_BACKEDGE]]
+ ; CHECK-NEXT:      i32 1, label [[FOR_COND48_BACKEDGE]]
+ ; CHECK-NEXT:    ]
+ ; CHECK:       cleanup87.jt0:
+-; CHECK-NEXT:    [[CLEANUP_DEST_SLOT_3_JT0:%.*]] = phi i32 [ 0, [[FOR_COND48]] ], [ [[DOTSI_UNFOLD_PHI4_JT0]], [[DOT6_SI_UNFOLD_FALSE_JT0]] ], [ [[SPEC_SELECT1_SI_UNFOLD_PHI_JT0]], [[SPEC_SELECT_SI_UNFOLD_FALSE]] ], [ [[DOTSI_UNFOLD_PHI3]], [[DOT6_SI_UNFOLD_TRUE]] ]
++; CHECK-NEXT:    [[CLEANUP_DEST_SLOT_3_JT0:%.*]] = phi i32 [ 0, [[FOR_COND48]] ], [ [[SPEC_SELECT1_SI_UNFOLD_PHI_JT0]], [[SPEC_SELECT_SI_UNFOLD_FALSE]] ], [ [[DOTSI_UNFOLD_PHI3]], [[DOT6_SI_UNFOLD_TRUE]] ], [ [[DOTSI_UNFOLD_PHI4_JT0]], [[DOT6_SI_UNFOLD_FALSE_JT0]] ]
+ ; CHECK-NEXT:    br label [[FOR_COND48_BACKEDGE]]
+ ; CHECK:       for.cond48.backedge:
+ ; CHECK-NEXT:    br label [[FOR_COND48]]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/DFAJumpThreading/equivalent-states.ll b/llvm/test/Transforms/DFAJumpThreading/equivalent-states.ll
+--- a/llvm/test/Transforms/DFAJumpThreading/equivalent-states.ll
++++ b/llvm/test/Transforms/DFAJumpThreading/equivalent-states.ll
+@@ -233,7 +233,7 @@
+ ; CHECK-NEXT:    call void @do_something()
+ ; CHECK-NEXT:    br label [[SWITCH_BB]]
+ ; CHECK:       case2end.jt4:
+-; CHECK-NEXT:    [[PHI_CASE2_JT3]] = phi i32 [ 5, [[CASE2THEN3]] ], [ 4, [[CASE2THEN2]] ]
++; CHECK-NEXT:    [[PHI_CASE2_JT3]] = phi i32 [ 4, [[CASE2THEN2]] ], [ 5, [[CASE2THEN3]] ]
+ ; CHECK-NEXT:    call void @do_something()
+ ; CHECK-NEXT:    br label [[SWITCH_BB_JT3:%.*]]
+ ; CHECK:       case2end.jt2:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/IndVarSimplify/eliminate-backedge.ll b/llvm/test/Transforms/IndVarSimplify/eliminate-backedge.ll
+--- a/llvm/test/Transforms/IndVarSimplify/eliminate-backedge.ll
++++ b/llvm/test/Transforms/IndVarSimplify/eliminate-backedge.ll
+@@ -26,7 +26,7 @@
+ ; CHECK-NEXT:    %or.cond = select i1 %baz_ret, i1 true, i1 false
+ ; CHECK-NEXT:    br i1 %or.cond, label %loop, label %exit.loopexit
+ ; CHECK:       exit.loopexit:
+-; CHECK-NEXT:    %val.ph = phi i1 [ %result, %loop ], [ %baz_ret, %exiting_3 ], [ %bar_ret, %exiting_2 ], [ false, %exiting_1 ]
++; CHECK-NEXT:    %val.ph = phi i1 [ %baz_ret, %exiting_3 ], [ %bar_ret, %exiting_2 ], [ false, %exiting_1 ], [ %result, %loop ]
+ ; CHECK-NEXT:    br label %exit
+ ; CHECK:       exit:
+ ; CHECK-NEXT:    %val = phi i1 [ false, %entry ], [ %val.ph, %exit.loopexit ]
+@@ -102,7 +102,7 @@
+ ; CHECK-NEXT:    %or.cond = select i1 %baz_ret, i1 true, i1 false
+ ; CHECK-NEXT:    br i1 %or.cond, label %loop, label %exit.loopexit
+ ; CHECK:       exit.loopexit:
+-; CHECK-NEXT:    %val.ph = phi i1 [ %result, %loop ], [ %baz_ret, %exiting_3 ], [ %bar_ret, %exiting_2 ], [ false, %exiting_1 ]
++; CHECK-NEXT:    %val.ph = phi i1 [ %baz_ret, %exiting_3 ], [ %bar_ret, %exiting_2 ], [ false, %exiting_1 ], [ %result, %loop ]
+ ; CHECK-NEXT:    br label %exit
+ ; CHECK:       exit:
+ ; CHECK-NEXT:    %val = phi i1 [ false, %entry ], [ %val.ph, %exit.loopexit ]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/Inline/inline_invoke.ll b/llvm/test/Transforms/Inline/inline_invoke.ll
+--- a/llvm/test/Transforms/Inline/inline_invoke.ll
++++ b/llvm/test/Transforms/Inline/inline_invoke.ll
+@@ -194,8 +194,8 @@
+ ; CHECK:      ret void
  
--struct ExpandShapeOpInterface
--    : public ValueBoundsOpInterface::ExternalModel<ExpandShapeOpInterface,
--                                                   ExpandShapeOp> {
--  void populateBoundsForShapedValueDim(Operation *op, Value value, int64_t dim,
--                                       ValueBoundsConstraintSet &cstr) const {
--    auto expandOp = cast<ExpandShapeOp>(op);
--    assert(value == expandOp.getResult() && "invalid value");
--    cstr.bound(value)[dim] == expandOp.getMixedOutputShape()[dim];
--  }
--};
--
- struct ExtractSliceOpInterface
-     : public ValueBoundsOpInterface::ExternalModel<ExtractSliceOpInterface,
-                                                    ExtractSliceOp> {
-@@ -149,12 +117,8 @@
-     DialectRegistry &registry) {
-   registry.addExtension(+[](MLIRContext *ctx, tensor::TensorDialect *dialect) {
-     tensor::CastOp::attachInterface<tensor::CastOpInterface>(*ctx);
--    tensor::CollapseShapeOp::attachInterface<tensor::CollapseShapeOpInterface>(
--        *ctx);
-     tensor::DimOp::attachInterface<tensor::DimOpInterface>(*ctx);
-     tensor::EmptyOp::attachInterface<tensor::EmptyOpInterface>(*ctx);
--    tensor::ExpandShapeOp::attachInterface<tensor::ExpandShapeOpInterface>(
--        *ctx);
-     tensor::ExtractSliceOp::attachInterface<tensor::ExtractSliceOpInterface>(
-         *ctx);
-     tensor::PadOp::attachInterface<tensor::PadOpInterface>(*ctx);
-diff -ruN --strip-trailing-cr a/mlir/test/Dialect/OpenACC/acc-specialize-for-device.mlir b/mlir/test/Dialect/OpenACC/acc-specialize-for-device.mlir
---- a/mlir/test/Dialect/OpenACC/acc-specialize-for-device.mlir
-+++ b/mlir/test/Dialect/OpenACC/acc-specialize-for-device.mlir
-@@ -1,204 +0,0 @@
--// RUN: mlir-opt %s -acc-specialize-for-device | FileCheck %s
--
--//===----------------------------------------------------------------------===//
--// Data entry ops in specialized routines
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_0 func(@attach) seq
--// CHECK-LABEL: func.func @attach
--// CHECK-NOT:   acc.attach
--func.func @attach(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_0, <seq>, "attach">} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.attach varPtr(%arg0 : memref<i32>) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--acc.routine @acc_routine_1 func(@copyin) seq
--// CHECK-LABEL: func.func @copyin
--// CHECK-NOT:   acc.copyin
--func.func @copyin(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_1, <seq>, "copyin">} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.copyin varPtr(%arg0 : memref<i32>) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--acc.routine @acc_routine_2 func(@create) seq
--// CHECK-LABEL: func.func @create
--// CHECK-NOT:   acc.create
--func.func @create(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_2, <seq>, "create">} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.create varPtr(%arg0 : memref<i32>) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--acc.routine @acc_routine_3 func(@present) seq
--// CHECK-LABEL: func.func @present
--// CHECK-NOT:   acc.present
--func.func @present(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_3, <seq>, "present">} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.present varPtr(%arg0 : memref<i32>) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Data entry ops INSIDE compute constructs (non-specialized functions)
--//===----------------------------------------------------------------------===//
--
--// CHECK-LABEL: func.func @copyin_inside_parallel
--// CHECK:       acc.parallel
--// CHECK-NOT:   acc.copyin
--// CHECK:       acc.yield
--func.func @copyin_inside_parallel(%arg0 : memref<i32>) {
--  %c0 = arith.constant 0 : i32
--  acc.parallel {
--    %0 = acc.copyin varPtr(%arg0 : memref<i32>) -> memref<i32>
--    memref.store %c0, %0[] : memref<i32>
--    acc.yield
--  }
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Data entry ops OUTSIDE compute constructs should NOT be removed
--//===----------------------------------------------------------------------===//
--
--// CHECK-LABEL: func.func @copyin_outside_parallel
--// CHECK:       acc.copyin
--// CHECK:       acc.parallel
--func.func @copyin_outside_parallel(%arg0 : memref<i32>) {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.copyin varPtr(%arg0 : memref<i32>) -> memref<i32>
--  acc.parallel dataOperands(%0 : memref<i32>) {
--    memref.store %c0, %0[] : memref<i32>
--    acc.yield
--  }
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Data exit ops in specialized routines
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_copyout func(@copyout) worker
--// CHECK-LABEL: func.func @copyout
--// CHECK-NOT:   acc.copyout
--func.func @copyout(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_copyout, <worker>, "copyout">} {
--  %0 = acc.copyin varPtr(%arg0 : memref<i32>) -> memref<i32>
--  acc.copyout accPtr(%0 : memref<i32>) to varPtr(%arg0 : memref<i32>)
--  return
--}
--
--acc.routine @acc_routine_delete func(@delete) worker
--// CHECK-LABEL: func.func @delete
--// CHECK-NOT:   acc.delete
--func.func @delete(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_delete, <worker>, "delete">} {
--  %0 = acc.create varPtr(%arg0 : memref<i32>) -> memref<i32>
--  acc.delete accPtr(%0 : memref<i32>)
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Erase ops (unstructured data and runtime ops)
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_enter_data func(@enter_data) worker
--// CHECK-LABEL: func.func @enter_data
--// CHECK-NOT:   acc.enter_data
--func.func @enter_data(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_enter_data, <worker>, "enter_data">} {
--  %0 = acc.create varPtr(%arg0 : memref<i32>) -> memref<i32>
--  acc.enter_data dataOperands(%0 : memref<i32>)
--  return
--}
--
--acc.routine @acc_routine_init func(@init_op) worker
--// CHECK-LABEL: func.func @init_op
--// CHECK-NOT:   acc.init
--func.func @init_op() attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_init, <worker>, "init_op">} {
--  acc.init
--  return
--}
--
--acc.routine @acc_routine_wait func(@wait_op) worker
--// CHECK-LABEL: func.func @wait_op
--// CHECK-NOT:   acc.wait
--func.func @wait_op() attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_wait, <worker>, "wait_op">} {
--  acc.wait
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Region unwrap (structured data and compute constructs)
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_data func(@data_construct) worker
--// CHECK-LABEL: func.func @data_construct
--// CHECK-NOT:   acc.data
--// CHECK:       arith.constant 42
--func.func @data_construct(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_data, <worker>, "data_construct">} {
--  %d = acc.create varPtr(%arg0 : memref<i32>) -> memref<i32>
--  acc.data dataOperands(%d : memref<i32>) {
--    %c42 = arith.constant 42 : i32
--    memref.store %c42, %arg0[] : memref<i32>
--    acc.terminator
--  }
--  return
--}
--
--acc.routine @acc_routine_parallel func(@parallel_construct) worker
--// CHECK-LABEL: func.func @parallel_construct
--// CHECK-NOT:   acc.parallel
--// CHECK:       arith.constant 44
--func.func @parallel_construct(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_parallel, <worker>, "parallel_construct">} {
--  acc.parallel {
--    %c44 = arith.constant 44 : i32
--    memref.store %c44, %arg0[] : memref<i32>
--    acc.yield
--  }
--  return
--}
--
--acc.routine @acc_routine_serial func(@serial_construct) worker
--// CHECK-LABEL: func.func @serial_construct
--// CHECK-NOT:   acc.serial
--// CHECK:       arith.constant 45
--func.func @serial_construct(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_serial, <worker>, "serial_construct">} {
--  acc.serial {
--    %c45 = arith.constant 45 : i32
--    memref.store %c45, %arg0[] : memref<i32>
--    acc.yield
--  }
--  return
--}
--
--acc.routine @acc_routine_kernels func(@kernels_construct) worker
--// CHECK-LABEL: func.func @kernels_construct
--// CHECK-NOT:   acc.kernels
--// CHECK:       arith.constant 46
--func.func @kernels_construct(%arg0 : memref<i32>) attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_kernels, <worker>, "kernels_construct">} {
--  acc.kernels {
--    %c46 = arith.constant 46 : i32
--    memref.store %c46, %arg0[] : memref<i32>
--    acc.terminator
--  }
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Declare enter/exit strip in device routines
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_declare func(@dev_routine_declare) worker
--// CHECK-LABEL: func.func @dev_routine_declare
--// CHECK-NOT: acc.declare_enter
--// CHECK-NOT: acc.declare_exit
--func.func @dev_routine_declare() attributes {acc.specialized_routine = #acc.specialized_routine<@acc_routine_declare, <worker>, "dev_routine_declare">} {
--  %var = memref.alloca() : memref<f32>
--  %c = acc.create varPtr(%var : memref<f32>) -> memref<f32>
--  %t = acc.declare_enter dataOperands(%c : memref<f32>)
--  acc.declare_exit token(%t) dataOperands(%c : memref<f32>)
--  return
--}
-diff -ruN --strip-trailing-cr a/mlir/test/Dialect/OpenACC/acc-specialize-for-host-fallback.mlir b/mlir/test/Dialect/OpenACC/acc-specialize-for-host-fallback.mlir
---- a/mlir/test/Dialect/OpenACC/acc-specialize-for-host-fallback.mlir
-+++ b/mlir/test/Dialect/OpenACC/acc-specialize-for-host-fallback.mlir
-@@ -1,157 +0,0 @@
--// RUN: mlir-opt %s --pass-pipeline='builtin.module(func.func(acc-specialize-for-host{enable-host-fallback=true}))' | FileCheck %s
--
--//===----------------------------------------------------------------------===//
--// Data entry ops - replaced with var (host fallback)
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_create func(@create) seq
--// CHECK-LABEL: func.func @create
--// CHECK-NOT:   acc.create
--func.func @create(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_create]>} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.create varPtr(%arg0 : memref<i32>) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--acc.routine @acc_routine_copyin func(@copyin) seq
--// CHECK-LABEL: func.func @copyin
--// CHECK-NOT:   acc.copyin
--func.func @copyin(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_copyin]>} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.copyin varPtr(%arg0 : memref<i32>) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--acc.routine @acc_routine_present func(@present) seq
--// CHECK-LABEL: func.func @present
--// CHECK-NOT:   acc.present
--func.func @present(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_present]>} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.present varPtr(%arg0 : memref<i32>) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Data exit ops - erased (host fallback)
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_copyout func(@copyout) seq
--// CHECK-LABEL: func.func @copyout
--// CHECK-NOT:   acc.copyout
--func.func @copyout(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_copyout]>} {
--  %0 = acc.copyin varPtr(%arg0 : memref<i32>) -> memref<i32>
--  acc.copyout accPtr(%0 : memref<i32>) to varPtr(%arg0 : memref<i32>)
--  return
--}
--
--acc.routine @acc_routine_delete func(@delete) seq
--// CHECK-LABEL: func.func @delete
--// CHECK-NOT:   acc.delete
--func.func @delete(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_delete]>} {
--  %0 = acc.create varPtr(%arg0 : memref<i32>) -> memref<i32>
--  acc.delete accPtr(%0 : memref<i32>)
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Runtime operations - erased (host fallback)
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_init func(@init_op) seq
--// CHECK-LABEL: func.func @init_op
--// CHECK-NOT:   acc.init
--func.func @init_op() attributes {acc.routine_info = #acc.routine_info<[@acc_routine_init]>} {
--  acc.init
--  return
--}
--
--acc.routine @acc_routine_shutdown func(@shutdown_op) seq
--// CHECK-LABEL: func.func @shutdown_op
--// CHECK-NOT:   acc.shutdown
--func.func @shutdown_op() attributes {acc.routine_info = #acc.routine_info<[@acc_routine_shutdown]>} {
--  acc.shutdown
--  return
--}
--
--acc.routine @acc_routine_wait func(@wait_op) seq
--// CHECK-LABEL: func.func @wait_op
--// CHECK-NOT:   acc.wait
--func.func @wait_op() attributes {acc.routine_info = #acc.routine_info<[@acc_routine_wait]>} {
--  acc.wait
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Structured data and compute constructs - unwrap regions (host fallback)
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_data func(@data_construct) seq
--// CHECK-LABEL: func.func @data_construct
--// CHECK-NOT:   acc.data
--// CHECK:       arith.constant 42
--func.func @data_construct(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_data]>} {
--  %0 = acc.create varPtr(%arg0 : memref<i32>) -> memref<i32>
--  acc.data dataOperands(%0 : memref<i32>) {
--    %c42 = arith.constant 42 : i32
--    memref.store %c42, %arg0[] : memref<i32>
--    acc.terminator
--  }
--  return
--}
--
--acc.routine @acc_routine_parallel func(@parallel_construct) seq
--// CHECK-LABEL: func.func @parallel_construct
--// CHECK-NOT:   acc.parallel
--// CHECK:       arith.constant 44
--func.func @parallel_construct(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_parallel]>} {
--  acc.parallel {
--    %c44 = arith.constant 44 : i32
--    memref.store %c44, %arg0[] : memref<i32>
--    acc.yield
--  }
--  return
--}
--
--acc.routine @acc_routine_serial func(@serial_construct) seq
--// CHECK-LABEL: func.func @serial_construct
--// CHECK-NOT:   acc.serial
--// CHECK:       arith.constant 45
--func.func @serial_construct(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_serial]>} {
--  acc.serial {
--    %c45 = arith.constant 45 : i32
--    memref.store %c45, %arg0[] : memref<i32>
--    acc.yield
--  }
--  return
--}
--
--acc.routine @acc_routine_kernels func(@kernels_construct) seq
--// CHECK-LABEL: func.func @kernels_construct
--// CHECK-NOT:   acc.kernels
--// CHECK:       arith.constant 46
--func.func @kernels_construct(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_kernels]>} {
--  acc.kernels {
--    %c46 = arith.constant 46 : i32
--    memref.store %c46, %arg0[] : memref<i32>
--    acc.terminator
--  }
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Declare enter/exit - erased (host fallback)
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_declare func(@declare_enter_exit) seq
--// CHECK-LABEL: func.func @declare_enter_exit
--// CHECK-NOT:   acc.declare_enter
--// CHECK-NOT:   acc.declare_exit
--func.func @declare_enter_exit(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_declare]>} {
--  %0 = acc.create varPtr(%arg0 : memref<i32>) -> memref<i32>
--  %token = acc.declare_enter dataOperands(%0 : memref<i32>)
--  acc.declare_exit token(%token) dataOperands(%0 : memref<i32>)
--  return
--}
-diff -ruN --strip-trailing-cr a/mlir/test/Dialect/OpenACC/acc-specialize-for-host.mlir b/mlir/test/Dialect/OpenACC/acc-specialize-for-host.mlir
---- a/mlir/test/Dialect/OpenACC/acc-specialize-for-host.mlir
-+++ b/mlir/test/Dialect/OpenACC/acc-specialize-for-host.mlir
-@@ -1,404 +0,0 @@
--// RUN: mlir-opt %s -acc-specialize-for-host | FileCheck %s
--
--// Recipe definitions
--acc.private.recipe @privatization_memref_i32 : memref<i32> init {
--^bb0(%arg0: memref<i32>):
--  %0 = memref.alloca() : memref<i32>
--  acc.yield %0 : memref<i32>
--}
--
--acc.firstprivate.recipe @firstprivatization_memref_i32 : memref<i32> init {
--^bb0(%arg0: memref<i32>):
--  %0 = memref.alloca() : memref<i32>
--  acc.yield %0 : memref<i32>
--} copy {
--^bb0(%arg0: memref<i32>, %arg1: memref<i32>):
--  %0 = memref.load %arg0[] : memref<i32>
--  memref.store %0, %arg1[] : memref<i32>
--  acc.terminator
--}
--
--acc.reduction.recipe @reduction_add_memref_i32 : memref<i32> reduction_operator <add> init {
--^bb0(%arg0: memref<i32>):
--  %c0_i32 = arith.constant 0 : i32
--  %0 = memref.alloca() : memref<i32>
--  memref.store %c0_i32, %0[] : memref<i32>
--  acc.yield %0 : memref<i32>
--} combiner {
--^bb0(%arg0: memref<i32>, %arg1: memref<i32>):
--  %0 = memref.load %arg0[] : memref<i32>
--  %1 = memref.load %arg1[] : memref<i32>
--  %2 = arith.addi %0, %1 : i32
--  memref.store %2, %arg0[] : memref<i32>
--  acc.yield %arg0 : memref<i32>
--}
--
--//===----------------------------------------------------------------------===//
--// Orphan data entry ops - replaced with var
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_private func(@private) seq
--// CHECK-LABEL: func.func @private
--// CHECK-NOT:   acc.private
--func.func @private(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_private]>} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.private varPtr(%arg0 : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--acc.routine @acc_routine_cache func(@cache) seq
--// CHECK-LABEL: func.func @cache
--// CHECK-NOT:   acc.cache
--func.func @cache(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_cache]>} {
--  %c0 = arith.constant 0 : i32
--  %0 = acc.cache varPtr(%arg0 : memref<i32>) -> memref<i32>
--  memref.store %c0, %0[] : memref<i32>
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Orphan atomic operations - converted to load/store
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_atomic func(@orphan_atomic_update) seq
--// CHECK-LABEL: func.func @orphan_atomic_update
--// CHECK-NOT:   acc.atomic.update
--// CHECK:       memref.load
--// CHECK:       arith.addi
--// CHECK:       memref.store
--func.func @orphan_atomic_update(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_atomic]>} {
--  acc.atomic.update %arg0 : memref<i32> {
--  ^bb0(%arg1: i32):
--    %c1 = arith.constant 1 : i32
--    %1 = arith.addi %arg1, %c1 : i32
--    acc.yield %1 : i32
--  }
--  return
--}
--
--acc.routine @acc_routine_atomic_read func(@orphan_atomic_read) seq
--// CHECK-LABEL: func.func @orphan_atomic_read
--// CHECK-NOT:   acc.atomic.read
--// CHECK:       memref.copy %arg0, %arg1
--func.func @orphan_atomic_read(%arg0 : memref<i32>, %arg1 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_atomic_read]>} {
--  acc.atomic.read %arg1 = %arg0 : memref<i32>, memref<i32>, i32
--  return
--}
--
--acc.routine @acc_routine_atomic_write func(@orphan_atomic_write) seq
--// CHECK-LABEL: func.func @orphan_atomic_write
--// CHECK-NOT:   acc.atomic.write
--// CHECK:       memref.store %arg1, %arg0[]
--func.func @orphan_atomic_write(%arg0 : memref<i32>, %arg1 : i32) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_atomic_write]>} {
--  acc.atomic.write %arg0 = %arg1 : memref<i32>, i32
--  return
--}
--
--acc.routine @acc_routine_atomic_capture func(@orphan_atomic_capture) seq
--// CHECK-LABEL: func.func @orphan_atomic_capture
--// CHECK-NOT:   acc.atomic.capture
--// CHECK:       memref.copy %arg0, %arg1
--// CHECK:       [[LOAD:%.*]] = memref.load %arg0[]
--// CHECK:       [[INC:%.*]] = arith.addi [[LOAD]]
--// CHECK:       memref.store [[INC]], %arg0[]
--func.func @orphan_atomic_capture(%arg0 : memref<i32>, %arg1 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_atomic_capture]>} {
--  %c1_i32 = arith.constant 1 : i32
--  acc.atomic.capture {
--    acc.atomic.read %arg1 = %arg0 : memref<i32>, memref<i32>, i32
--    acc.atomic.update %arg0 : memref<i32> {
--    ^bb0(%v: i32):
--      %r = arith.addi %v, %c1_i32 : i32
--      acc.yield %r : i32
--    }
--    acc.terminator
--  }
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Negative tests - ops that should NOT be converted
--//===----------------------------------------------------------------------===//
--
--// acc.private attached to acc.parallel should NOT be removed
--acc.routine @acc_routine_private_parallel func(@private_attached_to_parallel) seq
--// CHECK-LABEL: func.func @private_attached_to_parallel
--// CHECK:       acc.private
--// CHECK:       acc.parallel
--func.func @private_attached_to_parallel(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_private_parallel]>} {
--  %0 = acc.private varPtr(%arg0 : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--  acc.parallel private(%0 : memref<i32>) {
--    %c1 = arith.constant 1 : i32
--    memref.store %c1, %0[] : memref<i32>
--    acc.yield
--  }
--  return
--}
--
--// acc.atomic.update inside acc.parallel should NOT be converted
--acc.routine @acc_routine_atomic_parallel func(@atomic_inside_parallel) seq
--// CHECK-LABEL: func.func @atomic_inside_parallel
--// CHECK:       acc.parallel
--// CHECK:       acc.atomic.update
--func.func @atomic_inside_parallel(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_atomic_parallel]>} {
--  acc.parallel {
--    acc.atomic.update %arg0 : memref<i32> {
--    ^bb0(%arg1: i32):
--      %c1 = arith.constant 1 : i32
--      %1 = arith.addi %arg1, %c1 : i32
--      acc.yield %1 : i32
--    }
--    acc.yield
--  }
--  return
--}
--
--// acc.loop inside acc.parallel should NOT be converted
--acc.routine @acc_routine_loop_parallel func(@loop_inside_parallel) seq
--// CHECK-LABEL: func.func @loop_inside_parallel
--// CHECK:       acc.parallel
--// CHECK:       acc.loop
--func.func @loop_inside_parallel(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_loop_parallel]>} {
--  %c0 = arith.constant 0 : index
--  %c10 = arith.constant 10 : index
--  %c1 = arith.constant 1 : index
--  acc.parallel {
--    acc.loop control(%iv : index) = (%c0 : index) to (%c10 : index) step (%c1 : index) {
--      %c5 = arith.constant 5 : i32
--      memref.store %c5, %arg0[] : memref<i32>
--      acc.yield
--    } attributes {inclusiveUpperbound = array<i1: true>, seq = [#acc.device_type<none>]}
--    acc.yield
--  }
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Positive tests - orphan ops attached to orphan loop (both should convert)
--//===----------------------------------------------------------------------===//
--
--// acc.private attached to orphan acc.loop - BOTH should be removed
--acc.routine @acc_routine_private_loop func(@private_attached_to_loop) seq
--// CHECK-LABEL: func.func @private_attached_to_loop
--// CHECK-NOT:   acc.private
--// CHECK-NOT:   acc.loop
--// CHECK:       scf.for
--func.func @private_attached_to_loop(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_private_loop]>} {
--  %c0 = arith.constant 0 : i32
--  %c10 = arith.constant 10 : i32
--  %c1 = arith.constant 1 : i32
--  %0 = acc.private varPtr(%arg0 : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--  acc.loop private(%0 : memref<i32>) control(%iv : i32) = (%c0 : i32) to (%c10 : i32) step (%c1 : i32) {
--    %c1_i32 = arith.constant 1 : i32
--    memref.store %c1_i32, %0[] : memref<i32>
--    acc.yield
--  } attributes {inclusiveUpperbound = array<i1: true>, seq = [#acc.device_type<none>]}
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Orphan loop conversion tests
--//===----------------------------------------------------------------------===//
--
--// Orphan acc.loop should be converted to scf.for
--acc.routine @acc_routine_loop func(@orphan_loop) seq
--// CHECK-LABEL: func.func @orphan_loop
--// CHECK-NOT:   acc.loop
--// CHECK:       scf.for
--func.func @orphan_loop(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_loop]>} {
--  %c0 = arith.constant 0 : i32
--  %c10 = arith.constant 10 : i32
--  %c1 = arith.constant 1 : i32
--  acc.loop control(%iv : i32) = (%c0 : i32) to (%c10 : i32) step (%c1 : i32) {
--    memref.store %iv, %arg0[] : memref<i32>
--    acc.yield
--  } attributes {inclusiveUpperbound = array<i1: true>, seq = [#acc.device_type<none>]}
--  return
--}
--
--// Nested orphan acc.loop should be converted to nested scf.for
--acc.routine @acc_routine_nested_loop func(@nested_orphan_loop) seq
--// CHECK-LABEL: func.func @nested_orphan_loop
--// CHECK-NOT:   acc.loop
--// CHECK:       scf.for
--// CHECK:       scf.for
--func.func @nested_orphan_loop(%arg0 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_nested_loop]>} {
--  %c0 = arith.constant 0 : i32
--  %c10 = arith.constant 10 : i32
--  %c1 = arith.constant 1 : i32
--  acc.loop control(%iv0 : i32, %iv1 : i32) = (%c0, %c0 : i32, i32) to (%c10, %c10 : i32, i32) step (%c1, %c1 : i32, i32) {
--    %sum = arith.addi %iv0, %iv1 : i32
--    memref.store %sum, %arg0[] : memref<i32>
--    acc.yield
--  } attributes {inclusiveUpperbound = array<i1: true, true>, seq = [#acc.device_type<none>]}
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Unstructured orphan loop - converted to scf.execute_region
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_unstructured func(@orphan_unstructured_loop) seq
--// CHECK-LABEL: func.func @orphan_unstructured_loop
--// CHECK-NOT:   acc.loop
--// CHECK-NOT:   acc.private
--// CHECK:       scf.execute_region
--// CHECK:       ^bb{{[0-9]+}}:
--// CHECK:       cf.cond_br
--// CHECK:       scf.yield
--func.func @orphan_unstructured_loop(%arg0 : memref<32xi32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_unstructured]>} {
--  %c32_i32 = arith.constant 32 : i32
--  %c2_i32 = arith.constant 2 : i32
--  %c0_i32 = arith.constant 0 : i32
--  %c1_i32 = arith.constant 1 : i32
--  %iter_var = memref.alloca() : memref<i32>
--  %priv = acc.private varPtr(%iter_var : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--  acc.loop private(%priv : memref<i32>) {
--    %limit = memref.alloca() : memref<i32>
--    memref.store %c32_i32, %limit[] : memref<i32>
--    memref.store %c1_i32, %priv[] : memref<i32>
--    cf.br ^bb1
--  ^bb1:
--    %count = memref.load %limit[] : memref<i32>
--    %cond = arith.cmpi sgt, %count, %c0_i32 : i32
--    cf.cond_br %cond, ^bb2, ^bb3
--  ^bb2:
--    %idx = memref.load %priv[] : memref<i32>
--    %idx_idx = arith.index_cast %idx : i32 to index
--    %val = memref.load %arg0[%idx_idx] : memref<32xi32>
--    %new_val = arith.divsi %val, %c2_i32 : i32
--    memref.store %new_val, %arg0[%idx_idx] : memref<32xi32>
--    %new_count = arith.subi %count, %c1_i32 : i32
--    memref.store %new_count, %limit[] : memref<i32>
--    %new_idx = arith.addi %idx, %c1_i32 : i32
--    memref.store %new_idx, %priv[] : memref<i32>
--    cf.br ^bb1
--  ^bb3:
--    acc.yield
--  } attributes {independent = [#acc.device_type<none>], unstructured}
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Orphan loop with reduction - both converted
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_loop_reduction func(@orphan_loop_with_reduction) seq
--// CHECK-LABEL: func.func @orphan_loop_with_reduction
--// CHECK-NOT:   acc.loop
--// CHECK-NOT:   acc.reduction
--// CHECK-NOT:   acc.private
--// CHECK:       scf.for
--func.func @orphan_loop_with_reduction(%arg0 : memref<i32>, %arg1 : memref<100xi32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_loop_reduction]>} {
--  %c100_i32 = arith.constant 100 : i32
--  %c1_i32 = arith.constant 1 : i32
--  %iter_var = memref.alloca() : memref<i32>
--  %red = acc.reduction varPtr(%arg0 : memref<i32>) recipe(@reduction_add_memref_i32) -> memref<i32>
--  %priv = acc.private varPtr(%iter_var : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--  acc.loop vector private(%priv : memref<i32>) reduction(%red : memref<i32>) control(%arg2 : i32) = (%c1_i32 : i32) to (%c100_i32 : i32) step (%c1_i32 : i32) {
--    memref.store %arg2, %priv[] : memref<i32>
--    %idx = memref.load %priv[] : memref<i32>
--    %idx_cast = arith.index_cast %idx : i32 to index
--    %elem = memref.load %arg1[%idx_cast] : memref<100xi32>
--    %r_val = memref.load %arg0[] : memref<i32>
--    %new_r = arith.addi %r_val, %elem : i32
--    memref.store %new_r, %arg0[] : memref<i32>
--    acc.yield
--  } attributes {inclusiveUpperbound = array<i1: true>, independent = [#acc.device_type<none>]}
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Orphan loop with variable bounds
--//===----------------------------------------------------------------------===//
--
--acc.routine @acc_routine_var_bounds func(@orphan_loop_variable_bounds) seq
--// CHECK-LABEL: func.func @orphan_loop_variable_bounds
--// CHECK-NOT:   acc.loop
--// CHECK:       [[LB:%.*]] = memref.load %arg0[]
--// CHECK:       [[UB:%.*]] = memref.load %arg1[]
--// CHECK:       scf.for
--func.func @orphan_loop_variable_bounds(%arg0 : memref<i32>, %arg1 : memref<i32>, %arg2 : memref<i32>) attributes {acc.routine_info = #acc.routine_info<[@acc_routine_var_bounds]>} {
--  %c1 = arith.constant 1 : i32
--  %lb = memref.load %arg0[] : memref<i32>
--  %ub = memref.load %arg1[] : memref<i32>
--  acc.loop vector control(%iv : i32) = (%lb : i32) to (%ub : i32) step (%c1 : i32) {
--    memref.store %iv, %arg2[] : memref<i32>
--    acc.yield
--  } attributes {inclusiveUpperbound = array<i1: true>, independent = [#acc.device_type<none>]}
--  return
--}
--
--//===----------------------------------------------------------------------===//
--// Orphan loop between compute regions - only orphan converted
--//===----------------------------------------------------------------------===//
--
--acc.reduction.recipe @reduction_mul_memref_i32 : memref<i32> reduction_operator <mul> init {
--^bb0(%arg0: memref<i32>):
--  %c1_i32 = arith.constant 1 : i32
--  %0 = memref.alloca() : memref<i32>
--  memref.store %c1_i32, %0[] : memref<i32>
--  acc.yield %0 : memref<i32>
--} combiner {
--^bb0(%arg0: memref<i32>, %arg1: memref<i32>):
--  %0 = memref.load %arg0[] : memref<i32>
--  %1 = memref.load %arg1[] : memref<i32>
--  %2 = arith.muli %0, %1 : i32
--  memref.store %2, %arg0[] : memref<i32>
--  acc.yield %arg0 : memref<i32>
--}
--
--// Orphan loop sandwiched between compute regions - only orphan should convert
--// CHECK-LABEL: func.func @orphan_between_compute_regions
--// CHECK:       acc.parallel
--// CHECK:       acc.yield
--// CHECK-NOT:   acc.private varPtr
--// CHECK-NOT:   acc.reduction varPtr
--// CHECK:       scf.for
--// CHECK:       acc.parallel
--func.func @orphan_between_compute_regions(%arg0 : memref<i32>, %arg1 : memref<8xi32>, %arg2 : memref<i32>) {
--  %c2_i32 = arith.constant 2 : i32
--  %c8_i32 = arith.constant 8 : i32
--  %c1_i32 = arith.constant 1 : i32
--  %iter_var = memref.alloca() : memref<i32>
--
--  // First compute region - should NOT be converted
--  acc.parallel combined(loop) {
--    %priv1 = acc.private varPtr(%iter_var : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--    acc.loop combined(parallel) private(%priv1 : memref<i32>) control(%iv : i32) = (%c1_i32 : i32) to (%c8_i32 : i32) step (%c1_i32 : i32) {
--      memref.store %iv, %priv1[] : memref<i32>
--      %idx = arith.index_cast %iv : i32 to index
--      memref.store %c1_i32, %arg1[%idx] : memref<8xi32>
--      acc.yield
--    } attributes {inclusiveUpperbound = array<i1: true>, independent = [#acc.device_type<none>]}
--    acc.yield
--  }
--
--  // Orphan loop - SHOULD be converted
--  %priv_orphan = acc.private varPtr(%arg2 : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--  %red_orphan = acc.reduction varPtr(%arg0 : memref<i32>) recipe(@reduction_mul_memref_i32) -> memref<i32>
--  %priv_iv = acc.private varPtr(%iter_var : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--  acc.loop private(%priv_orphan, %priv_iv : memref<i32>, memref<i32>) reduction(%red_orphan : memref<i32>) control(%iv : i32) = (%c1_i32 : i32) to (%c8_i32 : i32) step (%c1_i32 : i32) {
--    memref.store %iv, %priv_iv[] : memref<i32>
--    %idx = arith.index_cast %iv : i32 to index
--    %elem = memref.load %arg1[%idx] : memref<8xi32>
--    memref.store %elem, %priv_orphan[] : memref<i32>
--    %t = memref.load %priv_orphan[] : memref<i32>
--    %mul = arith.muli %t, %c2_i32 : i32
--    memref.store %mul, %arg0[] : memref<i32>
--    acc.yield
--  } attributes {inclusiveUpperbound = array<i1: true>, independent = [#acc.device_type<none>]}
--
--  // Second compute region - should NOT be converted
--  acc.parallel combined(loop) {
--    %priv2 = acc.private varPtr(%iter_var : memref<i32>) recipe(@privatization_memref_i32) -> memref<i32>
--    acc.loop combined(parallel) private(%priv2 : memref<i32>) control(%iv : i32) = (%c1_i32 : i32) to (%c8_i32 : i32) step (%c1_i32 : i32) {
--      memref.store %iv, %priv2[] : memref<i32>
--      %idx = arith.index_cast %iv : i32 to index
--      memref.store %iv, %arg1[%idx] : memref<8xi32>
--      acc.yield
--    } attributes {inclusiveUpperbound = array<i1: true>, independent = [#acc.device_type<none>]}
--    acc.yield
--  }
--  return
--}
-diff -ruN --strip-trailing-cr a/mlir/test/Dialect/Tensor/value-bounds-op-interface-impl.mlir b/mlir/test/Dialect/Tensor/value-bounds-op-interface-impl.mlir
---- a/mlir/test/Dialect/Tensor/value-bounds-op-interface-impl.mlir
-+++ b/mlir/test/Dialect/Tensor/value-bounds-op-interface-impl.mlir
-@@ -230,35 +230,3 @@
-   %1 = "test.reify_bound"(%padded) {dim = 1, constant} : (tensor<1x?x64xf32>) -> (index)
-   return
- }
--
--// -----
--
--//       CHECK: #[[$MAP:.+]] = affine_map<()[s0] -> (s0 * 2)>
--// CHECK-LABEL: func @tensor_collapse(
--//  CHECK-SAME:     %[[sz0:.*]]: index
--//   CHECK-DAG:   %[[c2:.*]] = arith.constant 2 : index
--//   CHECK-DAG:   %[[c12:.*]] = arith.constant 12 : index
--//       CHECK:   %[[dim:.*]] = tensor.dim %{{.*}}, %[[c2]] : tensor<3x4x?x2xf32>
--//       CHECK:   %[[mul:.*]] = affine.apply #[[$MAP]]()[%[[dim]]]
--//       CHECK:   return %[[c12]], %[[mul]]
--func.func @tensor_collapse(%sz0: index) -> (index, index) {
--  %0 = tensor.empty(%sz0) : tensor<3x4x?x2xf32>
--  %1 = tensor.collapse_shape %0 [[0, 1], [2, 3]] : tensor<3x4x?x2xf32> into tensor<12x?xf32>
--  %2 = "test.reify_bound"(%1) {dim = 0} : (tensor<12x?xf32>) -> (index)
--  %3 = "test.reify_bound"(%1) {dim = 1} : (tensor<12x?xf32>) -> (index)
--  return %2, %3 : index, index
--}
--
--// -----
--
--// CHECK-LABEL: func @tensor_expand(
--//  CHECK-SAME:     %[[t:[a-zA-Z0-9]+]]: tensor<?xf32>
--//  CHECK-SAME:     %[[sz:[a-zA-Z0-9]+]]: index
--//       CHECK:   %[[c4:.*]] = arith.constant 4 : index
--//       CHECK:   return %[[c4]], %[[sz]]
--func.func @tensor_expand(%t: tensor<?xf32>, %sz: index) -> (index, index) {
--  %0 = tensor.expand_shape %t [[0, 1]] output_shape [4, %sz] : tensor<?xf32> into tensor<4x?xf32>
--  %1 = "test.reify_bound"(%0) {dim = 0} : (tensor<4x?xf32>) -> (index)
--  %2 = "test.reify_bound"(%0) {dim = 1} : (tensor<4x?xf32>) -> (index)
--  return %1, %2 : index, index
--}
+ ; CHECK:    [[LPAD]]:
+-; CHECK-NEXT: [[X:%.*]] = phi i32 [ 0, {{%.*}} ], [ 1, {{%.*}} ], [ 0, %entry ], [ 1, %cont ]
+-; CHECK-NEXT: [[Y:%.*]] = phi i32 [ 1, {{%.*}} ], [ 4, {{%.*}} ], [ 1, %entry ], [ 4, %cont ]
++; CHECK-NEXT: [[X:%.*]] = phi i32 [ 0, %entry ], [ 0, {{%.*}} ], [ 1, %cont ], [ 1, {{%.*}} ]
++; CHECK-NEXT: [[Y:%.*]] = phi i32 [ 1, %entry ], [ 1, {{%.*}} ], [ 4, %cont ], [ 4, {{%.*}} ]
+ ; CHECK-NEXT: [[LPADVAL:%.*]] = landingpad { ptr, i32 }
+ ; CHECK-NEXT:   catch ptr @_ZTIi
+ ; CHECK-NEXT: br label %[[LPAD_JOIN2]]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/JumpThreading/ddt-crash.ll b/llvm/test/Transforms/JumpThreading/ddt-crash.ll
+--- a/llvm/test/Transforms/JumpThreading/ddt-crash.ll
++++ b/llvm/test/Transforms/JumpThreading/ddt-crash.ll
+@@ -140,7 +140,7 @@
+ ; CHECK-NEXT:    [[TMP40:%.*]] = load ptr, ptr @global, align 8
+ ; CHECK-NEXT:    br label [[BB41_THREAD]]
+ ; CHECK:       bb41.thread11:
+-; CHECK-NEXT:    [[TMP0:%.*]] = phi ptr [ undef, [[BB27]] ], [ undef, [[BB41]] ], [ undef, [[BB25]] ], [ undef, [[BB31]] ], [ undef, [[BB37]] ]
++; CHECK-NEXT:    [[TMP0:%.*]] = phi ptr [ undef, [[BB41]] ], [ undef, [[BB25]] ], [ undef, [[BB31]] ], [ undef, [[BB27]] ], [ undef, [[BB37]] ]
+ ; CHECK-NEXT:    ret void
+ ;
+ bb:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/JumpThreading/fold-not-thread.ll b/llvm/test/Transforms/JumpThreading/fold-not-thread.ll
+--- a/llvm/test/Transforms/JumpThreading/fold-not-thread.ll
++++ b/llvm/test/Transforms/JumpThreading/fold-not-thread.ll
+@@ -11,7 +11,7 @@
+ ; CHECK-LABEL: define void @test_br_folding_not_threading_update_phi(
+ ; CHECK: br label %L1
+ ; Make sure we update the phi node properly here, i.e. we only have 2 predecessors, entry and L0
+-; CHECK: %res.0 = phi i32 [ 1, %entry ], [ 0, %L0 ]
++; CHECK: %res.0 = phi i32 [ 0, %L0 ], [ 1, %entry ]
+ define void @test_br_folding_not_threading_update_phi(i32 %val) nounwind {
+ entry:
+   %cmp = icmp eq i32 %val, 32
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/JumpThreading/invalidate-lvi.ll b/llvm/test/Transforms/JumpThreading/invalidate-lvi.ll
+--- a/llvm/test/Transforms/JumpThreading/invalidate-lvi.ll
++++ b/llvm/test/Transforms/JumpThreading/invalidate-lvi.ll
+@@ -20,7 +20,7 @@
+ ; CHECK-NEXT:    store i64 0, ptr [[V]], align 8
+ ; CHECK-NEXT:    br label [[BB4:%.*]]
+ ; CHECK:       bb2:
+-; CHECK-NEXT:    [[L2:%.*]] = phi i64 [ [[L1]], [[START:%.*]] ], [ [[L1]], [[BB0]] ]
++; CHECK-NEXT:    [[L2:%.*]] = phi i64 [ [[L1]], [[BB0]] ], [ [[L1]], [[START:%.*]] ]
+ ; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i64 [[L2]], 2
+ ; CHECK-NEXT:    br i1 [[TMP1]], label [[BB3:%.*]], label [[BB4]]
+ ; CHECK:       bb3:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopSimplifyCFG/phi_with_duplicating_inputs.ll b/llvm/test/Transforms/LoopSimplifyCFG/phi_with_duplicating_inputs.ll
+--- a/llvm/test/Transforms/LoopSimplifyCFG/phi_with_duplicating_inputs.ll
++++ b/llvm/test/Transforms/LoopSimplifyCFG/phi_with_duplicating_inputs.ll
+@@ -20,7 +20,7 @@
+ ; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i16 [[TMP0]], 0
+ ; CHECK-NEXT:    br label [[FOR_INC]]
+ ; CHECK:       for.inc:
+-; CHECK-NEXT:    [[C_1:%.*]] = phi i16 [ 1, [[FOR_COND]] ], [ 2, [[IF_THEN]] ]
++; CHECK-NEXT:    [[C_1:%.*]] = phi i16 [ 2, [[IF_THEN]] ], [ 1, [[FOR_COND]] ]
+ ; CHECK-NEXT:    br label [[FOR_COND]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopUnroll/AArch64/apple-unrolling-multi-exit.ll b/llvm/test/Transforms/LoopUnroll/AArch64/apple-unrolling-multi-exit.ll
+--- a/llvm/test/Transforms/LoopUnroll/AArch64/apple-unrolling-multi-exit.ll
++++ b/llvm/test/Transforms/LoopUnroll/AArch64/apple-unrolling-multi-exit.ll
+@@ -73,7 +73,7 @@
+ ; APPLE-NEXT:    [[C_2_3:%.*]] = icmp eq ptr [[PTR_IV_NEXT_3]], [[END]]
+ ; APPLE-NEXT:    br i1 [[C_2_3]], label %[[EXIT_UNR_LCSSA_LOOPEXIT]], label %[[LOOP_HEADER]]
+ ; APPLE:       [[EXIT_UNR_LCSSA_LOOPEXIT]]:
+-; APPLE-NEXT:    [[RES_PH_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[END]], %[[LOOP_LATCH_3]] ], [ [[PTR_IV_NEXT]], %[[LOOP_LATCH]] ], [ [[PTR_IV_NEXT_2]], %[[LOOP_LATCH_2]] ], [ [[PTR_IV_NEXT_1]], %[[LOOP_LATCH_1]] ]
++; APPLE-NEXT:    [[RES_PH_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[PTR_IV_NEXT]], %[[LOOP_LATCH]] ], [ [[PTR_IV_NEXT_1]], %[[LOOP_LATCH_1]] ], [ [[PTR_IV_NEXT_2]], %[[LOOP_LATCH_2]] ], [ [[END]], %[[LOOP_LATCH_3]] ]
+ ; APPLE-NEXT:    br label %[[EXIT_UNR_LCSSA:.*]]
+ ; APPLE:       [[EXIT_UNR_LCSSA_LOOPEXIT3]]:
+ ; APPLE-NEXT:    [[RES_PH_PH4:%.*]] = phi ptr [ [[PTR_IV_PROL]], %[[LOOP_HEADER_PROL]] ]
+@@ -201,7 +201,7 @@
+ ; APPLE-NEXT:    [[C_2_3:%.*]] = icmp eq ptr [[PTR_IV_NEXT_3]], [[END]]
+ ; APPLE-NEXT:    br i1 [[C_2_3]], label %[[EXIT_UNR_LCSSA_LOOPEXIT]], label %[[LOOP_HEADER]]
+ ; APPLE:       [[EXIT_UNR_LCSSA_LOOPEXIT]]:
+-; APPLE-NEXT:    [[RES_PH_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[END]], %[[LOOP_LATCH_3]] ], [ [[PTR_IV_NEXT]], %[[LOOP_LATCH]] ], [ [[PTR_IV_NEXT_2]], %[[LOOP_LATCH_2]] ], [ [[PTR_IV_NEXT_1]], %[[LOOP_LATCH_1]] ]
++; APPLE-NEXT:    [[RES_PH_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[PTR_IV_NEXT]], %[[LOOP_LATCH]] ], [ [[PTR_IV_NEXT_1]], %[[LOOP_LATCH_1]] ], [ [[PTR_IV_NEXT_2]], %[[LOOP_LATCH_2]] ], [ [[END]], %[[LOOP_LATCH_3]] ]
+ ; APPLE-NEXT:    br label %[[EXIT_UNR_LCSSA:.*]]
+ ; APPLE:       [[EXIT_UNR_LCSSA_LOOPEXIT3]]:
+ ; APPLE-NEXT:    [[RES_PH_PH4:%.*]] = phi ptr [ [[PTR_IV_PROL]], %[[LOOP_HEADER_PROL]] ]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopUnroll/AArch64/unrolling-multi-exit.ll b/llvm/test/Transforms/LoopUnroll/AArch64/unrolling-multi-exit.ll
+--- a/llvm/test/Transforms/LoopUnroll/AArch64/unrolling-multi-exit.ll
++++ b/llvm/test/Transforms/LoopUnroll/AArch64/unrolling-multi-exit.ll
+@@ -70,7 +70,7 @@
+ ; UNROLL4-NEXT:    [[C_2_3:%.*]] = icmp eq ptr [[PTR_IV_NEXT_3]], [[END]]
+ ; UNROLL4-NEXT:    br i1 [[C_2_3]], label %[[EXIT_UNR_LCSSA_LOOPEXIT]], label %[[LOOP_HEADER]]
+ ; UNROLL4:       [[EXIT_UNR_LCSSA_LOOPEXIT]]:
+-; UNROLL4-NEXT:    [[RES_PH_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[END]], %[[LOOP_LATCH_3]] ], [ [[PTR_IV_NEXT]], %[[LOOP_LATCH]] ], [ [[PTR_IV_NEXT_2]], %[[LOOP_LATCH_2]] ], [ [[PTR_IV_NEXT_1]], %[[LOOP_LATCH_1]] ]
++; UNROLL4-NEXT:    [[RES_PH_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[PTR_IV_NEXT]], %[[LOOP_LATCH]] ], [ [[PTR_IV_NEXT_1]], %[[LOOP_LATCH_1]] ], [ [[PTR_IV_NEXT_2]], %[[LOOP_LATCH_2]] ], [ [[END]], %[[LOOP_LATCH_3]] ]
+ ; UNROLL4-NEXT:    br label %[[EXIT_UNR_LCSSA:.*]]
+ ; UNROLL4:       [[EXIT_UNR_LCSSA_LOOPEXIT3]]:
+ ; UNROLL4-NEXT:    [[RES_PH_PH4:%.*]] = phi ptr [ [[PTR_IV_PROL]], %[[LOOP_HEADER_PROL]] ]
+@@ -317,7 +317,7 @@
+ ; UNROLL4-NEXT:    [[C_2_3:%.*]] = icmp eq ptr [[PTR_IV_NEXT_3]], [[END]]
+ ; UNROLL4-NEXT:    br i1 [[C_2_3]], label %[[EXIT_UNR_LCSSA_LOOPEXIT]], label %[[LOOP_HEADER]]
+ ; UNROLL4:       [[EXIT_UNR_LCSSA_LOOPEXIT]]:
+-; UNROLL4-NEXT:    [[RES_PH_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[END]], %[[LOOP_LATCH_3]] ], [ [[PTR_IV_NEXT]], %[[LOOP_LATCH]] ], [ [[PTR_IV_NEXT_2]], %[[LOOP_LATCH_2]] ], [ [[PTR_IV_NEXT_1]], %[[LOOP_LATCH_1]] ]
++; UNROLL4-NEXT:    [[RES_PH_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[PTR_IV_NEXT]], %[[LOOP_LATCH]] ], [ [[PTR_IV_NEXT_1]], %[[LOOP_LATCH_1]] ], [ [[PTR_IV_NEXT_2]], %[[LOOP_LATCH_2]] ], [ [[END]], %[[LOOP_LATCH_3]] ]
+ ; UNROLL4-NEXT:    br label %[[EXIT_UNR_LCSSA:.*]]
+ ; UNROLL4:       [[EXIT_UNR_LCSSA_LOOPEXIT3]]:
+ ; UNROLL4-NEXT:    [[RES_PH_PH4:%.*]] = phi ptr [ [[PTR_IV_PROL]], %[[LOOP_HEADER_PROL]] ]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopUnroll/full-unroll-one-unpredictable-exit.ll b/llvm/test/Transforms/LoopUnroll/full-unroll-one-unpredictable-exit.ll
+--- a/llvm/test/Transforms/LoopUnroll/full-unroll-one-unpredictable-exit.ll
++++ b/llvm/test/Transforms/LoopUnroll/full-unroll-one-unpredictable-exit.ll
+@@ -33,7 +33,7 @@
+ ; CHECK:       latch.1:
+ ; CHECK-NEXT:    br label [[EXIT]]
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[EXIT_VAL:%.*]] = phi i1 [ true, [[LATCH_1]] ], [ false, [[LOOP]] ], [ false, [[LATCH]] ]
++; CHECK-NEXT:    [[EXIT_VAL:%.*]] = phi i1 [ false, [[LOOP]] ], [ false, [[LATCH]] ], [ true, [[LATCH_1]] ]
+ ; CHECK-NEXT:    ret i1 [[EXIT_VAL]]
+ ;
+ start:
+@@ -99,7 +99,7 @@
+ ; CHECK:       latch.2:
+ ; CHECK-NEXT:    br label [[EXIT]]
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[EXIT_VAL:%.*]] = phi i1 [ false, [[LATCH]] ], [ false, [[LATCH_2]] ], [ true, [[LOOP_2]] ], [ false, [[LATCH_1]] ]
++; CHECK-NEXT:    [[EXIT_VAL:%.*]] = phi i1 [ false, [[LATCH]] ], [ false, [[LATCH_1]] ], [ true, [[LOOP_2]] ], [ false, [[LATCH_2]] ]
+ ; CHECK-NEXT:    ret i1 [[EXIT_VAL]]
+ ;
+ start:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopUnroll/partial-unroll-non-latch-exit.ll b/llvm/test/Transforms/LoopUnroll/partial-unroll-non-latch-exit.ll
+--- a/llvm/test/Transforms/LoopUnroll/partial-unroll-non-latch-exit.ll
++++ b/llvm/test/Transforms/LoopUnroll/partial-unroll-non-latch-exit.ll
+@@ -62,7 +62,7 @@
+ ; CHECK-NEXT:    [[EXITCOND2_4:%.*]] = icmp eq i64 [[LOAD1_4]], [[LOAD2_4]]
+ ; CHECK-NEXT:    br i1 [[EXITCOND2_4]], label [[LOOP]], label [[EXIT]]
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[EXIT_VAL:%.*]] = phi i1 [ false, [[LATCH]] ], [ false, [[LATCH_4]] ], [ true, [[LOOP_4]] ], [ false, [[LATCH_1]] ], [ false, [[LATCH_3]] ], [ false, [[LATCH_2]] ]
++; CHECK-NEXT:    [[EXIT_VAL:%.*]] = phi i1 [ false, [[LATCH]] ], [ false, [[LATCH_1]] ], [ false, [[LATCH_2]] ], [ false, [[LATCH_3]] ], [ true, [[LOOP_4]] ], [ false, [[LATCH_4]] ]
+ ; CHECK-NEXT:    ret i1 [[EXIT_VAL]]
+ ;
+ start:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopUnroll/peel-loop.ll b/llvm/test/Transforms/LoopUnroll/peel-loop.ll
+--- a/llvm/test/Transforms/LoopUnroll/peel-loop.ll
++++ b/llvm/test/Transforms/LoopUnroll/peel-loop.ll
+@@ -95,7 +95,7 @@
+ ; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[INC]], [[K]]
+ ; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP3:![0-9]+]]
+ ; CHECK:       for.end:
+-; CHECK-NEXT:    [[RET:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ 3, [[FOR_BODY_PEEL7]] ], [ 1, [[FOR_BODY_PEEL]] ], [ 2, [[FOR_BODY_PEEL2]] ], [ [[INC]], [[FOR_BODY]] ]
++; CHECK-NEXT:    [[RET:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ 1, [[FOR_BODY_PEEL]] ], [ 2, [[FOR_BODY_PEEL2]] ], [ 3, [[FOR_BODY_PEEL7]] ], [ [[INC]], [[FOR_BODY]] ]
+ ; CHECK-NEXT:    ret i32 [[RET]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopUnroll/runtime-loop-multiple-exits.ll b/llvm/test/Transforms/LoopUnroll/runtime-loop-multiple-exits.ll
+--- a/llvm/test/Transforms/LoopUnroll/runtime-loop-multiple-exits.ll
++++ b/llvm/test/Transforms/LoopUnroll/runtime-loop-multiple-exits.ll
+@@ -1521,7 +1521,7 @@
+ ; PROLOG-NEXT:    %exitcond.7 = icmp eq i64 %indvars.iv.next.7, %n
+ ; PROLOG-NEXT:    br i1 %exitcond.7, label %latchExit.unr-lcssa.loopexit, label %header
+ ; PROLOG:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-NEXT:    %result.ph.ph = phi i32 [ 0, %header ], [ %add.7, %latch.7 ], [ 0, %latch ], [ 0, %latch.6 ], [ 0, %latch.1 ], [ 0, %latch.4 ], [ 0, %latch.2 ], [ 0, %latch.5 ], [ 0, %latch.3 ]
++; PROLOG-NEXT:    %result.ph.ph = phi i32 [ 0, %header ], [ 0, %latch ], [ 0, %latch.1 ], [ 0, %latch.2 ], [ 0, %latch.3 ], [ 0, %latch.4 ], [ 0, %latch.5 ], [ 0, %latch.6 ], [ %add.7, %latch.7 ]
+ ; PROLOG-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG:       latchExit.unr-lcssa.loopexit1:
+ ; PROLOG-NEXT:    %result.ph.ph2 = phi i32 [ 0, %header.prol ]
+@@ -1588,7 +1588,7 @@
+ ; PROLOG-BLOCK-NEXT:    %exitcond.1 = icmp eq i64 %indvars.iv.next.1, %n
+ ; PROLOG-BLOCK-NEXT:    br i1 %exitcond.1, label %latchExit.unr-lcssa.loopexit, label %header, !llvm.loop !4
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-BLOCK-NEXT:    %result.ph.ph = phi i32 [ 0, %header ], [ %add.1, %latch.1 ], [ 0, %latch ]
++; PROLOG-BLOCK-NEXT:    %result.ph.ph = phi i32 [ 0, %header ], [ 0, %latch ], [ %add.1, %latch.1 ]
+ ; PROLOG-BLOCK-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa:
+ ; PROLOG-BLOCK-NEXT:    %result.ph = phi i32 [ 0, %header.prol ], [ %result.ph.ph, %latchExit.unr-lcssa.loopexit ]
+@@ -1959,7 +1959,7 @@
+ ; PROLOG-NEXT:    %exitcond.7 = icmp eq i64 %indvars.iv.next.7, %n
+ ; PROLOG-NEXT:    br i1 %exitcond.7, label %latchExit.unr-lcssa.loopexit, label %header
+ ; PROLOG:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-NEXT:    %result.ph.ph = phi i32 [ 2, %for.exiting_block ], [ %add.7, %latch.7 ], [ 2, %for.exiting_block.1 ], [ 2, %for.exiting_block.7 ], [ 2, %for.exiting_block.2 ], [ 2, %for.exiting_block.5 ], [ 2, %for.exiting_block.3 ], [ 2, %for.exiting_block.6 ], [ 2, %for.exiting_block.4 ]
++; PROLOG-NEXT:    %result.ph.ph = phi i32 [ 2, %for.exiting_block ], [ 2, %for.exiting_block.1 ], [ 2, %for.exiting_block.2 ], [ 2, %for.exiting_block.3 ], [ 2, %for.exiting_block.4 ], [ 2, %for.exiting_block.5 ], [ 2, %for.exiting_block.6 ], [ 2, %for.exiting_block.7 ], [ %add.7, %latch.7 ]
+ ; PROLOG-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG:       latchExit.unr-lcssa.loopexit2:
+ ; PROLOG-NEXT:    %result.ph.ph3 = phi i32 [ 2, %for.exiting_block.prol ]
+@@ -2026,7 +2026,7 @@
+ ; PROLOG-BLOCK-NEXT:    %exitcond.1 = icmp eq i64 %indvars.iv.next.1, %n
+ ; PROLOG-BLOCK-NEXT:    br i1 %exitcond.1, label %latchExit.unr-lcssa.loopexit, label %header, !llvm.loop !5
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-BLOCK-NEXT:    %result.ph.ph = phi i32 [ 2, %for.exiting_block ], [ %add.1, %latch.1 ], [ 2, %for.exiting_block.1 ]
++; PROLOG-BLOCK-NEXT:    %result.ph.ph = phi i32 [ 2, %for.exiting_block ], [ 2, %for.exiting_block.1 ], [ %add.1, %latch.1 ]
+ ; PROLOG-BLOCK-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa:
+ ; PROLOG-BLOCK-NEXT:    %result.ph = phi i32 [ 2, %for.exiting_block.prol ], [ %result.ph.ph, %latchExit.unr-lcssa.loopexit ]
+@@ -2398,7 +2398,7 @@
+ ; PROLOG-NEXT:    %exitcond.7 = icmp eq i64 %indvars.iv.next.7, %n
+ ; PROLOG-NEXT:    br i1 %exitcond.7, label %latchExit.unr-lcssa.loopexit, label %header
+ ; PROLOG:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-NEXT:    %result.ph.ph = phi i32 [ %sum.02, %for.exiting_block ], [ %add.7, %latch.7 ], [ %add, %for.exiting_block.1 ], [ %add.6, %for.exiting_block.7 ], [ %add.1, %for.exiting_block.2 ], [ %add.4, %for.exiting_block.5 ], [ %add.2, %for.exiting_block.3 ], [ %add.5, %for.exiting_block.6 ], [ %add.3, %for.exiting_block.4 ]
++; PROLOG-NEXT:    %result.ph.ph = phi i32 [ %sum.02, %for.exiting_block ], [ %add, %for.exiting_block.1 ], [ %add.1, %for.exiting_block.2 ], [ %add.2, %for.exiting_block.3 ], [ %add.3, %for.exiting_block.4 ], [ %add.4, %for.exiting_block.5 ], [ %add.5, %for.exiting_block.6 ], [ %add.6, %for.exiting_block.7 ], [ %add.7, %latch.7 ]
+ ; PROLOG-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG:       latchExit.unr-lcssa.loopexit2:
+ ; PROLOG-NEXT:    %result.ph.ph3 = phi i32 [ %sum.02.prol, %for.exiting_block.prol ]
+@@ -2465,7 +2465,7 @@
+ ; PROLOG-BLOCK-NEXT:    %exitcond.1 = icmp eq i64 %indvars.iv.next.1, %n
+ ; PROLOG-BLOCK-NEXT:    br i1 %exitcond.1, label %latchExit.unr-lcssa.loopexit, label %header, !llvm.loop !6
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-BLOCK-NEXT:    %result.ph.ph = phi i32 [ %sum.02, %for.exiting_block ], [ %add.1, %latch.1 ], [ %add, %for.exiting_block.1 ]
++; PROLOG-BLOCK-NEXT:    %result.ph.ph = phi i32 [ %sum.02, %for.exiting_block ], [ %add, %for.exiting_block.1 ], [ %add.1, %latch.1 ]
+ ; PROLOG-BLOCK-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa:
+ ; PROLOG-BLOCK-NEXT:    %result.ph = phi i32 [ 0, %for.exiting_block.prol ], [ %result.ph.ph, %latchExit.unr-lcssa.loopexit ]
+@@ -2838,7 +2838,7 @@
+ ; PROLOG-NEXT:    %exitcond.7 = icmp eq i64 %indvars.iv.next.7, %n
+ ; PROLOG-NEXT:    br i1 %exitcond.7, label %latchExit.unr-lcssa.loopexit, label %header
+ ; PROLOG:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-NEXT:    %result.ph.ph = phi i32 [ %sum.02, %for.exiting_block ], [ %add.7, %latch.7 ], [ %add, %for.exiting_block.1 ], [ %add.6, %for.exiting_block.7 ], [ %add.1, %for.exiting_block.2 ], [ %add.4, %for.exiting_block.5 ], [ %add.2, %for.exiting_block.3 ], [ %add.5, %for.exiting_block.6 ], [ %add.3, %for.exiting_block.4 ]
++; PROLOG-NEXT:    %result.ph.ph = phi i32 [ %sum.02, %for.exiting_block ], [ %add, %for.exiting_block.1 ], [ %add.1, %for.exiting_block.2 ], [ %add.2, %for.exiting_block.3 ], [ %add.3, %for.exiting_block.4 ], [ %add.4, %for.exiting_block.5 ], [ %add.5, %for.exiting_block.6 ], [ %add.6, %for.exiting_block.7 ], [ %add.7, %latch.7 ]
+ ; PROLOG-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG:       latchExit.unr-lcssa.loopexit2:
+ ; PROLOG-NEXT:    %result.ph.ph3 = phi i32 [ %sum.02.prol, %for.exiting_block.prol ]
+@@ -2905,7 +2905,7 @@
+ ; PROLOG-BLOCK-NEXT:    %exitcond.1 = icmp eq i64 %indvars.iv.next.1, %n
+ ; PROLOG-BLOCK-NEXT:    br i1 %exitcond.1, label %latchExit.unr-lcssa.loopexit, label %header, !llvm.loop !7
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-BLOCK-NEXT:    %result.ph.ph = phi i32 [ %sum.02, %for.exiting_block ], [ %add.1, %latch.1 ], [ %add, %for.exiting_block.1 ]
++; PROLOG-BLOCK-NEXT:    %result.ph.ph = phi i32 [ %sum.02, %for.exiting_block ], [ %add, %for.exiting_block.1 ], [ %add.1, %latch.1 ]
+ ; PROLOG-BLOCK-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa:
+ ; PROLOG-BLOCK-NEXT:    %result.ph = phi i32 [ 0, %for.exiting_block.prol ], [ %result.ph.ph, %latchExit.unr-lcssa.loopexit ]
+@@ -3201,7 +3201,7 @@
+ ; PROLOG-NEXT:    %cmp.7 = icmp ult i32 %inc.7, %M.shifted
+ ; PROLOG-NEXT:    br i1 %cmp.7, label %header, label %latchExit.unr-lcssa.loopexit
+ ; PROLOG:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-NEXT:    %i2.ph.ph.ph = phi i32 [ %i4, %header ], [ -1, %latch.7 ], [ %inc, %latch ], [ %inc.6, %latch.6 ], [ %inc.1, %latch.1 ], [ %inc.4, %latch.4 ], [ %inc.2, %latch.2 ], [ %inc.5, %latch.5 ], [ %inc.3, %latch.3 ]
++; PROLOG-NEXT:    %i2.ph.ph.ph = phi i32 [ %i4, %header ], [ %inc, %latch ], [ %inc.1, %latch.1 ], [ %inc.2, %latch.2 ], [ %inc.3, %latch.3 ], [ %inc.4, %latch.4 ], [ %inc.5, %latch.5 ], [ %inc.6, %latch.6 ], [ -1, %latch.7 ]
+ ; PROLOG-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG:       latchExit.unr-lcssa.loopexit1:
+ ; PROLOG-NEXT:    %i2.ph.ph.ph2 = phi i32 [ %i4.prol, %header.prol ]
+@@ -3249,7 +3249,7 @@
+ ; PROLOG-BLOCK-NEXT:    %cmp.1 = icmp ult i32 %inc.1, %M.shifted
+ ; PROLOG-BLOCK-NEXT:    br i1 %cmp.1, label %header, label %latchExit.unr-lcssa.loopexit, !llvm.loop !8
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa.loopexit:
+-; PROLOG-BLOCK-NEXT:    %i2.ph.ph.ph = phi i32 [ %i4, %header ], [ -1, %latch.1 ], [ %inc, %latch ]
++; PROLOG-BLOCK-NEXT:    %i2.ph.ph.ph = phi i32 [ %i4, %header ], [ %inc, %latch ], [ -1, %latch.1 ]
+ ; PROLOG-BLOCK-NEXT:    br label %latchExit.unr-lcssa
+ ; PROLOG-BLOCK:       latchExit.unr-lcssa:
+ ; PROLOG-BLOCK-NEXT:    %i2.ph.ph = phi i32 [ 0, %header.prol ], [ %i2.ph.ph.ph, %latchExit.unr-lcssa.loopexit ]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopUnroll/scevunroll.ll b/llvm/test/Transforms/LoopUnroll/scevunroll.ll
+--- a/llvm/test/Transforms/LoopUnroll/scevunroll.ll
++++ b/llvm/test/Transforms/LoopUnroll/scevunroll.ll
+@@ -320,8 +320,8 @@
+ ; CHECK:       for.cond.1:
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[B_03_LCSSA:%.*]] = phi i32 [ 0, [[FOR_COND_1]] ], [ 0, [[FOR_COND]] ], [ 8, [[FOR_BODY_1]] ]
+-; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 0, [[FOR_COND_1]] ], [ 0, [[FOR_COND]] ], [ 1, [[FOR_BODY_1]] ]
++; CHECK-NEXT:    [[B_03_LCSSA:%.*]] = phi i32 [ 0, [[FOR_COND]] ], [ 8, [[FOR_BODY_1]] ], [ 0, [[FOR_COND_1]] ]
++; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 0, [[FOR_COND]] ], [ 1, [[FOR_BODY_1]] ], [ 0, [[FOR_COND_1]] ]
+ ; CHECK-NEXT:    store i32 [[B_03_LCSSA]], ptr [[A:%.*]], align 4
+ ; CHECK-NEXT:    ret void
+ ;
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopUnroll/unroll-header-exiting-with-phis-multiple-exiting-blocks.ll b/llvm/test/Transforms/LoopUnroll/unroll-header-exiting-with-phis-multiple-exiting-blocks.ll
+--- a/llvm/test/Transforms/LoopUnroll/unroll-header-exiting-with-phis-multiple-exiting-blocks.ll
++++ b/llvm/test/Transforms/LoopUnroll/unroll-header-exiting-with-phis-multiple-exiting-blocks.ll
+@@ -53,7 +53,7 @@
+ ; CHECK:       latch.3:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[RES_LCSSA:%.*]] = phi i16 [ 1, [[EXITING_2_3]] ], [ 0, [[EXITING_1]] ], [ 1, [[EXITING_2]] ], [ 0, [[EXITING_1_3]] ], [ 0, [[EXITING_1_1]] ], [ 1, [[EXITING_2_1]] ], [ [[RES_NEXT_3]], [[LATCH_2]] ], [ 0, [[EXITING_1_2]] ], [ 1, [[EXITING_2_2]] ]
++; CHECK-NEXT:    [[RES_LCSSA:%.*]] = phi i16 [ 0, [[EXITING_1]] ], [ 1, [[EXITING_2]] ], [ 0, [[EXITING_1_1]] ], [ 1, [[EXITING_2_1]] ], [ 0, [[EXITING_1_2]] ], [ 1, [[EXITING_2_2]] ], [ [[RES_NEXT_3]], [[LATCH_2]] ], [ 0, [[EXITING_1_3]] ], [ 1, [[EXITING_2_3]] ]
+ ; CHECK-NEXT:    ret i16 [[RES_LCSSA]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/AArch64/simple_early_exit.ll b/llvm/test/Transforms/LoopVectorize/AArch64/simple_early_exit.ll
+--- a/llvm/test/Transforms/LoopVectorize/AArch64/simple_early_exit.ll
++++ b/llvm/test/Transforms/LoopVectorize/AArch64/simple_early_exit.ll
+@@ -130,7 +130,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP8]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -192,7 +192,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP9]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -341,7 +341,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP11]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ [[TMP10]], [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[TMP10]], [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/single-early-exit-deref-assumptions.ll b/llvm/test/Transforms/LoopVectorize/single-early-exit-deref-assumptions.ll
+--- a/llvm/test/Transforms/LoopVectorize/single-early-exit-deref-assumptions.ll
++++ b/llvm/test/Transforms/LoopVectorize/single-early-exit-deref-assumptions.ll
+@@ -32,7 +32,7 @@
+ ; CHECK-NEXT:    [[TMP9:%.*]] = add i64 [[INDEX1]], [[TMP8]]
+ ; CHECK-NEXT:    br label %[[LOOP_END]]
+ ; CHECK:       [[LOOP_END]]:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[TMP9]], %[[VECTOR_EARLY_EXIT]] ], [ -1, %[[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ -1, %[[MIDDLE_BLOCK]] ], [ [[TMP9]], %[[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -606,7 +606,7 @@
+ ; CHECK-NEXT:    [[TMP8:%.*]] = add i64 [[INDEX1]], [[TMP7]]
+ ; CHECK-NEXT:    br label %[[LOOP_END]]
+ ; CHECK:       [[LOOP_END]]:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[TMP8]], %[[VECTOR_EARLY_EXIT]] ], [ -1, %[[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ -1, %[[MIDDLE_BLOCK]] ], [ [[TMP8]], %[[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/single-early-exit-interleave.ll b/llvm/test/Transforms/LoopVectorize/single-early-exit-interleave.ll
+--- a/llvm/test/Transforms/LoopVectorize/single-early-exit-interleave.ll
++++ b/llvm/test/Transforms/LoopVectorize/single-early-exit-interleave.ll
+@@ -142,7 +142,7 @@
+ ; VF4IC4-NEXT:    [[TMP10:%.*]] = add i64 3, [[TMP9]]
+ ; VF4IC4-NEXT:    br label [[LOOP_END]]
+ ; VF4IC4:       loop.end:
+-; VF4IC4-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[TMP10]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; VF4IC4-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[TMP10]], [[VECTOR_EARLY_EXIT]] ]
+ ; VF4IC4-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -229,7 +229,7 @@
+ ; VF4IC4-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[P1]], i64 [[TMP7]]
+ ; VF4IC4-NEXT:    br label [[LOOP_END]]
+ ; VF4IC4:       loop.end:
+-; VF4IC4-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[TMP8]], [[VECTOR_EARLY_EXIT]] ], [ [[PTREND]], [[MIDDLE_BLOCK]] ]
++; VF4IC4-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[PTREND]], [[MIDDLE_BLOCK]] ], [ [[TMP8]], [[VECTOR_EARLY_EXIT]] ]
+ ; VF4IC4-NEXT:    ret ptr [[RETVAL]]
+ ;
+ entry:
+@@ -322,7 +322,7 @@
+ ; VF4IC4-NEXT:    [[TMP10:%.*]] = add i64 3, [[TMP9]]
+ ; VF4IC4-NEXT:    br label [[LOOP_END]]
+ ; VF4IC4:       loop.end:
+-; VF4IC4-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[TMP10]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; VF4IC4-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[TMP10]], [[VECTOR_EARLY_EXIT]] ]
+ ; VF4IC4-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -763,7 +763,7 @@
+ ; VF4IC4-NEXT:    [[TMP42:%.*]] = select i1 [[TMP41]], i8 [[TMP40]], i8 [[TMP38]]
+ ; VF4IC4-NEXT:    br label [[LOOP_END]]
+ ; VF4IC4:       loop.end:
+-; VF4IC4-NEXT:    [[RETVAL:%.*]] = phi i8 [ [[TMP42]], [[VECTOR_EARLY_EXIT]] ], [ -1, [[MIDDLE_BLOCK]] ]
++; VF4IC4-NEXT:    [[RETVAL:%.*]] = phi i8 [ -1, [[MIDDLE_BLOCK]] ], [ [[TMP42]], [[VECTOR_EARLY_EXIT]] ]
+ ; VF4IC4-NEXT:    ret i8 [[RETVAL]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/single_early_exit_live_outs.ll b/llvm/test/Transforms/LoopVectorize/single_early_exit_live_outs.ll
+--- a/llvm/test/Transforms/LoopVectorize/single_early_exit_live_outs.ll
++++ b/llvm/test/Transforms/LoopVectorize/single_early_exit_live_outs.ll
+@@ -37,7 +37,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP10]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -103,7 +103,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i32 9, [[TMP11]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i32 [[RETVAL]]
+ ;
+ entry:
+@@ -168,7 +168,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i32 9, [[TMP10]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i32 [[RETVAL]]
+ ;
+ entry:
+@@ -233,7 +233,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = fadd fast float 9.000000e+00, [[TMP11]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi float [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 1.230000e+02, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi float [ 1.230000e+02, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret float [[RETVAL]]
+ ;
+ entry:
+@@ -300,7 +300,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = getelementptr i8, ptr [[P2]], i64 [[TMP20]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ [[P1]], [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[P1]], [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret ptr [[RETVAL]]
+ ;
+ entry:
+@@ -362,7 +362,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = getelementptr i8, ptr [[P1]], i64 [[TMP8]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ [[PTREND]], [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[PTREND]], [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret ptr [[RETVAL]]
+ ;
+ entry:
+@@ -425,7 +425,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP11]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -490,7 +490,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP10]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -554,7 +554,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP10]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -615,7 +615,7 @@
+ ; CHECK:       vector.early.exit:
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[VECTOR_EARLY_EXIT]] ], [ 66, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 66, [[MIDDLE_BLOCK]] ], [ 67, [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -744,7 +744,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP8]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -806,7 +806,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP10]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -867,7 +867,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = getelementptr i8, ptr [[P1]], i64 [[TMP9]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ [[PTREND]], [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[PTREND]], [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret ptr [[RETVAL]]
+ ;
+ entry:
+@@ -928,7 +928,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP11]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 66, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 66, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -1406,7 +1406,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP9]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -1468,7 +1468,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP9]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -1531,7 +1531,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP11]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ [[TMP10]], [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[TMP10]], [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+@@ -1724,7 +1724,7 @@
+ ; CHECK-NEXT:    [[EARLY_EXIT_VALUE:%.*]] = add i64 3, [[TMP10]]
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ], [ 67, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 67, [[MIDDLE_BLOCK]] ], [ [[EARLY_EXIT_VALUE]], [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/single_early_exit.ll b/llvm/test/Transforms/LoopVectorize/single_early_exit.ll
+--- a/llvm/test/Transforms/LoopVectorize/single_early_exit.ll
++++ b/llvm/test/Transforms/LoopVectorize/single_early_exit.ll
+@@ -35,7 +35,7 @@
+ ; CHECK:       vector.early.exit:
+ ; CHECK-NEXT:    br label [[LOOP_END]]
+ ; CHECK:       loop.end:
+-; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 0, [[VECTOR_EARLY_EXIT]] ], [ 1, [[MIDDLE_BLOCK]] ]
++; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 1, [[MIDDLE_BLOCK]] ], [ 0, [[VECTOR_EARLY_EXIT]] ]
+ ; CHECK-NEXT:    ret i64 [[RETVAL]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/trip-count-expansion-may-introduce-ub.ll b/llvm/test/Transforms/LoopVectorize/trip-count-expansion-may-introduce-ub.ll
+--- a/llvm/test/Transforms/LoopVectorize/trip-count-expansion-may-introduce-ub.ll
++++ b/llvm/test/Transforms/LoopVectorize/trip-count-expansion-may-introduce-ub.ll
+@@ -424,7 +424,7 @@
+ ; CHECK-NEXT:    [[C_0:%.*]] = icmp slt i64 [[IV]], [[N]]
+ ; CHECK-NEXT:    br i1 [[C_0]], label [[LOOP_HEADER]], label [[EXIT]]
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[P:%.*]] = phi i64 [ 1, [[LOOP_HEADER]] ], [ 0, [[LOOP_LATCH]] ]
++; CHECK-NEXT:    [[P:%.*]] = phi i64 [ 0, [[LOOP_LATCH]] ], [ 1, [[LOOP_HEADER]] ]
+ ; CHECK-NEXT:    ret i64 [[P]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/vector-loop-backedge-elimination-early-exit.ll b/llvm/test/Transforms/LoopVectorize/vector-loop-backedge-elimination-early-exit.ll
+--- a/llvm/test/Transforms/LoopVectorize/vector-loop-backedge-elimination-early-exit.ll
++++ b/llvm/test/Transforms/LoopVectorize/vector-loop-backedge-elimination-early-exit.ll
+@@ -32,7 +32,7 @@
+ ; VF8UF1:       [[VECTOR_EARLY_EXIT]]:
+ ; VF8UF1-NEXT:    br label %[[EXIT]]
+ ; VF8UF1:       [[EXIT]]:
+-; VF8UF1-NEXT:    [[RES:%.*]] = phi i8 [ 0, %[[VECTOR_EARLY_EXIT]] ], [ 1, %[[MIDDLE_BLOCK]] ]
++; VF8UF1-NEXT:    [[RES:%.*]] = phi i8 [ 1, %[[MIDDLE_BLOCK]] ], [ 0, %[[VECTOR_EARLY_EXIT]] ]
+ ; VF8UF1-NEXT:    ret i8 [[RES]]
+ ;
+ ; VF8UF2-LABEL: define i8 @test_early_exit_max_tc_less_than_16(
+@@ -59,7 +59,7 @@
+ ; VF8UF2:       [[VECTOR_EARLY_EXIT]]:
+ ; VF8UF2-NEXT:    br label %[[EXIT]]
+ ; VF8UF2:       [[EXIT]]:
+-; VF8UF2-NEXT:    [[RES:%.*]] = phi i8 [ 0, %[[VECTOR_EARLY_EXIT]] ], [ 1, %[[MIDDLE_BLOCK]] ]
++; VF8UF2-NEXT:    [[RES:%.*]] = phi i8 [ 1, %[[MIDDLE_BLOCK]] ], [ 0, %[[VECTOR_EARLY_EXIT]] ]
+ ; VF8UF2-NEXT:    ret i8 [[RES]]
+ ;
+ ; VF16UF1-LABEL: define i8 @test_early_exit_max_tc_less_than_16(
+@@ -81,7 +81,7 @@
+ ; VF16UF1:       [[VECTOR_EARLY_EXIT]]:
+ ; VF16UF1-NEXT:    br label %[[EXIT]]
+ ; VF16UF1:       [[EXIT]]:
+-; VF16UF1-NEXT:    [[RES:%.*]] = phi i8 [ 0, %[[VECTOR_EARLY_EXIT]] ], [ 1, %[[MIDDLE_BLOCK]] ]
++; VF16UF1-NEXT:    [[RES:%.*]] = phi i8 [ 1, %[[MIDDLE_BLOCK]] ], [ 0, %[[VECTOR_EARLY_EXIT]] ]
+ ; VF16UF1-NEXT:    ret i8 [[RES]]
+ ;
+ entry:
+@@ -131,7 +131,7 @@
+ ; VF8UF1-NEXT:    [[TMP8:%.*]] = add i64 [[INDEX]], [[FIRST_ACTIVE_LANE]]
+ ; VF8UF1-NEXT:    br label %[[EXIT]]
+ ; VF8UF1:       [[EXIT]]:
+-; VF8UF1-NEXT:    [[RES:%.*]] = phi i64 [ [[TMP8]], %[[VECTOR_EARLY_EXIT]] ], [ 1, %[[MIDDLE_BLOCK]] ]
++; VF8UF1-NEXT:    [[RES:%.*]] = phi i64 [ 1, %[[MIDDLE_BLOCK]] ], [ [[TMP8]], %[[VECTOR_EARLY_EXIT]] ]
+ ; VF8UF1-NEXT:    ret i64 [[RES]]
+ ;
+ ; VF8UF2-LABEL: define i64 @test_early_exit_max_tc_less_than_16_with_iv_used_outside(
+@@ -164,7 +164,7 @@
+ ; VF8UF2-NEXT:    [[TMP11:%.*]] = select i1 [[TMP10]], i64 [[TMP9]], i64 [[TMP7]]
+ ; VF8UF2-NEXT:    br label %[[EXIT]]
+ ; VF8UF2:       [[EXIT]]:
+-; VF8UF2-NEXT:    [[RES:%.*]] = phi i64 [ [[TMP11]], %[[VECTOR_EARLY_EXIT]] ], [ 1, %[[MIDDLE_BLOCK]] ]
++; VF8UF2-NEXT:    [[RES:%.*]] = phi i64 [ 1, %[[MIDDLE_BLOCK]] ], [ [[TMP11]], %[[VECTOR_EARLY_EXIT]] ]
+ ; VF8UF2-NEXT:    ret i64 [[RES]]
+ ;
+ ; VF16UF1-LABEL: define i64 @test_early_exit_max_tc_less_than_16_with_iv_used_outside(
+@@ -187,7 +187,7 @@
+ ; VF16UF1-NEXT:    [[FIRST_ACTIVE_LANE:%.*]] = call i64 @llvm.experimental.cttz.elts.i64.v16i1(<16 x i1> [[TMP3]], i1 false)
+ ; VF16UF1-NEXT:    br label %[[EXIT]]
+ ; VF16UF1:       [[EXIT]]:
+-; VF16UF1-NEXT:    [[RES:%.*]] = phi i64 [ [[FIRST_ACTIVE_LANE]], %[[VECTOR_EARLY_EXIT]] ], [ 1, %[[MIDDLE_BLOCK]] ]
++; VF16UF1-NEXT:    [[RES:%.*]] = phi i64 [ 1, %[[MIDDLE_BLOCK]] ], [ [[FIRST_ACTIVE_LANE]], %[[VECTOR_EARLY_EXIT]] ]
+ ; VF16UF1-NEXT:    ret i64 [[RES]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LowerSwitch/2014-06-23-PHIlowering.ll b/llvm/test/Transforms/LowerSwitch/2014-06-23-PHIlowering.ll
+--- a/llvm/test/Transforms/LowerSwitch/2014-06-23-PHIlowering.ll
++++ b/llvm/test/Transforms/LowerSwitch/2014-06-23-PHIlowering.ll
+@@ -6,7 +6,7 @@
+ ; CHECK-NEXT:  %res.0 = phi i32 [ 1, %NodeBlock ], [ 2, %1 ]
+ ; CHECK-NEXT:  br label %3
+ ; CHECK: 5:
+-; CHECK-NEXT:   %res.3 = phi i32 [ 0, %LeafBlock1 ], [ %res.2, %4 ], [ 0, %LeafBlock ]
++; CHECK-NEXT:   %res.3 = phi i32 [ %res.2, %4 ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
+ ; CHECK-NEXT:   %6 = add nsw i32 %res.3, 1
+ ; CHECK-NEXT:   ret i32 %6
+ 
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LowerSwitch/do-not-handle-impossible-values.ll b/llvm/test/Transforms/LowerSwitch/do-not-handle-impossible-values.ll
+--- a/llvm/test/Transforms/LowerSwitch/do-not-handle-impossible-values.ll
++++ b/llvm/test/Transforms/LowerSwitch/do-not-handle-impossible-values.ll
+@@ -432,7 +432,7 @@
+ ; CHECK-NEXT:    [[RES1:%.*]] = call i32 @case1()
+ ; CHECK-NEXT:    br label [[EXIT:%.*]]
+ ; CHECK:       case.D:
+-; CHECK-NEXT:    [[DELTA:%.*]] = phi i32 [ 20, [[LEAFBLOCK]] ], [ 0, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[DELTA:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ 20, [[LEAFBLOCK]] ]
+ ; CHECK-NEXT:    [[RESD_TMP:%.*]] = call i32 @caseD()
+ ; CHECK-NEXT:    [[RESD:%.*]] = add i32 [[RESD_TMP]], [[DELTA]]
+ ; CHECK-NEXT:    br label [[EXIT]]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/MergeICmps/X86/alias-merge-blocks.ll b/llvm/test/Transforms/MergeICmps/X86/alias-merge-blocks.ll
+--- a/llvm/test/Transforms/MergeICmps/X86/alias-merge-blocks.ll
++++ b/llvm/test/Transforms/MergeICmps/X86/alias-merge-blocks.ll
+@@ -71,7 +71,7 @@
+ ; X86-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[MEMCMP]], 0
+ ; X86-NEXT:    br label [[EXIT]]
+ ; X86:       exit:
+-; X86-NEXT:    [[RET:%.*]] = phi i1 [ false, [[BB01:%.*]] ], [ [[TMP5]], %"bb1+bb2+bb3" ]
++; X86-NEXT:    [[RET:%.*]] = phi i1 [ [[TMP5]], %"bb1+bb2+bb3" ], [ false, [[BB01:%.*]] ]
+ ; X86-NEXT:    ret i1 [[RET]]
+ ;
+ bb0:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/MergeICmps/X86/entry-block-shuffled-2.ll b/llvm/test/Transforms/MergeICmps/X86/entry-block-shuffled-2.ll
+--- a/llvm/test/Transforms/MergeICmps/X86/entry-block-shuffled-2.ll
++++ b/llvm/test/Transforms/MergeICmps/X86/entry-block-shuffled-2.ll
+@@ -27,7 +27,7 @@
+ ; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[TMP3]], [[TMP4]]
+ ; CHECK-NEXT:    br label [[LAND_END]]
+ ; CHECK:       land.end:
+-; CHECK-NEXT:    [[V9:%.*]] = phi i1 [ false, %"land.lhs.true+entry" ], [ [[TMP5]], [[LAND_RHS1]] ]
++; CHECK-NEXT:    [[V9:%.*]] = phi i1 [ [[TMP5]], [[LAND_RHS1]] ], [ false, %"land.lhs.true+entry" ]
+ ; CHECK-NEXT:    ret i1 [[V9]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/MergeICmps/X86/entry-block-shuffled.ll b/llvm/test/Transforms/MergeICmps/X86/entry-block-shuffled.ll
+--- a/llvm/test/Transforms/MergeICmps/X86/entry-block-shuffled.ll
++++ b/llvm/test/Transforms/MergeICmps/X86/entry-block-shuffled.ll
+@@ -28,7 +28,7 @@
+ ; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i32 [[TMP8]], [[TMP9]]
+ ; CHECK-NEXT:    br label [[OPEQ1_EXIT]]
+ ; CHECK:       opeq1.exit:
+-; CHECK-NEXT:    [[TMP11:%.*]] = phi i1 [ false, [[ENTRY2:%.*]] ], [ false, %"land.rhs.i+land.rhs.i.2" ], [ [[TMP10]], [[LAND_RHS_I_31]] ]
++; CHECK-NEXT:    [[TMP11:%.*]] = phi i1 [ [[TMP10]], [[LAND_RHS_I_31]] ], [ false, %"land.rhs.i+land.rhs.i.2" ], [ false, [[ENTRY2:%.*]] ]
+ ; CHECK-NEXT:    ret i1 [[TMP11]]
+ ;
+   ptr nocapture readonly dereferenceable(16) %a,
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/MergeICmps/X86/pr59740.ll b/llvm/test/Transforms/MergeICmps/X86/pr59740.ll
+--- a/llvm/test/Transforms/MergeICmps/X86/pr59740.ll
++++ b/llvm/test/Transforms/MergeICmps/X86/pr59740.ll
+@@ -126,7 +126,7 @@
+ ; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[MEMCMP]], 0
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[CMP:%.*]] = phi i1 [ false, [[BB01:%.*]] ], [ [[TMP5]], %"bb1+bb2" ]
++; CHECK-NEXT:    [[CMP:%.*]] = phi i1 [ [[TMP5]], %"bb1+bb2" ], [ false, [[BB01:%.*]] ]
+ ; CHECK-NEXT:    ret i1 [[CMP]]
+ ;
+ bb0:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/PGOProfile/chr.ll b/llvm/test/Transforms/PGOProfile/chr.ll
+--- a/llvm/test/Transforms/PGOProfile/chr.ll
++++ b/llvm/test/Transforms/PGOProfile/chr.ll
+@@ -483,7 +483,7 @@
+ ; CHECK-NEXT:    [[SUM5_NONCHR:%.*]] = select i1 [[TMP12]], i32 [[SUM2_NONCHR]], i32 [[SUM4_NONCHR]], !prof [[PROF16]]
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[SUM5_NONCHR]], [[BB0_NONCHR]] ], [ [[TMP3]], [[BB1]] ], [ [[SUM0]], [[ENTRY_SPLIT_NONCHR]] ]
++; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[TMP3]], [[BB1]] ], [ [[SUM0]], [[ENTRY_SPLIT_NONCHR]] ], [ [[SUM5_NONCHR]], [[BB0_NONCHR]] ]
+ ; CHECK-NEXT:    ret i32 [[SUM6]]
+ ;
+ entry:
+@@ -584,7 +584,7 @@
+ ; CHECK-NEXT:    [[SUM5_NONCHR:%.*]] = select i1 [[TMP15]], i32 [[SUM2_NONCHR]], i32 [[SUM4_NONCHR]], !prof [[PROF16]]
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[SUM5_NONCHR]], [[BB0_NONCHR]] ], [ [[TMP6]], [[BB1]] ], [ [[SUM0_FR]], [[ENTRY_SPLIT_NONCHR]] ]
++; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[TMP6]], [[BB1]] ], [ [[SUM0_FR]], [[ENTRY_SPLIT_NONCHR]] ], [ [[SUM5_NONCHR]], [[BB0_NONCHR]] ]
+ ; CHECK-NEXT:    ret i32 [[SUM6]]
+ ;
+ entry:
+@@ -682,7 +682,7 @@
+ ; CHECK-NEXT:    [[SUM5_NONCHR:%.*]] = select i1 [[V10_NONCHR]], i32 [[SUM2_NONCHR]], i32 [[SUM4_NONCHR]], !prof [[PROF16]]
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[SUM5_NONCHR]], [[BB0_NONCHR]] ], [ [[V13]], [[BB1]] ], [ [[SUM0]], [[ENTRY_SPLIT_NONCHR]] ]
++; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[V13]], [[BB1]] ], [ [[SUM0]], [[ENTRY_SPLIT_NONCHR]] ], [ [[SUM5_NONCHR]], [[BB0_NONCHR]] ]
+ ; CHECK-NEXT:    ret i32 [[SUM6]]
+ ;
+ entry:
+@@ -974,7 +974,7 @@
+ ; CHECK-NEXT:    call void @foo()
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[TMP8:%.*]] = phi i32 [ [[TMP7]], [[BB2_NONCHR]] ], [ [[TMP3]], [[BB0]] ], [ [[DOTFR1]], [[BB1_NONCHR]] ]
++; CHECK-NEXT:    [[TMP8:%.*]] = phi i32 [ [[TMP3]], [[BB0]] ], [ [[DOTFR1]], [[BB1_NONCHR]] ], [ [[TMP7]], [[BB2_NONCHR]] ]
+ ; CHECK-NEXT:    ret i32 [[TMP8]]
+ ;
+ entry:
+@@ -1056,7 +1056,7 @@
+ ; CHECK-NEXT:    call void @foo()
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[TMP8:%.*]] = phi i32 [ [[TMP3]], [[BB0]] ], [ [[TMP5]], [[BB1_NONCHR]] ], [ [[TMP5]], [[BB2_NONCHR]] ]
++; CHECK-NEXT:    [[TMP8:%.*]] = phi i32 [ [[TMP3]], [[BB0]] ], [ [[TMP5]], [[BB2_NONCHR]] ], [ [[TMP5]], [[BB1_NONCHR]] ]
+ ; CHECK-NEXT:    [[TMP9:%.*]] = mul i32 [[TMP8]], 42
+ ; CHECK-NEXT:    [[TMP10:%.*]] = add i32 [[TMP8]], -99
+ ; CHECK-NEXT:    [[TMP11:%.*]] = add i32 [[TMP9]], [[TMP10]]
+@@ -1218,7 +1218,7 @@
+ ; CHECK-NEXT:    [[SUM4_NONCHR:%.*]] = add i32 [[SUM2]], [[SUM4_NONCHR_V]]
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[SUM0]], [[ENTRY:%.*]] ], [ [[SUM4_NONCHR]], [[BB1_NONCHR]] ], [ [[TMP14]], [[BB1]] ], [ [[SUM2]], [[BB0_SPLIT_NONCHR]] ]
++; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[SUM0]], [[ENTRY:%.*]] ], [ [[TMP14]], [[BB1]] ], [ [[SUM2]], [[BB0_SPLIT_NONCHR]] ], [ [[SUM4_NONCHR]], [[BB1_NONCHR]] ]
+ ; CHECK-NEXT:    ret i32 [[SUM6]]
+ ;
+ entry:
+@@ -1514,8 +1514,8 @@
+ ; CHECK-NEXT:    call void @foo()
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[TMP6:%.*]] = phi i32 [ [[V40]], [[BB0]] ], [ [[V40_NONCHR]], [[BB1_NONCHR]] ], [ [[V40_NONCHR]], [[BB2_NONCHR]] ]
+-; CHECK-NEXT:    [[V42:%.*]] = phi i32 [ [[V41]], [[BB0]] ], [ [[V40_NONCHR]], [[BB1_NONCHR]] ], [ [[V41_NONCHR]], [[BB2_NONCHR]] ]
++; CHECK-NEXT:    [[TMP6:%.*]] = phi i32 [ [[V40]], [[BB0]] ], [ [[V40_NONCHR]], [[BB2_NONCHR]] ], [ [[V40_NONCHR]], [[BB1_NONCHR]] ]
++; CHECK-NEXT:    [[V42:%.*]] = phi i32 [ [[V41]], [[BB0]] ], [ [[V41_NONCHR]], [[BB2_NONCHR]] ], [ [[V40_NONCHR]], [[BB1_NONCHR]] ]
+ ; CHECK-NEXT:    [[V43:%.*]] = add i32 [[V42]], [[TMP6]]
+ ; CHECK-NEXT:    ret i32 [[V43]]
+ ;
+@@ -1690,8 +1690,8 @@
+ ; CHECK-NEXT:    [[SUM3_NONCHR:%.*]] = add i32 [[SUM2_NONCHR]], 44
+ ; CHECK-NEXT:    br label [[BB2]]
+ ; CHECK:       bb2:
+-; CHECK-NEXT:    [[TMP2]] = phi i32 [ [[INC2]], [[BB1]] ], [ [[INC2_NONCHR]], [[BB0_SPLIT_NONCHR]] ], [ [[INC2_NONCHR]], [[BB1_NONCHR]] ]
+-; CHECK-NEXT:    [[SUM4:%.*]] = phi i32 [ [[SUM3]], [[BB1]] ], [ [[SUM1]], [[BB0_SPLIT_NONCHR]] ], [ [[SUM3_NONCHR]], [[BB1_NONCHR]] ]
++; CHECK-NEXT:    [[TMP2]] = phi i32 [ [[INC2]], [[BB1]] ], [ [[INC2_NONCHR]], [[BB1_NONCHR]] ], [ [[INC2_NONCHR]], [[BB0_SPLIT_NONCHR]] ]
++; CHECK-NEXT:    [[SUM4:%.*]] = phi i32 [ [[SUM3]], [[BB1]] ], [ [[SUM3_NONCHR]], [[BB1_NONCHR]] ], [ [[SUM1]], [[BB0_SPLIT_NONCHR]] ]
+ ; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP2]], 100
+ ; CHECK-NEXT:    br i1 [[CMP]], label [[BB3:%.*]], label [[BB0]], !prof [[PROF16]]
+ ; CHECK:       bb3:
+@@ -1782,7 +1782,7 @@
+ ; CHECK-NEXT:    [[SUM5_NONCHR:%.*]] = select i1 [[TMP6]], i32 [[SUM2_NONCHR]], i32 [[SUM4_NONCHR]], !prof [[PROF16]]
+ ; CHECK-NEXT:    br label [[BB3]]
+ ; CHECK:       bb3:
+-; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[SUM5_NONCHR]], [[BB0_NONCHR]] ], [ [[TMP3]], [[BB1]] ], [ [[SUM0]], [[ENTRY_SPLIT_NONCHR]] ]
++; CHECK-NEXT:    [[SUM6:%.*]] = phi i32 [ [[TMP3]], [[BB1]] ], [ [[SUM0]], [[ENTRY_SPLIT_NONCHR]] ], [ [[SUM5_NONCHR]], [[BB0_NONCHR]] ]
+ ; CHECK-NEXT:    ret i32 [[SUM6]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/PhaseOrdering/AArch64/std-find.ll b/llvm/test/Transforms/PhaseOrdering/AArch64/std-find.ll
+--- a/llvm/test/Transforms/PhaseOrdering/AArch64/std-find.ll
++++ b/llvm/test/Transforms/PhaseOrdering/AArch64/std-find.ll
+@@ -90,7 +90,7 @@
+ ; CHECK-NEXT:    [[CMP_NOT_I_I:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[COERCE_VAL_IP]]
+ ; CHECK-NEXT:    br i1 [[CMP_NOT_I_I]], label %[[RETURN]], label %[[LOOP_HEADER]]
+ ; CHECK:       [[RETURN]]:
+-; CHECK-NEXT:    [[MERGE_PH:%.*]] = phi ptr [ [[PTR_IV]], %[[LOOP_HEADER]] ], [ [[COERCE_VAL_IP]], %[[LOOP_LATCH]] ]
++; CHECK-NEXT:    [[MERGE_PH:%.*]] = phi ptr [ [[COERCE_VAL_IP]], %[[LOOP_LATCH]] ], [ [[PTR_IV]], %[[LOOP_HEADER]] ]
+ ; CHECK-NEXT:    [[DOTPRE:%.*]] = ptrtoint ptr [[MERGE_PH]] to i64
+ ; CHECK-NEXT:    ret i64 [[DOTPRE]]
+ ;
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/PhaseOrdering/switch-sext.ll b/llvm/test/Transforms/PhaseOrdering/switch-sext.ll
+--- a/llvm/test/Transforms/PhaseOrdering/switch-sext.ll
++++ b/llvm/test/Transforms/PhaseOrdering/switch-sext.ll
+@@ -14,7 +14,7 @@
+ ; CHECK:       sw.bb3:
+ ; CHECK-NEXT:    br label [[SW_EPILOG]]
+ ; CHECK:       sw.epilog:
+-; CHECK-NEXT:    [[PEP_CODE:%.*]] = phi i8 [ 113, [[SW_BB2]] ], [ [[CODE]], [[ENTRY:%.*]] ], [ 81, [[SW_BB3]] ]
++; CHECK-NEXT:    [[PEP_CODE:%.*]] = phi i8 [ 81, [[SW_BB3]] ], [ 113, [[SW_BB2]] ], [ [[CODE]], [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    ret i8 [[PEP_CODE]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/PhaseOrdering/X86/vector-reductions-logical.ll b/llvm/test/Transforms/PhaseOrdering/X86/vector-reductions-logical.ll
+--- a/llvm/test/Transforms/PhaseOrdering/X86/vector-reductions-logical.ll
++++ b/llvm/test/Transforms/PhaseOrdering/X86/vector-reductions-logical.ll
+@@ -486,7 +486,7 @@
+ ; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[TMP5]], i32 0, i32 [[ADD]]
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ [[SPEC_SELECT]], [[IF_END]] ], [ 0, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SPEC_SELECT]], [[IF_END]] ]
+ ; CHECK-NEXT:    ret i32 [[RETVAL_0]]
+ ;
+ entry:
+@@ -564,7 +564,7 @@
+ ; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[DOTNOT6]], i32 [[ADD]], i32 0
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ [[SPEC_SELECT]], [[IF_END]] ], [ 0, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SPEC_SELECT]], [[IF_END]] ]
+ ; CHECK-NEXT:    ret i32 [[RETVAL_0]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimpleLoopUnswitch/inject-invariant-conditions.ll b/llvm/test/Transforms/SimpleLoopUnswitch/inject-invariant-conditions.ll
+--- a/llvm/test/Transforms/SimpleLoopUnswitch/inject-invariant-conditions.ll
++++ b/llvm/test/Transforms/SimpleLoopUnswitch/inject-invariant-conditions.ll
+@@ -37,7 +37,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]], !llvm.loop [[LOOP4:![0-9]+]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP_US]] ], [ 0, [[GUARDED_US]] ], [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ 0, [[GUARDED_US]] ], [ -1, [[LOOP]] ], [ -1, [[LOOP_US]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -94,7 +94,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP]] ], [ 0, [[BACKEDGE]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -162,7 +162,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], 1000
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]], !llvm.loop [[LOOP6:![0-9]+]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP_US]] ], [ 0, [[GUARDED_US]] ], [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ 0, [[GUARDED_US]] ], [ -1, [[LOOP]] ], [ -1, [[LOOP_US]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -218,7 +218,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP]] ], [ 0, [[BACKEDGE]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -275,7 +275,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP]] ], [ 0, [[BACKEDGE]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -332,7 +332,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP]] ], [ 0, [[BACKEDGE]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -403,7 +403,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]], !llvm.loop [[LOOP10:![0-9]+]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP_US]] ], [ 0, [[GUARDED_US]] ], [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ 0, [[GUARDED_US]] ], [ -1, [[LOOP]] ], [ -1, [[LOOP_US]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -473,7 +473,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]], !llvm.loop [[LOOP12:![0-9]+]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP_US]] ], [ 0, [[GUARDED_US]] ], [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ 0, [[GUARDED_US]] ], [ -1, [[LOOP]] ], [ -1, [[LOOP_US]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -543,7 +543,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]], !llvm.loop [[LOOP13:![0-9]+]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP_US]] ], [ 0, [[GUARDED_US]] ], [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ 0, [[GUARDED_US]] ], [ -1, [[LOOP]] ], [ -1, [[LOOP_US]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+@@ -615,7 +615,7 @@
+ ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N]]
+ ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[COMMON_RET]], !llvm.loop [[LOOP14:![0-9]+]]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ -1, [[LOOP_US]] ], [ 0, [[GUARDED_US]] ], [ 0, [[BACKEDGE]] ], [ -1, [[LOOP]] ], [ -2, [[GUARDED]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, [[BACKEDGE]] ], [ 0, [[GUARDED_US]] ], [ -1, [[LOOP]] ], [ -1, [[LOOP_US]] ], [ -2, [[GUARDED]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimpleLoopUnswitch/nontrivial-unswitch-freeze.ll b/llvm/test/Transforms/SimpleLoopUnswitch/nontrivial-unswitch-freeze.ll
+--- a/llvm/test/Transforms/SimpleLoopUnswitch/nontrivial-unswitch-freeze.ll
++++ b/llvm/test/Transforms/SimpleLoopUnswitch/nontrivial-unswitch-freeze.ll
+@@ -1508,7 +1508,7 @@
+ ; CHECK-NEXT:    [[TMP_B_SUM:%.*]] = add i32 [[TMP_B_PHI]], [[TMP_B]]
+ ; CHECK-NEXT:    br label [[BODY_C]]
+ ; CHECK:       body.c:
+-; CHECK-NEXT:    [[TMP_C_PHI:%.*]] = phi i32 [ [[TMP_B_SUM]], [[BODY_B]] ], [ [[TMP]], [[DISPATCH]] ]
++; CHECK-NEXT:    [[TMP_C_PHI:%.*]] = phi i32 [ [[TMP]], [[DISPATCH]] ], [ [[TMP_B_SUM]], [[BODY_B]] ]
+ ; CHECK-NEXT:    [[TMP_C:%.*]] = call i32 @c()
+ ; CHECK-NEXT:    [[TMP_C_SUM:%.*]] = add i32 [[TMP_C_PHI]], [[TMP_C]]
+ ; CHECK-NEXT:    br label [[LATCH:%.*]]
+@@ -1630,7 +1630,7 @@
+ ; CHECK-NEXT:    [[TMP_A_SUM_US9:%.*]] = add i32 [[TMP_A_PHI_US7]], [[TMP_A_US8]]
+ ; CHECK-NEXT:    br label [[BODY_B_US10]]
+ ; CHECK:       body.b.us10:
+-; CHECK-NEXT:    [[TMP_B_PHI_US11:%.*]] = phi i32 [ [[TMP_A_SUM_US9]], [[BODY_A_US6]] ], [ [[TMP_US3]], [[DISPATCH_US5]] ]
++; CHECK-NEXT:    [[TMP_B_PHI_US11:%.*]] = phi i32 [ [[TMP_US3]], [[DISPATCH_US5]] ], [ [[TMP_A_SUM_US9]], [[BODY_A_US6]] ]
+ ; CHECK-NEXT:    [[TMP_B_US12:%.*]] = call i32 @b()
+ ; CHECK-NEXT:    [[TMP_B_SUM_US13:%.*]] = add i32 [[TMP_B_PHI_US11]], [[TMP_B_US12]]
+ ; CHECK-NEXT:    br label [[LATCH_US14:%.*]]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimpleLoopUnswitch/nontrivial-unswitch.ll b/llvm/test/Transforms/SimpleLoopUnswitch/nontrivial-unswitch.ll
+--- a/llvm/test/Transforms/SimpleLoopUnswitch/nontrivial-unswitch.ll
++++ b/llvm/test/Transforms/SimpleLoopUnswitch/nontrivial-unswitch.ll
+@@ -3213,7 +3213,7 @@
+ ; CHECK-NEXT:    br label %[[BODY_C_C:.*]]
+ ;
+ ; CHECK:       [[BODY_C_C]]:
+-; CHECK-NEXT:    %[[TMP_C_PHI_C:.*]] = phi i32 [ %[[TMP_B_SUM_C]], %[[BODY_B_C]] ], [ %[[TMP_C]], %[[DISPATCH_C]] ]
++; CHECK-NEXT:    %[[TMP_C_PHI_C:.*]] = phi i32 [ %[[TMP_C]], %[[DISPATCH_C]] ], [ %[[TMP_B_SUM_C]], %[[BODY_B_C]] ]
+ ; CHECK-NEXT:    %[[TMP_C_C:.*]] = call i32 @c()
+ ; CHECK-NEXT:    %[[TMP_C_SUM_C:.*]] = add i32 %[[TMP_C_PHI_C]], %[[TMP_C_C]]
+ ; CHECK-NEXT:    br label %[[LATCH_C:.*]]
+@@ -3335,7 +3335,7 @@
+ ; CHECK-NEXT:    br label %[[BODY_B_B:.*]]
+ ;
+ ; CHECK:       [[BODY_B_B]]:
+-; CHECK-NEXT:    %[[TMP_B_PHI_B:.*]] = phi i32 [ %[[TMP_A_SUM_B]], %[[BODY_A_B]] ], [ %[[TMP_B]], %[[DISPATCH_B]] ]
++; CHECK-NEXT:    %[[TMP_B_PHI_B:.*]] = phi i32 [ %[[TMP_B]], %[[DISPATCH_B]] ], [ %[[TMP_A_SUM_B]], %[[BODY_A_B]] ]
+ ; CHECK-NEXT:    %[[TMP_B_B:.*]] = call i32 @b()
+ ; CHECK-NEXT:    %[[TMP_B_SUM_B:.*]] = add i32 %[[TMP_B_PHI_B]], %[[TMP_B_B]]
+ ; CHECK-NEXT:    br label %[[LATCH_B:.*]]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/avoid-complex-phi.ll b/llvm/test/Transforms/SimplifyCFG/avoid-complex-phi.ll
+--- a/llvm/test/Transforms/SimplifyCFG/avoid-complex-phi.ll
++++ b/llvm/test/Transforms/SimplifyCFG/avoid-complex-phi.ll
+@@ -48,11 +48,11 @@
+ ; CHECK-12:       [[B7]]:
+ ; CHECK-12-NEXT:    br label %[[MERGE]]
+ ; CHECK-12:       [[MERGE]]:
+-; CHECK-12-NEXT:    [[X1:%.*]] = phi i16 [ 2, %[[B7]] ], [ 0, %[[B6]] ], [ 1, %[[B4]] ], [ 1, %[[B3]] ], [ 1, %[[B2]] ], [ 1, %[[B1]] ]
+-; CHECK-12-NEXT:    [[X2:%.*]] = phi i16 [ 2, %[[B7]] ], [ 0, %[[B6]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ], [ 2, %[[B2]] ], [ 2, %[[B1]] ]
+-; CHECK-12-NEXT:    [[X3:%.*]] = phi i16 [ 2, %[[B7]] ], [ 0, %[[B6]] ], [ 3, %[[B4]] ], [ 3, %[[B3]] ], [ 3, %[[B2]] ], [ 3, %[[B1]] ]
+-; CHECK-12-NEXT:    [[X4:%.*]] = phi i16 [ 2, %[[B7]] ], [ 0, %[[B6]] ], [ 4, %[[B4]] ], [ 4, %[[B3]] ], [ 4, %[[B2]] ], [ 4, %[[B1]] ]
+-; CHECK-12-NEXT:    [[VAL_MERGE:%.*]] = phi i32 [ 2, %[[B7]] ], [ 0, %[[B6]] ], [ [[VAL1]], %[[B1]] ], [ [[VAL2]], %[[B2]] ], [ [[VAL3]], %[[B3]] ], [ [[VAL4]], %[[B4]] ]
++; CHECK-12-NEXT:    [[X1:%.*]] = phi i16 [ 0, %[[B6]] ], [ 2, %[[B7]] ], [ 1, %[[B4]] ], [ 1, %[[B3]] ], [ 1, %[[B2]] ], [ 1, %[[B1]] ]
++; CHECK-12-NEXT:    [[X2:%.*]] = phi i16 [ 0, %[[B6]] ], [ 2, %[[B7]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ], [ 2, %[[B2]] ], [ 2, %[[B1]] ]
++; CHECK-12-NEXT:    [[X3:%.*]] = phi i16 [ 0, %[[B6]] ], [ 2, %[[B7]] ], [ 3, %[[B4]] ], [ 3, %[[B3]] ], [ 3, %[[B2]] ], [ 3, %[[B1]] ]
++; CHECK-12-NEXT:    [[X4:%.*]] = phi i16 [ 0, %[[B6]] ], [ 2, %[[B7]] ], [ 4, %[[B4]] ], [ 4, %[[B3]] ], [ 4, %[[B2]] ], [ 4, %[[B1]] ]
++; CHECK-12-NEXT:    [[VAL_MERGE:%.*]] = phi i32 [ 0, %[[B6]] ], [ 2, %[[B7]] ], [ [[VAL1]], %[[B1]] ], [ [[VAL2]], %[[B2]] ], [ [[VAL3]], %[[B3]] ], [ [[VAL4]], %[[B4]] ]
+ ; CHECK-12-NEXT:    ret void
+ ;
+ ; CHECK-11-LABEL: define void @foo(
+@@ -79,11 +79,11 @@
+ ; CHECK-11-NEXT:    [[VAL:%.*]] = phi i32 [ [[VAL1]], %[[B1]] ], [ [[VAL2]], %[[B2]] ], [ [[VAL3]], %[[B3]] ], [ [[VAL4]], %[[B4]] ]
+ ; CHECK-11-NEXT:    br label %[[MERGE]]
+ ; CHECK-11:       [[MERGE]]:
+-; CHECK-11-NEXT:    [[X1:%.*]] = phi i16 [ 1, %[[B5]] ], [ 0, %[[B1]] ], [ 0, %[[B2]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
+-; CHECK-11-NEXT:    [[X2:%.*]] = phi i16 [ 2, %[[B5]] ], [ 0, %[[B1]] ], [ 0, %[[B2]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
+-; CHECK-11-NEXT:    [[X3:%.*]] = phi i16 [ 3, %[[B5]] ], [ 0, %[[B1]] ], [ 0, %[[B2]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
+-; CHECK-11-NEXT:    [[X4:%.*]] = phi i16 [ 4, %[[B5]] ], [ 0, %[[B1]] ], [ 0, %[[B2]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
+-; CHECK-11-NEXT:    [[VAL_MERGE:%.*]] = phi i32 [ [[VAL]], %[[B5]] ], [ 0, %[[B1]] ], [ 0, %[[B2]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
++; CHECK-11-NEXT:    [[X1:%.*]] = phi i16 [ 1, %[[B5]] ], [ 0, %[[B2]] ], [ 0, %[[B1]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
++; CHECK-11-NEXT:    [[X2:%.*]] = phi i16 [ 2, %[[B5]] ], [ 0, %[[B2]] ], [ 0, %[[B1]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
++; CHECK-11-NEXT:    [[X3:%.*]] = phi i16 [ 3, %[[B5]] ], [ 0, %[[B2]] ], [ 0, %[[B1]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
++; CHECK-11-NEXT:    [[X4:%.*]] = phi i16 [ 4, %[[B5]] ], [ 0, %[[B2]] ], [ 0, %[[B1]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
++; CHECK-11-NEXT:    [[VAL_MERGE:%.*]] = phi i32 [ [[VAL]], %[[B5]] ], [ 0, %[[B2]] ], [ 0, %[[B1]] ], [ 2, %[[B4]] ], [ 2, %[[B3]] ]
+ ; CHECK-11-NEXT:    ret void
+ ;
+ ; CHECK-4-LABEL: define void @foo(
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/branch-fold.ll b/llvm/test/Transforms/SimplifyCFG/branch-fold.ll
+--- a/llvm/test/Transforms/SimplifyCFG/branch-fold.ll
++++ b/llvm/test/Transforms/SimplifyCFG/branch-fold.ll
+@@ -125,7 +125,7 @@
+ ; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[C2:%.*]], i8 4, i8 1
+ ; CHECK-NEXT:    br label [[SUCC]]
+ ; CHECK:       Succ:
+-; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ [[SPEC_SELECT]], [[COMMONPRED]] ], [ 0, [[PRED:%.*]] ]
++; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 0, [[PRED:%.*]] ], [ [[SPEC_SELECT]], [[COMMONPRED]] ]
+ ; CHECK-NEXT:    ret i8 [[PHI2]]
+ ;
+ Pred:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/branch-fold-threshold.ll b/llvm/test/Transforms/SimplifyCFG/branch-fold-threshold.ll
+--- a/llvm/test/Transforms/SimplifyCFG/branch-fold-threshold.ll
++++ b/llvm/test/Transforms/SimplifyCFG/branch-fold-threshold.ll
+@@ -130,7 +130,7 @@
+ ; WAYAGGRESSIVE-NEXT:    [[TMP0:%.*]] = load i32, ptr [[INPUT]], align 4
+ ; WAYAGGRESSIVE-NEXT:    br label %[[COND_END]]
+ ; WAYAGGRESSIVE:       [[COND_END]]:
+-; WAYAGGRESSIVE-NEXT:    [[COND:%.*]] = phi i32 [ [[TMP0]], %[[COND_FALSE]] ], [ 0, %[[PRED_B]] ], [ 0, %[[PRED_A]] ]
++; WAYAGGRESSIVE-NEXT:    [[COND:%.*]] = phi i32 [ [[TMP0]], %[[COND_FALSE]] ], [ 0, %[[PRED_A]] ], [ 0, %[[PRED_B]] ]
+ ; WAYAGGRESSIVE-NEXT:    ret i32 [[COND]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/EqualPHIEdgeBlockMerge.ll b/llvm/test/Transforms/SimplifyCFG/EqualPHIEdgeBlockMerge.ll
+--- a/llvm/test/Transforms/SimplifyCFG/EqualPHIEdgeBlockMerge.ll
++++ b/llvm/test/Transforms/SimplifyCFG/EqualPHIEdgeBlockMerge.ll
+@@ -114,7 +114,7 @@
+ ; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
+ ; CHECK-NEXT:    br label [[Y]]
+ ; CHECK:       Y:
+-; CHECK-NEXT:    [[VAL_0:%.*]] = phi i8 [ 1, [[V:%.*]] ], [ 2, [[W]] ], [ 1, [[Z]] ]
++; CHECK-NEXT:    [[VAL_0:%.*]] = phi i8 [ 2, [[W]] ], [ 1, [[Z]] ], [ 1, [[V:%.*]] ]
+ ; CHECK-NEXT:    ret i8 [[VAL_0]]
+ ;
+ V:
+@@ -156,7 +156,7 @@
+ ; CHECK-NEXT:    store i32 1, ptr [[A:%.*]], align 4
+ ; CHECK-NEXT:    br label [[Y]]
+ ; CHECK:       Y:
+-; CHECK-NEXT:    [[VAL_0:%.*]] = phi i8 [ 1, [[V:%.*]] ], [ 1, [[V]] ], [ 2, [[W]] ], [ 1, [[V]] ]
++; CHECK-NEXT:    [[VAL_0:%.*]] = phi i8 [ 1, [[V:%.*]] ], [ 2, [[W]] ], [ 1, [[V]] ], [ 1, [[V]] ]
+ ; CHECK-NEXT:    ret i8 [[VAL_0]]
+ ;
+ V:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/ForwardSwitchConditionToPHI.ll b/llvm/test/Transforms/SimplifyCFG/ForwardSwitchConditionToPHI.ll
+--- a/llvm/test/Transforms/SimplifyCFG/ForwardSwitchConditionToPHI.ll
++++ b/llvm/test/Transforms/SimplifyCFG/ForwardSwitchConditionToPHI.ll
+@@ -146,7 +146,7 @@
+ ; NO_FWD:       else3:
+ ; NO_FWD-NEXT:    br label [[RETURN]]
+ ; NO_FWD:       return:
+-; NO_FWD-NEXT:    [[R:%.*]] = phi i32 [ [[X]], [[IF19]] ], [ 17, [[ENTRY:%.*]] ], [ 0, [[ELSE3]] ]
++; NO_FWD-NEXT:    [[R:%.*]] = phi i32 [ [[X]], [[IF19]] ], [ 0, [[ELSE3]] ], [ 17, [[ENTRY:%.*]] ]
+ ; NO_FWD-NEXT:    ret i32 [[R]]
+ ;
+ ; FWD-LABEL: @PR34471(
+@@ -159,7 +159,7 @@
+ ; FWD:       else3:
+ ; FWD-NEXT:    br label [[RETURN]]
+ ; FWD:       return:
+-; FWD-NEXT:    [[R:%.*]] = phi i32 [ [[X]], [[ENTRY:%.*]] ], [ [[X]], [[ENTRY]] ], [ 0, [[ELSE3]] ], [ [[X]], [[ENTRY]] ]
++; FWD-NEXT:    [[R:%.*]] = phi i32 [ 0, [[ELSE3]] ], [ [[X]], [[ENTRY:%.*]] ], [ [[X]], [[ENTRY]] ], [ [[X]], [[ENTRY]] ]
+ ; FWD-NEXT:    ret i32 [[R]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/Hexagon/switch-to-lookup-table.ll b/llvm/test/Transforms/SimplifyCFG/Hexagon/switch-to-lookup-table.ll
+--- a/llvm/test/Transforms/SimplifyCFG/Hexagon/switch-to-lookup-table.ll
++++ b/llvm/test/Transforms/SimplifyCFG/Hexagon/switch-to-lookup-table.ll
+@@ -43,7 +43,7 @@
+ ; DISABLE:       sw.default:
+ ; DISABLE-NEXT:    br label [[RETURN]]
+ ; DISABLE:       return:
+-; DISABLE-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 19, [[SW_DEFAULT]] ], [ 33, [[SW_BB5]] ], [ 20, [[SW_BB1]] ], [ 14, [[SW_BB2]] ], [ 22, [[SW_BB3]] ], [ 12, [[SW_BB4]] ], [ 9, [[ENTRY:%.*]] ]
++; DISABLE-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 19, [[SW_DEFAULT]] ], [ 20, [[SW_BB1]] ], [ 14, [[SW_BB2]] ], [ 22, [[SW_BB3]] ], [ 12, [[SW_BB4]] ], [ 33, [[SW_BB5]] ], [ 9, [[ENTRY:%.*]] ]
+ ; DISABLE-NEXT:    ret i32 [[RETVAL_0]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/HoistCode.ll b/llvm/test/Transforms/SimplifyCFG/HoistCode.ll
+--- a/llvm/test/Transforms/SimplifyCFG/HoistCode.ll
++++ b/llvm/test/Transforms/SimplifyCFG/HoistCode.ll
+@@ -70,7 +70,7 @@
+ ; CHECK:       bb1:
+ ; CHECK-NEXT:    br label [[END]]
+ ; CHECK:       end:
+-; CHECK-NEXT:    [[COND:%.*]] = phi fast float [ 0.000000e+00, [[ENTRY:%.*]] ], [ [[X:%.*]], [[BB1]] ]
++; CHECK-NEXT:    [[COND:%.*]] = phi fast float [ [[X:%.*]], [[BB1]] ], [ 0.000000e+00, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    ret float [[COND]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/merge-phis-in-switch.ll b/llvm/test/Transforms/SimplifyCFG/merge-phis-in-switch.ll
+--- a/llvm/test/Transforms/SimplifyCFG/merge-phis-in-switch.ll
++++ b/llvm/test/Transforms/SimplifyCFG/merge-phis-in-switch.ll
+@@ -237,7 +237,7 @@
+ ; CHECK:       case345:
+ ; CHECK-NEXT:    br label [[CASE0123456]]
+ ; CHECK:       case0123456:
+-; CHECK-NEXT:    [[PHI1234567:%.*]] = phi i8 [ 7, [[START:%.*]] ], [ 3, [[CASE012]] ], [ 2, [[CASE1]] ], [ 1, [[CASE0]] ], [ 5, [[CASE4]] ], [ 4, [[CASE3]] ], [ 6, [[CASE345]] ]
++; CHECK-NEXT:    [[PHI1234567:%.*]] = phi i8 [ 7, [[START:%.*]] ], [ 2, [[CASE1]] ], [ 1, [[CASE0]] ], [ 3, [[CASE012]] ], [ 5, [[CASE4]] ], [ 4, [[CASE3]] ], [ 6, [[CASE345]] ]
+ ; CHECK-NEXT:    ret i8 [[PHI1234567]]
+ ;
+ start:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/multiple-phis.ll b/llvm/test/Transforms/SimplifyCFG/multiple-phis.ll
+--- a/llvm/test/Transforms/SimplifyCFG/multiple-phis.ll
++++ b/llvm/test/Transforms/SimplifyCFG/multiple-phis.ll
+@@ -64,8 +64,8 @@
+ ; CHECK-LABEL: define i32 @merge0
+ ; CHECK-SAME: (i1 [[C1:%.*]], i1 [[C2:%.*]], i1 [[C3:%.*]]) {
+ ; CHECK-NEXT:  j2:
+-; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[C3]], i32 2, i32 3
+ ; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[C2]], i32 0, i32 1
++; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[C3]], i32 2, i32 3
+ ; CHECK-NEXT:    [[PHI2:%.*]] = select i1 [[C1]], i32 [[DOT]], i32 [[SPEC_SELECT]]
+ ; CHECK-NEXT:    ret i32 [[PHI2]]
+ ;
+@@ -111,7 +111,7 @@
+ ; CHECK:       case2:
+ ; CHECK-NEXT:    br label [[SUCC]]
+ ; CHECK:       Succ:
+-; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ [[SPEC_SELECT]], [[CASE0]] ], [ 1, [[ENTRY:%.*]] ], [ 2, [[CASE2]] ]
++; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 2, [[CASE2]] ], [ 1, [[ENTRY:%.*]] ], [ [[SPEC_SELECT]], [[CASE0]] ]
+ ; CHECK-NEXT:    ret i8 [[PHI2]]
+ ;
+ entry:
+@@ -167,7 +167,7 @@
+ ; CHECK:       case2:
+ ; CHECK-NEXT:    br label [[SUCC]]
+ ; CHECK:       Succ:
+-; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ [[SPEC_SELECT]], [[CASE0]] ], [ 1, [[ENTRY:%.*]] ], [ 2, [[CASE2]] ]
++; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 2, [[CASE2]] ], [ 1, [[ENTRY:%.*]] ], [ [[SPEC_SELECT]], [[CASE0]] ]
+ ; CHECK-NEXT:    ret i8 [[PHI2]]
+ ;
+ entry:
+@@ -225,7 +225,7 @@
+ ; CHECK-NEXT:    call void @dummy()
+ ; CHECK-NEXT:    br label [[SUCC]]
+ ; CHECK:       Succ:
+-; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ [[SPEC_SELECT]], [[CASE0]] ], [ 1, [[CASE1]] ], [ 2, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 1, [[CASE1]] ], [ 2, [[ENTRY:%.*]] ], [ [[SPEC_SELECT]], [[CASE0]] ]
+ ; CHECK-NEXT:    ret i8 [[PHI2]]
+ ;
+ entry:
+@@ -286,7 +286,7 @@
+ ; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[C2]], i8 4, i8 3
+ ; CHECK-NEXT:    br label [[SUCC]]
+ ; CHECK:       Succ:
+-; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ [[SPEC_SELECT]], [[COMMONPRED]] ], [ 0, [[CASE0]] ], [ 1, [[CASE1]] ], [ 2, [[CASE2]] ]
++; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 0, [[CASE0]] ], [ 1, [[CASE1]] ], [ 2, [[CASE2]] ], [ [[SPEC_SELECT]], [[COMMONPRED]] ]
+ ; CHECK-NEXT:    ret i8 [[PHI2]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/rangereduce.ll b/llvm/test/Transforms/SimplifyCFG/rangereduce.ll
+--- a/llvm/test/Transforms/SimplifyCFG/rangereduce.ll
++++ b/llvm/test/Transforms/SimplifyCFG/rangereduce.ll
+@@ -54,7 +54,7 @@
+ ; CHECK-NEXT:      i128 109, label [[THREE]]
+ ; CHECK-NEXT:    ]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i128 [ 99783, [[THREE]] ], [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 8867, [[TMP0:%.*]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i128 [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 99783, [[THREE]] ], [ 8867, [[TMP0:%.*]] ]
+ ; CHECK-NEXT:    ret i128 [[COMMON_RET_OP]]
+ ; CHECK:       one:
+ ; CHECK-NEXT:    br label [[COMMON_RET]]
+@@ -123,7 +123,7 @@
+ ; CHECK-NEXT:      i32 109, label [[THREE]]
+ ; CHECK-NEXT:    ]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 99783, [[THREE]] ], [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 8867, [[TMP0:%.*]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 99783, [[THREE]] ], [ 8867, [[TMP0:%.*]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ; CHECK:       one:
+ ; CHECK-NEXT:    br label [[COMMON_RET]]
+@@ -160,7 +160,7 @@
+ ; CHECK-NEXT:      i32 112, label [[THREE]]
+ ; CHECK-NEXT:    ]
+ ; CHECK:       common.ret:
+-; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 99783, [[THREE]] ], [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 8867, [[TMP0:%.*]] ]
++; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 99783, [[THREE]] ], [ 8867, [[TMP0:%.*]] ]
+ ; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
+ ; CHECK:       one:
+ ; CHECK-NEXT:    br label [[COMMON_RET]]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/RISCV/switch-of-powers-of-two.ll b/llvm/test/Transforms/SimplifyCFG/RISCV/switch-of-powers-of-two.ll
+--- a/llvm/test/Transforms/SimplifyCFG/RISCV/switch-of-powers-of-two.ll
++++ b/llvm/test/Transforms/SimplifyCFG/RISCV/switch-of-powers-of-two.ll
+@@ -28,7 +28,7 @@
+ ; RV64I:       bb5:
+ ; RV64I-NEXT:    br label [[RETURN]]
+ ; RV64I:       return:
+-; RV64I-NEXT:    [[P:%.*]] = phi i32 [ 42, [[BB5]] ], [ 2, [[BB2]] ], [ 1, [[BB3]] ], [ 0, [[BB4]] ], [ 3, [[ENTRY:%.*]] ]
++; RV64I-NEXT:    [[P:%.*]] = phi i32 [ 2, [[BB2]] ], [ 1, [[BB3]] ], [ 0, [[BB4]] ], [ 42, [[BB5]] ], [ 3, [[ENTRY:%.*]] ]
+ ; RV64I-NEXT:    ret i32 [[P]]
+ ;
+ ; RV64ZBB-LABEL: @switch_of_powers(
+@@ -102,7 +102,7 @@
+ ; RV64ZBB-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
+ ; RV64ZBB-NEXT:    br label [[RETURN]]
+ ; RV64ZBB:       return:
+-; RV64ZBB-NEXT:    [[P:%.*]] = phi i32 [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ], [ -1, [[ENTRY_SPLIT]] ], [ -1, [[ENTRY:%.*]] ]
++; RV64ZBB-NEXT:    [[P:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ -1, [[ENTRY_SPLIT]] ], [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ]
+ ; RV64ZBB-NEXT:    ret i32 [[P]]
+ ;
+ entry:
+@@ -149,7 +149,7 @@
+ ; CHECK:       bb5:
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[P:%.*]] = phi i32 [ 42, [[BB5]] ], [ 2, [[BB2]] ], [ 1, [[BB3]] ], [ 0, [[BB4]] ], [ 3, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[P:%.*]] = phi i32 [ 2, [[BB2]] ], [ 1, [[BB3]] ], [ 0, [[BB4]] ], [ 42, [[BB5]] ], [ 3, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    ret i32 [[P]]
+ ;
+ entry:
+@@ -192,7 +192,7 @@
+ ; CHECK:       bb5:
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[P:%.*]] = phi i32 [ 42, [[BB5]] ], [ 0, [[BB4]] ], [ 1, [[BB3]] ], [ 2, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[P:%.*]] = phi i32 [ 1, [[BB3]] ], [ 0, [[BB4]] ], [ 42, [[BB5]] ], [ 2, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    ret i32 [[P]]
+ ;
+ entry:
+@@ -248,7 +248,7 @@
+ ; RV64I-NEXT:    [[ADD5:%.*]] = add i32 [[CALL5]], [[X]]
+ ; RV64I-NEXT:    br label [[RETURN]]
+ ; RV64I:       return:
+-; RV64I-NEXT:    [[P:%.*]] = phi i32 [ [[ADD5]], [[BB5]] ], [ [[ADD2]], [[BB2]] ], [ [[ADD3]], [[BB3]] ], [ [[ADD4]], [[BB4]] ]
++; RV64I-NEXT:    [[P:%.*]] = phi i32 [ [[ADD2]], [[BB2]] ], [ [[ADD3]], [[BB3]] ], [ [[ADD4]], [[BB4]] ], [ [[ADD5]], [[BB5]] ]
+ ; RV64I-NEXT:    ret i32 [[P]]
+ ;
+ ; RV64ZBB-LABEL: @unable_to_generate_lookup_table(
+@@ -282,7 +282,7 @@
+ ; RV64ZBB-NEXT:    [[ADD5:%.*]] = add i32 [[CALL5]], [[X]]
+ ; RV64ZBB-NEXT:    br label [[RETURN]]
+ ; RV64ZBB:       return:
+-; RV64ZBB-NEXT:    [[P:%.*]] = phi i32 [ [[ADD5]], [[BB5]] ], [ [[ADD2]], [[BB2]] ], [ [[ADD3]], [[BB3]] ], [ [[ADD4]], [[BB4]] ]
++; RV64ZBB-NEXT:    [[P:%.*]] = phi i32 [ [[ADD2]], [[BB2]] ], [ [[ADD3]], [[BB3]] ], [ [[ADD4]], [[BB4]] ], [ [[ADD5]], [[BB5]] ]
+ ; RV64ZBB-NEXT:    ret i32 [[P]]
+ ;
+ entry:
+@@ -344,7 +344,7 @@
+ ; CHECK:       bb5:
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[P:%.*]] = phi i128 [ 42, [[BB5]] ], [ 0, [[BB4]] ], [ 1, [[BB3]] ], [ 2, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[P:%.*]] = phi i128 [ 1, [[BB3]] ], [ 0, [[BB4]] ], [ 42, [[BB5]] ], [ 2, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    ret i128 [[P]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/switch_create-custom-dl.ll b/llvm/test/Transforms/SimplifyCFG/switch_create-custom-dl.ll
+--- a/llvm/test/Transforms/SimplifyCFG/switch_create-custom-dl.ll
++++ b/llvm/test/Transforms/SimplifyCFG/switch_create-custom-dl.ll
+@@ -215,7 +215,7 @@
+ ; CHECK:       lor.rhs:
+ ; CHECK-NEXT:    br label [[LOR_END]]
+ ; CHECK:       lor.end:
+-; CHECK-NEXT:    [[TMP0:%.*]] = phi i1 [ true, [[ENTRY:%.*]] ], [ true, [[ENTRY]] ], [ false, [[LOR_RHS]] ], [ true, [[ENTRY]] ]
++; CHECK-NEXT:    [[TMP0:%.*]] = phi i1 [ true, [[ENTRY:%.*]] ], [ false, [[LOR_RHS]] ], [ true, [[ENTRY]] ], [ true, [[ENTRY]] ]
+ ; CHECK-NEXT:    [[LOR_EXT:%.*]] = zext i1 [[TMP0]] to i32
+ ; CHECK-NEXT:    ret i32 [[LOR_EXT]]
+ ;
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/switch_create.ll b/llvm/test/Transforms/SimplifyCFG/switch_create.ll
+--- a/llvm/test/Transforms/SimplifyCFG/switch_create.ll
++++ b/llvm/test/Transforms/SimplifyCFG/switch_create.ll
+@@ -212,7 +212,7 @@
+ ; CHECK:       lor.rhs:
+ ; CHECK-NEXT:    br label [[LOR_END]]
+ ; CHECK:       lor.end:
+-; CHECK-NEXT:    [[TMP0:%.*]] = phi i1 [ true, [[ENTRY:%.*]] ], [ true, [[ENTRY]] ], [ false, [[LOR_RHS]] ], [ true, [[ENTRY]] ]
++; CHECK-NEXT:    [[TMP0:%.*]] = phi i1 [ true, [[ENTRY:%.*]] ], [ false, [[LOR_RHS]] ], [ true, [[ENTRY]] ], [ true, [[ENTRY]] ]
+ ; CHECK-NEXT:    [[LOR_EXT:%.*]] = zext i1 [[TMP0]] to i32
+ ; CHECK-NEXT:    ret i32 [[LOR_EXT]]
+ ;
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/switch-dup-bbs.ll b/llvm/test/Transforms/SimplifyCFG/switch-dup-bbs.ll
+--- a/llvm/test/Transforms/SimplifyCFG/switch-dup-bbs.ll
++++ b/llvm/test/Transforms/SimplifyCFG/switch-dup-bbs.ll
+@@ -142,7 +142,7 @@
+ ; SIMPLIFY-CFG:       [[DEFAULT]]:
+ ; SIMPLIFY-CFG-NEXT:    br label %[[EXIT]]
+ ; SIMPLIFY-CFG:       [[EXIT]]:
+-; SIMPLIFY-CFG-NEXT:    [[RET:%.*]] = phi i32 [ 0, %[[DEFAULT]] ], [ 1, %[[ENTRY]] ], [ 3, %[[BB1]] ], [ 1, %[[ENTRY]] ]
++; SIMPLIFY-CFG-NEXT:    [[RET:%.*]] = phi i32 [ 0, %[[DEFAULT]] ], [ 3, %[[BB1]] ], [ 1, %[[ENTRY]] ], [ 1, %[[ENTRY]] ]
+ ; SIMPLIFY-CFG-NEXT:    ret i32 [[RET]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/switch-on-const.ll b/llvm/test/Transforms/SimplifyCFG/switch-on-const.ll
+--- a/llvm/test/Transforms/SimplifyCFG/switch-on-const.ll
++++ b/llvm/test/Transforms/SimplifyCFG/switch-on-const.ll
+@@ -17,7 +17,7 @@
+ ; CHECK-NEXT:    tail call void @bees.a() #[[ATTR0:[0-9]+]]
+ ; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
+ ; CHECK:       b:
+-; CHECK-NEXT:    [[RETVAL]] = phi i32 [ 2, [[ENTRY:%.*]] ], [ 0, [[SWITCH]] ]
++; CHECK-NEXT:    [[RETVAL]] = phi i32 [ 0, [[SWITCH]] ], [ 2, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    tail call void @bees.b() #[[ATTR0]]
+ ; CHECK-NEXT:    br label [[COMMON_RET]]
+ ;
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/switch-simplify-crash2.ll b/llvm/test/Transforms/SimplifyCFG/switch-simplify-crash2.ll
+--- a/llvm/test/Transforms/SimplifyCFG/switch-simplify-crash2.ll
++++ b/llvm/test/Transforms/SimplifyCFG/switch-simplify-crash2.ll
+@@ -6,7 +6,7 @@
+ ; CHECK-NEXT:  entry:
+ ; CHECK-NEXT:    br label [[LOOP2:%.*]]
+ ; CHECK:       loop2:
+-; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ [[SPEC_SELECT:%.*]], [[LOOP2]] ], [ 0, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 0, [[ENTRY:%.*]] ], [ [[SPEC_SELECT:%.*]], [[LOOP2]] ]
+ ; CHECK-NEXT:    [[COND:%.*]] = icmp eq i8 [[PHI2]], 0
+ ; CHECK-NEXT:    [[SPEC_SELECT]] = select i1 [[COND]], i8 0, i8 [[PHI2]]
+ ; CHECK-NEXT:    br label [[LOOP2]]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/switch-to-select-two-case.ll b/llvm/test/Transforms/SimplifyCFG/switch-to-select-two-case.ll
+--- a/llvm/test/Transforms/SimplifyCFG/switch-to-select-two-case.ll
++++ b/llvm/test/Transforms/SimplifyCFG/switch-to-select-two-case.ll
+@@ -279,7 +279,7 @@
+ ; CHECK:       default:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       end:
+-; CHECK-NEXT:    [[T0:%.*]] = phi i8 [ 42, [[ENTRY:%.*]] ], [ 42, [[ENTRY]] ], [ 44, [[CASE3]] ]
++; CHECK-NEXT:    [[T0:%.*]] = phi i8 [ 44, [[CASE3]] ], [ 42, [[ENTRY:%.*]] ], [ 42, [[ENTRY]] ]
+ ; CHECK-NEXT:    ret i8 [[T0]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/switch-transformations-no-lut.ll b/llvm/test/Transforms/SimplifyCFG/switch-transformations-no-lut.ll
+--- a/llvm/test/Transforms/SimplifyCFG/switch-transformations-no-lut.ll
++++ b/llvm/test/Transforms/SimplifyCFG/switch-transformations-no-lut.ll
+@@ -24,7 +24,7 @@
+ ; TTINOLUT-NEXT:    [[SWITCH_OFFSET:%.*]] = add nsw i32 [[SWITCH_IDX_MULT]], 1
+ ; TTINOLUT-NEXT:    br label %[[END]]
+ ; TTINOLUT:       [[END]]:
+-; TTINOLUT-NEXT:    [[IDX:%.*]] = phi i32 [ [[SWITCH_OFFSET]], %[[SWITCH_LOOKUP]] ], [ 13, %[[ENTRY]] ]
++; TTINOLUT-NEXT:    [[IDX:%.*]] = phi i32 [ 13, %[[ENTRY]] ], [ [[SWITCH_OFFSET]], %[[SWITCH_LOOKUP]] ]
+ ; TTINOLUT-NEXT:    ret i32 [[IDX]]
+ ;
+ entry:
+@@ -182,7 +182,7 @@
+ ; OPTNOLUT:       [[DEFAULT]]:
+ ; OPTNOLUT-NEXT:    unreachable
+ ; OPTNOLUT:       [[END]]:
+-; OPTNOLUT-NEXT:    [[SWITCH_MASKED:%.*]] = phi i4 [ -8, %[[CASE3]] ], [ 2, %[[CASE1]] ], [ 4, %[[CASE2]] ], [ 0, %[[ENTRY]] ]
++; OPTNOLUT-NEXT:    [[SWITCH_MASKED:%.*]] = phi i4 [ 2, %[[CASE1]] ], [ 4, %[[CASE2]] ], [ -8, %[[CASE3]] ], [ 0, %[[ENTRY]] ]
+ ; OPTNOLUT-NEXT:    ret i4 [[SWITCH_MASKED]]
+ ;
+ ; TTINOLUT-LABEL: define i4 @bitmap_no_default(
+@@ -237,7 +237,7 @@
+ ; OPTNOLUT:       [[DEFAULT]]:
+ ; OPTNOLUT-NEXT:    br label %[[END]]
+ ; OPTNOLUT:       [[END]]:
+-; OPTNOLUT-NEXT:    [[IDX:%.*]] = phi i4 [ -1, %[[DEFAULT]] ], [ 2, %[[CASE1]] ], [ 4, %[[CASE2]] ], [ -8, %[[CASE3]] ], [ 0, %[[ENTRY]] ]
++; OPTNOLUT-NEXT:    [[IDX:%.*]] = phi i4 [ 2, %[[CASE1]] ], [ 4, %[[CASE2]] ], [ -8, %[[CASE3]] ], [ -1, %[[DEFAULT]] ], [ 0, %[[ENTRY]] ]
+ ; OPTNOLUT-NEXT:    ret i4 [[IDX]]
+ ;
+ ; TTINOLUT-LABEL: define i4 @bitmap_with_default(
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/UnreachableEliminate.ll b/llvm/test/Transforms/SimplifyCFG/UnreachableEliminate.ll
+--- a/llvm/test/Transforms/SimplifyCFG/UnreachableEliminate.ll
++++ b/llvm/test/Transforms/SimplifyCFG/UnreachableEliminate.ll
+@@ -644,7 +644,7 @@
+ ; CHECK:       default:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 1, [[ENTRY:%.*]] ], [ 3, [[CASE2]] ], [ 2, [[CASE1]] ]
++; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 2, [[CASE1]] ], [ 3, [[CASE2]] ], [ 1, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    call void @llvm.assume(i1 true)
+ ; CHECK-NEXT:    ret i32 [[RES]]
+ ;
+@@ -689,7 +689,7 @@
+ ; CHECK:       default:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 1, [[ENTRY:%.*]] ], [ 3, [[CASE2]] ], [ 2, [[CASE1]] ]
++; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 2, [[CASE1]] ], [ 3, [[CASE2]] ], [ 1, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    call void @llvm.assume(i1 true)
+ ; CHECK-NEXT:    ret i32 [[RES]]
+ ;
+@@ -734,8 +734,8 @@
+ ; CHECK:       default:
+ ; CHECK-NEXT:    br label [[EXIT]]
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[BOOL:%.*]] = phi i1 [ [[VAR:%.*]], [[DEFAULT]] ], [ true, [[CASE2]] ], [ true, [[CASE1]] ], [ true, [[ENTRY:%.*]] ]
+-; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 0, [[DEFAULT]] ], [ 3, [[CASE2]] ], [ 2, [[CASE1]] ], [ 1, [[ENTRY]] ]
++; CHECK-NEXT:    [[BOOL:%.*]] = phi i1 [ [[VAR:%.*]], [[DEFAULT]] ], [ true, [[CASE1]] ], [ true, [[CASE2]] ], [ true, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 0, [[DEFAULT]] ], [ 2, [[CASE1]] ], [ 3, [[CASE2]] ], [ 1, [[ENTRY]] ]
+ ; CHECK-NEXT:    call void @llvm.assume(i1 [[BOOL]])
+ ; CHECK-NEXT:    ret i32 [[RES]]
+ ;
+@@ -780,8 +780,8 @@
+ ; CHECK:       default:
+ ; CHECK-NEXT:    br label [[EXIT]]
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[PTR:%.*]] = phi ptr [ null, [[DEFAULT]] ], [ [[P:%.*]], [[CASE2]] ], [ [[P]], [[CASE1]] ], [ [[P]], [[ENTRY:%.*]] ]
+-; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 0, [[DEFAULT]] ], [ 3, [[CASE2]] ], [ 2, [[CASE1]] ], [ 1, [[ENTRY]] ]
++; CHECK-NEXT:    [[PTR:%.*]] = phi ptr [ null, [[DEFAULT]] ], [ [[P:%.*]], [[CASE1]] ], [ [[P]], [[CASE2]] ], [ [[P]], [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 0, [[DEFAULT]] ], [ 2, [[CASE1]] ], [ 3, [[CASE2]] ], [ 1, [[ENTRY]] ]
+ ; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(ptr [[PTR]]) ]
+ ; CHECK-NEXT:    ret i32 [[RES]]
+ ;
+@@ -826,8 +826,8 @@
+ ; CHECK:       default:
+ ; CHECK-NEXT:    br label [[EXIT]]
+ ; CHECK:       exit:
+-; CHECK-NEXT:    [[PTR:%.*]] = phi ptr [ null, [[DEFAULT]] ], [ [[P:%.*]], [[CASE2]] ], [ [[P]], [[CASE1]] ], [ [[P]], [[ENTRY:%.*]] ]
+-; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 0, [[DEFAULT]] ], [ 3, [[CASE2]] ], [ 2, [[CASE1]] ], [ 1, [[ENTRY]] ]
++; CHECK-NEXT:    [[PTR:%.*]] = phi ptr [ null, [[DEFAULT]] ], [ [[P:%.*]], [[CASE1]] ], [ [[P]], [[CASE2]] ], [ [[P]], [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 0, [[DEFAULT]] ], [ 2, [[CASE1]] ], [ 3, [[CASE2]] ], [ 1, [[ENTRY]] ]
+ ; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[PTR]], i32 8) ]
+ ; CHECK-NEXT:    ret i32 [[RES]]
+ ;
+@@ -952,7 +952,7 @@
+ ; CHECK:       sw.default:
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[Y:%.*]] = phi i8 [ [[V:%.*]], [[SW_DEFAULT]] ], [ 9, [[SW_BB2]] ], [ 2, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[Y:%.*]] = phi i8 [ 9, [[SW_BB2]] ], [ [[V:%.*]], [[SW_DEFAULT]] ], [ 2, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    [[R:%.*]] = udiv i8 [[X:%.*]], [[Y]]
+ ; CHECK-NEXT:    ret i8 [[R]]
+ ;
+@@ -994,7 +994,7 @@
+ ; CHECK:       sw.default:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[Y:%.*]] = phi i8 [ [[V:%.*]], [[ENTRY:%.*]] ], [ 2, [[SW_BB1]] ], [ 9, [[SW_BB2]] ]
++; CHECK-NEXT:    [[Y:%.*]] = phi i8 [ 2, [[SW_BB1]] ], [ 9, [[SW_BB2]] ], [ [[V:%.*]], [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    [[R:%.*]] = urem i8 [[X:%.*]], [[Y]]
+ ; CHECK-NEXT:    ret i8 [[R]]
+ ;
+@@ -1036,7 +1036,7 @@
+ ; CHECK:       sw.default:
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[Y:%.*]] = phi i8 [ [[V:%.*]], [[SW_DEFAULT]] ], [ 2, [[SW_BB1]] ], [ 9, [[SW_BB2]] ], [ 0, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[Y:%.*]] = phi i8 [ 2, [[SW_BB1]] ], [ 9, [[SW_BB2]] ], [ [[V:%.*]], [[SW_DEFAULT]] ], [ 0, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    [[R:%.*]] = udiv i8 [[Y]], [[X:%.*]]
+ ; CHECK-NEXT:    ret i8 [[R]]
+ ;
+@@ -1144,7 +1144,7 @@
+ ; CHECK:       sw.default:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[Y:%.*]] = phi i8 [ -1, [[SW_BB2]] ], [ [[V]], [[SW_BB1]] ], [ 4, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[Y:%.*]] = phi i8 [ [[V]], [[SW_BB1]] ], [ -1, [[SW_BB2]] ], [ 4, [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    [[R:%.*]] = sdiv i8 -128, [[Y]]
+ ; CHECK-NEXT:    ret i8 [[R]]
+ ;
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/X86/debugloc-switch-powers-of-two.ll b/llvm/test/Transforms/SimplifyCFG/X86/debugloc-switch-powers-of-two.ll
+--- a/llvm/test/Transforms/SimplifyCFG/X86/debugloc-switch-powers-of-two.ll
++++ b/llvm/test/Transforms/SimplifyCFG/X86/debugloc-switch-powers-of-two.ll
+@@ -23,7 +23,7 @@
+ ; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4, !dbg [[DBG8]]
+ ; CHECK-NEXT:    br label %[[RETURN]], !dbg [[DBG8]]
+ ; CHECK:       [[RETURN]]:
+-; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[SWITCH_LOAD]], %[[SWITCH_LOOKUP]] ], [ 5, %[[ENTRY_SPLIT]] ], [ 5, %[[ENTRY]] ]
++; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 5, %[[ENTRY]] ], [ 5, %[[ENTRY_SPLIT]] ], [ [[SWITCH_LOAD]], %[[SWITCH_LOOKUP]] ]
+ ; CHECK-NEXT:    ret i32 [[PHI]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/X86/empty-cleanuppad.ll b/llvm/test/Transforms/SimplifyCFG/X86/empty-cleanuppad.ll
+--- a/llvm/test/Transforms/SimplifyCFG/X86/empty-cleanuppad.ll
++++ b/llvm/test/Transforms/SimplifyCFG/X86/empty-cleanuppad.ll
+@@ -318,7 +318,7 @@
+ ; CHECK-NEXT:    invoke void @g()
+ ; CHECK-NEXT:            to label [[RETURN:%.*]] unwind label [[CATCH_DISPATCH]]
+ ; CHECK:       catch.dispatch:
+-; CHECK-NEXT:    [[STATE_1:%.*]] = phi i32 [ 2, [[INVOKE_CONT]] ], [ 1, [[ENTRY:%.*]] ], [ 3, [[INVOKE_CONT_1]] ]
++; CHECK-NEXT:    [[STATE_1:%.*]] = phi i32 [ 1, [[ENTRY:%.*]] ], [ 3, [[INVOKE_CONT_1]] ], [ 2, [[INVOKE_CONT]] ]
+ ; CHECK-NEXT:    [[CS1:%.*]] = catchswitch within none [label %catch] unwind to caller
+ ; CHECK:       catch:
+ ; CHECK-NEXT:    [[TMP0:%.*]] = catchpad within [[CS1]] [ptr null, i32 64, ptr null]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/X86/switch-of-powers-of-two.ll b/llvm/test/Transforms/SimplifyCFG/X86/switch-of-powers-of-two.ll
+--- a/llvm/test/Transforms/SimplifyCFG/X86/switch-of-powers-of-two.ll
++++ b/llvm/test/Transforms/SimplifyCFG/X86/switch-of-powers-of-two.ll
+@@ -57,7 +57,7 @@
+ ; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
+ ; CHECK-NEXT:    br label %[[RETURN]]
+ ; CHECK:       [[RETURN]]:
+-; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[SWITCH_LOAD]], %[[SWITCH_LOOKUP]] ], [ 5, %[[ENTRY_SPLIT]] ], [ 5, %[[ENTRY]] ]
++; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 5, %[[ENTRY]] ], [ 5, %[[ENTRY_SPLIT]] ], [ [[SWITCH_LOAD]], %[[SWITCH_LOOKUP]] ]
+ ; CHECK-NEXT:    ret i32 [[PHI]]
+ ;
+ entry:
+@@ -104,7 +104,7 @@
+ ; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
+ ; CHECK-NEXT:    br label %[[RETURN]]
+ ; CHECK:       [[RETURN]]:
+-; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[SWITCH_LOAD]], %[[SWITCH_LOOKUP]] ], [ 0, %[[ENTRY]] ], [ [[ARG]], %[[SWITCH]] ], [ [[ARG]], %[[SWITCH_SPLIT]] ]
++; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[ARG]], %[[SWITCH_SPLIT]] ], [ [[ARG]], %[[SWITCH]] ], [ [[SWITCH_LOAD]], %[[SWITCH_LOOKUP]] ]
+ ; CHECK-NEXT:    ret i32 [[PHI]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/X86/switch-to-lookup-gep.ll b/llvm/test/Transforms/SimplifyCFG/X86/switch-to-lookup-gep.ll
+--- a/llvm/test/Transforms/SimplifyCFG/X86/switch-to-lookup-gep.ll
++++ b/llvm/test/Transforms/SimplifyCFG/X86/switch-to-lookup-gep.ll
+@@ -57,7 +57,7 @@
+ ; CHECK:       default:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       end:
+-; CHECK-NEXT:    [[DOTSROA_0_0:%.*]] = phi ptr [ getelementptr (<{ [2 x i8] }>, ptr @alloc2, i32 0, i32 0, i32 4), [[BB2]] ], [ getelementptr (<{ [2 x i8] }>, ptr @alloc1, i32 0, i32 0, i32 4), [[BB1]] ], [ getelementptr (<{ [2 x i8] }>, ptr @alloc0, i32 0, i32 0, i32 4), [[START:%.*]] ]
++; CHECK-NEXT:    [[DOTSROA_0_0:%.*]] = phi ptr [ getelementptr (<{ [2 x i8] }>, ptr @alloc1, i32 0, i32 0, i32 4), [[BB1]] ], [ getelementptr (<{ [2 x i8] }>, ptr @alloc2, i32 0, i32 0, i32 4), [[BB2]] ], [ getelementptr (<{ [2 x i8] }>, ptr @alloc0, i32 0, i32 0, i32 4), [[START:%.*]] ]
+ ; CHECK-NEXT:    [[TMP1:%.*]] = insertvalue { ptr, i64 } undef, ptr [[DOTSROA_0_0]], 0
+ ; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue { ptr, i64 } [[TMP1]], i64 1, 1
+ ; CHECK-NEXT:    ret { ptr, i64 } [[TMP2]]
+@@ -103,7 +103,7 @@
+ ; CHECK:       default:
+ ; CHECK-NEXT:    unreachable
+ ; CHECK:       end:
+-; CHECK-NEXT:    [[DOTSROA_0_0:%.*]] = phi ptr [ getelementptr (<{ [2 x i8] }>, ptr @alloc2, i32 0, i32 0, i64 ptrtoint (ptr @alloc0 to i64)), [[BB2]] ], [ getelementptr (<{ [2 x i8] }>, ptr @alloc1, i32 0, i32 0, i64 ptrtoint (ptr @alloc0 to i64)), [[BB1]] ], [ getelementptr (<{ [2 x i8] }>, ptr @alloc0, i32 0, i32 0, i64 ptrtoint (ptr @alloc0 to i64)), [[START:%.*]] ]
++; CHECK-NEXT:    [[DOTSROA_0_0:%.*]] = phi ptr [ getelementptr (<{ [2 x i8] }>, ptr @alloc1, i32 0, i32 0, i64 ptrtoint (ptr @alloc0 to i64)), [[BB1]] ], [ getelementptr (<{ [2 x i8] }>, ptr @alloc2, i32 0, i32 0, i64 ptrtoint (ptr @alloc0 to i64)), [[BB2]] ], [ getelementptr (<{ [2 x i8] }>, ptr @alloc0, i32 0, i32 0, i64 ptrtoint (ptr @alloc0 to i64)), [[START:%.*]] ]
+ ; CHECK-NEXT:    [[TMP1:%.*]] = insertvalue { ptr, i64 } undef, ptr [[DOTSROA_0_0]], 0
+ ; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue { ptr, i64 } [[TMP1]], i64 1, 1
+ ; CHECK-NEXT:    ret { ptr, i64 } [[TMP2]]
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/X86/switch-to-lookup-globals.ll b/llvm/test/Transforms/SimplifyCFG/X86/switch-to-lookup-globals.ll
+--- a/llvm/test/Transforms/SimplifyCFG/X86/switch-to-lookup-globals.ll
++++ b/llvm/test/Transforms/SimplifyCFG/X86/switch-to-lookup-globals.ll
+@@ -18,7 +18,7 @@
+ ; CHECK-NEXT:    %switch.load = load ptr, ptr %switch.gep, align 8
+ ; CHECK-NEXT:    br label %bb6
+ ; CHECK:       bb6:
+-; CHECK-NEXT:    %tmp7 = phi ptr [ null, %bb ], [ %switch.load, %switch.lookup ]
++; CHECK-NEXT:    %tmp7 = phi ptr [ %switch.load, %switch.lookup ], [ null, %bb ]
+ ; CHECK-NEXT:    %tmp8 = icmp eq ptr %tmp7, getelementptr inbounds ([75 x { i32, i32, i32, i8, i8 }], ptr @global, i64 1, i64 0, i32 0)
+ ; CHECK-NEXT:    ret i1 %tmp8
+ ;
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/X86/switch_to_lookup_table_big.ll b/llvm/test/Transforms/SimplifyCFG/X86/switch_to_lookup_table_big.ll
+--- a/llvm/test/Transforms/SimplifyCFG/X86/switch_to_lookup_table_big.ll
++++ b/llvm/test/Transforms/SimplifyCFG/X86/switch_to_lookup_table_big.ll
+@@ -434,7 +434,7 @@
+ ; CHECK:       bb7:
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 7, [[BB7]] ], [ 0, [[BB0]] ], [ 1, [[BB1]] ], [ 2, [[BB2]] ], [ 3, [[BB3]] ], [ 4, [[BB4]] ], [ 5, [[BB5]] ], [ 6, [[BB6]] ], [ [[Y:%.*]], [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[RES:%.*]] = phi i32 [ 0, [[BB0]] ], [ 1, [[BB1]] ], [ 2, [[BB2]] ], [ 3, [[BB3]] ], [ 4, [[BB4]] ], [ 5, [[BB5]] ], [ 6, [[BB6]] ], [ 7, [[BB7]] ], [ [[Y:%.*]], [[ENTRY:%.*]] ]
+ ; CHECK-NEXT:    ret i32 [[RES]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SimplifyCFG/X86/switch_to_lookup_table.ll b/llvm/test/Transforms/SimplifyCFG/X86/switch_to_lookup_table.ll
+--- a/llvm/test/Transforms/SimplifyCFG/X86/switch_to_lookup_table.ll
++++ b/llvm/test/Transforms/SimplifyCFG/X86/switch_to_lookup_table.ll
+@@ -278,7 +278,7 @@
+ ; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i59 [[SWITCH_DOWNSHIFT]] to i1
+ ; CHECK-NEXT:    br label [[LOR_END]]
+ ; CHECK:       lor.end:
+-; CHECK-NEXT:    [[TMP1:%.*]] = phi i1 [ [[SWITCH_MASKED]], [[SWITCH_LOOKUP]] ], [ true, [[ENTRY:%.*]] ], [ false, [[SWITCH_EARLY_TEST]] ]
++; CHECK-NEXT:    [[TMP1:%.*]] = phi i1 [ true, [[ENTRY:%.*]] ], [ [[SWITCH_MASKED]], [[SWITCH_LOOKUP]] ], [ false, [[SWITCH_EARLY_TEST]] ]
+ ; CHECK-NEXT:    [[LOR_EXT:%.*]] = zext i1 [[TMP1]] to i32
+ ; CHECK-NEXT:    ret i32 [[LOR_EXT]]
+ ;
+@@ -415,7 +415,7 @@
+ ; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
+ ; CHECK-NEXT:    br label [[RETURN]]
+ ; CHECK:       return:
+-; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ], [ 0, [[ENTRY:%.*]] ]
++; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ]
+ ; CHECK-NEXT:    ret i32 [[RETVAL_0]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/Util/lowerswitch.ll b/llvm/test/Transforms/Util/lowerswitch.ll
+--- a/llvm/test/Transforms/Util/lowerswitch.ll
++++ b/llvm/test/Transforms/Util/lowerswitch.ll
+@@ -55,7 +55,7 @@
+ ; CHECK-LABEL: bb3
+ ; CHECK: %tmp = phi i32 [ 1, %NodeBlock ], [ 0, %bb2 ], [ 1, %LeafBlock3 ]
+   %tmp = phi i32 [ 1, %bb1 ], [ 0, %bb2 ], [ 1, %bb1 ], [ 1, %bb1 ]
+-; CHECK-NEXT: %tmp2 = phi i32 [ 2, %NodeBlock ], [ 2, %LeafBlock3 ], [ 5, %bb2 ]
++; CHECK-NEXT: %tmp2 = phi i32 [ 2, %NodeBlock ], [ 5, %bb2 ], [ 2, %LeafBlock3 ]
+   %tmp2 = phi i32 [ 2, %bb1 ], [ 2, %bb1 ], [ 5, %bb2 ], [ 2, %bb1 ]
+   br label %exit
+ 
+@@ -293,7 +293,7 @@
+ 
+ for.inc:
+ ; CHECK: for.inc:
+-; CHECK-NEXT: phi i16 [ undef, %cleanup10 ], [ 0, %cleanup10.thread ]
++; CHECK-NEXT: phi i16 [ 0, %cleanup10.thread ], [ undef, %cleanup10 ]
+ %0 = phi i16 [ undef, %cleanup10 ], [ 0, %cleanup10.thread ], [ undef, %cleanup10 ]
+   unreachable
+ 
+diff -ruN --strip-trailing-cr a/llvm/unittests/SandboxIR/SandboxIRTest.cpp b/llvm/unittests/SandboxIR/SandboxIRTest.cpp
+--- a/llvm/unittests/SandboxIR/SandboxIRTest.cpp
++++ b/llvm/unittests/SandboxIR/SandboxIRTest.cpp
+@@ -5963,15 +5963,17 @@
+            PHI->getIncomingBlock(Idx) == RemoveBB1;
+   });
+   EXPECT_EQ(PHI->getNumIncomingValues(), 3u);
+-  EXPECT_THAT(PHI->blocks(),
+-              ::testing::UnorderedElementsAre(RemainBB0, RemainBB1, RemainBB2));
++  EXPECT_EQ(PHI->getIncomingBlock(0), RemainBB0);
++  EXPECT_EQ(PHI->getIncomingBlock(1), RemainBB1);
++  EXPECT_EQ(PHI->getIncomingBlock(2), RemainBB2);
+   // Check replaceIncomingBlockWith
+   OrigBB = RemainBB0;
+   auto *NewBB = RemainBB1;
+   EXPECT_NE(NewBB, OrigBB);
+   PHI->replaceIncomingBlockWith(OrigBB, NewBB);
+-  EXPECT_THAT(PHI->blocks(),
+-              ::testing::UnorderedElementsAre(NewBB, RemainBB1, RemainBB2));
++  EXPECT_EQ(PHI->getIncomingBlock(0), NewBB);
++  EXPECT_EQ(PHI->getIncomingBlock(1), RemainBB1);
++  EXPECT_EQ(PHI->getIncomingBlock(2), RemainBB2);
+   // Check create().
+   auto *NewPHI = cast<sandboxir::PHINode>(sandboxir::PHINode::create(
+       PHI->getType(), 0, Br->getIterator(), Ctx, "NewPHI"));
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 55a1ce3..8f4547d 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "0812f41cd68d63d10a4c3a02271b0ea8276dbe57"
-    LLVM_SHA256 = "c5bbfd7e6accbb4bfbeeb990666aa64654a667c6569366e90aa1f8d8b28dbf8c"
+    LLVM_COMMIT = "5c19f77a7e0c4b35c0efb511a7d9e2e436335e61"
+    LLVM_SHA256 = "7149b29e628657d9d6c88ff48b45808f7ab47560b79afcf40d83fd694053ee47"
 
     tf_http_archive(
         name = name,
