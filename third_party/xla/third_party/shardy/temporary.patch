diff --git a/shardy/dialect/mpmd/ir/ops.td b/shardy/dialect/mpmd/ir/ops.td
index b5c49cc..33e3ad1 100644
--- a/shardy/dialect/mpmd/ir/ops.td
+++ b/shardy/dialect/mpmd/ir/ops.td
@@ -575,6 +575,9 @@ def ForOp : Mpmd_Op<"for",
    std::optional<ResultRange> getLoopResults() {
       return getResults();
     }
+    bool isValidInductionVarType(Type type) {
+      return getElementTypeOrSelf(type).isInteger();
+    }
   }];
 
 }
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 1a0e599..dd1ead4 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,263 +1,429 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/Analysis.cpp b/llvm/lib/CodeGen/Analysis.cpp
---- a/llvm/lib/CodeGen/Analysis.cpp
-+++ b/llvm/lib/CodeGen/Analysis.cpp
-@@ -814,5 +814,13 @@
-        CatchRetSuccessors)
-     collectEHScopeMembers(EHScopeMembership, CatchRetPair.second,
-                           CatchRetPair.first);
-+
-+  // Add any remaining blocks in the function to the unreachable set, which
-+  // might not otherwise have been identified as unreachable (such as infinite
-+  // loops).
-+  for (const MachineBasicBlock &MBB : MF)
-+    if (!EHScopeMembership.count(&MBB))
-+      collectEHScopeMembers(EHScopeMembership, EntryBBNumber, &MBB);
-+
-   return EHScopeMembership;
- }
-diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/MachineBasicBlock.cpp b/llvm/lib/CodeGen/MachineBasicBlock.cpp
---- a/llvm/lib/CodeGen/MachineBasicBlock.cpp
-+++ b/llvm/lib/CodeGen/MachineBasicBlock.cpp
-@@ -551,6 +551,11 @@
-       os << "ehfunclet-entry";
-       hasAttributes = true;
+diff -ruN --strip-trailing-cr a/libcxx/include/__algorithm/find_if.h b/libcxx/include/__algorithm/find_if.h
+--- a/libcxx/include/__algorithm/find_if.h
++++ b/libcxx/include/__algorithm/find_if.h
+@@ -11,7 +11,6 @@
+ #define _LIBCPP___ALGORITHM_FIND_IF_H
+ 
+ #include <__config>
+-#include <__memory/valid_range.h>
+ 
+ #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+ #  pragma GCC system_header
+@@ -22,8 +21,6 @@
+ template <class _InputIterator, class _Predicate>
+ [[__nodiscard__]] inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 _InputIterator
+ find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
+-  std::__assume_valid_range(__first, __last);
+-
+   for (; __first != __last; ++__first)
+     if (__pred(*__first))
+       break;
+diff -ruN --strip-trailing-cr a/libcxx/include/CMakeLists.txt b/libcxx/include/CMakeLists.txt
+--- a/libcxx/include/CMakeLists.txt
++++ b/libcxx/include/CMakeLists.txt
+@@ -607,7 +607,6 @@
+   __memory/unique_temporary_buffer.h
+   __memory/uses_allocator.h
+   __memory/uses_allocator_construction.h
+-  __memory/valid_range.h
+   __memory_resource/memory_resource.h
+   __memory_resource/monotonic_buffer_resource.h
+   __memory_resource/polymorphic_allocator.h
+@@ -932,6 +931,7 @@
+   __utility/in_place.h
+   __utility/integer_sequence.h
+   __utility/is_pointer_in_range.h
++  __utility/is_valid_range.h
+   __utility/lazy_synth_three_way_comparator.h
+   __utility/move.h
+   __utility/no_destroy.h
+diff -ruN --strip-trailing-cr a/libcxx/include/__memory/valid_range.h b/libcxx/include/__memory/valid_range.h
+--- a/libcxx/include/__memory/valid_range.h
++++ b/libcxx/include/__memory/valid_range.h
+@@ -1,74 +0,0 @@
+-//===----------------------------------------------------------------------===//
+-//
+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+-// See https://llvm.org/LICENSE.txt for license information.
+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+-//
+-//===----------------------------------------------------------------------===//
+-
+-#ifndef _LIBCPP___MEMORY_VALID_RANGE_H
+-#define _LIBCPP___MEMORY_VALID_RANGE_H
+-
+-#include <__algorithm/comp.h>
+-#include <__assert>
+-#include <__config>
+-#include <__iterator/iterator_traits.h>
+-#include <__memory/assume_aligned.h>
+-#include <__memory/pointer_traits.h>
+-#include <__type_traits/is_constant_evaluated.h>
+-#include <__type_traits/is_same.h>
+-#include <__type_traits/remove_cvref.h>
+-
+-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+-#  pragma GCC system_header
+-#endif
+-
+-_LIBCPP_BEGIN_NAMESPACE_STD
+-
+-// A valid range as defined by the C++ Standard has the following constraints:
+-// - [__first, __last) is dereferenceable
+-// - __last is reachable from __first
+-// - if __first and __last are contiguous iterators, the pointers they "decay to" are correctly aligned according to the
+-// language rules for pointers
+-
+-// This function attempts to detect invalid ranges as defined above. Specifically, it checks bullet (2). This also means
+-// that it doesn't return whether a range is actually valid, but only whether a range is definitely not valid.
+-// The checks may be extended in the future.
+-template <class _Tp>
+-_LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_SANITIZE("address") bool
+-__is_valid_range(const _Tp* __first, const _Tp* __last) {
+-  if (__libcpp_is_constant_evaluated()) {
+-    // If this is not a constant during constant evaluation, that is because __first and __last are not
+-    // part of the same allocation. If they are part of the same allocation, we must still make sure they
+-    // are ordered properly.
+-    return __builtin_constant_p(__first <= __last) && __first <= __last;
+-  }
+-
+-  return !__less<>()(__last, __first);
+-}
+-
+-// This function allows the compiler to assume that [__first, __last) is a valid range as defined above.
+-//
+-// In practice, we only add explicit assumptions for bullets (1) and (3). These assumptions allow (currently only
+-// clang-based compilers) to auto-vectorize algorithms that contain early returns.
+-template <class _Iter, class _Sent>
+-_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
+-__assume_valid_range([[__maybe_unused__]] _Iter&& __first, [[__maybe_unused__]] _Sent&& __last) {
+-#if defined(_LIBCPP_CLANG_VER) && _LIBCPP_CLANG_VER >= 2200 && !defined(_LIBCPP_CXX03_LANG)
+-  if constexpr (__libcpp_is_contiguous_iterator<__remove_cvref_t<_Iter>>::value &&
+-                is_same<__remove_cvref_t<_Iter>, __remove_cvref_t<_Sent>>::value) {
+-    _LIBCPP_ASSERT_INTERNAL(std::__is_valid_range(std::__to_address(__first), std::__to_address(__last)),
+-                            "Valid range assumption does not hold");
+-    if (!__libcpp_is_constant_evaluated()) {
+-      using __value_type = typename iterator_traits<__remove_cvref_t<_Iter>>::value_type;
+-      __builtin_assume_dereferenceable(std::__to_address(__first), (__last - __first) * sizeof(__value_type));
+-      (void)std::__assume_aligned<_LIBCPP_ALIGNOF(__value_type)>(std::__to_address(__first));
+-      (void)std::__assume_aligned<_LIBCPP_ALIGNOF(__value_type)>(std::__to_address(__last));
+-    }
+-  }
+-#endif
+-}
+-
+-_LIBCPP_END_NAMESPACE_STD
+-
+-#endif // _LIBCPP___MEMORY_VALID_RANGE_H
+diff -ruN --strip-trailing-cr a/libcxx/include/module.modulemap.in b/libcxx/include/module.modulemap.in
+--- a/libcxx/include/module.modulemap.in
++++ b/libcxx/include/module.modulemap.in
+@@ -1690,7 +1690,6 @@
      }
-+    if (isEHScopeEntry()) {
-+      os << (hasAttributes ? ", " : " (");
-+      os << "ehscope-entry";
-+      hasAttributes = true;
-+    }
-     if (getAlignment() != Align(1)) {
-       os << (hasAttributes ? ", " : " (");
-       os << "align " << getAlignment().value();
-diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/MIRParser/MILexer.cpp b/llvm/lib/CodeGen/MIRParser/MILexer.cpp
---- a/llvm/lib/CodeGen/MIRParser/MILexer.cpp
-+++ b/llvm/lib/CodeGen/MIRParser/MILexer.cpp
-@@ -271,6 +271,7 @@
-       .Case("landing-pad", MIToken::kw_landing_pad)
-       .Case("inlineasm-br-indirect-target",
-             MIToken::kw_inlineasm_br_indirect_target)
-+      .Case("ehscope-entry", MIToken::kw_ehscope_entry)
-       .Case("ehfunclet-entry", MIToken::kw_ehfunclet_entry)
-       .Case("liveins", MIToken::kw_liveins)
-       .Case("successors", MIToken::kw_successors)
-diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/MIRParser/MILexer.h b/llvm/lib/CodeGen/MIRParser/MILexer.h
---- a/llvm/lib/CodeGen/MIRParser/MILexer.h
-+++ b/llvm/lib/CodeGen/MIRParser/MILexer.h
-@@ -126,6 +126,7 @@
-     kw_liveout,
-     kw_landing_pad,
-     kw_inlineasm_br_indirect_target,
-+    kw_ehscope_entry,
-     kw_ehfunclet_entry,
-     kw_liveins,
-     kw_successors,
-diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/MIRParser/MIParser.cpp b/llvm/lib/CodeGen/MIRParser/MIParser.cpp
---- a/llvm/lib/CodeGen/MIRParser/MIParser.cpp
-+++ b/llvm/lib/CodeGen/MIRParser/MIParser.cpp
-@@ -719,6 +719,7 @@
-   bool IsLandingPad = false;
-   bool IsInlineAsmBrIndirectTarget = false;
-   bool IsEHFuncletEntry = false;
-+  bool IsEHScopeEntry = false;
-   std::optional<MBBSectionID> SectionID;
-   uint64_t Alignment = 0;
-   std::optional<UniqueBBID> BBID;
-@@ -748,6 +749,10 @@
-         IsEHFuncletEntry = true;
-         lex();
-         break;
-+      case MIToken::kw_ehscope_entry:
-+        IsEHScopeEntry = true;
-+        lex();
-+        break;
-       case MIToken::kw_align:
-         if (parseAlignment(Alignment))
-           return true;
-@@ -804,6 +809,7 @@
-   MBB->setIsEHPad(IsLandingPad);
-   MBB->setIsInlineAsmBrIndirectTarget(IsInlineAsmBrIndirectTarget);
-   MBB->setIsEHFuncletEntry(IsEHFuncletEntry);
-+  MBB->setIsEHScopeEntry(IsEHScopeEntry);
-   if (SectionID) {
-     MBB->setSectionID(*SectionID);
-     MF.setBBSectionsType(BasicBlockSection::List);
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/AArch64/seh-unreachable-loop.mir b/llvm/test/CodeGen/AArch64/seh-unreachable-loop.mir
---- a/llvm/test/CodeGen/AArch64/seh-unreachable-loop.mir
-+++ b/llvm/test/CodeGen/AArch64/seh-unreachable-loop.mir
-@@ -0,0 +1,154 @@
-+# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 6
-+# RUN: llc -o - %s -mtriple=aarch64-pc-windows-msvc19.33.0 -run-pass=branch-folder | FileCheck %s
-+
-+# Check that the dead blocks in bb.2 and bb.3 are correctly handled by BranchFolders EHScopeMembership.
-+
-+--- |
-+  declare i32 @__CxxFrameHandler3(...)
-+
-+  declare ptr @"??2@YAPEAX_K@Z"(i64)
-+
-+  define ptr @test(ptr writeonly captures(none) %0, ptr captures(none) %1) personality ptr @__CxxFrameHandler3 {
-+    unreachable
-+  }
-+...
-+---
-+name:            test
-+tracksRegLiveness: true
-+hasEHContTarget: false
-+hasEHScopes:     true
-+hasEHFunclets:   true
-+body:             |
-+  ; CHECK-LABEL: name: test
-+  ; CHECK: bb.0:
-+  ; CHECK-NEXT:   successors: %bb.1(0x7ffff800), %bb.2(0x00000800)
-+  ; CHECK-NEXT:   liveins: $x0, $x1, $x20, $x19, $lr
-+  ; CHECK-NEXT: {{  $}}
-+  ; CHECK-NEXT:   early-clobber $sp = frame-setup STPXpre killed $x19, killed $x20, $sp, -6 :: (store (s64)), (store (s64))
-+  ; CHECK-NEXT:   frame-setup SEH_SaveRegP_X 19, 20, -48
-+  ; CHECK-NEXT:   frame-setup STPXi killed $fp, killed $lr, $sp, 2 :: (store (s64)), (store (s64))
-+  ; CHECK-NEXT:   frame-setup SEH_SaveFPLR 16
-+  ; CHECK-NEXT:   $fp = frame-setup ADDXri $sp, 16, 0
-+  ; CHECK-NEXT:   frame-setup SEH_AddFP 16
-+  ; CHECK-NEXT:   frame-setup SEH_PrologEnd
-+  ; CHECK-NEXT:   $x2 = MOVi64imm -2
-+  ; CHECK-NEXT:   STURXi killed $x2, $fp, 16
-+  ; CHECK-NEXT:   renamable $x20 = COPY $x1
-+  ; CHECK-NEXT:   renamable $x19 = COPY $x0
-+  ; CHECK-NEXT:   EH_LABEL <mcsymbol .Ltmp0>
-+  ; CHECK-NEXT:   $x0 = COPY $xzr
-+  ; CHECK-NEXT:   BL @"??2@YAPEAX_K@Z", csr_aarch64_aapcs, implicit-def dead $lr, implicit $sp, implicit $x0, implicit-def $sp, implicit-def $x0
-+  ; CHECK-NEXT:   EH_LABEL <mcsymbol .Ltmp0>
-+  ; CHECK-NEXT: {{  $}}
-+  ; CHECK-NEXT: bb.1:
-+  ; CHECK-NEXT:   liveins: $x0, $x19, $x20
-+  ; CHECK-NEXT: {{  $}}
-+  ; CHECK-NEXT:   STRXui $xzr, renamable $x20, 1 :: (store (s64), align 1)
-+  ; CHECK-NEXT:   STRXui $xzr, renamable $x20, 0 :: (store (s64), align 1)
-+  ; CHECK-NEXT:   STRXui $xzr, killed renamable $x20, 2 :: (store (s64), align 1)
-+  ; CHECK-NEXT:   STRXui killed renamable $x0, renamable $x19, 0 :: (store (s64))
-+  ; CHECK-NEXT:   $x0 = COPY $xzr
-+  ; CHECK-NEXT:   frame-destroy SEH_EpilogStart
-+  ; CHECK-NEXT:   $fp, $lr = frame-destroy LDPXi $sp, 2 :: (load (s64)), (load (s64))
-+  ; CHECK-NEXT:   frame-destroy SEH_SaveFPLR 16
-+  ; CHECK-NEXT:   early-clobber $sp, $x19, $x20 = frame-destroy LDPXpost $sp, 6 :: (load (s64)), (load (s64))
-+  ; CHECK-NEXT:   frame-destroy SEH_SaveRegP_X 19, 20, -48
-+  ; CHECK-NEXT:   frame-destroy SEH_EpilogEnd
-+  ; CHECK-NEXT:   RET_ReallyLR implicit $x0
-+  ; CHECK-NEXT: {{  $}}
-+  ; CHECK-NEXT: bb.2 (landing-pad, ehfunclet-entry, ehscope-entry):
-+  ; CHECK-NEXT:   liveins: $x20, $x19, $lr
-+  ; CHECK-NEXT: {{  $}}
-+  ; CHECK-NEXT:   early-clobber $sp = frame-setup STPXpre killed $x19, killed $x20, $sp, -4 :: (store (s64)), (store (s64))
-+  ; CHECK-NEXT:   frame-setup SEH_SaveRegP_X 19, 20, -32
-+  ; CHECK-NEXT:   frame-setup STPXi killed $fp, killed $lr, $sp, 2 :: (store (s64)), (store (s64))
-+  ; CHECK-NEXT:   frame-setup SEH_SaveFPLR 16
-+  ; CHECK-NEXT:   frame-setup SEH_PrologEnd
-+  ; CHECK-NEXT:   renamable $x8 = COPY $xzr
-+  ; CHECK-NEXT:   STRWui $wzr, killed renamable $x8, 0 :: (volatile store (s32) into `ptr null`, align 4294967296)
-+  ; CHECK-NEXT:   frame-destroy SEH_EpilogStart
-+  ; CHECK-NEXT:   $fp, $lr = frame-destroy LDPXi $sp, 2 :: (load (s64)), (load (s64))
-+  ; CHECK-NEXT:   frame-destroy SEH_SaveFPLR 16
-+  ; CHECK-NEXT:   early-clobber $sp, $x19, $x20 = frame-destroy LDPXpost $sp, 4 :: (load (s64)), (load (s64))
-+  ; CHECK-NEXT:   frame-destroy SEH_SaveRegP_X 19, 20, -32
-+  ; CHECK-NEXT:   frame-destroy SEH_EpilogEnd
-+  ; CHECK-NEXT:   CLEANUPRET
-+  ; CHECK-NEXT: {{  $}}
-+  ; CHECK-NEXT: bb.3:
-+  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
-+  ; CHECK-NEXT:   liveins: $x8
-+  ; CHECK-NEXT: {{  $}}
-+  ; CHECK-NEXT:   early-clobber renamable $x8 = STRXpost $xzr, killed renamable $x8, -8 :: (store (s64))
-+  ; CHECK-NEXT:   B %bb.3
-+  bb.0:
-+    successors: %bb.1(0x7ffff800), %bb.5(0x00000800)
-+    liveins: $x0, $x1, $x20, $x19, $lr
-+
-+    early-clobber $sp = frame-setup STPXpre killed $x19, killed $x20, $sp, -6 :: (store (s64)), (store (s64))
-+    frame-setup SEH_SaveRegP_X 19, 20, -48
-+    frame-setup STPXi killed $fp, killed $lr, $sp, 2 :: (store (s64)), (store (s64))
-+    frame-setup SEH_SaveFPLR 16
-+    $fp = frame-setup ADDXri $sp, 16, 0
-+    frame-setup SEH_AddFP 16
-+    frame-setup SEH_PrologEnd
-+    $x2 = MOVi64imm -2
-+    STURXi killed $x2, $fp, 16
-+    renamable $x20 = COPY $x1
-+    renamable $x19 = COPY $x0
-+    EH_LABEL <mcsymbol .Ltmp0>
-+    $x0 = COPY $xzr
-+    BL @"??2@YAPEAX_K@Z", csr_aarch64_aapcs, implicit-def dead $lr, implicit $sp, implicit $x0, implicit-def $sp, implicit-def $x0
-+    EH_LABEL <mcsymbol .Ltmp0>
-+    B %bb.1
-+
-+  bb.1:
-+    successors: %bb.4(0x30000000)
-+    liveins: $x0, $x19, $x20
+     module uses_allocator                     { header "__memory/uses_allocator.h" }
+     module uses_allocator_construction        { header "__memory/uses_allocator_construction.h" }
+-    module valid_range                        { header "__memory/valid_range.h" }
+ 
+     header "memory"
+     export *
+@@ -2173,6 +2172,7 @@
+     }
+     module integer_sequence                { header "__utility/integer_sequence.h" }
+     module is_pointer_in_range             { header "__utility/is_pointer_in_range.h" }
++    module is_valid_range                  { header "__utility/is_valid_range.h" }
+     module lazy_synth_three_way_comparator { header "__utility/lazy_synth_three_way_comparator.h" }
+     module move                            { header "__utility/move.h" }
+     module no_destroy                      { header "__utility/no_destroy.h" }
+diff -ruN --strip-trailing-cr a/libcxx/include/streambuf b/libcxx/include/streambuf
+--- a/libcxx/include/streambuf
++++ b/libcxx/include/streambuf
+@@ -117,8 +117,8 @@
+ #    include <__assert>
+ #    include <__fwd/streambuf.h>
+ #    include <__locale>
+-#    include <__memory/valid_range.h>
+ #    include <__type_traits/is_same.h>
++#    include <__utility/is_valid_range.h>
+ #    include <__utility/scope_guard.h>
+ #    include <climits>
+ #    include <ios>
+diff -ruN --strip-trailing-cr a/libcxx/include/__utility/is_pointer_in_range.h b/libcxx/include/__utility/is_pointer_in_range.h
+--- a/libcxx/include/__utility/is_pointer_in_range.h
++++ b/libcxx/include/__utility/is_pointer_in_range.h
+@@ -12,12 +12,12 @@
+ #include <__algorithm/comp.h>
+ #include <__assert>
+ #include <__config>
+-#include <__memory/valid_range.h>
+ #include <__type_traits/enable_if.h>
+ #include <__type_traits/integral_constant.h>
+ #include <__type_traits/is_constant_evaluated.h>
+ #include <__type_traits/void_t.h>
+ #include <__utility/declval.h>
++#include <__utility/is_valid_range.h>
+ 
+ #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+ #  pragma GCC system_header
+diff -ruN --strip-trailing-cr a/libcxx/include/__utility/is_valid_range.h b/libcxx/include/__utility/is_valid_range.h
+--- a/libcxx/include/__utility/is_valid_range.h
++++ b/libcxx/include/__utility/is_valid_range.h
+@@ -0,0 +1,37 @@
++//===----------------------------------------------------------------------===//
++//
++// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
++// See https://llvm.org/LICENSE.txt for license information.
++// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
++//
++//===----------------------------------------------------------------------===//
 +
-+    STRXui $xzr, renamable $x20, 1 :: (store (s64), align 1)
-+    STRXui $xzr, renamable $x20, 0 :: (store (s64), align 1)
-+    STRXui $xzr, killed renamable $x20, 2 :: (store (s64), align 1)
-+    STRXui killed renamable $x0, renamable $x19, 0 :: (store (s64))
-+    B %bb.4
++#ifndef _LIBCPP___UTILITY_IS_VALID_RANGE_H
++#define _LIBCPP___UTILITY_IS_VALID_RANGE_H
 +
-+  bb.2:
-+    successors: %bb.3(0x80000000)
-+    liveins: $x19
++#include <__algorithm/comp.h>
++#include <__config>
++#include <__type_traits/is_constant_evaluated.h>
 +
-+    renamable $x8 = SUBXri killed renamable $x19, 8, 0
++#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
++#  pragma GCC system_header
++#endif
 +
-+  bb.3:
-+    successors: %bb.3(0x80000000)
-+    liveins: $x8
++_LIBCPP_BEGIN_NAMESPACE_STD
 +
-+    early-clobber renamable $x8 = STRXpost $xzr, killed renamable $x8, -8 :: (store (s64))
-+    B %bb.3
++template <class _Tp>
++_LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_SANITIZE("address") bool
++__is_valid_range(const _Tp* __first, const _Tp* __last) {
++  if (__libcpp_is_constant_evaluated()) {
++    // If this is not a constant during constant evaluation, that is because __first and __last are not
++    // part of the same allocation. If they are part of the same allocation, we must still make sure they
++    // are ordered properly.
++    return __builtin_constant_p(__first <= __last) && __first <= __last;
++  }
 +
-+  bb.4:
-+    $x0 = COPY $xzr
-+    frame-destroy SEH_EpilogStart
-+    $fp, $lr = frame-destroy LDPXi $sp, 2 :: (load (s64)), (load (s64))
-+    frame-destroy SEH_SaveFPLR 16
-+    early-clobber $sp, $x19, $x20 = frame-destroy LDPXpost $sp, 6 :: (load (s64)), (load (s64))
-+    frame-destroy SEH_SaveRegP_X 19, 20, -48
-+    frame-destroy SEH_EpilogEnd
-+    RET_ReallyLR implicit $x0
++  return !__less<>()(__last, __first);
++}
 +
-+  bb.5 (landing-pad, ehfunclet-entry, ehscope-entry):
-+    liveins: $x20, $x19, $lr
++_LIBCPP_END_NAMESPACE_STD
 +
-+    early-clobber $sp = frame-setup STPXpre killed $x19, killed $x20, $sp, -4 :: (store (s64)), (store (s64))
-+    frame-setup SEH_SaveRegP_X 19, 20, -32
-+    frame-setup STPXi killed $fp, killed $lr, $sp, 2 :: (store (s64)), (store (s64))
-+    frame-setup SEH_SaveFPLR 16
-+    frame-setup SEH_PrologEnd
-+    renamable $x8 = COPY $xzr
-+    STRWui $wzr, killed renamable $x8, 0 :: (volatile store (s32) into `ptr null`, align 4294967296)
-+    frame-destroy SEH_EpilogStart
-+    $fp, $lr = frame-destroy LDPXi $sp, 2 :: (load (s64)), (load (s64))
-+    frame-destroy SEH_SaveFPLR 16
-+    early-clobber $sp, $x19, $x20 = frame-destroy LDPXpost $sp, 4 :: (load (s64)), (load (s64))
-+    frame-destroy SEH_SaveRegP_X 19, 20, -32
-+    frame-destroy SEH_EpilogEnd
-+    CLEANUPRET
-+...
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/MIR/Generic/machine-basic-block-ehscope-entry.mir b/llvm/test/CodeGen/MIR/Generic/machine-basic-block-ehscope-entry.mir
---- a/llvm/test/CodeGen/MIR/Generic/machine-basic-block-ehscope-entry.mir
-+++ b/llvm/test/CodeGen/MIR/Generic/machine-basic-block-ehscope-entry.mir
-@@ -0,0 +1,16 @@
-+# RUN: llc -run-pass none -o - %s 2>&1 | FileCheck %s
++#endif // _LIBCPP___UTILITY_IS_VALID_RANGE_H
+diff -ruN --strip-trailing-cr a/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp b/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
+--- a/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
++++ b/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
+@@ -22,18 +22,30 @@
+ int main(int argc, char** argv) {
+   auto std_find    = [](auto first, auto last, auto const& value) { return std::find(first, last, value); };
+   auto std_find_if = [](auto first, auto last, auto const& value) {
+-    return std::find_if(first, last, [&](auto element) { return element == value; });
++    return std::find_if(first, last, [&](auto element) {
++      benchmark::DoNotOptimize(element);
++      return element == value;
++    });
+   };
+   auto std_find_if_not = [](auto first, auto last, auto const& value) {
+-    return std::find_if_not(first, last, [&](auto element) { return element != value; });
++    return std::find_if_not(first, last, [&](auto element) {
++      benchmark::DoNotOptimize(element);
++      return element != value;
++    });
+   };
+ 
+   auto ranges_find    = [](auto first, auto last, auto const& value) { return std::ranges::find(first, last, value); };
+   auto ranges_find_if = [](auto first, auto last, auto const& value) {
+-    return std::ranges::find_if(first, last, [&](auto element) { return element == value; });
++    return std::ranges::find_if(first, last, [&](auto element) {
++      benchmark::DoNotOptimize(element);
++      return element == value;
++    });
+   };
+   auto ranges_find_if_not = [](auto first, auto last, auto const& value) {
+-    return std::ranges::find_if_not(first, last, [&](auto element) { return element != value; });
++    return std::ranges::find_if_not(first, last, [&](auto element) {
++      benchmark::DoNotOptimize(element);
++      return element != value;
++    });
+   };
+ 
+   auto register_benchmarks = [&](auto bm, std::string comment) {
+diff -ruN --strip-trailing-cr a/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp b/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
+--- a/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
++++ b/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
+@@ -6,7 +6,7 @@
+ //
+ //===----------------------------------------------------------------------===//
+ 
+-#include <__memory/valid_range.h>
++#include <__utility/is_valid_range.h>
+ #include <cassert>
+ 
+ #include "test_macros.h"
+diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
++++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+@@ -16573,7 +16573,15 @@
+   bool Changed = false;
+   while (!Worklist.empty() && Worklist.top().second.first > 0) {
+     TreeEntry *TE = Worklist.top().first;
+-    if (TE->isGather() || TE->Idx == 0 || DeletedNodes.contains(TE)) {
++    if (TE->isGather() || TE->Idx == 0 || DeletedNodes.contains(TE) ||
++        // Exit early if the parent node is split node and any of scalars is
++        // used in other split nodes.
++        (TE->UserTreeIndex &&
++         TE->UserTreeIndex.UserTE->State == TreeEntry::SplitVectorize &&
++         any_of(TE->Scalars, [&](Value *V) {
++           ArrayRef<TreeEntry *> Entries = getSplitTreeEntries(V);
++           return Entries.size() > 1;
++         }))) {
+       Worklist.pop();
+       continue;
+     }
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SLPVectorizer/X86/split-node-throttled.ll b/llvm/test/Transforms/SLPVectorizer/X86/split-node-throttled.ll
+--- a/llvm/test/Transforms/SLPVectorizer/X86/split-node-throttled.ll
++++ b/llvm/test/Transforms/SLPVectorizer/X86/split-node-throttled.ll
+@@ -0,0 +1,147 @@
++; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
++; RUN: opt -S --passes=slp-vectorizer -mtriple=x86_64-grtev4-linux-gnu -mcpu=haswell < %s | FileCheck %s
 +
-+# Test ehscope-entry machine basic block parameters
++define fastcc void @test(i32 %arg) {
++; CHECK-LABEL: define fastcc void @test(
++; CHECK-SAME: i32 [[ARG:%.*]]) #[[ATTR0:[0-9]+]] {
++; CHECK-NEXT:  [[BB:.*:]]
++; CHECK-NEXT:    [[SELECT:%.*]] = select i1 false, i32 0, i32 0
++; CHECK-NEXT:    [[GETELEMENTPTR:%.*]] = getelementptr i8, ptr poison, i64 16
++; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> poison, i32 [[ARG]], i32 1
++; CHECK-NEXT:    [[TMP0:%.*]] = insertelement <2 x i32> [[TMP3]], i32 [[SELECT]], i32 0
++; CHECK-NEXT:    [[TMP1:%.*]] = zext <2 x i32> [[TMP0]] to <2 x i64>
++; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <2 x i64> [[TMP1]], <2 x i64> poison, <4 x i32> <i32 0, i32 1, i32 0, i32 1>
++; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x i64> [[TMP2]], <4 x i64> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
++; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i64> [[TMP6]], <8 x i64> <i64 0, i64 0, i64 0, i64 0, i64 undef, i64 undef, i64 undef, i64 undef>, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>
++; CHECK-NEXT:    [[TMP24:%.*]] = shufflevector <2 x i32> [[TMP0]], <2 x i32> <i32 0, i32 poison>, <2 x i32> <i32 2, i32 0>
++; CHECK-NEXT:    [[TMP25:%.*]] = zext <2 x i32> [[TMP24]] to <2 x i64>
++; CHECK-NEXT:    [[TMP26:%.*]] = shufflevector <2 x i64> [[TMP25]], <2 x i64> poison, <4 x i32> <i32 0, i32 1, i32 0, i32 1>
++; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x i64> [[TMP26]], <4 x i64> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
++; CHECK-NEXT:    [[TMP9:%.*]] = shufflevector <8 x i64> [[TMP8]], <8 x i64> <i64 0, i64 0, i64 0, i64 0, i64 undef, i64 undef, i64 undef, i64 undef>, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>
++; CHECK-NEXT:    [[TMP10:%.*]] = mul <8 x i64> zeroinitializer, [[TMP7]]
++; CHECK-NEXT:    [[TMP11:%.*]] = trunc <8 x i64> [[TMP10]] to <8 x i1>
++; CHECK-NEXT:    [[TMP12:%.*]] = or <8 x i1> zeroinitializer, [[TMP11]]
++; CHECK-NEXT:    [[TMP13:%.*]] = or <8 x i1> [[TMP12]], zeroinitializer
++; CHECK-NEXT:    [[TMP14:%.*]] = shufflevector <8 x i1> [[TMP13]], <8 x i1> poison, <8 x i32> <i32 0, i32 4, i32 2, i32 6, i32 1, i32 5, i32 3, i32 7>
++; CHECK-NEXT:    [[TMP15:%.*]] = mul <8 x i64> zeroinitializer, [[TMP9]]
++; CHECK-NEXT:    [[TMP16:%.*]] = trunc <8 x i64> [[TMP15]] to <8 x i1>
++; CHECK-NEXT:    [[TMP17:%.*]] = or <8 x i1> [[TMP14]], [[TMP16]]
++; CHECK-NEXT:    [[TMP18:%.*]] = lshr <8 x i1> [[TMP17]], zeroinitializer
++; CHECK-NEXT:    [[TMP19:%.*]] = zext <8 x i1> [[TMP18]] to <8 x i32>
++; CHECK-NEXT:    [[TMP20:%.*]] = call <8 x i32> @llvm.smax.v8i32(<8 x i32> [[TMP19]], <8 x i32> zeroinitializer)
++; CHECK-NEXT:    [[TMP21:%.*]] = call <8 x i32> @llvm.smin.v8i32(<8 x i32> [[TMP20]], <8 x i32> zeroinitializer)
++; CHECK-NEXT:    [[TMP22:%.*]] = trunc <8 x i32> [[TMP21]] to <8 x i16>
++; CHECK-NEXT:    [[TMP23:%.*]] = shufflevector <8 x i16> [[TMP22]], <8 x i16> poison, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>
++; CHECK-NEXT:    store <8 x i16> [[TMP23]], ptr [[GETELEMENTPTR]], align 2
++; CHECK-NEXT:    ret void
++;
++bb:
++  %zext = zext i32 %arg to i64
++  %sext = sext i32 0 to i64
++  %select = select i1 false, i32 0, i32 0
++  %zext1 = zext i32 %select to i64
++  %mul = mul i64 0, %zext1
++  %or = or i64 0, %mul
++  %or2 = or i64 %or, 0
++  %zext3 = zext i32 0 to i64
++  %mul4 = mul i64 0, %zext3
++  %or5 = or i64 %or2, %mul4
++  %lshr = lshr i64 %or5, 0
++  %trunc = trunc i64 %lshr to i32
++  %call = tail call i32 @llvm.smax.i32(i32 %trunc, i32 0)
++  %call6 = tail call i32 @llvm.smin.i32(i32 %call, i32 0)
++  %trunc7 = trunc i32 %call6 to i16
++  %getelementptr = getelementptr i8, ptr poison, i64 16
++  store i16 %trunc7, ptr %getelementptr, align 2
++  %mul8 = mul i64 0, %zext
++  %or9 = or i64 0, %mul8
++  %or10 = or i64 %or9, 0
++  %sext11 = sext i32 0 to i64
++  %mul12 = mul i64 0, %sext11
++  %or13 = or i64 %or10, %mul12
++  %lshr14 = lshr i64 %or13, 0
++  %trunc15 = trunc i64 %lshr14 to i32
++  %call16 = tail call i32 @llvm.smax.i32(i32 %trunc15, i32 0)
++  %call17 = tail call i32 @llvm.smin.i32(i32 %call16, i32 0)
++  %trunc18 = trunc i32 %call17 to i16
++  %getelementptr19 = getelementptr i8, ptr poison, i64 18
++  store i16 %trunc18, ptr %getelementptr19, align 2
++  %sext20 = sext i32 0 to i64
++  %mul21 = mul i64 0, %sext20
++  %or22 = or i64 %zext3, %mul21
++  %or23 = or i64 %or22, 0
++  %mul24 = mul i64 0, %zext1
++  %or25 = or i64 %or23, %mul24
++  %lshr26 = lshr i64 %or25, 0
++  %trunc27 = trunc i64 %lshr26 to i32
++  %call28 = tail call i32 @llvm.smax.i32(i32 %trunc27, i32 0)
++  %call29 = tail call i32 @llvm.smin.i32(i32 %call28, i32 0)
++  %trunc30 = trunc i32 %call29 to i16
++  %getelementptr31 = getelementptr i8, ptr poison, i64 20
++  store i16 %trunc30, ptr %getelementptr31, align 2
++  %sext32 = sext i32 0 to i64
++  %mul33 = mul i64 0, %sext32
++  %or34 = or i64 0, %mul33
++  %or35 = or i64 %or34, 0
++  %mul36 = mul i64 0, %sext
++  %or37 = or i64 %or35, %mul36
++  %lshr38 = lshr i64 %or37, 0
++  %trunc39 = trunc i64 %lshr38 to i32
++  %call40 = tail call i32 @llvm.smax.i32(i32 %trunc39, i32 0)
++  %call41 = tail call i32 @llvm.smin.i32(i32 %call40, i32 0)
++  %trunc42 = trunc i32 %call41 to i16
++  %getelementptr43 = getelementptr i8, ptr poison, i64 22
++  store i16 %trunc42, ptr %getelementptr43, align 2
++  %mul44 = mul i64 0, %zext1
++  %or45 = or i64 0, %mul44
++  %or46 = or i64 %or45, 0
++  %mul47 = mul i64 0, %zext3
++  %or48 = or i64 %or46, %mul47
++  %lshr49 = lshr i64 %or48, 0
++  %trunc50 = trunc i64 %lshr49 to i32
++  %call51 = tail call i32 @llvm.smax.i32(i32 %trunc50, i32 0)
++  %call52 = tail call i32 @llvm.smin.i32(i32 %call51, i32 0)
++  %trunc53 = trunc i32 %call52 to i16
++  %getelementptr54 = getelementptr i8, ptr poison, i64 24
++  store i16 %trunc53, ptr %getelementptr54, align 2
++  %mul55 = mul i64 0, %zext
++  %or56 = or i64 0, %mul55
++  %or57 = or i64 %or56, 0
++  %mul58 = mul i64 0, %sext11
++  %or59 = or i64 %or57, %mul58
++  %lshr60 = lshr i64 %or59, 0
++  %trunc61 = trunc i64 %lshr60 to i32
++  %call62 = tail call i32 @llvm.smax.i32(i32 %trunc61, i32 0)
++  %call63 = tail call i32 @llvm.smin.i32(i32 %call62, i32 0)
++  %trunc64 = trunc i32 %call63 to i16
++  %getelementptr65 = getelementptr i8, ptr poison, i64 26
++  store i16 %trunc64, ptr %getelementptr65, align 2
++  %mul66 = mul i64 0, %sext20
++  %or67 = or i64 0, %mul66
++  %or68 = or i64 %or67, 0
++  %mul69 = mul i64 0, %zext1
++  %or70 = or i64 %or68, %mul69
++  %lshr71 = lshr i64 %or70, 0
++  %trunc72 = trunc i64 %lshr71 to i32
++  %call73 = tail call i32 @llvm.smax.i32(i32 %trunc72, i32 0)
++  %call74 = tail call i32 @llvm.smin.i32(i32 %call73, i32 0)
++  %trunc75 = trunc i32 %call74 to i16
++  %getelementptr76 = getelementptr i8, ptr poison, i64 28
++  store i16 %trunc75, ptr %getelementptr76, align 2
++  %mul77 = mul i64 0, %sext32
++  %or78 = or i64 0, %mul77
++  %or79 = or i64 %or78, 0
++  %mul80 = mul i64 0, %sext
++  %or81 = or i64 %or79, %mul80
++  %lshr82 = lshr i64 %or81, 0
++  %trunc83 = trunc i64 %lshr82 to i32
++  %call84 = tail call i32 @llvm.smax.i32(i32 %trunc83, i32 0)
++  %call85 = tail call i32 @llvm.smin.i32(i32 %call84, i32 0)
++  %trunc86 = trunc i32 %call85 to i16
++  %getelementptr87 = getelementptr i8, ptr poison, i64 30
++  store i16 %trunc86, ptr %getelementptr87, align 2
++  ret void
++}
 +
-+---
-+name:            test
-+body: |
-+  ; CHECK: bb.0 (ehscope-entry):
-+  bb.0 (ehscope-entry):
-+...
-+---
-+name:            withalign
-+body: |
-+  ; CHECK: bb.0 (ehscope-entry, align 8):
-+  bb.0 (align 8, ehscope-entry):
-+...
++declare i32 @llvm.smin.i32(i32, i32)
++declare i32 @llvm.smax.i32(i32, i32)
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 0a33b09..1a81c35 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "f6d0a512972a74ef100723b9526a6a0ddb23f894"
-    LLVM_SHA256 = "75dba7f15864c9ddc25dd621dcaf2d325a9ca8f23957ff4eb6b01df5b493b5d5"
+    LLVM_COMMIT = "95da1354d03bf66594d0bd1763b9c9c5fbcf8843"
+    LLVM_SHA256 = "455bf49a264ec2d8648fe348c377b94bddf73a868bc9d0b636e937ff45885823"
 
     tf_http_archive(
         name = name,
diff --git a/third_party/stablehlo/temporary.patch b/third_party/stablehlo/temporary.patch
index 1cf585d..9a61379 100755
--- a/third_party/stablehlo/temporary.patch
+++ b/third_party/stablehlo/temporary.patch
@@ -28,19 +28,13 @@ diff --ruN a/stablehlo/stablehlo/integrations/cpp/builder/StablehloBuilder.cpp b
  
  namespace mlir {
  namespace stablehlo {
-@@ -94,6 +96,49 @@
+@@ -94,6 +96,43 @@
        value));
  }
  
 +
 +MlirOp IotaLike(MlirOp input, int64_t dim, Type elementType) {
 +  auto inputType = mlir::cast<RankedTensorType>(input.getType());
-+  if (inputType.getRank() == 0) {
-+    // Need to construct 1-D iota and reshape to 0-D.
-+    auto iota = stablehlo::Iota(input.getBuilder(),
-+                                inputType.clone({1}, elementType), dim);
-+    return stablehlo::Reshape(iota, {});
-+  }
 +  if (inputType.hasStaticShape()) {
 +    return stablehlo::Iota(input.getBuilder(), inputType.clone(elementType),
 +                           dim);
@@ -97,7 +91,7 @@ diff --ruN a/stablehlo/stablehlo/integrations/cpp/builder/StablehloBuilder.h b/s
 diff --ruN a/stablehlo/stablehlo/integrations/cpp/builder/StablehloBuilderTest.cpp b/stablehlo/stablehlo/integrations/cpp/builder/StablehloBuilderTest.cpp
 --- stablehlo/stablehlo/integrations/cpp/builder/StablehloBuilderTest.cpp
 +++ stablehlo/stablehlo/integrations/cpp/builder/StablehloBuilderTest.cpp
-@@ -199,6 +199,79 @@
+@@ -199,6 +199,56 @@
          &ctx, {Precision::HIGHEST, Precision::HIGHEST});
      auto dot = stablehlo::DotGeneral(arg0, arg1, dotDimsAttr, precision);
      func::Return(fb, dot);
@@ -130,29 +124,6 @@ diff --ruN a/stablehlo/stablehlo/integrations/cpp/builder/StablehloBuilderTest.c
 +  EXPECT_EQ(expected, debugString(*module));
 +}
 +
-+TEST(MlirBuilderTest, IotaLikeScalar) {
-+  std::string expected = R"mlir(module {
-+  func.func @main(%arg0: tensor<i64>) -> tensor<i64> {
-+    %0 = stablehlo.iota dim = 0 : tensor<1xi64>
-+    %1 = stablehlo.reshape %0 : (tensor<1xi64>) -> tensor<i64>
-+    return %1 : tensor<i64>
-+  }
-+})mlir";
-+  StablehloModuleBuilder mb;
-+  {  // Build Main Func
-+    func::FunctionBuilder fb(mb.get(), "main");
-+    auto& ctx = fb.getContext();
-+    auto typei64 = makeTensorType(ctx, {}, ElementType::I64);
-+    auto arg0 = func::Argument(fb, typei64);
-+    auto iota = stablehlo::IotaLike(arg0, 0, typei64.getElementType());
-+    func::Return(fb, iota);
-+  }
-+
-+  OwningOpRef<ModuleOp> module = mb->build();
-+  EXPECT_TRUE(succeeded(mlir::verify(*module)));
-+  EXPECT_EQ(expected, debugString(*module));
-+}
-+
 +TEST(MlirBuilderTest, IotaLikeDynamic) {
 +  std::string expected = R"mlir(module {
 +  func.func @main(%arg0: tensor<2x3xi64>, %arg1: tensor<i32>) -> tensor<?x3xi64, #stablehlo.bounds<2, ?>> {
