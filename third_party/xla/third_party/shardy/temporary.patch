diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index dd1ead4..b1dc3af 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,261 +1,4 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/libcxx/include/__algorithm/find_if.h b/libcxx/include/__algorithm/find_if.h
---- a/libcxx/include/__algorithm/find_if.h
-+++ b/libcxx/include/__algorithm/find_if.h
-@@ -11,7 +11,6 @@
- #define _LIBCPP___ALGORITHM_FIND_IF_H
- 
- #include <__config>
--#include <__memory/valid_range.h>
- 
- #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
- #  pragma GCC system_header
-@@ -22,8 +21,6 @@
- template <class _InputIterator, class _Predicate>
- [[__nodiscard__]] inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 _InputIterator
- find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
--  std::__assume_valid_range(__first, __last);
--
-   for (; __first != __last; ++__first)
-     if (__pred(*__first))
-       break;
-diff -ruN --strip-trailing-cr a/libcxx/include/CMakeLists.txt b/libcxx/include/CMakeLists.txt
---- a/libcxx/include/CMakeLists.txt
-+++ b/libcxx/include/CMakeLists.txt
-@@ -607,7 +607,6 @@
-   __memory/unique_temporary_buffer.h
-   __memory/uses_allocator.h
-   __memory/uses_allocator_construction.h
--  __memory/valid_range.h
-   __memory_resource/memory_resource.h
-   __memory_resource/monotonic_buffer_resource.h
-   __memory_resource/polymorphic_allocator.h
-@@ -932,6 +931,7 @@
-   __utility/in_place.h
-   __utility/integer_sequence.h
-   __utility/is_pointer_in_range.h
-+  __utility/is_valid_range.h
-   __utility/lazy_synth_three_way_comparator.h
-   __utility/move.h
-   __utility/no_destroy.h
-diff -ruN --strip-trailing-cr a/libcxx/include/__memory/valid_range.h b/libcxx/include/__memory/valid_range.h
---- a/libcxx/include/__memory/valid_range.h
-+++ b/libcxx/include/__memory/valid_range.h
-@@ -1,74 +0,0 @@
--//===----------------------------------------------------------------------===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
--
--#ifndef _LIBCPP___MEMORY_VALID_RANGE_H
--#define _LIBCPP___MEMORY_VALID_RANGE_H
--
--#include <__algorithm/comp.h>
--#include <__assert>
--#include <__config>
--#include <__iterator/iterator_traits.h>
--#include <__memory/assume_aligned.h>
--#include <__memory/pointer_traits.h>
--#include <__type_traits/is_constant_evaluated.h>
--#include <__type_traits/is_same.h>
--#include <__type_traits/remove_cvref.h>
--
--#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
--#  pragma GCC system_header
--#endif
--
--_LIBCPP_BEGIN_NAMESPACE_STD
--
--// A valid range as defined by the C++ Standard has the following constraints:
--// - [__first, __last) is dereferenceable
--// - __last is reachable from __first
--// - if __first and __last are contiguous iterators, the pointers they "decay to" are correctly aligned according to the
--// language rules for pointers
--
--// This function attempts to detect invalid ranges as defined above. Specifically, it checks bullet (2). This also means
--// that it doesn't return whether a range is actually valid, but only whether a range is definitely not valid.
--// The checks may be extended in the future.
--template <class _Tp>
--_LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_SANITIZE("address") bool
--__is_valid_range(const _Tp* __first, const _Tp* __last) {
--  if (__libcpp_is_constant_evaluated()) {
--    // If this is not a constant during constant evaluation, that is because __first and __last are not
--    // part of the same allocation. If they are part of the same allocation, we must still make sure they
--    // are ordered properly.
--    return __builtin_constant_p(__first <= __last) && __first <= __last;
--  }
--
--  return !__less<>()(__last, __first);
--}
--
--// This function allows the compiler to assume that [__first, __last) is a valid range as defined above.
--//
--// In practice, we only add explicit assumptions for bullets (1) and (3). These assumptions allow (currently only
--// clang-based compilers) to auto-vectorize algorithms that contain early returns.
--template <class _Iter, class _Sent>
--_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
--__assume_valid_range([[__maybe_unused__]] _Iter&& __first, [[__maybe_unused__]] _Sent&& __last) {
--#if defined(_LIBCPP_CLANG_VER) && _LIBCPP_CLANG_VER >= 2200 && !defined(_LIBCPP_CXX03_LANG)
--  if constexpr (__libcpp_is_contiguous_iterator<__remove_cvref_t<_Iter>>::value &&
--                is_same<__remove_cvref_t<_Iter>, __remove_cvref_t<_Sent>>::value) {
--    _LIBCPP_ASSERT_INTERNAL(std::__is_valid_range(std::__to_address(__first), std::__to_address(__last)),
--                            "Valid range assumption does not hold");
--    if (!__libcpp_is_constant_evaluated()) {
--      using __value_type = typename iterator_traits<__remove_cvref_t<_Iter>>::value_type;
--      __builtin_assume_dereferenceable(std::__to_address(__first), (__last - __first) * sizeof(__value_type));
--      (void)std::__assume_aligned<_LIBCPP_ALIGNOF(__value_type)>(std::__to_address(__first));
--      (void)std::__assume_aligned<_LIBCPP_ALIGNOF(__value_type)>(std::__to_address(__last));
--    }
--  }
--#endif
--}
--
--_LIBCPP_END_NAMESPACE_STD
--
--#endif // _LIBCPP___MEMORY_VALID_RANGE_H
-diff -ruN --strip-trailing-cr a/libcxx/include/module.modulemap.in b/libcxx/include/module.modulemap.in
---- a/libcxx/include/module.modulemap.in
-+++ b/libcxx/include/module.modulemap.in
-@@ -1690,7 +1690,6 @@
-     }
-     module uses_allocator                     { header "__memory/uses_allocator.h" }
-     module uses_allocator_construction        { header "__memory/uses_allocator_construction.h" }
--    module valid_range                        { header "__memory/valid_range.h" }
- 
-     header "memory"
-     export *
-@@ -2173,6 +2172,7 @@
-     }
-     module integer_sequence                { header "__utility/integer_sequence.h" }
-     module is_pointer_in_range             { header "__utility/is_pointer_in_range.h" }
-+    module is_valid_range                  { header "__utility/is_valid_range.h" }
-     module lazy_synth_three_way_comparator { header "__utility/lazy_synth_three_way_comparator.h" }
-     module move                            { header "__utility/move.h" }
-     module no_destroy                      { header "__utility/no_destroy.h" }
-diff -ruN --strip-trailing-cr a/libcxx/include/streambuf b/libcxx/include/streambuf
---- a/libcxx/include/streambuf
-+++ b/libcxx/include/streambuf
-@@ -117,8 +117,8 @@
- #    include <__assert>
- #    include <__fwd/streambuf.h>
- #    include <__locale>
--#    include <__memory/valid_range.h>
- #    include <__type_traits/is_same.h>
-+#    include <__utility/is_valid_range.h>
- #    include <__utility/scope_guard.h>
- #    include <climits>
- #    include <ios>
-diff -ruN --strip-trailing-cr a/libcxx/include/__utility/is_pointer_in_range.h b/libcxx/include/__utility/is_pointer_in_range.h
---- a/libcxx/include/__utility/is_pointer_in_range.h
-+++ b/libcxx/include/__utility/is_pointer_in_range.h
-@@ -12,12 +12,12 @@
- #include <__algorithm/comp.h>
- #include <__assert>
- #include <__config>
--#include <__memory/valid_range.h>
- #include <__type_traits/enable_if.h>
- #include <__type_traits/integral_constant.h>
- #include <__type_traits/is_constant_evaluated.h>
- #include <__type_traits/void_t.h>
- #include <__utility/declval.h>
-+#include <__utility/is_valid_range.h>
- 
- #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
- #  pragma GCC system_header
-diff -ruN --strip-trailing-cr a/libcxx/include/__utility/is_valid_range.h b/libcxx/include/__utility/is_valid_range.h
---- a/libcxx/include/__utility/is_valid_range.h
-+++ b/libcxx/include/__utility/is_valid_range.h
-@@ -0,0 +1,37 @@
-+//===----------------------------------------------------------------------===//
-+//
-+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-+// See https://llvm.org/LICENSE.txt for license information.
-+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-+//
-+//===----------------------------------------------------------------------===//
-+
-+#ifndef _LIBCPP___UTILITY_IS_VALID_RANGE_H
-+#define _LIBCPP___UTILITY_IS_VALID_RANGE_H
-+
-+#include <__algorithm/comp.h>
-+#include <__config>
-+#include <__type_traits/is_constant_evaluated.h>
-+
-+#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-+#  pragma GCC system_header
-+#endif
-+
-+_LIBCPP_BEGIN_NAMESPACE_STD
-+
-+template <class _Tp>
-+_LIBCPP_CONSTEXPR_SINCE_CXX14 _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_SANITIZE("address") bool
-+__is_valid_range(const _Tp* __first, const _Tp* __last) {
-+  if (__libcpp_is_constant_evaluated()) {
-+    // If this is not a constant during constant evaluation, that is because __first and __last are not
-+    // part of the same allocation. If they are part of the same allocation, we must still make sure they
-+    // are ordered properly.
-+    return __builtin_constant_p(__first <= __last) && __first <= __last;
-+  }
-+
-+  return !__less<>()(__last, __first);
-+}
-+
-+_LIBCPP_END_NAMESPACE_STD
-+
-+#endif // _LIBCPP___UTILITY_IS_VALID_RANGE_H
-diff -ruN --strip-trailing-cr a/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp b/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
---- a/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
-+++ b/libcxx/test/benchmarks/algorithms/nonmodifying/find.bench.cpp
-@@ -22,18 +22,30 @@
- int main(int argc, char** argv) {
-   auto std_find    = [](auto first, auto last, auto const& value) { return std::find(first, last, value); };
-   auto std_find_if = [](auto first, auto last, auto const& value) {
--    return std::find_if(first, last, [&](auto element) { return element == value; });
-+    return std::find_if(first, last, [&](auto element) {
-+      benchmark::DoNotOptimize(element);
-+      return element == value;
-+    });
-   };
-   auto std_find_if_not = [](auto first, auto last, auto const& value) {
--    return std::find_if_not(first, last, [&](auto element) { return element != value; });
-+    return std::find_if_not(first, last, [&](auto element) {
-+      benchmark::DoNotOptimize(element);
-+      return element != value;
-+    });
-   };
- 
-   auto ranges_find    = [](auto first, auto last, auto const& value) { return std::ranges::find(first, last, value); };
-   auto ranges_find_if = [](auto first, auto last, auto const& value) {
--    return std::ranges::find_if(first, last, [&](auto element) { return element == value; });
-+    return std::ranges::find_if(first, last, [&](auto element) {
-+      benchmark::DoNotOptimize(element);
-+      return element == value;
-+    });
-   };
-   auto ranges_find_if_not = [](auto first, auto last, auto const& value) {
--    return std::ranges::find_if_not(first, last, [&](auto element) { return element != value; });
-+    return std::ranges::find_if_not(first, last, [&](auto element) {
-+      benchmark::DoNotOptimize(element);
-+      return element != value;
-+    });
-   };
- 
-   auto register_benchmarks = [&](auto bm, std::string comment) {
-diff -ruN --strip-trailing-cr a/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp b/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
---- a/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
-+++ b/libcxx/test/libcxx/utilities/is_valid_range.pass.cpp
-@@ -6,7 +6,7 @@
- //
- //===----------------------------------------------------------------------===//
- 
--#include <__memory/valid_range.h>
-+#include <__utility/is_valid_range.h>
- #include <cassert>
- 
- #include "test_macros.h"
 diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
 --- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
 +++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 1a81c35..1b98d12 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "95da1354d03bf66594d0bd1763b9c9c5fbcf8843"
-    LLVM_SHA256 = "455bf49a264ec2d8648fe348c377b94bddf73a868bc9d0b636e937ff45885823"
+    LLVM_COMMIT = "808a6ba345ce6e898e9acc4c5eda60165806e967"
+    LLVM_SHA256 = "6cd9c9f7a1620b9d91ce9caca2f3a97b3da02c6430dd61a7d63ceb3f16d61bf6"
 
     tf_http_archive(
         name = name,
