diff --git a/shardy/dialect/mpmd/transforms/common/test/rule_based_merge.mlir b/shardy/dialect/mpmd/transforms/common/test/rule_based_merge.mlir
index 48f7afb..6badec2 100644
--- a/shardy/dialect/mpmd/transforms/common/test/rule_based_merge.mlir
+++ b/shardy/dialect/mpmd/transforms/common/test/rule_based_merge.mlir
@@ -1,10 +1,10 @@
-// RUN: mpmd_opt %s -mpmd-rule-based-merge='rules=FragmentMergeRule(sources=[FragmentInfo(origins=["f"]),FragmentInfo(origins=["g"])],target=FragmentInfo(origins=["f","g"])),FragmentMergeRule(sources=[FragmentInfo(origins=["i"]),FragmentInfo(origins=["j"]),FragmentInfo(origins=["k"])],target=FragmentInfo(origins=["i","j","k"]))'2>&1 | FileCheck %s
+// RUN: mpmd_opt %s -mpmd-rule-based-merge=rules='FragmentMergeRule(sources=[FragmentInfo(origins=["f"]),FragmentInfo(origins=["g"])],target=FragmentInfo(origins=["f","g"]))' 2>&1 | FileCheck %s
 // TODO(b/435182733) Add more lit tests for rule based merge pass.
 
 !mesh_1_tensor_2_2_f32 = !mpmd.mesh_tensor<"m1", tensor<2x2xf32>>
 
-// CHECK-LABEL: func @merge_two_fragments
-func.func @merge_two_fragments
+// CHECK-LABEL: func @main
+func.func @main
 (%arg0: !mesh_1_tensor_2_2_f32, %arg1: !mesh_1_tensor_2_2_f32, %arg2: !mesh_1_tensor_2_2_f32)
  -> (!mesh_1_tensor_2_2_f32)
  attributes {topology = #mpmd.topology<<"m1" : <["x"=1]>>>} {
@@ -17,45 +17,10 @@ func.func @merge_two_fragments
     %1 = stablehlo.add %arg3, %arg4 : tensor<2x2xf32>
     mpmd.return %1 : tensor<2x2xf32>
   } : (!mesh_1_tensor_2_2_f32, !mesh_1_tensor_2_2_f32) -> !mesh_1_tensor_2_2_f32
-  %2 = mpmd.fragment<mesh="m1", origin=["g"]> (%0, %arg2) (%arg3: tensor<2x2xf32>, %arg4: tensor<2x2xf32>) {
-    %3 = stablehlo.add %arg3, %arg4 : tensor<2x2xf32>
+  %2 = mpmd.fragment<mesh="m1", origin=["g"]> (%0, %arg2) (%arg5: tensor<2x2xf32>, %arg6: tensor<2x2xf32>) {
+    %3 = stablehlo.add %arg5, %arg6 : tensor<2x2xf32>
     mpmd.return %3 : tensor<2x2xf32>
   } : (!mesh_1_tensor_2_2_f32, !mesh_1_tensor_2_2_f32) -> !mesh_1_tensor_2_2_f32
   // CHECK-NEXT: return %[[RES]] : !mpmd.mesh_tensor<"m1", tensor<2x2xf32>>
   return %2 : !mesh_1_tensor_2_2_f32
 }
-
-// CHECK-LABEL: func @merge_three_fragments
-func.func @merge_three_fragments
-(%arg0: !mesh_1_tensor_2_2_f32, %arg1: !mesh_1_tensor_2_2_f32, %arg2: !mesh_1_tensor_2_2_f32)
- -> (!mesh_1_tensor_2_2_f32)
- attributes {topology = #mpmd.topology<<"m1" : <["x"=1]>>>} {
-  // CHECK: %[[FRAG1_RES:.*]] = mpmd.fragment<mesh="m1", origin=["i", "j", "k"]> (%arg0, %arg1, %arg2) (%arg3: tensor<2x2xf32>, %arg4: tensor<2x2xf32>, %arg5: tensor<2x2xf32>) {
-  // CHECK-NEXT:   %2 = stablehlo.add %arg3, %arg4 : tensor<2x2xf32>
-  // CHECK-NEXT:   %3 = stablehlo.add %2, %arg5 : tensor<2x2xf32>
-  // CHECK-NEXT:   %4 = stablehlo.add %3, %arg4 : tensor<2x2xf32>
-  // CHECK-NEXT:   mpmd.return %4 : tensor<2x2xf32>
-  // CHECK-NEXT: } : (!mpmd.mesh_tensor<"m1", tensor<2x2xf32>>, !mpmd.mesh_tensor<"m1", tensor<2x2xf32>>, !mpmd.mesh_tensor<"m1", tensor<2x2xf32>>) -> !mpmd.mesh_tensor<"m1", tensor<2x2xf32>>
-  %0 = mpmd.fragment<mesh="m1", origin=["i"]> (%arg0, %arg1) (%arg3: tensor<2x2xf32>, %arg4: tensor<2x2xf32>) {
-    %1 = stablehlo.add %arg3, %arg4 : tensor<2x2xf32>
-    mpmd.return %1 : tensor<2x2xf32>
-  } : (!mesh_1_tensor_2_2_f32, !mesh_1_tensor_2_2_f32) -> !mesh_1_tensor_2_2_f32
-  %2 = mpmd.fragment<mesh="m1", origin=["j"]> (%0, %arg2) (%arg3: tensor<2x2xf32>, %arg4: tensor<2x2xf32>) {
-    %3 = stablehlo.add %arg3, %arg4 : tensor<2x2xf32>
-    mpmd.return %3 : tensor<2x2xf32>
-  } : (!mesh_1_tensor_2_2_f32, !mesh_1_tensor_2_2_f32) -> !mesh_1_tensor_2_2_f32
-  %4 = mpmd.fragment<mesh="m1", origin=["k"]> (%2, %arg1) (%arg3: tensor<2x2xf32>, %arg4: tensor<2x2xf32>) {
-    %5 = stablehlo.add %arg3, %arg4 : tensor<2x2xf32>
-    mpmd.return %5 : tensor<2x2xf32>
-  } : (!mesh_1_tensor_2_2_f32, !mesh_1_tensor_2_2_f32) -> !mesh_1_tensor_2_2_f32
-  // CHECK: %[[FRAG2_RES:.*]] = mpmd.fragment<mesh="m1", origin=["no_merge"]> (%0, %arg2) (%arg3: tensor<2x2xf32>, %arg4: tensor<2x2xf32>) {
-  // CHECK-NEXT:   %2 = stablehlo.add %arg3, %arg4 : tensor<2x2xf32>
-  // CHECK-NEXT:   mpmd.return %2 : tensor<2x2xf32>
-  // CHECK-NEXT: } : (!mpmd.mesh_tensor<"m1", tensor<2x2xf32>>, !mpmd.mesh_tensor<"m1", tensor<2x2xf32>>) -> !mpmd.mesh_tensor<"m1", tensor<2x2xf32>>
-  %6 = mpmd.fragment<mesh="m1", origin=["no_merge"]> (%4, %arg2) (%arg3: tensor<2x2xf32>, %arg4: tensor<2x2xf32>) {
-    %7 = stablehlo.add %arg3, %arg4 : tensor<2x2xf32>
-    mpmd.return %7 : tensor<2x2xf32>
-  } : (!mesh_1_tensor_2_2_f32, !mesh_1_tensor_2_2_f32) -> !mesh_1_tensor_2_2_f32
-  // CHECK-NEXT: return %[[FRAG2_RES]] : !mpmd.mesh_tensor<"m1", tensor<2x2xf32>>
-  return %6 : !mesh_1_tensor_2_2_f32
-}
diff --git a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
index 00fb5dd..58168f3 100644
--- a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
+++ b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
@@ -962,10 +962,8 @@ bool shouldReshard(TensorShardingAttr sourceSharding,
 
 TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
     OpOperand& use, TensorShardingAttr sourceSharding,
-    TensorShardingAttr userSharding, MeshAttr mesh, IRRewriter& rewriter) {
-  ArrayRef<AxisRefAttr> targetUnreducedAxes =
-      userSharding ? userSharding.getUnreducedAxes() : ArrayRef<AxisRefAttr>();
-
+    ArrayRef<AxisRefAttr> targetUnreducedAxes, MeshAttr mesh,
+    IRRewriter& rewriter) {
   if (!sourceSharding) {
     return nullptr;
   }
@@ -987,6 +985,15 @@ TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
   return allReduceSharding;
 }
 
+TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
+    OpOperand& use, TensorShardingAttr sourceSharding,
+    TensorShardingAttr userSharding, MeshAttr mesh, IRRewriter& rewriter) {
+  return insertAllReduceIfUnreducedToReplicated(
+      use, sourceSharding,
+      userSharding ? userSharding.getUnreducedAxes() : ArrayRef<AxisRefAttr>(),
+      mesh, rewriter);
+}
+
 bool hasOverlappingAxis(ArrayRef<AxisRefAttr> axes, AxisRefAttr axis) {
   return llvm::any_of(axes, [&](AxisRefAttr a) { return a.overlaps(axis); });
 }
@@ -1032,6 +1039,20 @@ void insertExplicitReshardsOnOp(Operation* op, IRRewriter& rewriter,
     return;
   }
 
+  // For each operand that has unreduced axes, insert an all-reduce if any of
+  // the unreduced axes isn't unreduced in the target sharding.
+  //
+  // We assume all results of an op should have the same unreduced axes, so we
+  // look at the first result.
+  TensorShardingAttr firstOutSharding =
+      outShardings.empty() ? nullptr : outShardings.front();
+  rewriter.setInsertionPoint(op);
+  for (auto [operand, sharding] :
+       llvm::zip_equal(op->getOpOperands(), inShardings)) {
+    sharding = insertAllReduceIfUnreducedToReplicated(
+        operand, sharding, firstOutSharding, defaultMesh.attr(), rewriter);
+  }
+
   ShardingProjection shardingProjection = ShardingProjection::build(
       inShardings, outShardings, shardingRule, defaultMesh.attr(),
       /*closedIfMissing=*/true);
diff --git a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
index 6a6231b..775be8c 100644
--- a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
+++ b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
@@ -59,8 +59,7 @@ bool shouldReshard(TensorShardingAttr sourceSharding,
                    TensorShardingAttr targetSharding);
 
 // Inserts an `sdy.all-reduce` on `use` if `sourceSharding` has unreduced axes
-// or sub-axes that aren't in the user's unreduced axes
-// (`userSharding.getUnreducedAxes()` if present , or an empty array otherwise.)
+// or sub-axes that aren't in `targetUnreducedAxes`.
 //
 // The inserted all-reduce will have `sourceSharding.getUnreducedAxes() -
 // targetUnreducedAxes` as the reduction axes.
@@ -71,6 +70,13 @@ bool shouldReshard(TensorShardingAttr sourceSharding,
 //
 // Returns the sharding of the inserted all-reduce, or `sourceSharding` if none
 // was inserted.
+TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
+    OpOperand& use, TensorShardingAttr sourceSharding,
+    ArrayRef<AxisRefAttr> targetUnreducedAxes, MeshAttr mesh,
+    IRRewriter& rewriter);
+
+// Same as above, but gets the target unreduced axes from `userSharding` if
+// present, or an empty array otherwise.
 TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
     OpOperand& use, TensorShardingAttr sourceSharding,
     TensorShardingAttr userSharding, MeshAttr mesh, IRRewriter& rewriter);
diff --git a/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc b/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
index d6d43c9..73a5070 100644
--- a/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
+++ b/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
@@ -299,29 +299,33 @@ struct InsertExplicitReshardsPass
         return;
       }
 
-      // For each operand that has unreduced axes, insert an all-reduce if
-      // any of the unreduced axes isn't unreduced in the target sharding.
-      //
-      // We assume all results of an op should have the same unreduced axes,
-      // so we look at the first result.
-      TensorShardingAttr outSharding =
-          op->getResults().empty() ? nullptr : getSharding(op->getResult(0));
-      rewriter.setInsertionPoint(op);
-      for (OpOperand& operand : op->getOpOperands()) {
-        if (TensorShardingAttr inSharding = getSharding(operand.get())) {
-          insertAllReduceIfUnreducedToReplicated(
-              operand, inSharding, outSharding, inSharding.getMesh(symbolTable),
-              rewriter);
-        }
-      }
-
       // TODO(enver): Refactor to deduplicate logic between minimal and full.
-      if (enableFullVersion ||
-          op->getName().getStringRef() == "mhlo.ragged_dot") {
+      if (enableFullVersion) {
         insertExplicitReshardsOnOp(op, rewriter, symbolTable);
         return;
       }
 
+      if (op->getName().getStringRef() == "mhlo.ragged_dot") {
+        insertExplicitReshardsOnOp(op, rewriter, symbolTable);
+      } else {
+        // For each operand that has unreduced axes, insert an all-reduce if
+        // any of the unreduced axes isn't unreduced in the target sharding.
+        //
+        // We assume all results of an op should have the same unreduced axes,
+        // so we look at the first result.
+        TensorShardingAttr outSharding =
+            op->getResults().empty() ? nullptr : getSharding(op->getResult(0));
+        rewriter.setInsertionPoint(op);
+        for (OpOperand& operand : op->getOpOperands()) {
+          TensorShardingAttr inSharding = getSharding(operand.get());
+          if (inSharding) {
+            insertAllReduceIfUnreducedToReplicated(
+                operand, inSharding, outSharding,
+                inSharding.getMesh(symbolTable), rewriter);
+          }
+        }
+      }
+
       TypeSwitch<Operation*>(op)
           .Case<stablehlo::DotOp>([&](stablehlo::DotOp dotOp) {
             processDot(dotOp, rewriter, symbolTable);
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index a4953c3..d7acb4c 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,54 +1,743 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaOverload.cpp b/clang/lib/Sema/SemaOverload.cpp
---- a/clang/lib/Sema/SemaOverload.cpp
-+++ b/clang/lib/Sema/SemaOverload.cpp
-@@ -8042,8 +8042,8 @@
+diff -ruN --strip-trailing-cr a/clang/lib/Sema/AnalysisBasedWarnings.cpp b/clang/lib/Sema/AnalysisBasedWarnings.cpp
+--- a/clang/lib/Sema/AnalysisBasedWarnings.cpp
++++ b/clang/lib/Sema/AnalysisBasedWarnings.cpp
+@@ -503,8 +503,12 @@
  
-     Candidate.IgnoreObjectArgument =
-         isa<CXXMethodDecl>(Candidate.Function) &&
--        cast<CXXMethodDecl>(Candidate.Function)
--            ->isImplicitObjectMemberFunction() &&
-+        !cast<CXXMethodDecl>(Candidate.Function)
-+             ->isExplicitObjectMemberFunction() &&
-         !isa<CXXConstructorDecl>(Candidate.Function);
+   TransferFunctions TF(VD);
+   BackwardDataflowWorklist Worklist(*AC.getCFG(), AC);
++  llvm::DenseSet<const CFGBlock *> Visited;
+   Worklist.enqueueBlock(&VarBlk);
+   while (const CFGBlock *B = Worklist.dequeue()) {
++    if (Visited.contains(B))
++      continue;
++    Visited.insert(B);
+     // First check the current block.
+     for (CFGBlock::const_reverse_iterator ri = B->rbegin(), re = B->rend();
+          ri != re; ++ri) {
+diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/noreturn-weverything.c b/clang/test/SemaCXX/noreturn-weverything.c
+--- a/clang/test/SemaCXX/noreturn-weverything.c
++++ b/clang/test/SemaCXX/noreturn-weverything.c
+@@ -0,0 +1,15 @@
++// RUN: %clang_cc1 -fsyntax-only %s -Weverything
++
++void free(void *);
++typedef void (*set_free_func)(void *);
++struct Method {
++  int nparams;
++  int *param;
++};
++void selelem_free_method(struct Method* method, void* data) {
++    set_free_func free_func = 0;
++    for (int i = 0; i < method->nparams; ++i)
++        free(&method->param[i]);
++    if (data && free_func)
++        free_func(data);
++}
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/MC/MCObjectStreamer.h b/llvm/include/llvm/MC/MCObjectStreamer.h
+--- a/llvm/include/llvm/MC/MCObjectStreamer.h
++++ b/llvm/include/llvm/MC/MCObjectStreamer.h
+@@ -52,10 +52,6 @@
+   DenseMap<const MCSymbol *, SmallVector<PendingAssignment, 1>>
+       pendingAssignments;
+ 
+-  SmallVector<std::unique_ptr<char[]>, 0> FragStorage;
+-  // Available bytes in the current block for trailing data or new fragments.
+-  size_t FragSpace = 0;
+-
+   void emitInstToData(const MCInst &Inst, const MCSubtargetInfo &);
+   void emitCFIStartProcImpl(MCDwarfFrameInfo &Frame) override;
+   void emitCFIEndProcImpl(MCDwarfFrameInfo &Frame) override;
+@@ -88,18 +84,11 @@
+   // Add a fragment with a variable-size tail and start a new empty fragment.
+   void insert(MCFragment *F);
+ 
+-  char *getCurFragEnd() const {
+-    return reinterpret_cast<char *>(CurFrag + 1) + CurFrag->getFixedSize();
+-  }
+-  MCFragment *allocFragSpace(size_t Headroom);
+   // Add a new fragment to the current section without a variable-size tail.
+   void newFragment();
+ 
+-  void ensureHeadroom(size_t Headroom);
+   void appendContents(ArrayRef<char> Contents);
+   void appendContents(size_t Num, char Elt);
+-  // Add a fixup to the current fragment. Call ensureHeadroom beforehand to
+-  // ensure the fixup and appended content apply to the same fragment.
+   void addFixup(const MCExpr *Value, MCFixupKind Kind);
+ 
+   void emitLabel(MCSymbol *Symbol, SMLoc Loc = SMLoc()) override;
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/MC/MCSection.h b/llvm/include/llvm/MC/MCSection.h
+--- a/llvm/include/llvm/MC/MCSection.h
++++ b/llvm/include/llvm/MC/MCSection.h
+@@ -93,7 +93,8 @@
+   // Track content and fixups for the fixed-size part as fragments are
+   // appended to the section. The content remains immutable, except when
+   // modified by applyFixup.
+-  uint32_t FixedSize = 0;
++  uint32_t ContentStart = 0;
++  uint32_t ContentEnd = 0;
+   uint32_t FixupStart = 0;
+   uint32_t FixupEnd = 0;
+ 
+@@ -187,6 +188,18 @@
+   //== Content-related functions manage parent's storage using ContentStart and
+   // ContentSize.
+ 
++  // Get a SmallVector reference. The caller should call doneAppending to update
++  // `ContentEnd`.
++  SmallVectorImpl<char> &getContentsForAppending();
++  void doneAppending();
++  void appendContents(ArrayRef<char> Contents) {
++    getContentsForAppending().append(Contents.begin(), Contents.end());
++    doneAppending();
++  }
++  void appendContents(size_t Num, char Elt) {
++    getContentsForAppending().append(Num, Elt);
++    doneAppending();
++  }
+   MutableArrayRef<char> getContents();
+   ArrayRef<char> getContents() const;
+ 
+@@ -195,10 +208,10 @@
+   MutableArrayRef<char> getVarContents();
+   ArrayRef<char> getVarContents() const;
+ 
+-  size_t getFixedSize() const { return FixedSize; }
++  size_t getFixedSize() const { return ContentEnd - ContentStart; }
+   size_t getVarSize() const { return VarContentEnd - VarContentStart; }
+   size_t getSize() const {
+-    return FixedSize + (VarContentEnd - VarContentStart);
++    return ContentEnd - ContentStart + (VarContentEnd - VarContentStart);
+   }
+ 
+   //== Fixup-related functions manage parent's storage using FixupStart and
+@@ -621,11 +634,28 @@
+   bool isBssSection() const { return IsBss; }
+ };
+ 
++inline SmallVectorImpl<char> &MCFragment::getContentsForAppending() {
++  SmallVectorImpl<char> &S = getParent()->ContentStorage;
++  if (LLVM_UNLIKELY(ContentEnd != S.size())) {
++    // Move the elements to the end. Reserve space to avoid invalidating
++    // S.begin()+I for `append`.
++    auto Size = ContentEnd - ContentStart;
++    auto I = std::exchange(ContentStart, S.size());
++    S.reserve(S.size() + Size);
++    S.append(S.begin() + I, S.begin() + I + Size);
++  }
++  return S;
++}
++inline void MCFragment::doneAppending() {
++  ContentEnd = getParent()->ContentStorage.size();
++}
+ inline MutableArrayRef<char> MCFragment::getContents() {
+-  return {reinterpret_cast<char *>(this + 1), FixedSize};
++  return MutableArrayRef(getParent()->ContentStorage)
++      .slice(ContentStart, ContentEnd - ContentStart);
+ }
+ inline ArrayRef<char> MCFragment::getContents() const {
+-  return {reinterpret_cast<const char *>(this + 1), FixedSize};
++  return ArrayRef(getParent()->ContentStorage)
++      .slice(ContentStart, ContentEnd - ContentStart);
+ }
+ 
+ inline MutableArrayRef<char> MCFragment::getVarContents() {
+diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCObjectStreamer.cpp b/llvm/lib/MC/MCObjectStreamer.cpp
+--- a/llvm/lib/MC/MCObjectStreamer.cpp
++++ b/llvm/lib/MC/MCObjectStreamer.cpp
+@@ -46,83 +46,27 @@
+   return nullptr;
+ }
+ 
+-constexpr size_t FragBlockSize = 16384;
+-// Ensure the new fragment can at least store a few bytes.
+-constexpr size_t NewFragHeadroom = 8;
+-
+-static_assert(NewFragHeadroom >= alignof(MCFragment));
+-static_assert(FragBlockSize >= sizeof(MCFragment) + NewFragHeadroom);
+-
+-MCFragment *MCObjectStreamer::allocFragSpace(size_t Headroom) {
+-  auto Size = std::max(FragBlockSize, sizeof(MCFragment) + Headroom);
+-  FragSpace = Size - sizeof(MCFragment);
+-  auto Chunk = std::unique_ptr<char[]>(new char[Size]);
+-  auto *F = reinterpret_cast<MCFragment *>(Chunk.get());
+-  FragStorage.push_back(std::move(Chunk));
+-  return F;
+-}
+-
+ void MCObjectStreamer::newFragment() {
+-  MCFragment *F;
+-  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
+-    auto End = reinterpret_cast<size_t>(getCurFragEnd());
+-    F = reinterpret_cast<MCFragment *>(
+-        alignToPowerOf2(End, alignof(MCFragment)));
+-    FragSpace -= size_t(F) - End + sizeof(MCFragment);
+-  } else {
+-    F = allocFragSpace(0);
+-  }
+-  new (F) MCFragment();
+-  addFragment(F);
+-}
+-
+-void MCObjectStreamer::ensureHeadroom(size_t Headroom) {
+-  if (Headroom <= FragSpace)
+-    return;
+-  auto *F = allocFragSpace(Headroom);
+-  new (F) MCFragment();
+-  addFragment(F);
++  addFragment(getContext().allocFragment<MCFragment>());
+ }
  
-     Candidate.ExplicitCallArguments = Args.size();
-diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx2b-deducing-this.cpp b/clang/test/SemaCXX/cxx2b-deducing-this.cpp
---- a/clang/test/SemaCXX/cxx2b-deducing-this.cpp
-+++ b/clang/test/SemaCXX/cxx2b-deducing-this.cpp
-@@ -1357,3 +1357,35 @@
+-void MCObjectStreamer::insert(MCFragment *Frag) {
+-  assert(Frag->getKind() != MCFragment::FT_Data &&
++void MCObjectStreamer::insert(MCFragment *F) {
++  assert(F->getKind() != MCFragment::FT_Data &&
+          "F should have a variable-size tail");
+-  // Frag is not connected to FragSpace. Before modifying CurFrag with
+-  // addFragment(Frag), allocate an empty fragment to maintain FragSpace
+-  // connectivity, potentially reusing CurFrag's associated space.
+-  MCFragment *F;
+-  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
+-    auto End = reinterpret_cast<size_t>(getCurFragEnd());
+-    F = reinterpret_cast<MCFragment *>(
+-        alignToPowerOf2(End, alignof(MCFragment)));
+-    FragSpace -= size_t(F) - End + sizeof(MCFragment);
+-  } else {
+-    F = allocFragSpace(0);
+-  }
+-  new (F) MCFragment();
+-
+-  addFragment(Frag);
+   addFragment(F);
++  newFragment();
  }
  
+ void MCObjectStreamer::appendContents(ArrayRef<char> Contents) {
+-  ensureHeadroom(Contents.size());
+-  assert(FragSpace >= Contents.size());
+-  llvm::copy(Contents, getCurFragEnd());
+-  CurFrag->FixedSize += Contents.size();
+-  FragSpace -= Contents.size();
++  CurFrag->appendContents(Contents);
  }
+ 
+ void MCObjectStreamer::appendContents(size_t Num, char Elt) {
+-  ensureHeadroom(Num);
+-  MutableArrayRef<char> Data(getCurFragEnd(), Num);
+-  llvm::fill(Data, Elt);
+-  CurFrag->FixedSize += Num;
+-  FragSpace -= Num;
++  CurFrag->appendContents(Num, Elt);
+ }
+ 
+ void MCObjectStreamer::addFixup(const MCExpr *Value, MCFixupKind Kind) {
+-  CurFrag->addFixup(MCFixup::create(getCurFragSize(), Value, Kind));
++  CurFrag->addFixup(MCFixup::create(CurFrag->getFixedSize(), Value, Kind));
+ }
+ 
+ // As a compile-time optimization, avoid allocating and evaluating an MCExpr
+@@ -171,8 +115,6 @@
+   }
+   EmitEHFrame = true;
+   EmitDebugFrame = false;
+-  FragStorage.clear();
+-  FragSpace = 0;
+   MCStreamer::reset();
+ }
+ 
+@@ -201,6 +143,7 @@
+ void MCObjectStreamer::emitValueImpl(const MCExpr *Value, unsigned Size,
+                                      SMLoc Loc) {
+   MCStreamer::emitValueImpl(Value, Size, Loc);
++  MCFragment *DF = getCurrentFragment();
+ 
+   MCDwarfLineEntry::make(this, getCurrentSectionOnly());
+ 
+@@ -215,9 +158,9 @@
+     emitIntValue(AbsValue, Size);
+     return;
+   }
+-  ensureHeadroom(Size);
+-  addFixup(Value, MCFixup::getDataKindForSize(Size));
+-  appendContents(Size, 0);
++  DF->addFixup(MCFixup::create(DF->getContents().size(), Value,
++                               MCFixup::getDataKindForSize(Size)));
++  DF->appendContents(Size, 0);
+ }
+ 
+ MCSymbol *MCObjectStreamer::emitCFILabel() {
+@@ -251,7 +194,7 @@
+   // section.
+   MCFragment *F = CurFrag;
+   Symbol->setFragment(F);
+-  Symbol->setOffset(F->getFixedSize());
++  Symbol->setOffset(F->getContents().size());
+ 
+   emitPendingAssignments(Symbol);
+ }
+@@ -317,21 +260,6 @@
+     F0 = CurFrag;
+   }
+ 
+-  // To maintain connectivity between CurFrag and FragSpace when CurFrag is
+-  // modified, allocate an empty fragment and append it to the fragment list.
+-  // (Subsections[I].second.Tail is not connected to FragSpace.)
+-  MCFragment *F;
+-  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
+-    auto End = reinterpret_cast<size_t>(getCurFragEnd());
+-    F = reinterpret_cast<MCFragment *>(
+-        alignToPowerOf2(End, alignof(MCFragment)));
+-    FragSpace -= size_t(F) - End + sizeof(MCFragment);
+-  } else {
+-    F = allocFragSpace(0);
+-  }
+-  new (F) MCFragment();
+-  F->setParent(Section);
+-
+   auto &Subsections = Section->Subsections;
+   size_t I = 0, E = Subsections.size();
+   while (I != E && Subsections[I].first < Subsection)
+@@ -339,16 +267,13 @@
+   // If the subsection number is not in the sorted Subsections list, create a
+   // new fragment list.
+   if (I == E || Subsections[I].first != Subsection) {
++    auto *F = getContext().allocFragment<MCFragment>();
++    F->setParent(Section);
+     Subsections.insert(Subsections.begin() + I,
+                        {Subsection, MCSection::FragList{F, F}});
+-    Section->CurFragList = &Subsections[I].second;
+-    CurFrag = F;
+-  } else {
+-    Section->CurFragList = &Subsections[I].second;
+-    CurFrag = Subsections[I].second.Tail;
+-    // Ensure CurFrag is associated with FragSpace.
+-    addFragment(F);
+   }
++  Section->CurFragList = &Subsections[I].second;
++  CurFrag = Section->CurFragList->Tail;
+ 
+   // Define the section symbol at subsection 0's initial fragment if required.
+   if (!NewSec)
+@@ -419,15 +344,11 @@
+   MCFragment *F = getCurrentFragment();
+ 
+   // Append the instruction to the data fragment.
+-  size_t CodeOffset = getCurFragSize();
+-  SmallString<16> Content;
++  size_t CodeOffset = F->getContents().size();
+   SmallVector<MCFixup, 1> Fixups;
+-  getAssembler().getEmitter().encodeInstruction(Inst, Content, Fixups, STI);
+-  appendContents(Content);
+-  if (CurFrag != F) {
+-    F = CurFrag;
+-    CodeOffset = 0;
+-  }
++  getAssembler().getEmitter().encodeInstruction(
++      Inst, F->getContentsForAppending(), Fixups, STI);
++  F->doneAppending();
+   F->setHasInstructions(STI);
+ 
+   if (Fixups.empty())
+diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCWin64EH.cpp b/llvm/lib/MC/MCWin64EH.cpp
+--- a/llvm/lib/MC/MCWin64EH.cpp
++++ b/llvm/lib/MC/MCWin64EH.cpp
+@@ -318,9 +318,6 @@
+ 
+   // Emit the epilog instructions.
+   if (EnableUnwindV2) {
+-    // Ensure the fixups and appended content apply to the same fragment.
+-    OS->ensureHeadroom(info->EpilogMap.size() * 2);
+-
+     bool IsLast = true;
+     for (const auto &Epilog : llvm::reverse(info->EpilogMap)) {
+       if (IsLast) {
+diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCWinCOFFStreamer.cpp b/llvm/lib/MC/MCWinCOFFStreamer.cpp
+--- a/llvm/lib/MC/MCWinCOFFStreamer.cpp
++++ b/llvm/lib/MC/MCWinCOFFStreamer.cpp
+@@ -280,7 +280,6 @@
+ void MCWinCOFFStreamer::emitCOFFSectionIndex(const MCSymbol *Symbol) {
+   visitUsedSymbol(*Symbol);
+   const MCSymbolRefExpr *SRE = MCSymbolRefExpr::create(Symbol, getContext());
+-  ensureHeadroom(2);
+   addFixup(SRE, FK_SecRel_2);
+   appendContents(2, 0);
+ }
+@@ -294,7 +293,6 @@
+   if (Offset)
+     MCE = MCBinaryExpr::createAdd(
+         MCE, MCConstantExpr::create(Offset, getContext()), getContext());
+-  ensureHeadroom(4);
+   addFixup(MCE, FK_SecRel_4);
+   // Emit 4 bytes (zeros) to the object file.
+   appendContents(4, 0);
+@@ -310,7 +308,6 @@
+   if (Offset)
+     MCE = MCBinaryExpr::createAdd(
+         MCE, MCConstantExpr::create(Offset, getContext()), getContext());
+-  ensureHeadroom(4);
+   addFixup(MCE, FK_Data_4);
+   // Emit 4 bytes (zeros) to the object file.
+   appendContents(4, 0);
+@@ -321,7 +318,6 @@
+   // Create Symbol for section number.
+   const MCExpr *MCE = MCCOFFSectionNumberTargetExpr::create(
+       *Symbol, this->getWriter(), getContext());
+-  ensureHeadroom(4);
+   addFixup(MCE, FK_Data_4);
+   // Emit 4 bytes (zeros) to the object file.
+   appendContents(4, 0);
+@@ -332,7 +328,6 @@
+   // Create Symbol for section offset.
+   const MCExpr *MCE =
+       MCCOFFSectionOffsetTargetExpr::create(*Symbol, getContext());
+-  ensureHeadroom(4);
+   addFixup(MCE, FK_Data_4);
+   // Emit 4 bytes (zeros) to the object file.
+   appendContents(4, 0);
+diff -ruN --strip-trailing-cr a/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp b/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
+--- a/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
++++ b/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
+@@ -1034,14 +1034,12 @@
+ 
+ void MipsTargetELFStreamer::emitGPRel32Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(4);
+   S.addFixup(Value, Mips::fixup_Mips_GPREL32);
+   S.appendContents(4, 0);
+ }
+ 
+ void MipsTargetELFStreamer::emitGPRel64Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(8);
+   // fixup_Mips_GPREL32 desginates R_MIPS_GPREL32+R_MIPS_64 on MIPS64.
+   S.addFixup(Value, Mips::fixup_Mips_GPREL32);
+   S.appendContents(8, 0);
+@@ -1049,28 +1047,24 @@
+ 
+ void MipsTargetELFStreamer::emitDTPRel32Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(4);
+   S.addFixup(Value, Mips::fixup_Mips_DTPREL32);
+   S.appendContents(4, 0);
+ }
+ 
+ void MipsTargetELFStreamer::emitDTPRel64Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(8);
+   S.addFixup(Value, Mips::fixup_Mips_DTPREL64);
+   S.appendContents(8, 0);
+ }
+ 
+ void MipsTargetELFStreamer::emitTPRel32Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(4);
+   S.addFixup(Value, Mips::fixup_Mips_TPREL32);
+   S.appendContents(4, 0);
+ }
+ 
+ void MipsTargetELFStreamer::emitTPRel64Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(8);
+   S.addFixup(Value, Mips::fixup_Mips_TPREL64);
+   S.appendContents(8, 0);
+ }
+diff -ruN --strip-trailing-cr a/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td b/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
+--- a/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
++++ b/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
+@@ -1830,6 +1830,18 @@
+ def : Pat<(declare_scalar_param externalsym:$a, imm:$size),
+           (DECLARE_PARAM_scalar (to_texternsym $a), imm:$size)>;
+ 
++// Call prototype wrapper, this is a dummy instruction that just prints it's
++// operand which is string defining the prototype.
++def SDTCallPrototype : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
++def CallPrototype :
++  SDNode<"NVPTXISD::CallPrototype", SDTCallPrototype,
++         [SDNPHasChain, SDNPOutGlue, SDNPInGlue, SDNPSideEffect]>;
++def ProtoIdent : Operand<i32> { let PrintMethod = "printProtoIdent"; }
++def CALL_PROTOTYPE :
++  NVPTXInst<(outs), (ins ProtoIdent:$ident),
++            "$ident", [(CallPrototype (i32 texternalsym:$ident))]>;
 +
-+namespace GH147046_regression {
 +
-+template <typename z> struct ai {
-+    ai(z::ah);
-+};
+ foreach t = [I32RT, I64RT] in {
+   defvar inst_name = "MOV" # t.Size # "_PARAM";
+   def inst_name : BasicNVPTXInst<(outs t.RC:$dst), (ins t.RC:$src), "mov.b" # t.Size>;
+@@ -1849,6 +1861,32 @@
+ defm ProxyRegB32 : ProxyRegInst<"b32",  B32>;
+ defm ProxyRegB64 : ProxyRegInst<"b64",  B64>;
+ 
 +
-+template <typename z> struct ak {
-+    template <typename am> void an(am, z);
-+    template <typename am> static void an(am, ai<z>);
-+};
-+template <typename> struct ao {};
++// Callseq start and end
 +
-+template <typename ap>
-+auto ar(ao<ap> at) -> decltype(ak<ap>::an(at, 0));
-+// expected-note@-1 {{candidate template ignored: substitution failure [with ap = GH147046_regression::ay]: no matching function for call to 'an'}}
++// Note: these nodes are marked as SDNPMayStore and SDNPMayLoad because
++// they define the scope in which the declared params may be used. Therefore
++// we add these flags to ensure ld.param and st.param are not sunk or hoisted
++// out of that scope.
 +
-+class aw;
-+struct ax {
-+    typedef int ah;
-+};
-+struct ay {
-+    typedef aw ah;
-+};
++def callseq_start : SDNode<"ISD::CALLSEQ_START",
++                           SDCallSeqStart<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>,
++                           [SDNPHasChain, SDNPOutGlue,
++                            SDNPSideEffect, SDNPMayStore, SDNPMayLoad]>;
++def callseq_end   : SDNode<"ISD::CALLSEQ_END",
++                           SDCallSeqEnd<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>,
++                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
++                            SDNPSideEffect, SDNPMayStore, SDNPMayLoad]>;
++
++def Callseq_Start :
++  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
++            "\\{ // callseq $amt1, $amt2",
++            [(callseq_start timm:$amt1, timm:$amt2)]>;
++def Callseq_End :
++  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
++            "\\} // callseq $amt1",
++            [(callseq_end timm:$amt1, timm:$amt2)]>;
++
+ //
+ // Load / Store Handling
+ //
+@@ -2392,26 +2430,6 @@
+ def : Pat<(brcond (i1 (setne i1:$a, -1)), bb:$target),
+           (CBranchOther $a, bb:$target)>;
+ 
+-// Call
+-def SDT_NVPTXCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>,
+-                                            SDTCisVT<1, i32>]>;
+-def SDT_NVPTXCallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>;
+-
+-def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_NVPTXCallSeqStart,
+-                           [SDNPHasChain, SDNPOutGlue, SDNPSideEffect]>;
+-def callseq_end   : SDNode<"ISD::CALLSEQ_END", SDT_NVPTXCallSeqEnd,
+-                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
+-                            SDNPSideEffect]>;
+-
+-def Callseq_Start :
+-  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
+-            "\\{ // callseq $amt1, $amt2",
+-            [(callseq_start timm:$amt1, timm:$amt2)]>;
+-def Callseq_End :
+-  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
+-            "\\} // callseq $amt1",
+-            [(callseq_end timm:$amt1, timm:$amt2)]>;
+-
+ // trap instruction
+ def trapinst : BasicNVPTXInst<(outs), (ins), "trap", [(trap)]>, Requires<[noPTXASUnreachableBug]>;
+ // Emit an `exit` as well to convey to ptxas that `trap` exits the CFG.
+@@ -2420,18 +2438,6 @@
+ // brkpt instruction
+ def debugtrapinst : BasicNVPTXInst<(outs), (ins), "brkpt", [(debugtrap)]>;
+ 
+-// Call prototype wrapper
+-def SDTCallPrototype : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
+-def CallPrototype :
+-  SDNode<"NVPTXISD::CallPrototype", SDTCallPrototype,
+-         [SDNPHasChain, SDNPOutGlue, SDNPInGlue, SDNPSideEffect]>;
+-def ProtoIdent : Operand<i32> {
+-  let PrintMethod = "printProtoIdent";
+-}
+-def CALL_PROTOTYPE :
+-  NVPTXInst<(outs), (ins ProtoIdent:$ident),
+-            "$ident", [(CallPrototype (i32 texternalsym:$ident))]>;
+-
+ def SDTDynAllocaOp :
+   SDTypeProfile<1, 2, [SDTCisSameAs<0, 1>, SDTCisInt<1>, SDTCisVT<2, i32>]>;
+ 
+diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/ld-param-sink.ll b/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
+--- a/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
++++ b/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
+@@ -0,0 +1,47 @@
++; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
++; RUN: llc < %s -verify-machineinstrs | FileCheck %s
++; RUN: %if ptxas %{ llc < %s | %ptxas-verify %}
++
++target triple = "nvptx64-nvidia-cuda"
++
++declare ptr @bar(i64)
++declare i64 @baz()
++
++define ptr @foo(i1 %cond) {
++; CHECK-LABEL: foo(
++; CHECK:       {
++; CHECK-NEXT:    .reg .pred %p<2>;
++; CHECK-NEXT:    .reg .b16 %rs<3>;
++; CHECK-NEXT:    .reg .b64 %rd<3>;
++; CHECK-EMPTY:
++; CHECK-NEXT:  // %bb.0: // %entry
++; CHECK-NEXT:    ld.param.b8 %rs1, [foo_param_0];
++; CHECK-NEXT:    and.b16 %rs2, %rs1, 1;
++; CHECK-NEXT:    setp.ne.b16 %p1, %rs2, 0;
++; CHECK-NEXT:    { // callseq 0, 0
++; CHECK-NEXT:    .param .b64 retval0;
++; CHECK-NEXT:    call.uni (retval0), baz, ();
++; CHECK-NEXT:    ld.param.b64 %rd2, [retval0];
++; CHECK-NEXT:    } // callseq 0
++; CHECK-NEXT:    @%p1 bra $L__BB0_2;
++; CHECK-NEXT:  // %bb.1: // %bb
++; CHECK-NEXT:    { // callseq 1, 0
++; CHECK-NEXT:    .param .b64 param0;
++; CHECK-NEXT:    .param .b64 retval0;
++; CHECK-NEXT:    st.param.b64 [param0], %rd2;
++; CHECK-NEXT:    call.uni (retval0), bar, (param0);
++; CHECK-NEXT:    } // callseq 1
++; CHECK-NEXT:  $L__BB0_2: // %common.ret
++; CHECK-NEXT:    st.param.b64 [func_retval0], 0;
++; CHECK-NEXT:    ret;
++entry:
++  %call = call i64 @baz()
++  br i1 %cond, label %common.ret, label %bb
++
++bb:
++  %tmp = call ptr @bar(i64 %call)
++  br label %common.ret
++
++common.ret:
++  ret ptr null
++}
+diff -ruN --strip-trailing-cr a/llvm/test/MC/ELF/many-instructions.s b/llvm/test/MC/ELF/many-instructions.s
+--- a/llvm/test/MC/ELF/many-instructions.s
++++ b/llvm/test/MC/ELF/many-instructions.s
+@@ -1,10 +0,0 @@
+-# REQUIRES: asserts
+-# RUN: llvm-mc -filetype=obj -triple=x86_64 %s -o /dev/null -debug-only=mc-dump
+-
+-## Test that encodeInstruction may cause a new fragment to be created.
+-# CHECK: 0 Data Size:16200
+-# CHECK: 16200 Data Size:180
+-
+-.rept 16384/10
+-movabsq $foo, %rax
+-.endr
+diff -ruN --strip-trailing-cr a/mlir/lib/IR/MLIRContext.cpp b/mlir/lib/IR/MLIRContext.cpp
+--- a/mlir/lib/IR/MLIRContext.cpp
++++ b/mlir/lib/IR/MLIRContext.cpp
+@@ -884,6 +884,8 @@
+ void OperationName::UnregisteredOpModel::initProperties(
+     OperationName opName, OpaqueProperties storage, OpaqueProperties init) {
+   new (storage.as<Attribute *>()) Attribute();
++  if (init)
++    *storage.as<Attribute *>() = *init.as<Attribute *>();
+ }
+ void OperationName::UnregisteredOpModel::deleteProperties(
+     OpaqueProperties prop) {
+diff -ruN --strip-trailing-cr a/mlir/lib/Parser/Parser.cpp b/mlir/lib/Parser/Parser.cpp
+--- a/mlir/lib/Parser/Parser.cpp
++++ b/mlir/lib/Parser/Parser.cpp
+@@ -17,14 +17,32 @@
+ 
+ using namespace mlir;
+ 
++static std::pair<int64_t, int64_t>
++getLineAndColStart(const llvm::SourceMgr &sourceMgr) {
++  unsigned lastFileID = sourceMgr.getNumBuffers();
++  if (lastFileID == 1)
++    return {0, 0};
 +
-+ao<ay> az ;
-+ai<ax> bd(0);
-+void f() {
-+    ar(az); // expected-error {{no matching function for call to 'ar'}}
++  auto bufferID = sourceMgr.getMainFileID();
++  const llvm::MemoryBuffer *main = sourceMgr.getMemoryBuffer(bufferID);
++  const llvm::MemoryBuffer *last = sourceMgr.getMemoryBuffer(lastFileID);
++  // Exclude same start.
++  if (main->getBufferStart() < last->getBufferStart() &&
++      main->getBufferEnd() >= last->getBufferEnd()) {
++    return sourceMgr.getLineAndColumn(
++        llvm::SMLoc::getFromPointer(last->getBufferStart()), bufferID);
++  }
++  return {0, 0};
 +}
 +
+ LogicalResult mlir::parseSourceFile(const llvm::SourceMgr &sourceMgr,
+                                     Block *block, const ParserConfig &config,
+                                     LocationAttr *sourceFileLoc) {
+   const auto *sourceBuf = sourceMgr.getMemoryBuffer(sourceMgr.getMainFileID());
+   if (sourceFileLoc) {
+-    *sourceFileLoc = FileLineColLoc::get(config.getContext(),
+-                                         sourceBuf->getBufferIdentifier(),
+-                                         /*line=*/0, /*column=*/0);
++    auto [line, column] = getLineAndColStart(sourceMgr);
++    *sourceFileLoc = FileLineColLoc::get(
++        config.getContext(), sourceBuf->getBufferIdentifier(), line, column);
+   }
+   if (isBytecode(*sourceBuf))
+     return readBytecodeFile(*sourceBuf, block, config);
+@@ -37,9 +55,9 @@
+   const auto *sourceBuf =
+       sourceMgr->getMemoryBuffer(sourceMgr->getMainFileID());
+   if (sourceFileLoc) {
+-    *sourceFileLoc = FileLineColLoc::get(config.getContext(),
+-                                         sourceBuf->getBufferIdentifier(),
+-                                         /*line=*/0, /*column=*/0);
++    auto [line, column] = getLineAndColStart(*sourceMgr);
++    *sourceFileLoc = FileLineColLoc::get(
++        config.getContext(), sourceBuf->getBufferIdentifier(), line, column);
+   }
+   if (isBytecode(*sourceBuf))
+     return readBytecodeFile(sourceMgr, block, config);
+diff -ruN --strip-trailing-cr a/mlir/test/IR/test-clone.mlir b/mlir/test/IR/test-clone.mlir
+--- a/mlir/test/IR/test-clone.mlir
++++ b/mlir/test/IR/test-clone.mlir
+@@ -1,4 +1,4 @@
+-// RUN: mlir-opt -allow-unregistered-dialect %s -pass-pipeline="builtin.module(func.func(test-clone))" | FileCheck %s
++// RUN: mlir-opt -allow-unregistered-dialect %s -pass-pipeline="builtin.module(func.func(test-clone))" --split-input-file | FileCheck %s
+ 
+ module {
+   func.func @fixpoint(%arg1 : i32) -> i32 {
+@@ -18,7 +18,8 @@
+ // CHECK-NEXT: notifyOperationInserted: test.yield
+ // CHECK-NEXT: notifyOperationInserted: func.return
+ 
+-// CHECK:   func @fixpoint(%[[arg0:.+]]: i32) -> i32 {
++// CHECK-LABEL: func @fixpoint
++// CHECK-SAME:       (%[[arg0:.+]]: i32) -> i32 {
+ // CHECK-NEXT:     %[[i0:.+]] = "test.use"(%[[arg0]]) ({
+ // CHECK-NEXT:       %[[r2:.+]] = "test.use2"(%[[arg0]]) ({
+ // CHECK-NEXT:         "test.yield2"(%[[arg0]]) : (i32) -> ()
+@@ -33,3 +34,33 @@
+ // CHECK-NEXT:     }) : (i32) -> i32
+ // CHECK-NEXT:     return %[[i1]] : i32
+ // CHECK-NEXT:   }
++
++// -----
++
++func.func @clone_unregistered_with_attrs() {
++  "unregistered.foo"() <{bar = 1 : i64, flag = true, name = "test", value = 3.14 : f32}> : () -> ()
++  "unregistered.bar"() : () -> ()
++  "unregistered.empty_dict"() <{}> : () -> ()
++  "unregistered.complex"() <{
++    array = [1, 2, 3],
++    dict = {key1 = 42 : i32, key2 = "value"},
++    nested = {inner = {deep = 100 : i64}}
++  }> : () -> ()
++  return
 +}
++
++// CHECK: notifyOperationInserted: unregistered.foo
++// CHECK-NEXT: notifyOperationInserted: unregistered.bar
++// CHECK-NEXT: notifyOperationInserted: unregistered.empty_dict
++// CHECK-NEXT: notifyOperationInserted: unregistered.complex
++// CHECK-NEXT: notifyOperationInserted: func.return
++
++// CHECK-LABEL:  func @clone_unregistered_with_attrs() {
++// CHECK-NEXT:     "unregistered.foo"() <{bar = 1 : i64, flag = true, name = "test", value = [[PI:.+]] : f32}> : () -> ()
++// CHECK-NEXT:     "unregistered.bar"() : () -> ()
++// CHECK-NEXT:     "unregistered.empty_dict"() <{}> : () -> ()
++// CHECK-NEXT:     "unregistered.complex"() <{array = [1, 2, 3], dict = {key1 = 42 : i32, key2 = "value"}, nested = {inner = {deep = 100 : i64}}}> : () -> ()
++// CHECK-NEXT:     "unregistered.foo"() <{bar = 1 : i64, flag = true, name = "test", value = [[PI]] : f32}> : () -> ()
++// CHECK-NEXT:     "unregistered.bar"() : () -> ()
++// CHECK-NEXT:     "unregistered.empty_dict"() <{}> : () -> ()
++// CHECK-NEXT:     "unregistered.complex"() <{array = [1, 2, 3], dict = {key1 = 42 : i32, key2 = "value"}, nested = {inner = {deep = 100 : i64}}}> : () -> ()
+diff -ruN --strip-trailing-cr a/mlir/test/IR/top-level.mlir b/mlir/test/IR/top-level.mlir
+--- a/mlir/test/IR/top-level.mlir
++++ b/mlir/test/IR/top-level.mlir
+@@ -6,10 +6,10 @@
+ 
+ // -----
+ 
+-// expected-error@-9 {{source must contain a single top-level operation, found: 2}}
++// expected-error@-2 {{source must contain a single top-level operation, found: 2}}
+ func.func private @bar()
+ func.func private @baz()
+ 
+ // -----
+ 
+-// expected-error@-15 {{source must contain a single top-level operation, found: 0}}
++// expected-error@-2 {{source must contain a single top-level operation, found: 0}}
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index aa7fc32..fababfa 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "652048ad2578c715d8d65d90fd3fe5d5d2bd42e7"
-    LLVM_SHA256 = "7398adc86335c401bc018583f03c87987cdae19988036819eb3c2b7ebe74b449"
+    LLVM_COMMIT = "8e7b02fc0cd5f63a14f4117866f860b7f174baf3"
+    LLVM_SHA256 = "465cf31bab17d09f9e119ea7a295ddc027ff2d142ee2aa971e8187c154bcdf44"
 
     tf_http_archive(
         name = name,
