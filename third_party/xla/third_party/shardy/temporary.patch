diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 509398d..ab67b8e 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1 +1,313 @@
 Auto generated patch. Do not edit or delete it, even if empty.
+diff -ruN --strip-trailing-cr a/clang/test/CodeGen/distributed-thin-lto/supports-hot-cold-new.ll b/clang/test/CodeGen/distributed-thin-lto/supports-hot-cold-new.ll
+--- a/clang/test/CodeGen/distributed-thin-lto/supports-hot-cold-new.ll
++++ b/clang/test/CodeGen/distributed-thin-lto/supports-hot-cold-new.ll
+@@ -22,7 +22,7 @@
+ 
+ ; RUN: %clang -target x86_64-unknown-linux-gnu -O2 -o %t1.o -x ir %t.o -c -fthinlto-index=%t.o.thinlto.bc -save-temps=obj
+ 
+-; RUN: llvm-dis %t.s.3.import.bc -o - | FileCheck %s --check-prefix=CHECK-IR
++; RUN: llvm-dis %t.s.4.opt.bc -o - | FileCheck %s --check-prefix=CHECK-IR
+ ; CHECK-IR: !memprof {{.*}} !callsite
+ ; CHECK-IR: "memprof"="cold"
+ 
+@@ -42,10 +42,15 @@
+ 
+ ; RUN: %clang -target x86_64-unknown-linux-gnu -O2 -o %t1.o -x ir %t.o -c -fthinlto-index=%t.o.thinlto.bc -save-temps=obj
+ 
+-; RUN: llvm-dis %t.s.3.import.bc -o - | FileCheck %s \
++; RUN: llvm-dis %t.s.4.opt.bc -o - | FileCheck %s \
+ ; RUN: --implicit-check-not "!memprof" --implicit-check-not "!callsite" \
+ ; RUN: --implicit-check-not "memprof"="cold"
+ 
++;; Ensure the attributes and metadata are stripped when running a non-LTO pipeline.
++; RUN: %clang -target x86_64-unknown-linux-gnu -O2 -x ir %t.o -S -emit-llvm -o - | FileCheck %s \
++; RUN: 	--implicit-check-not "!memprof" --implicit-check-not "!callsite" \
++; RUN: 	--implicit-check-not "memprof"="cold"
++
+ source_filename = "thinlto-distributed-supports-hot-cold-new.ll"
+ target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+ target triple = "x86_64-unknown-linux-gnu"
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/LTO/LTO.h b/llvm/include/llvm/LTO/LTO.h
+--- a/llvm/include/llvm/LTO/LTO.h
++++ b/llvm/include/llvm/LTO/LTO.h
+@@ -105,12 +105,6 @@
+ /// ordered indices to elements in the input array.
+ LLVM_ABI std::vector<int> generateModulesOrdering(ArrayRef<BitcodeModule *> R);
+ 
+-/// Updates MemProf attributes (and metadata) based on whether the index
+-/// has recorded that we are linking with allocation libraries containing
+-/// the necessary APIs for downstream transformations.
+-LLVM_ABI void updateMemProfAttributes(Module &Mod,
+-                                      const ModuleSummaryIndex &Index);
+-
+ class LTO;
+ struct SymbolResolution;
+ 
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h b/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h
+--- a/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h
++++ b/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h
+@@ -95,6 +95,16 @@
+            function_ref<bool(GlobalValue::GUID, const GlobalValueSummary *)>
+                isPrevailing);
+ };
++
++/// Strips MemProf attributes and metadata. Can be invoked by the pass pipeline
++/// when we don't have an index that has recorded that we are linking with
++/// allocation libraries containing the necessary APIs for downstream
++/// transformations.
++class MemProfRemoveInfo : public PassInfoMixin<MemProfRemoveInfo> {
++public:
++  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);
++};
++
+ } // end namespace llvm
+ 
+ #endif // LLVM_TRANSFORMS_IPO_MEMPROF_CONTEXT_DISAMBIGUATION_H
+diff -ruN --strip-trailing-cr a/llvm/lib/LTO/LTOBackend.cpp b/llvm/lib/LTO/LTOBackend.cpp
+--- a/llvm/lib/LTO/LTOBackend.cpp
++++ b/llvm/lib/LTO/LTOBackend.cpp
+@@ -726,7 +726,6 @@
+   }
+ 
+   // Do this after any importing so that imported code is updated.
+-  updateMemProfAttributes(Mod, CombinedIndex);
+   updatePublicTypeTestCalls(Mod, CombinedIndex.withWholeProgramVisibility());
+ 
+   if (Conf.PostImportModuleHook && !Conf.PostImportModuleHook(Task, Mod))
+diff -ruN --strip-trailing-cr a/llvm/lib/LTO/LTO.cpp b/llvm/lib/LTO/LTO.cpp
+--- a/llvm/lib/LTO/LTO.cpp
++++ b/llvm/lib/LTO/LTO.cpp
+@@ -1257,38 +1257,6 @@
+   return Result;
+ }
+ 
+-void lto::updateMemProfAttributes(Module &Mod,
+-                                  const ModuleSummaryIndex &Index) {
+-  llvm::TimeTraceScope timeScope("LTO update memprof attributes");
+-  if (Index.withSupportsHotColdNew())
+-    return;
+-
+-  // The profile matcher applies hotness attributes directly for allocations,
+-  // and those will cause us to generate calls to the hot/cold interfaces
+-  // unconditionally. If supports-hot-cold-new was not enabled in the LTO
+-  // link then assume we don't want these calls (e.g. not linking with
+-  // the appropriate library, or otherwise trying to disable this behavior).
+-  for (auto &F : Mod) {
+-    for (auto &BB : F) {
+-      for (auto &I : BB) {
+-        auto *CI = dyn_cast<CallBase>(&I);
+-        if (!CI)
+-          continue;
+-        if (CI->hasFnAttr("memprof"))
+-          CI->removeFnAttr("memprof");
+-        // Strip off all memprof metadata as it is no longer needed.
+-        // Importantly, this avoids the addition of new memprof attributes
+-        // after inlining propagation.
+-        // TODO: If we support additional types of MemProf metadata beyond hot
+-        // and cold, we will need to update the metadata based on the allocator
+-        // APIs supported instead of completely stripping all.
+-        CI->setMetadata(LLVMContext::MD_memprof, nullptr);
+-        CI->setMetadata(LLVMContext::MD_callsite, nullptr);
+-      }
+-    }
+-  }
+-}
+-
+ Error LTO::runRegularLTO(AddStreamFn AddStream) {
+   llvm::TimeTraceScope timeScope("Run regular LTO");
+   LLVMContext &CombinedCtx = RegularLTO.CombinedModule->getContext();
+@@ -1346,8 +1314,6 @@
+     }
+   }
+ 
+-  updateMemProfAttributes(*RegularLTO.CombinedModule, ThinLTO.CombinedIndex);
+-
+   bool WholeProgramVisibilityEnabledInLTO =
+       Conf.HasWholeProgramVisibility &&
+       // If validation is enabled, upgrade visibility only when all vtables
+diff -ruN --strip-trailing-cr a/llvm/lib/Passes/PassBuilderPipelines.cpp b/llvm/lib/Passes/PassBuilderPipelines.cpp
+--- a/llvm/lib/Passes/PassBuilderPipelines.cpp
++++ b/llvm/lib/Passes/PassBuilderPipelines.cpp
+@@ -1658,6 +1658,16 @@
+ 
+   ModulePassManager MPM;
+ 
++  // Currently this pipeline is only invoked in an LTO pre link pass or when we
++  // are not running LTO. If that changes the below checks may need updating.
++  assert(isLTOPreLink(Phase) || Phase == ThinOrFullLTOPhase::None);
++
++  // If we are invoking this in non-LTO mode, remove any MemProf related
++  // attributes and metadata, as we don't know whether we are linking with
++  // a library containing the necessary interfaces.
++  if (Phase == ThinOrFullLTOPhase::None)
++    MPM.addPass(MemProfRemoveInfo());
++
+   // Convert @llvm.global.annotations to !annotation metadata.
+   MPM.addPass(Annotation2MetadataPass());
+ 
+@@ -1803,6 +1813,12 @@
+     OptimizationLevel Level, const ModuleSummaryIndex *ImportSummary) {
+   ModulePassManager MPM;
+ 
++  // If we are invoking this without a summary index noting that we are linking
++  // with a library containing the necessary APIs, remove any MemProf related
++  // attributes and metadata.
++  if (!ImportSummary || !ImportSummary->withSupportsHotColdNew())
++    MPM.addPass(MemProfRemoveInfo());
++
+   if (ImportSummary) {
+     // For ThinLTO we must apply the context disambiguation decisions early, to
+     // ensure we can correctly match the callsites to summary data.
+@@ -1874,6 +1890,12 @@
+ 
+   invokeFullLinkTimeOptimizationEarlyEPCallbacks(MPM, Level);
+ 
++  // If we are invoking this without a summary index noting that we are linking
++  // with a library containing the necessary APIs, remove any MemProf related
++  // attributes and metadata.
++  if (!ExportSummary || !ExportSummary->withSupportsHotColdNew())
++    MPM.addPass(MemProfRemoveInfo());
++
+   // Create a function that performs CFI checks for cross-DSO calls with targets
+   // in the current module.
+   MPM.addPass(CrossDSOCFIPass());
+diff -ruN --strip-trailing-cr a/llvm/lib/Passes/PassRegistry.def b/llvm/lib/Passes/PassRegistry.def
+--- a/llvm/lib/Passes/PassRegistry.def
++++ b/llvm/lib/Passes/PassRegistry.def
+@@ -113,6 +113,7 @@
+                                           ? PGOOpt->ColdOptType
+                                           : PGOOptions::ColdFuncOpt::Default))
+ MODULE_PASS("memprof-context-disambiguation", MemProfContextDisambiguation())
++MODULE_PASS("memprof-remove-attributes", MemProfRemoveInfo())
+ MODULE_PASS("memprof-module", ModuleMemProfilerPass())
+ MODULE_PASS("mergefunc", MergeFunctionsPass())
+ MODULE_PASS("metarenamer", MetaRenamerPass())
+diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
+--- a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
++++ b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
+@@ -6150,3 +6150,42 @@
+   IndexCallsiteContextGraph CCG(Index, isPrevailing);
+   CCG.process();
+ }
++
++// Strips MemProf attributes and metadata. Can be invoked by the pass pipeline
++// when we don't have an index that has recorded that we are linking with
++// allocation libraries containing the necessary APIs for downstream
++// transformations.
++PreservedAnalyses MemProfRemoveInfo::run(Module &M, ModuleAnalysisManager &AM) {
++  // The profile matcher applies hotness attributes directly for allocations,
++  // and those will cause us to generate calls to the hot/cold interfaces
++  // unconditionally. If supports-hot-cold-new was not enabled in the LTO
++  // link then assume we don't want these calls (e.g. not linking with
++  // the appropriate library, or otherwise trying to disable this behavior).
++  bool Changed = false;
++  for (auto &F : M) {
++    for (auto &BB : F) {
++      for (auto &I : BB) {
++        auto *CI = dyn_cast<CallBase>(&I);
++        if (!CI)
++          continue;
++        if (CI->hasFnAttr("memprof")) {
++          CI->removeFnAttr("memprof");
++          Changed = true;
++        }
++        if (!CI->hasMetadata(LLVMContext::MD_callsite)) {
++          assert(!CI->hasMetadata(LLVMContext::MD_memprof));
++          continue;
++        }
++        // Strip off all memprof metadata as it is no longer needed.
++        // Importantly, this avoids the addition of new memprof attributes
++        // after inlining propagation.
++        CI->setMetadata(LLVMContext::MD_memprof, nullptr);
++        CI->setMetadata(LLVMContext::MD_callsite, nullptr);
++        Changed = true;
++      }
++    }
++  }
++  if (!Changed)
++    return PreservedAnalyses::all();
++  return PreservedAnalyses::none();
++}
+diff -ruN --strip-trailing-cr a/llvm/test/LTO/X86/memprof-supports-hot-cold-new.ll b/llvm/test/LTO/X86/memprof-supports-hot-cold-new.ll
+--- a/llvm/test/LTO/X86/memprof-supports-hot-cold-new.ll
++++ b/llvm/test/LTO/X86/memprof-supports-hot-cold-new.ll
+@@ -13,14 +13,14 @@
+ ; RUN:	-r=%t.o,main,plx \
+ ; RUN:	-r=%t.o,_Znam, \
+ ; RUN:	-memprof-dump-ccg \
+-; RUN:	 -save-temps \
+-; RUN:	-o %t.out 2>&1 | FileCheck %s --check-prefix=DUMP
+-; DUMP: Callsite Context Graph:
++; RUN:	-print-before=memprof-context-disambiguation \
++; RUN:	-o %t.out 2>&1 | FileCheck %s --check-prefix=DUMP --check-prefix=IR
+ 
+-; RUN: llvm-dis %t.out.0.0.preopt.bc -o - | FileCheck %s --check-prefix=IR
+ ; IR: !memprof {{.*}} !callsite
+ ; IR: "memprof"="cold"
+ 
++; DUMP: Callsite Context Graph:
++
+ ;; Next check without -supports-hot-cold-new, we should not perform
+ ;; context disambiguation, and we should strip memprof metadata and
+ ;; attributes before optimization.
+@@ -28,13 +28,16 @@
+ ; RUN:	-r=%t.o,main,plx \
+ ; RUN:	-r=%t.o,_Znam, \
+ ; RUN:	-memprof-dump-ccg \
+-; RUN:	 -save-temps \
++; RUN:	-print-before=memprof-context-disambiguation \
+ ; RUN:	-o %t.out 2>&1 | FileCheck %s --allow-empty \
+-; RUN:  --implicit-check-not "Callsite Context Graph:"
++; RUN:  --implicit-check-not "Callsite Context Graph:" \
++; RUN: 	--implicit-check-not "!memprof" --implicit-check-not "!callsite" \
++; RUN: 	--implicit-check-not "memprof"="cold"
+ 
+-; RUN: llvm-dis %t.out.0.0.preopt.bc -o - | FileCheck %s \
+-; RUN: --implicit-check-not "!memprof" --implicit-check-not "!callsite" \
+-; RUN: --implicit-check-not "memprof"="cold"
++;; Ensure the attributes and metadata are stripped when running a non-LTO pipeline.
++; RUN: opt -O3 %t.o -S | FileCheck %s \
++; RUN: 	--implicit-check-not "!memprof" --implicit-check-not "!callsite" \
++; RUN: 	--implicit-check-not "memprof"="cold"
+ 
+ source_filename = "memprof-supports-hot-cold-new.ll"
+ target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+diff -ruN --strip-trailing-cr a/llvm/test/ThinLTO/X86/memprof-supports-hot-cold-new.ll b/llvm/test/ThinLTO/X86/memprof-supports-hot-cold-new.ll
+--- a/llvm/test/ThinLTO/X86/memprof-supports-hot-cold-new.ll
++++ b/llvm/test/ThinLTO/X86/memprof-supports-hot-cold-new.ll
+@@ -17,11 +17,12 @@
+ ; RUN:	-r=%t/foo.o,foo,plx \
+ ; RUN:	-r=%t/foo.o,_Znam, \
+ ; RUN:	-memprof-dump-ccg \
+-; RUN:	 -save-temps \
+-; RUN:	-o %t.out 2>&1 | FileCheck %s --check-prefix=DUMP
++; RUN:	-print-before=memprof-context-disambiguation \
++; RUN:	-thinlto-threads=1 \
++; RUN:	-o %t.out 2>&1 | FileCheck %s --check-prefix=DUMP --check-prefix=IR
++
+ ; DUMP: Callsite Context Graph:
+ 
+-; RUN: llvm-dis %t.out.1.3.import.bc -o - | FileCheck %s --check-prefix=IR
+ ; IR: @main()
+ ; IR: !memprof {{.*}} !callsite
+ ; IR: @_Znam(i64 0) #[[ATTR:[0-9]+]]
+@@ -41,13 +42,12 @@
+ ; RUN:	-r=%t/foo.o,foo,plx \
+ ; RUN:	-r=%t/foo.o,_Znam, \
+ ; RUN:	-memprof-dump-ccg \
+-; RUN:	 -save-temps \
++; RUN:	-print-before=memprof-context-disambiguation \
++; RUN:	-thinlto-threads=1 \
+ ; RUN:	-o %t.out 2>&1 | FileCheck %s --allow-empty \
+-; RUN:  --implicit-check-not "Callsite Context Graph:"
+-
+-; RUN: llvm-dis %t.out.1.3.import.bc -o - | FileCheck %s \
+-; RUN: --implicit-check-not "!memprof" --implicit-check-not "!callsite" \
+-; RUN: --implicit-check-not "memprof"="cold"
++; RUN:  --implicit-check-not "Callsite Context Graph:" \
++; RUN: 	--implicit-check-not "!memprof" --implicit-check-not "!callsite" \
++; RUN: 	--implicit-check-not "memprof"="cold"
+ 
+ ;--- main.ll
+ target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index ba4c1a2..4a87034 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "bfee9db7857757e63b64fb4d411a264690ff711a"
-    LLVM_SHA256 = "b14cb659a35562d1fccee470d0bba41cf96363e1b576e113a3a795db9ad78e3e"
+    LLVM_COMMIT = "d55de66c1da53754ee9c5162594267a5c6367363"
+    LLVM_SHA256 = "5a6c7c29df501a4334233fdabb39b4d6b7bde7c0fb87997a5dfc704c5af3800b"
 
     tf_http_archive(
         name = name,
diff --git a/third_party/stablehlo/temporary.patch b/third_party/stablehlo/temporary.patch
index 8949936..473baf0 100755
--- a/third_party/stablehlo/temporary.patch
+++ b/third_party/stablehlo/temporary.patch
@@ -537,6 +537,17 @@ diff --ruN a/stablehlo/stablehlo/conversions/tosa/transforms/StablehloQuantLegal
    // unary ops
    patterns->addWithLabel<QuantizedStablehloOpConversion<stablehlo::AbsOp>>(
        {"StablehloQuantAbsOp"}, context);
+diff --ruN a/stablehlo/stablehlo/dialect/StablehloOps.cpp b/stablehlo/stablehlo/dialect/StablehloOps.cpp
+--- stablehlo/stablehlo/dialect/StablehloOps.cpp
++++ stablehlo/stablehlo/dialect/StablehloOps.cpp
+@@ -3164,6 +3164,7 @@
+ using mlir::hlo::printVariadicOperandWithAttribute;
+ using mlir::hlo::printVariadicSameOperandsAndResultType;
+ 
++using mlir::stablehlo::TokenType;
+ #define GET_OP_CLASSES
+ #include "stablehlo/dialect/StablehloOps.cpp.inc"
+ 
 diff --ruN a/stablehlo/stablehlo/integrations/c/VhloDialect.h b/stablehlo/stablehlo/integrations/c/VhloDialect.h
 --- stablehlo/stablehlo/integrations/c/VhloDialect.h
 +++ stablehlo/stablehlo/integrations/c/VhloDialect.h
@@ -787,6 +798,17 @@ diff --ruN a/stablehlo/stablehlo/integrations/cpp/builder/StablehloBuilderTest.c
 +
  }  // namespace stablehlo
  }  // namespace mlir
+diff --ruN a/stablehlo/stablehlo/reference/InterpreterOps.cpp b/stablehlo/stablehlo/reference/InterpreterOps.cpp
+--- stablehlo/stablehlo/reference/InterpreterOps.cpp
++++ stablehlo/stablehlo/reference/InterpreterOps.cpp
+@@ -46,6 +46,7 @@
+ #include "stablehlo/reference/ProcessGrid.h"
+ #include "stablehlo/reference/Value.h"
+ 
++using mlir::stablehlo::TokenType;
+ #define GET_OP_CLASSES
+ #include "stablehlo/reference/InterpreterOps.cpp.inc"
+ 
 diff --ruN a/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir b/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir
 --- stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir
 +++ stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir
