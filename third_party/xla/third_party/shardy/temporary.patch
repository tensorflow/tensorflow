diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index a79a29a..1f46ae4 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,41 +1,50 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/libcxx/include/__tree b/libcxx/include/__tree
---- a/libcxx/include/__tree
-+++ b/libcxx/include/__tree
-@@ -1281,7 +1281,7 @@
-   }
-   _LIBCPP_HIDE_FROM_ABI void __move_assign_alloc(__tree&, false_type) _NOEXCEPT {}
- 
--  template <class _From, __enable_if_t<__is_pair_v<__remove_cvref_t<_From> >, int> = 0>
-+  template <class _From, class _ValueT = _Tp, __enable_if_t<__is_tree_value_type<_ValueT>::value, int> = 0>
-   _LIBCPP_HIDE_FROM_ABI static void __assign_value(__get_node_value_type_t<value_type>& __lhs, _From&& __rhs) {
-     using __key_type = typename _NodeTypes::key_type;
- 
-@@ -1291,7 +1291,7 @@
-     __lhs.second                         = std::forward<_From>(__rhs).second;
-   }
- 
--  template <class _To, class _From, class _ValueT = _Tp, __enable_if_t<!__is_pair_v<__remove_cvref_t<_From> >, int> = 0>
-+  template <class _To, class _From, class _ValueT = _Tp, __enable_if_t<!__is_tree_value_type<_ValueT>::value, int> = 0>
-   _LIBCPP_HIDE_FROM_ABI static void __assign_value(_To& __lhs, _From&& __rhs) {
-     __lhs = std::forward<_From>(__rhs);
-   }
-diff -ruN --strip-trailing-cr a/libcxx/test/std/containers/associative/set/set.cons/copy_assign.pass.cpp b/libcxx/test/std/containers/associative/set/set.cons/copy_assign.pass.cpp
---- a/libcxx/test/std/containers/associative/set/set.cons/copy_assign.pass.cpp
-+++ b/libcxx/test/std/containers/associative/set/set.cons/copy_assign.pass.cpp
-@@ -80,5 +80,15 @@
-     assert(*std::next(mo.begin(), 2) == 3);
-   }
- 
-+  { // Test with std::pair, since we have some special handling for pairs inside __tree
-+    std::pair<int, int> arr[] = {
-+        std::make_pair(1, 2), std::make_pair(2, 3), std::make_pair(3, 4), std::make_pair(4, 5)};
-+    std::set<std::pair<int, int> > a(arr, arr + 4);
-+    std::set<std::pair<int, int> > b;
+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaExpr.cpp b/clang/lib/Sema/SemaExpr.cpp
+--- a/clang/lib/Sema/SemaExpr.cpp
++++ b/clang/lib/Sema/SemaExpr.cpp
+@@ -9966,8 +9966,13 @@
+       // If there is a conversion of some kind, check to see what kind of
+       // pointer conversion happened so we can diagnose a C++ compatibility
+       // diagnostic if the conversion is invalid. This only matters if the RHS
+-      // is some kind of void pointer.
+-      if (Kind != CK_NoOp && !getLangOpts().CPlusPlus) {
++      // is some kind of void pointer. We have a carve-out when the RHS is from
++      // a macro expansion because the use of a macro may indicate different
++      // code between C and C++. Consider: char *s = NULL; where NULL is
++      // defined as (void *)0 in C (which would be invalid in C++), but 0 in
++      // C++, which is valid in C++.
++      if (Kind != CK_NoOp && !getLangOpts().CPlusPlus &&
++          !RHS.get()->getBeginLoc().isMacroID()) {
+         QualType CanRHS =
+             RHS.get()->getType().getCanonicalType().getUnqualifiedType();
+         QualType CanLHS = LHSType.getCanonicalType().getUnqualifiedType();
+diff -ruN --strip-trailing-cr a/clang/test/Sema/implicit-void-ptr-cast.c b/clang/test/Sema/implicit-void-ptr-cast.c
+--- a/clang/test/Sema/implicit-void-ptr-cast.c
++++ b/clang/test/Sema/implicit-void-ptr-cast.c
+@@ -59,4 +59,26 @@
+   b3 = (char *)0;
+   b3 = nullptr;
+   b3 = 0;
 +
-+    b = a;
-+    assert(a == b);
-+  }
++  // Note that we explicitly silence the diagnostic if the RHS is from a macro
++  // expansion. This allows for things like NULL expanding to different token
++  // sequences depending on language mode, but applies to any macro that
++  // expands to a valid null pointer constant.
++#if defined(__cplusplus)
++  #define NULL 0
++#else
++  #define NULL ((void *)0)
++#endif
++  #define SOMETHING_NOT_SPELLED_NULL nullptr
++  #define SOMETHING_THAT_IS_NOT_NULL (void *)12
 +
-   return 0;
++  char *ptr1 = NULL; // Ok
++  char *ptr2 = SOMETHING_NOT_SPELLED_NULL; // Ok
++  char *ptr3 = SOMETHING_THAT_IS_NOT_NULL; // c-warning {{implicit conversion when initializing 'char *' with an expression of type 'void *' is not permitted in C++}} \
++                                              cxx-error {{cannot initialize a variable of type 'char *' with an rvalue of type 'void *'}}
++
++  ptr1 = NULL; // Ok
++  ptr2 = SOMETHING_NOT_SPELLED_NULL; // Ok
++  ptr3 = SOMETHING_THAT_IS_NOT_NULL; // c-warning {{implicit conversion when assigning to 'char *' from type 'void *' is not permitted in C++}} \
++                                        cxx-error {{assigning to 'char *' from incompatible type 'void *'}}
  }
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 70e5132..fb55d2b 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "3fcfce4c5e5fd1c3072e8db1d692c93459e8cd74"
-    LLVM_SHA256 = "9c4bde7ff2804eb03b23777c1d95abc1b33ca286cda6115f8d14e057585e3974"
+    LLVM_COMMIT = "025639bc396f1e0d2ead279c5f345cb381733f16"
+    LLVM_SHA256 = "efc28911635460a865e977d4109ea8944a7ad5d23eb478b31f9c1713a9d37701"
 
     tf_http_archive(
         name = name,
