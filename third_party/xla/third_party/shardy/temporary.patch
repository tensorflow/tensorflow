diff --git a/docs/sdy_dialect.md b/docs/sdy_dialect.md
index ad4deef..0c63197 100755
--- a/docs/sdy_dialect.md
+++ b/docs/sdy_dialect.md
@@ -769,17 +769,17 @@ Syntax:
 operation ::= `sdy.reshard` $input $sharding attr-dict `:` type($result)
 ```
 
-Reshards the input tensor with the specified sharding, which is different
-from the input tensor's existing sharding.
-
-Both ShardingConstraintOp and ReshardOp attach a sharding to a tensor. Their
-lifespan is:
-1. Before sharding propagation, ShardingConstraintOp is added by users.
-2. Sharding propagation consumes ShardingConstraintOp. There is no
-   ShardingConstraintOp in the results of sharding propagation. Instead,
-   ReshardOp may be added if needed.
-3. A partitioner converts a ReshardOp into a collective op (or an identity
-   op). There should be no ReshardOp in the results of the partitioner.
+  Reshards the input tensor with the specified sharding, which is different
+  from the input tensor's existing sharding.
+
+  Both ShardingConstraintOp and ReshardOp attach a sharding to a tensor. Their
+  lifespan is:
+  1. Before sharding propagation, ShardingConstraintOp is added by users.
+  2. Sharding propagation consumes ShardingConstraintOp. There is no
+     ShardingConstraintOp in the results of sharding propagation. Instead,
+     ReshardOp may be added if needed.
+  3. A partitioner converts a ReshardOp into a collective op (or an identity
+     op). There should be no ReshardOp in the results of the partitioner.
 
 Traits: `AlwaysSpeculatableImplTrait`, `SameOperandsAndResultType`
 
diff --git a/shardy/dialect/sdy/ir/BUILD b/shardy/dialect/sdy/ir/BUILD
index d42c5dc..ce57a60 100644
--- a/shardy/dialect/sdy/ir/BUILD
+++ b/shardy/dialect/sdy/ir/BUILD
@@ -26,7 +26,6 @@ td_library(
         "@llvm-project//mlir:BuiltinDialectBytecodeTdFiles",
         "@llvm-project//mlir:BuiltinDialectTdFiles",
         "@llvm-project//mlir:BytecodeOpInterfaceTdFiles",
-        "@llvm-project//mlir:ControlFlowInterfacesTdFiles",
         "@llvm-project//mlir:InferTypeOpInterfaceTdFiles",
         "@llvm-project//mlir:OpBaseTdFiles",
         "@llvm-project//mlir:SideEffectInterfacesTdFiles",
@@ -167,7 +166,6 @@ cc_library(
         "//shardy/common:logging",
         "@llvm-project//llvm:Support",
         "@llvm-project//mlir:BytecodeOpInterface",
-        "@llvm-project//mlir:ControlFlowInterfaces",
         "@llvm-project//mlir:FuncDialect",
         "@llvm-project//mlir:IR",
         "@llvm-project//mlir:InferTypeOpInterface",
diff --git a/shardy/dialect/sdy/ir/dialect.h b/shardy/dialect/sdy/ir/dialect.h
index d4a7a76..280c2e7 100644
--- a/shardy/dialect/sdy/ir/dialect.h
+++ b/shardy/dialect/sdy/ir/dialect.h
@@ -41,7 +41,6 @@ limitations under the License.
 #include "mlir/IR/Types.h"
 #include "mlir/IR/ValueRange.h"
 #include "mlir/Interfaces/CallInterfaces.h"
-#include "mlir/Interfaces/ControlFlowInterfaces.h"
 #include "mlir/Interfaces/InferTypeOpInterface.h"
 #include "mlir/Interfaces/SideEffectInterfaces.h"
 #include "mlir/Support/LLVM.h"
diff --git a/shardy/dialect/sdy/ir/ops.td b/shardy/dialect/sdy/ir/ops.td
index bf3283f..613e203 100644
--- a/shardy/dialect/sdy/ir/ops.td
+++ b/shardy/dialect/sdy/ir/ops.td
@@ -16,11 +16,11 @@ limitations under the License.
 #ifndef SDY_OPS
 #define SDY_OPS
 
+include "mlir/Interfaces/SideEffectInterfaces.td"
 include "mlir/IR/AttrTypeBase.td"
 include "mlir/IR/BuiltinAttributeInterfaces.td"
 include "mlir/IR/OpBase.td"
 include "mlir/IR/SymbolInterfaces.td"
-include "mlir/Interfaces/ControlFlowInterfaces.td"
 include "mlir/Interfaces/InferTypeOpInterface.td"
 include "mlir/Interfaces/SideEffectInterfaces.td"
 include "shardy/dialect/sdy/ir/attrs.td"
@@ -106,7 +106,7 @@ def Sdy_ReshardOp : Sdy_Op<"reshard",
   let hasCanonicalizer = 1;
 }
 
-def Sdy_ReturnOp : Sdy_Op<"return", [Pure, ReturnLike, Terminator]> {
+def Sdy_ReturnOp : Sdy_Op<"return", [Pure, Terminator]> {
   let summary = [{
     The `sdy.return` operation terminates the regions attached to
     `sdy` region-based ops and any other Shardy region-based ops. It is
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 509398d..e53a142 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1 +1,746 @@
 Auto generated patch. Do not edit or delete it, even if empty.
+diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReader.cpp b/clang/lib/Serialization/ASTReader.cpp
+--- a/clang/lib/Serialization/ASTReader.cpp
++++ b/clang/lib/Serialization/ASTReader.cpp
+@@ -555,25 +555,7 @@
+ 
+ using MacroDefinitionsMap =
+     llvm::StringMap<std::pair<StringRef, bool /*IsUndef*/>>;
+-
+-class DeclsSet {
+-  SmallVector<NamedDecl *, 64> Decls;
+-  llvm::SmallPtrSet<NamedDecl *, 8> Found;
+-
+-public:
+-  operator ArrayRef<NamedDecl *>() const { return Decls; }
+-
+-  bool empty() const { return Decls.empty(); }
+-
+-  bool insert(NamedDecl *ND) {
+-    auto [_, Inserted] = Found.insert(ND);
+-    if (Inserted)
+-      Decls.push_back(ND);
+-    return Inserted;
+-  }
+-};
+-
+-using DeclsMap = llvm::DenseMap<DeclarationName, DeclsSet>;
++using DeclsMap = llvm::DenseMap<DeclarationName, SmallVector<NamedDecl *, 8>>;
+ 
+ } // namespace
+ 
+@@ -8752,23 +8734,14 @@
+     return false;
+ 
+   // Load the list of declarations.
+-  DeclsSet DS;
++  SmallVector<NamedDecl *, 64> Decls;
++  llvm::SmallPtrSet<NamedDecl *, 8> Found;
+ 
+   auto Find = [&, this](auto &&Table, auto &&Key) {
+     for (GlobalDeclID ID : Table.find(Key)) {
+       NamedDecl *ND = cast<NamedDecl>(GetDecl(ID));
+-      if (ND->getDeclName() != Name)
+-        continue;
+-      // Special case for namespaces: There can be a lot of redeclarations of
+-      // some namespaces, and we import a "key declaration" per imported module.
+-      // Since all declarations of a namespace are essentially interchangeable,
+-      // we can optimize namespace look-up by only storing the key declaration
+-      // of the current TU, rather than storing N key declarations where N is
+-      // the # of imported modules that declare that namespace.
+-      // TODO: Try to generalize this optimization to other redeclarable decls.
+-      if (isa<NamespaceDecl>(ND))
+-        ND = cast<NamedDecl>(getKeyDeclaration(ND));
+-      DS.insert(ND);
++      if (ND->getDeclName() == Name && Found.insert(ND).second)
++        Decls.push_back(ND);
+     }
+   };
+ 
+@@ -8803,8 +8776,8 @@
+     Find(It->second.Table, Name);
+   }
+ 
+-  SetExternalVisibleDeclsForName(DC, Name, DS);
+-  return !DS.empty();
++  SetExternalVisibleDeclsForName(DC, Name, Decls);
++  return !Decls.empty();
+ }
+ 
+ void ASTReader::completeVisibleDeclsMap(const DeclContext *DC) {
+@@ -8822,16 +8795,7 @@
+ 
+     for (GlobalDeclID ID : It->second.Table.findAll()) {
+       NamedDecl *ND = cast<NamedDecl>(GetDecl(ID));
+-      // Special case for namespaces: There can be a lot of redeclarations of
+-      // some namespaces, and we import a "key declaration" per imported module.
+-      // Since all declarations of a namespace are essentially interchangeable,
+-      // we can optimize namespace look-up by only storing the key declaration
+-      // of the current TU, rather than storing N key declarations where N is
+-      // the # of imported modules that declare that namespace.
+-      // TODO: Try to generalize this optimization to other redeclarable decls.
+-      if (isa<NamespaceDecl>(ND))
+-        ND = cast<NamedDecl>(getKeyDeclaration(ND));
+-      Decls[ND->getDeclName()].insert(ND);
++      Decls[ND->getDeclName()].push_back(ND);
+     }
+ 
+     // FIXME: Why a PCH test is failing if we remove the iterator after findAll?
+@@ -8841,9 +8805,9 @@
+   findAll(ModuleLocalLookups, NumModuleLocalVisibleDeclContexts);
+   findAll(TULocalLookups, NumTULocalVisibleDeclContexts);
+ 
+-  for (auto &[Name, DS] : Decls)
+-    SetExternalVisibleDeclsForName(DC, Name, DS);
+-
++  for (DeclsMap::iterator I = Decls.begin(), E = Decls.end(); I != E; ++I) {
++    SetExternalVisibleDeclsForName(DC, I->first, I->second);
++  }
+   const_cast<DeclContext *>(DC)->setHasExternalVisibleStorage(false);
+ }
+ 
+diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTWriter.cpp b/clang/lib/Serialization/ASTWriter.cpp
+--- a/clang/lib/Serialization/ASTWriter.cpp
++++ b/clang/lib/Serialization/ASTWriter.cpp
+@@ -4397,20 +4397,20 @@
+ 
+   template <typename Coll> data_type getData(const Coll &Decls) {
+     unsigned Start = DeclIDs.size();
+-    auto AddDecl = [this](NamedDecl *D) {
++    for (NamedDecl *D : Decls) {
+       NamedDecl *DeclForLocalLookup =
+           getDeclForLocalLookup(Writer.getLangOpts(), D);
+ 
+       if (Writer.getDoneWritingDeclsAndTypes() &&
+           !Writer.wasDeclEmitted(DeclForLocalLookup))
+-        return;
++        continue;
+ 
+       // Try to avoid writing internal decls to reduced BMI.
+       // See comments in ASTWriter::WriteDeclContextLexicalBlock for details.
+       if (Writer.isGeneratingReducedBMI() &&
+           !DeclForLocalLookup->isFromExplicitGlobalModule() &&
+           IsInternalDeclFromFileContext(DeclForLocalLookup))
+-        return;
++        continue;
+ 
+       auto ID = Writer.GetDeclRef(DeclForLocalLookup);
+ 
+@@ -4424,7 +4424,7 @@
+             ModuleLocalDeclsMap.insert({Key, DeclIDsTy{ID}});
+           else
+             Iter->second.push_back(ID);
+-          return;
++          continue;
+         }
+         break;
+       case LookupVisibility::TULocal: {
+@@ -4433,7 +4433,7 @@
+           TULocalDeclsMap.insert({D->getDeclName(), DeclIDsTy{ID}});
+         else
+           Iter->second.push_back(ID);
+-        return;
++        continue;
+       }
+       case LookupVisibility::GenerallyVisibile:
+         // Generally visible decls go into the general lookup table.
+@@ -4441,24 +4441,6 @@
+       }
+ 
+       DeclIDs.push_back(ID);
+-    };
+-    ASTReader *Chain = Writer.getChain();
+-    for (NamedDecl *D : Decls) {
+-      if (Chain && isa<NamespaceDecl>(D) && D->isFromASTFile() &&
+-          D == Chain->getKeyDeclaration(D)) {
+-        // In ASTReader, we stored only the key declaration of a namespace decl
+-        // for this TU rather than storing all of the key declarations from each
+-        // imported module. If we have an external namespace decl, this is that
+-        // key declaration and we need to re-expand it to write out all of the
+-        // key declarations from each imported module again.
+-        //
+-        // See comment 'ASTReader::FindExternalVisibleDeclsByName' for details.
+-        Chain->forEachImportedKeyDecl(D, [&AddDecl](const Decl *D) {
+-          AddDecl(cast<NamedDecl>(const_cast<Decl *>(D)));
+-        });
+-      } else {
+-        AddDecl(D);
+-      }
+     }
+     return std::make_pair(Start, DeclIDs.size());
+   }
+diff -ruN --strip-trailing-cr a/clang/unittests/Serialization/CMakeLists.txt b/clang/unittests/Serialization/CMakeLists.txt
+--- a/clang/unittests/Serialization/CMakeLists.txt
++++ b/clang/unittests/Serialization/CMakeLists.txt
+@@ -2,7 +2,6 @@
+   ForceCheckFileInputTest.cpp
+   InMemoryModuleCacheTest.cpp
+   ModuleCacheTest.cpp
+-  NamespaceLookupTest.cpp
+   NoCommentsTest.cpp
+   PreambleInNamedModulesTest.cpp
+   LoadSpecLazilyTest.cpp
+diff -ruN --strip-trailing-cr a/clang/unittests/Serialization/NamespaceLookupTest.cpp b/clang/unittests/Serialization/NamespaceLookupTest.cpp
+--- a/clang/unittests/Serialization/NamespaceLookupTest.cpp
++++ b/clang/unittests/Serialization/NamespaceLookupTest.cpp
+@@ -1,247 +0,0 @@
+-//== unittests/Serialization/NamespaceLookupOptimizationTest.cpp =======//
+-//
+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+-// See https://llvm.org/LICENSE.txt for license information.
+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+-//
+-//===----------------------------------------------------------------------===//
+-
+-#include "clang/Driver/CreateInvocationFromArgs.h"
+-#include "clang/Frontend/CompilerInstance.h"
+-#include "clang/Frontend/FrontendAction.h"
+-#include "clang/Frontend/FrontendActions.h"
+-#include "clang/Parse/ParseAST.h"
+-#include "clang/Serialization/ASTReader.h"
+-#include "clang/Tooling/Tooling.h"
+-#include "gtest/gtest.h"
+-
+-using namespace llvm;
+-using namespace clang;
+-using namespace clang::tooling;
+-
+-namespace {
+-
+-class NamespaceLookupTest : public ::testing::Test {
+-  void SetUp() override {
+-    ASSERT_FALSE(
+-        sys::fs::createUniqueDirectory("namespace-lookup-test", TestDir));
+-  }
+-
+-  void TearDown() override { sys::fs::remove_directories(TestDir); }
+-
+-public:
+-  SmallString<256> TestDir;
+-
+-  void addFile(StringRef Path, StringRef Contents) {
+-    ASSERT_FALSE(sys::path::is_absolute(Path));
+-
+-    SmallString<256> AbsPath(TestDir);
+-    sys::path::append(AbsPath, Path);
+-
+-    ASSERT_FALSE(
+-        sys::fs::create_directories(llvm::sys::path::parent_path(AbsPath)));
+-
+-    std::error_code EC;
+-    llvm::raw_fd_ostream OS(AbsPath, EC);
+-    ASSERT_FALSE(EC);
+-    OS << Contents;
+-  }
+-
+-  std::string GenerateModuleInterface(StringRef ModuleName,
+-                                      StringRef Contents) {
+-    std::string FileName = llvm::Twine(ModuleName + ".cppm").str();
+-    addFile(FileName, Contents);
+-
+-    IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS =
+-        llvm::vfs::createPhysicalFileSystem();
+-    DiagnosticOptions DiagOpts;
+-    IntrusiveRefCntPtr<DiagnosticsEngine> Diags =
+-        CompilerInstance::createDiagnostics(*VFS, DiagOpts);
+-    CreateInvocationOptions CIOpts;
+-    CIOpts.Diags = Diags;
+-    CIOpts.VFS = VFS;
+-
+-    std::string CacheBMIPath =
+-        llvm::Twine(TestDir + "/" + ModuleName + ".pcm").str();
+-    std::string PrebuiltModulePath =
+-        "-fprebuilt-module-path=" + TestDir.str().str();
+-    const char *Args[] = {"clang++",
+-                          "-std=c++20",
+-                          "--precompile",
+-                          PrebuiltModulePath.c_str(),
+-                          "-working-directory",
+-                          TestDir.c_str(),
+-                          "-I",
+-                          TestDir.c_str(),
+-                          FileName.c_str(),
+-                          "-o",
+-                          CacheBMIPath.c_str()};
+-    std::shared_ptr<CompilerInvocation> Invocation =
+-        createInvocation(Args, CIOpts);
+-    EXPECT_TRUE(Invocation);
+-
+-    CompilerInstance Instance(std::move(Invocation));
+-    Instance.setDiagnostics(Diags);
+-    Instance.getFrontendOpts().OutputFile = CacheBMIPath;
+-    // Avoid memory leaks.
+-    Instance.getFrontendOpts().DisableFree = false;
+-    GenerateModuleInterfaceAction Action;
+-    EXPECT_TRUE(Instance.ExecuteAction(Action));
+-    EXPECT_FALSE(Diags->hasErrorOccurred());
+-
+-    return CacheBMIPath;
+-  }
+-};
+-
+-struct NamespaceLookupResult {
+-  int NumLocalNamespaces = 0;
+-  int NumExternalNamespaces = 0;
+-};
+-
+-class NamespaceLookupConsumer : public ASTConsumer {
+-  NamespaceLookupResult &Result;
+-
+-public:
+-  explicit NamespaceLookupConsumer(NamespaceLookupResult &Result)
+-      : Result(Result) {}
+-
+-  void HandleTranslationUnit(ASTContext &Context) override {
+-    TranslationUnitDecl *TU = Context.getTranslationUnitDecl();
+-    ASSERT_TRUE(TU);
+-    ASTReader *Chain = dyn_cast_or_null<ASTReader>(Context.getExternalSource());
+-    ASSERT_TRUE(Chain);
+-    for (const Decl *D :
+-         TU->lookup(DeclarationName(&Context.Idents.get("N")))) {
+-      if (!isa<NamespaceDecl>(D))
+-        continue;
+-      if (!D->isFromASTFile()) {
+-        ++Result.NumLocalNamespaces;
+-      } else {
+-        ++Result.NumExternalNamespaces;
+-        EXPECT_EQ(D, Chain->getKeyDeclaration(D));
+-      }
+-    }
+-  }
+-};
+-
+-class NamespaceLookupAction : public ASTFrontendAction {
+-  NamespaceLookupResult &Result;
+-
+-public:
+-  explicit NamespaceLookupAction(NamespaceLookupResult &Result)
+-      : Result(Result) {}
+-
+-  std::unique_ptr<ASTConsumer>
+-  CreateASTConsumer(CompilerInstance &CI, StringRef /*Unused*/) override {
+-    return std::make_unique<NamespaceLookupConsumer>(Result);
+-  }
+-};
+-
+-TEST_F(NamespaceLookupTest, ExternalNamespacesOnly) {
+-  GenerateModuleInterface("M1", R"cpp(
+-export module M1;
+-namespace N {}
+-  )cpp");
+-  GenerateModuleInterface("M2", R"cpp(
+-export module M2;
+-namespace N {}
+-  )cpp");
+-  GenerateModuleInterface("M3", R"cpp(
+-export module M3;
+-namespace N {}
+-  )cpp");
+-  const char *test_file_contents = R"cpp(
+-import M1;
+-import M2;
+-import M3;
+-  )cpp";
+-  std::string DepArg = "-fprebuilt-module-path=" + TestDir.str().str();
+-  NamespaceLookupResult Result;
+-  EXPECT_TRUE(runToolOnCodeWithArgs(
+-      std::make_unique<NamespaceLookupAction>(Result), test_file_contents,
+-      {
+-          "-std=c++20",
+-          DepArg.c_str(),
+-          "-I",
+-          TestDir.c_str(),
+-      },
+-      "main.cpp"));
+-
+-  EXPECT_EQ(0, Result.NumLocalNamespaces);
+-  EXPECT_EQ(1, Result.NumExternalNamespaces);
+-}
+-
+-TEST_F(NamespaceLookupTest, ExternalReplacedByLocal) {
+-  GenerateModuleInterface("M1", R"cpp(
+-export module M1;
+-namespace N {}
+-  )cpp");
+-  GenerateModuleInterface("M2", R"cpp(
+-export module M2;
+-namespace N {}
+-  )cpp");
+-  GenerateModuleInterface("M3", R"cpp(
+-export module M3;
+-namespace N {}
+-  )cpp");
+-  const char *test_file_contents = R"cpp(
+-import M1;
+-import M2;
+-import M3;
+-
+-namespace N {}
+-  )cpp";
+-  std::string DepArg = "-fprebuilt-module-path=" + TestDir.str().str();
+-  NamespaceLookupResult Result;
+-  EXPECT_TRUE(runToolOnCodeWithArgs(
+-      std::make_unique<NamespaceLookupAction>(Result), test_file_contents,
+-      {
+-          "-std=c++20",
+-          DepArg.c_str(),
+-          "-I",
+-          TestDir.c_str(),
+-      },
+-      "main.cpp"));
+-
+-  EXPECT_EQ(1, Result.NumLocalNamespaces);
+-  EXPECT_EQ(0, Result.NumExternalNamespaces);
+-}
+-
+-TEST_F(NamespaceLookupTest, LocalAndExternalInterleaved) {
+-  GenerateModuleInterface("M1", R"cpp(
+-export module M1;
+-namespace N {}
+-  )cpp");
+-  GenerateModuleInterface("M2", R"cpp(
+-export module M2;
+-namespace N {}
+-  )cpp");
+-  GenerateModuleInterface("M3", R"cpp(
+-export module M3;
+-namespace N {}
+-  )cpp");
+-  const char *test_file_contents = R"cpp(
+-import M1;
+-
+-namespace N {}
+-
+-import M2;
+-import M3;
+-  )cpp";
+-  std::string DepArg = "-fprebuilt-module-path=" + TestDir.str().str();
+-  NamespaceLookupResult Result;
+-  EXPECT_TRUE(runToolOnCodeWithArgs(
+-      std::make_unique<NamespaceLookupAction>(Result), test_file_contents,
+-      {
+-          "-std=c++20",
+-          DepArg.c_str(),
+-          "-I",
+-          TestDir.c_str(),
+-      },
+-      "main.cpp"));
+-
+-  EXPECT_EQ(1, Result.NumLocalNamespaces);
+-  EXPECT_EQ(1, Result.NumExternalNamespaces);
+-}
+-
+-} // namespace
+diff -ruN --strip-trailing-cr a/llvm/lib/Analysis/AliasAnalysis.cpp b/llvm/lib/Analysis/AliasAnalysis.cpp
+--- a/llvm/lib/Analysis/AliasAnalysis.cpp
++++ b/llvm/lib/Analysis/AliasAnalysis.cpp
+@@ -433,7 +433,7 @@
+                                     const MemoryLocation &Loc,
+                                     AAQueryInfo &AAQI) {
+   // Be conservative in the face of atomic.
+-  if (isStrongerThanMonotonic(L->getOrdering()))
++  if (isStrongerThan(L->getOrdering(), AtomicOrdering::Unordered))
+     return ModRefInfo::ModRef;
+ 
+   // If the load address doesn't alias the given address, it doesn't read
+@@ -443,13 +443,6 @@
+     if (AR == AliasResult::NoAlias)
+       return ModRefInfo::NoModRef;
+   }
+-
+-  assert(!isStrongerThanMonotonic(L->getOrdering()) &&
+-         "Stronger atomic orderings should have been handled above!");
+-
+-  if (isStrongerThanUnordered(L->getOrdering()))
+-    return ModRefInfo::ModRef;
+-
+   // Otherwise, a load just reads.
+   return ModRefInfo::Ref;
+ }
+@@ -458,7 +451,7 @@
+                                     const MemoryLocation &Loc,
+                                     AAQueryInfo &AAQI) {
+   // Be conservative in the face of atomic.
+-  if (isStrongerThanMonotonic(S->getOrdering()))
++  if (isStrongerThan(S->getOrdering(), AtomicOrdering::Unordered))
+     return ModRefInfo::ModRef;
+ 
+   if (Loc.Ptr) {
+@@ -476,13 +469,7 @@
+       return ModRefInfo::NoModRef;
+   }
+ 
+-  assert(!isStrongerThanMonotonic(S->getOrdering()) &&
+-         "Stronger atomic orderings should have been handled above!");
+-
+-  if (isStrongerThanUnordered(S->getOrdering()))
+-    return ModRefInfo::ModRef;
+-
+-  // A store just writes.
++  // Otherwise, a store just writes.
+   return ModRefInfo::Mod;
+ }
+ 
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/DeadStoreElimination/atomic.ll b/llvm/test/Transforms/DeadStoreElimination/atomic.ll
+--- a/llvm/test/Transforms/DeadStoreElimination/atomic.ll
++++ b/llvm/test/Transforms/DeadStoreElimination/atomic.ll
+@@ -37,21 +37,9 @@
+   ret void
+ }
+ 
+-; DSE doesn't remove monotonic store.
++; DSE unordered store overwriting non-atomic store (allowed)
+ define void @test5() {
+ ; CHECK-LABEL: @test5(
+-; CHECK-NEXT:    store atomic i32 2, ptr @x monotonic, align 4
+-; CHECK-NEXT:    store i32 1, ptr @x, align 4
+-; CHECK-NEXT:    ret void
+-;
+-  store atomic i32 2, ptr @x monotonic, align 4
+-  store i32 1, ptr @x
+-  ret void
+-}
+-
+-; DSE unordered store overwriting non-atomic store (allowed)
+-define void @test6() {
+-; CHECK-LABEL: @test6(
+ ; CHECK-NEXT:    store atomic i32 1, ptr @x unordered, align 4
+ ; CHECK-NEXT:    ret void
+ ;
+@@ -61,8 +49,8 @@
+ }
+ 
+ ; DSE no-op unordered atomic store (allowed)
+-define void @test7() {
+-; CHECK-LABEL: @test7(
++define void @test6() {
++; CHECK-LABEL: @test6(
+ ; CHECK-NEXT:    ret void
+ ;
+   %x = load atomic i32, ptr @x unordered, align 4
+@@ -72,8 +60,8 @@
+ 
+ ; DSE seq_cst store (be conservative; DSE doesn't have infrastructure
+ ; to reason about atomic operations).
+-define void @test8() {
+-; CHECK-LABEL: @test8(
++define void @test7() {
++; CHECK-LABEL: @test7(
+ ; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
+ ; CHECK-NEXT:    store atomic i32 0, ptr [[A]] seq_cst, align 4
+ ; CHECK-NEXT:    ret void
+@@ -85,8 +73,8 @@
+ 
+ ; DSE and seq_cst load (be conservative; DSE doesn't have infrastructure
+ ; to reason about atomic operations).
+-define i32 @test9() {
+-; CHECK-LABEL: @test9(
++define i32 @test8() {
++; CHECK-LABEL: @test8(
+ ; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
+ ; CHECK-NEXT:    call void @randomop(ptr [[A]])
+ ; CHECK-NEXT:    store i32 0, ptr [[A]], align 4
+@@ -100,40 +88,11 @@
+   ret i32 %x
+ }
+ 
+-; DSE across monotonic load (allowed if the monotonic load's address is NoAlias)
+-define i32 @test10() {
+-; CHECK-LABEL: @test10(
+-; CHECK-NEXT:    [[X:%.*]] = load atomic i32, ptr @y monotonic, align 4
+-; CHECK-NEXT:    store i32 1, ptr @x, align 4
+-; CHECK-NEXT:    ret i32 [[X]]
+-;
+-  store i32 0, ptr @x
+-  %x = load atomic i32, ptr @y monotonic, align 4
+-  store i32 1, ptr @x
+-  ret i32 %x
+-}
+-
+-; DSE across monotonic load (blocked if the atomic load's address isn't NoAlias)
+-define i32 @test11(ptr %ptr) {
+-; CHECK-LABEL: @test11(
+-; CHECK-NEXT:    store i32 0, ptr @x, align 4
+-; CHECK-NEXT:    [[X:%.*]] = load atomic i32, ptr [[PTR:%.*]] monotonic, align 4
+-; CHECK-NEXT:    store i32 1, ptr @x, align 4
+-; CHECK-NEXT:    ret i32 [[X]]
+-;
+-  store i32 0, ptr @x
+-  %x = load atomic i32, ptr %ptr monotonic, align 4
+-  store i32 1, ptr @x
+-  ret i32 %x
+-}
+-
+ ; DSE across monotonic store (allowed as long as the eliminated store isUnordered)
+-define void @test12() {
+-; CHECK-LABEL: @test12(
+-; CHECK-NEXT:    store atomic i32 42, ptr @y monotonic, align 4
+-; CHECK-NEXT:    store i32 1, ptr @x, align 4
+-; CHECK-NEXT:    ret void
+-;
++define void @test10() {
++; CHECK-LABEL: test10
++; CHECK-NOT: store i32 0
++; CHECK: store i32 1
+   store i32 0, ptr @x
+   store atomic i32 42, ptr @y monotonic, align 4
+   store i32 1, ptr @x
+@@ -141,8 +100,8 @@
+ }
+ 
+ ; DSE across monotonic load (forbidden since the eliminated store is atomic)
+-define i32 @test13() {
+-; CHECK-LABEL: @test13(
++define i32 @test11() {
++; CHECK-LABEL: @test11(
+ ; CHECK-NEXT:    store atomic i32 0, ptr @x monotonic, align 4
+ ; CHECK-NEXT:    [[X:%.*]] = load atomic i32, ptr @y monotonic, align 4
+ ; CHECK-NEXT:    store atomic i32 1, ptr @x monotonic, align 4
+@@ -155,8 +114,8 @@
+ }
+ 
+ ; DSE across monotonic store (forbidden since the eliminated store is atomic)
+-define void @test14() {
+-; CHECK-LABEL: @test14(
++define void @test12() {
++; CHECK-LABEL: @test12(
+ ; CHECK-NEXT:    store atomic i32 0, ptr @x monotonic, align 4
+ ; CHECK-NEXT:    store atomic i32 42, ptr @y monotonic, align 4
+ ; CHECK-NEXT:    store atomic i32 1, ptr @x monotonic, align 4
+@@ -191,7 +150,7 @@
+ define i64 @test_atomicrmw_0() {
+ ; CHECK-LABEL: @test_atomicrmw_0(
+ ; CHECK-NEXT:    store i64 1, ptr @z, align 8
+-; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @z, i64 -1 monotonic, align 8
++; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @z, i64 -1 monotonic
+ ; CHECK-NEXT:    ret i64 [[RES]]
+ ;
+   store i64 1, ptr @z
+@@ -203,7 +162,7 @@
+ define i64 @test_atomicrmw_1() {
+ ; CHECK-LABEL: @test_atomicrmw_1(
+ ; CHECK-NEXT:    store i64 1, ptr @z, align 8
+-; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @z, i64 -1 acq_rel, align 8
++; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @z, i64 -1 acq_rel
+ ; CHECK-NEXT:    ret i64 [[RES]]
+ ;
+   store i64 1, ptr @z
+@@ -214,7 +173,7 @@
+ ; Monotonic atomicrmw should not block eliminating no-aliasing stores.
+ define i64 @test_atomicrmw_2() {
+ ; CHECK-LABEL: @test_atomicrmw_2(
+-; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @a, i64 -1 monotonic, align 8
++; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @a, i64 -1 monotonic
+ ; CHECK-NEXT:    store i64 2, ptr @z, align 8
+ ; CHECK-NEXT:    ret i64 [[RES]]
+ ;
+@@ -228,7 +187,7 @@
+ define i64 @test_atomicrmw_3() {
+ ; CHECK-LABEL: @test_atomicrmw_3(
+ ; CHECK-NEXT:    store i64 1, ptr @z, align 8
+-; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @a, i64 -1 release, align 8
++; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @a, i64 -1 release
+ ; CHECK-NEXT:    store i64 2, ptr @z, align 8
+ ; CHECK-NEXT:    ret i64 [[RES]]
+ ;
+@@ -242,7 +201,7 @@
+ define i64 @test_atomicrmw_4(ptr %ptr) {
+ ; CHECK-LABEL: @test_atomicrmw_4(
+ ; CHECK-NEXT:    store i64 1, ptr @z, align 8
+-; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr [[PTR:%.*]], i64 -1 monotonic, align 8
++; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr [[PTR:%.*]], i64 -1 monotonic
+ ; CHECK-NEXT:    store i64 2, ptr @z, align 8
+ ; CHECK-NEXT:    ret i64 [[RES]]
+ ;
+@@ -256,7 +215,7 @@
+ define i64 @test_atomicrmw_5() {
+ ; CHECK-LABEL: @test_atomicrmw_5(
+ ; CHECK-NEXT:    store i64 1, ptr @z, align 8
+-; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @z, i64 -1 monotonic, align 8
++; CHECK-NEXT:    [[RES:%.*]] = atomicrmw add ptr @z, i64 -1 monotonic
+ ; CHECK-NEXT:    store i64 2, ptr @z, align 8
+ ; CHECK-NEXT:    ret i64 [[RES]]
+ ;
+@@ -270,7 +229,7 @@
+ define { i32, i1} @test_cmpxchg_1() {
+ ; CHECK-LABEL: @test_cmpxchg_1(
+ ; CHECK-NEXT:    store i32 1, ptr @x, align 4
+-; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr @x, i32 10, i32 20 seq_cst monotonic, align 4
++; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr @x, i32 10, i32 20 seq_cst monotonic
+ ; CHECK-NEXT:    store i32 2, ptr @x, align 4
+ ; CHECK-NEXT:    ret { i32, i1 } [[RET]]
+ ;
+@@ -283,7 +242,7 @@
+ ; Monotonic cmpxchg should not block DSE for non-aliasing stores.
+ define { i32, i1} @test_cmpxchg_2() {
+ ; CHECK-LABEL: @test_cmpxchg_2(
+-; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr @y, i32 10, i32 20 monotonic monotonic, align 4
++; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr @y, i32 10, i32 20 monotonic monotonic
+ ; CHECK-NEXT:    store i32 2, ptr @x, align 4
+ ; CHECK-NEXT:    ret { i32, i1 } [[RET]]
+ ;
+@@ -297,7 +256,7 @@
+ define { i32, i1} @test_cmpxchg_3() {
+ ; CHECK-LABEL: @test_cmpxchg_3(
+ ; CHECK-NEXT:    store i32 1, ptr @x, align 4
+-; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr @y, i32 10, i32 20 seq_cst seq_cst, align 4
++; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr @y, i32 10, i32 20 seq_cst seq_cst
+ ; CHECK-NEXT:    store i32 2, ptr @x, align 4
+ ; CHECK-NEXT:    ret { i32, i1 } [[RET]]
+ ;
+@@ -311,7 +270,7 @@
+ define { i32, i1} @test_cmpxchg_4(ptr %ptr) {
+ ; CHECK-LABEL: @test_cmpxchg_4(
+ ; CHECK-NEXT:    store i32 1, ptr @x, align 4
+-; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr [[PTR:%.*]], i32 10, i32 20 monotonic monotonic, align 4
++; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr [[PTR:%.*]], i32 10, i32 20 monotonic monotonic
+ ; CHECK-NEXT:    store i32 2, ptr @x, align 4
+ ; CHECK-NEXT:    ret { i32, i1 } [[RET]]
+ ;
+@@ -325,7 +284,7 @@
+ define { i32, i1} @test_cmpxchg_5(ptr %ptr) {
+ ; CHECK-LABEL: @test_cmpxchg_5(
+ ; CHECK-NEXT:    store i32 1, ptr @x, align 4
+-; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr @x, i32 10, i32 20 monotonic monotonic, align 4
++; CHECK-NEXT:    [[RET:%.*]] = cmpxchg volatile ptr @x, i32 10, i32 20 monotonic monotonic
+ ; CHECK-NEXT:    store i32 2, ptr @x, align 4
+ ; CHECK-NEXT:    ret { i32, i1 } [[RET]]
+ ;
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/DeadStoreElimination/atomic-todo.ll b/llvm/test/Transforms/DeadStoreElimination/atomic-todo.ll
+--- a/llvm/test/Transforms/DeadStoreElimination/atomic-todo.ll
++++ b/llvm/test/Transforms/DeadStoreElimination/atomic-todo.ll
+@@ -0,0 +1,23 @@
++; XFAIL: *
++; RUN: opt -passes=dse -S < %s | FileCheck %s
++
++target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
++target triple = "x86_64-apple-macosx10.7.0"
++
++; Basic correctness tests for atomic stores.
++; Note that it turns out essentially every transformation DSE does is legal on
++; atomic ops, just some transformations are not allowed across release-acquire pairs.
++
++@x = common global i32 0, align 4
++@y = common global i32 0, align 4
++
++; DSE across monotonic load (allowed as long as the eliminated store isUnordered)
++define i32 @test9() {
++; CHECK-LABEL: test9
++; CHECK-NOT: store i32 0
++; CHECK: store i32 1
++  store i32 0, ptr @x
++  %x = load atomic i32, ptr @y monotonic, align 4
++  store i32 1, ptr @x
++  ret i32 %x
++}
+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+--- a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
++++ b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+@@ -517,6 +517,7 @@
+         ":IRDLDialect",
+         ":InferTypeOpInterface",
+         ":Parser",
++        ":TransformsPassIncGen",
+     ],
+ )
+ 
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 4957ce4..35c22ed 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "125948a058dcd89b7fe377872a5fc1a7f9d34e70"
-    LLVM_SHA256 = "8f79c221169dec52116dea2202be64aa653584f98b03a715c30d74ea9141328b"
+    LLVM_COMMIT = "53f84636eb86e6c64c1ec405f70b3dd2b27f4ddc"
+    LLVM_SHA256 = "b487990b6006fe720c305782d142aa28612df42191bb756a1eb302ab2a0092b8"
 
     tf_http_archive(
         name = name,
