diff --git a/shardy/dialect/mpmd/ir/utils.cc b/shardy/dialect/mpmd/ir/utils.cc
index 67724a9..2d4a5de 100644
--- a/shardy/dialect/mpmd/ir/utils.cc
+++ b/shardy/dialect/mpmd/ir/utils.cc
@@ -58,6 +58,7 @@ namespace {
 
 using ::mlir::func::FuncOp;
 
+
 SpmdTensorPartitionSpec ExtractTensorPartitionSpec(MeshTensorType type) {
   if (!type.getSharding()) {
     return {};
@@ -486,60 +487,13 @@ bool IsExecutedImmediatelyAfter(FragmentOp fragment1, FragmentOp fragment2) {
   return false;
 }
 
-namespace {
-
-// Returns true if two meshes are equal, ignoring axes of size 1.
-bool IsEquivalentMesh(sdy::MeshAttr mesh1, sdy::MeshAttr mesh2) {
-  if (mesh1.getDeviceIds() != mesh2.getDeviceIds()) {
-    return false;
-  }
-
-  const auto* it1 = mesh1.getAxes().begin();
-  const auto* end1 = mesh1.getAxes().end();
-  const auto* it2 = mesh2.getAxes().begin();
-  const auto* end2 = mesh2.getAxes().end();
-
-  while (it1 != end1 && it2 != end2) {
-    if (it1->getSize() == 1) {
-      ++it1;
-      continue;
-    }
-    if (it2->getSize() == 1) {
-      ++it2;
-      continue;
-    }
-    if (*it1 != *it2) {
-      return false;
-    }
-    ++it1;
-    ++it2;
-  }
-
-  while (it1 != end1) {
-    if (it1->getSize() != 1) {
-      return false;
-    }
-    ++it1;
-  }
-
-  while (it2 != end2) {
-    if (it2->getSize() != 1) {
-      return false;
-    }
-    ++it2;
-  }
-
-  return true;
-}
-
-}  // namespace
-
 bool HasHomogeneousTopology(FuncOp func) {
   ArrayRef<NamedMeshAttr> named_meshes = GetTopologyMeshes(func);
-  return llvm::all_of(named_meshes, [&](NamedMeshAttr named_mesh) {
-    return IsEquivalentMesh(named_mesh.getMesh(),
-                            named_meshes.front().getMesh());
-  });
+  DenseSet<sdy::MeshAttr> meshes;
+  for (NamedMeshAttr named_mesh : named_meshes) {
+    meshes.insert(named_mesh.getMesh());
+  }
+  return meshes.size() == 1;
 }
 
 ArrayAttr GetFragmentOriginUnion(FragmentOp fragment1, FragmentOp fragment2,
@@ -720,3 +674,4 @@ std::optional<ReductionType> ComputeReductionType(Block& block) {
 }
 
 }  // namespace mlir::mpmd
+
diff --git a/shardy/dialect/mpmd/transforms/import/test/call_op_set_topology.mlir b/shardy/dialect/mpmd/transforms/import/test/call_op_set_topology.mlir
index 9122ee7..2a83989 100644
--- a/shardy/dialect/mpmd/transforms/import/test/call_op_set_topology.mlir
+++ b/shardy/dialect/mpmd/transforms/import/test/call_op_set_topology.mlir
@@ -1,4 +1,4 @@
-// RUN: mpmd_opt %s -mpmd-copy-topology-from-main -split-input-file 2>&1 | FileCheck %s
+// RUN: mpmd_opt %s -mpmd-copy-topology-from-main 2>&1 | FileCheck %s
 
 // CHECK-LABEL: sdy.mesh @mesh = <["a"=4, "b"=2]>
 #topology = #mpmd.topology<<"mesh1": <["a"=4, "b"=2]>>, <"mesh2": <["a"=4, "b"=2]>>>
@@ -38,18 +38,3 @@ func.func @shardy_mpmd_i(%arg0: tensor<5xf32>, %arg1: tensor<5xf32>) -> tensor<5
   %0 = stablehlo.add %arg0, %arg1 : tensor<5xf32>
   return %0 : tensor<5xf32>
 }
-
-// -----
-
-// Verify that the homogeneous topology check ignores axes of size 1.
-// CHECK-LABEL: func.func public @main(%arg0: tensor<8xf32>) -> tensor<8xf32>
-func.func public @main(%arg0: tensor<8xf32>) -> tensor<8xf32> attributes {
-  topology=#mpmd.topology<
-    <"mesh1": <["a"=4, "b"=2]>>,
-    <"mesh2": <["x"=1, "a"=4, "b"=2]>>,
-    <"mesh3": <["a"=4, "b"=2, "y"=1]>>,
-    <"mesh4": <["a"=4, "z"=1, "b"=2]>>
-  >
-}{
-  return %arg0 : tensor<8xf32>
-}
diff --git a/shardy/dialect/mpmd/transforms/optimize/utils.cc b/shardy/dialect/mpmd/transforms/optimize/utils.cc
index 39e05f0..d3fd142 100644
--- a/shardy/dialect/mpmd/transforms/optimize/utils.cc
+++ b/shardy/dialect/mpmd/transforms/optimize/utils.cc
@@ -76,9 +76,9 @@ SmallVector<mpmd::NamedMeshAttr> GetSchedulableMeshes(func::FuncOp func) {
   auto all_meshes = mpmd::GetTopologyMeshes(func);
   SmallVector<mpmd::NamedMeshAttr> hbm_meshes;
   llvm::copy_if(all_meshes, std::back_inserter(hbm_meshes),
-                [](const mpmd::NamedMeshAttr& mesh) {
-                  return !mesh.getName().ends_with(mpmd::kCpuMeshSuffix);
-                });
+                  [](const mpmd::NamedMeshAttr& mesh) {
+                    return !mesh.getName().ends_with("#cpu");
+                  });
   return hbm_meshes;
 }
 
diff --git a/shardy/dialect/sdy/ir/dialect.cc b/shardy/dialect/sdy/ir/dialect.cc
index 5113b47..008bb20 100644
--- a/shardy/dialect/sdy/ir/dialect.cc
+++ b/shardy/dialect/sdy/ir/dialect.cc
@@ -972,11 +972,11 @@ bool TensorShardingAttr::isEquivalent(TensorShardingAttr otherSharding) const {
   if (!otherSharding) {
     return false;
   }
+  ArrayRef<DimensionShardingAttr> left = getDimShardings();
+  ArrayRef<DimensionShardingAttr> right = otherSharding.getDimShardings();
   if (getMeshOrRef() != otherSharding.getMeshOrRef()) {
     return false;
   }
-  ArrayRef<DimensionShardingAttr> left = getDimShardings();
-  ArrayRef<DimensionShardingAttr> right = otherSharding.getDimShardings();
   return left.size() == right.size() &&
          llvm::all_of(llvm::zip_equal(left, right), [](auto&& pair) {
            return std::get<0>(pair).getAxes() == std::get<1>(pair).getAxes();
diff --git a/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc b/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
index 2f21374..a109df3 100644
--- a/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
+++ b/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
@@ -158,7 +158,7 @@ void insertExplicitReshardsOnDataFlowOp(ShardableDataFlowOpInterface& op,
 // return %reshard  : tensor<4x8xf32>
 // ```
 template <class OpTy>
-void processDot(OpTy op, ShardingProjection& shardingProjection,
+void processDot(OpTy op, ArrayRef<TensorShardingAttr> inShardings,
                 ArrayRef<TensorShardingAttr> outShardings, IRRewriter& rewriter,
                 const SymbolTable& symbolTable, OpShardingRuleAttr shardingRule,
                 const Mesh& mesh) {
@@ -166,6 +166,10 @@ void processDot(OpTy op, ShardingProjection& shardingProjection,
     // Result doesn't have a sharding.
     return;
   }
+  ShardingProjection shardingProjection =
+      ShardingProjection::build(inShardings, outShardings, shardingRule,
+                                mesh.attr(), /*closedIfMissing=*/true);
+
   const TensorFactorShardings& lhsSharding = shardingProjection.getOperand(0);
   const TensorFactorShardings& rhsSharding = shardingProjection.getOperand(1);
   TensorFactorShardings& resultSharding =
@@ -445,11 +449,11 @@ SmallVector<AxisRefAttr> processOp(Operation* op,
 
   TypeSwitch<Operation*>(op)
       .Case<stablehlo::DotOp>([&](stablehlo::DotOp dotOp) {
-        processDot(dotOp, shardingProjection, outShardings, rewriter,
-                   symbolTable, shardingRule, mesh);
+        processDot(dotOp, inShardings, outShardings, rewriter, symbolTable,
+                   shardingRule, mesh);
       })
       .Case<stablehlo::DotGeneralOp>([&](stablehlo::DotGeneralOp dotGeneralOp) {
-        processDot(dotGeneralOp, shardingProjection, outShardings, rewriter,
+        processDot(dotGeneralOp, inShardings, outShardings, rewriter,
                    symbolTable, shardingRule, mesh);
       });
 
diff --git a/shardy/dialect/sdy/transforms/export/reshard_to_collectives.cc b/shardy/dialect/sdy/transforms/export/reshard_to_collectives.cc
index 845eeab..4e6c593 100644
--- a/shardy/dialect/sdy/transforms/export/reshard_to_collectives.cc
+++ b/shardy/dialect/sdy/transforms/export/reshard_to_collectives.cc
@@ -469,8 +469,8 @@ class CollectiveInserter {
       collectiveAxes = AxisRefListAttr::get(getContext(), gatheringAxes);
     }
     if (hasGatheringAxes) {
-      result = AllGatherOp::create(rewriter, loc, result, collectiveAxesPerDim,
-                                   getCurrentSharding());
+      result = rewriter.create<AllGatherOp>(loc, result, collectiveAxesPerDim,
+                                            getCurrentSharding());
     }
   }
 
@@ -484,7 +484,7 @@ class CollectiveInserter {
   // - Splits A into two sub-axes A1 and A2, such that
   //   `size(A1) == capacityPerDim[d]`, adds A1 to `inAxesPerDim[d]`, and adds
   //   A2 back to the front of `getAvailableAxes(d)`.
-  // - Skips A if it isn't divisible by `capacityPerDim[d]` or vice versa, and
+  // - Skips A if it isn't divisible by `capacityPerDim[d]` or visa versa, and
   //   adds it back to the front of `getAvailableAxes(d)`.
   //
   // For each axis A that is added to `inAxesPerDim[d]`, calls
@@ -861,8 +861,8 @@ class CollectiveInserter {
            llvm::zip_equal(collectiveAxesPerDim, *slicingAxesPerDim)) {
         collectiveAxes = AxisRefListAttr::get(getContext(), slicingAxes);
       }
-      result = AllSliceOp::create(rewriter, loc, result, collectiveAxesPerDim,
-                                  getCurrentSharding());
+      result = rewriter.create<AllSliceOp>(loc, result, collectiveAxesPerDim,
+                                           getCurrentSharding());
     }
   }
 
@@ -1148,8 +1148,8 @@ class CollectiveInserter {
     // TODO(b/392797233): if the order of device ids changes, but the input or
     // output sharding is fully replicated, we can skip the collective permute.
 
-    result = CollectivePermuteOp::create(rewriter, loc, result,
-                                         getCurrentSharding());
+    result =
+        rewriter.create<CollectivePermuteOp>(loc, result, getCurrentSharding());
   }
 
   // TODO(b/392952931): currently we are greedily all-to-all-ing axes even if
@@ -1291,8 +1291,8 @@ class CollectiveInserter {
   void tryAllToAlls(bool allowOutOfOrderTarget) {
     for (int64_t srcDim = 0; srcDim < getRank(); ++srcDim) {
       while (auto info = getAllToAllInfo(srcDim, allowOutOfOrderTarget)) {
-        result = AllToAllOp::create(
-            rewriter, loc, result,
+        result = rewriter.create<AllToAllOp>(
+            loc, result,
             AllToAllParamAttr::get(rewriter.getContext(), info->axes, srcDim,
                                    info->tgtDim),
             getCurrentSharding());
diff --git a/shardy/dialect/sdy/transforms/propagation/aggressive_propagation.cc b/shardy/dialect/sdy/transforms/propagation/aggressive_propagation.cc
index 30a4324..a800444 100644
--- a/shardy/dialect/sdy/transforms/propagation/aggressive_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/aggressive_propagation.cc
@@ -25,9 +25,9 @@ limitations under the License.
 #include "mlir/Pass/PassRegistry.h"
 #include "mlir/Support/LLVM.h"
 #include "mlir/Support/LogicalResult.h"
-#include "shardy/dialect/sdy/transforms/common/propagation_options.h"
 #include "shardy/dialect/sdy/transforms/propagation/basic_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/factor_propagation.h"
+#include "shardy/dialect/sdy/transforms/propagation/passes.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_group_map.h"
 
 namespace mlir {
diff --git a/shardy/dialect/sdy/transforms/propagation/aggressive_propagation.h b/shardy/dialect/sdy/transforms/propagation/aggressive_propagation.h
index 7b3835e..941cd0e 100644
--- a/shardy/dialect/sdy/transforms/propagation/aggressive_propagation.h
+++ b/shardy/dialect/sdy/transforms/propagation/aggressive_propagation.h
@@ -24,9 +24,9 @@ limitations under the License.
 #include "mlir/Pass/Pass.h"
 #include "mlir/Support/LLVM.h"
 #include "mlir/Support/LogicalResult.h"
-#include "shardy/dialect/sdy/transforms/common/propagation_options.h"
 #include "shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/basic_propagation.h"
+#include "shardy/dialect/sdy/transforms/propagation/passes.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_group_map.h"
 
 namespace mlir {
diff --git a/shardy/dialect/sdy/transforms/propagation/basic_propagation.cc b/shardy/dialect/sdy/transforms/propagation/basic_propagation.cc
index 336748e..1c5a9ca 100644
--- a/shardy/dialect/sdy/transforms/propagation/basic_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/basic_propagation.cc
@@ -23,6 +23,7 @@ limitations under the License.
 #include <utility>
 
 #include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/Threading.h"
 #include "mlir/Dialect/Func/IR/FuncOps.h"
 #include "mlir/IR/BuiltinAttributes.h"
 #include "mlir/IR/BuiltinOps.h"
@@ -41,8 +42,8 @@ limitations under the License.
 #include "mlir/Pass/PassRegistry.h"
 #include "mlir/Support/LLVM.h"
 #include "mlir/Support/LogicalResult.h"
-#include "mlir/Support/WalkResult.h"
 #include "mlir/Transforms/GreedyPatternRewriteDriver.h"
+#include "shardy/common/file_utils.h"
 #include "shardy/dialect/sdy/ir/dialect.h"
 #include "shardy/dialect/sdy/ir/enums.h"
 #include "shardy/dialect/sdy/ir/utils.h"
@@ -51,6 +52,7 @@ limitations under the License.
 #include "shardy/dialect/sdy/transforms/propagation/factor_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/op_sharding_rule_builder.h"
 #include "shardy/dialect/sdy/transforms/propagation/op_sharding_rule_registry.h"
+#include "shardy/dialect/sdy/transforms/propagation/passes.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_group_map.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_projection.h"
 
diff --git a/shardy/dialect/sdy/transforms/propagation/basic_propagation.h b/shardy/dialect/sdy/transforms/propagation/basic_propagation.h
index de1527e..bfda43c 100644
--- a/shardy/dialect/sdy/transforms/propagation/basic_propagation.h
+++ b/shardy/dialect/sdy/transforms/propagation/basic_propagation.h
@@ -34,6 +34,7 @@ limitations under the License.
 #include "shardy/dialect/sdy/transforms/common/propagation_options.h"
 #include "shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/factor_propagation.h"
+#include "shardy/dialect/sdy/transforms/propagation/passes.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_group_map.h"
 
 namespace mlir {
diff --git a/shardy/dialect/sdy/transforms/propagation/op_priority_propagation.cc b/shardy/dialect/sdy/transforms/propagation/op_priority_propagation.cc
index 81d9858..ff05e4f 100644
--- a/shardy/dialect/sdy/transforms/propagation/op_priority_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/op_priority_propagation.cc
@@ -34,9 +34,9 @@ limitations under the License.
 #include "shardy/dialect/sdy/ir/dialect.h"
 #include "shardy/dialect/sdy/ir/utils.h"
 #include "shardy/dialect/sdy/transforms/common/op_properties.h"
-#include "shardy/dialect/sdy/transforms/common/propagation_options.h"
 #include "shardy/dialect/sdy/transforms/propagation/aggressive_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/basic_propagation.h"
+#include "shardy/dialect/sdy/transforms/propagation/passes.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_group_map.h"
 #include "shardy/dialect/sdy/transforms/propagation/utils.h"
 #include "stablehlo/dialect/StablehloOps.h"
diff --git a/shardy/dialect/sdy/transforms/propagation/op_priority_propagation.h b/shardy/dialect/sdy/transforms/propagation/op_priority_propagation.h
index b0eecb6..ebd91d8 100644
--- a/shardy/dialect/sdy/transforms/propagation/op_priority_propagation.h
+++ b/shardy/dialect/sdy/transforms/propagation/op_priority_propagation.h
@@ -24,9 +24,9 @@ limitations under the License.
 #include "mlir/Pass/Pass.h"
 #include "mlir/Support/LLVM.h"
 #include "mlir/Support/LogicalResult.h"
-#include "shardy/dialect/sdy/transforms/common/propagation_options.h"
 #include "shardy/dialect/sdy/transforms/propagation/aggressive_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/basic_propagation.h"
+#include "shardy/dialect/sdy/transforms/propagation/passes.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_group_map.h"
 
 namespace mlir {
diff --git a/shardy/dialect/sdy/transforms/propagation/user_priority_propagation.cc b/shardy/dialect/sdy/transforms/propagation/user_priority_propagation.cc
index f7571a6..7c3f9fa 100644
--- a/shardy/dialect/sdy/transforms/propagation/user_priority_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/user_priority_propagation.cc
@@ -37,10 +37,10 @@ limitations under the License.
 #include "mlir/Support/LogicalResult.h"
 #include "shardy/common/file_utils.h"
 #include "shardy/dialect/sdy/ir/dialect.h"
-#include "shardy/dialect/sdy/transforms/common/propagation_options.h"
 #include "shardy/dialect/sdy/transforms/common/sharding_walker.h"
 #include "shardy/dialect/sdy/transforms/propagation/basic_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/op_priority_propagation.h"
+#include "shardy/dialect/sdy/transforms/propagation/passes.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_group_map.h"
 
 namespace mlir {
diff --git a/shardy/dialect/sdy/transforms/propagation/user_priority_propagation.h b/shardy/dialect/sdy/transforms/propagation/user_priority_propagation.h
index 061d7ad..c59c923 100644
--- a/shardy/dialect/sdy/transforms/propagation/user_priority_propagation.h
+++ b/shardy/dialect/sdy/transforms/propagation/user_priority_propagation.h
@@ -23,9 +23,9 @@ limitations under the License.
 #include "mlir/Pass/Pass.h"
 #include "mlir/Support/LLVM.h"
 #include "mlir/Support/LogicalResult.h"
-#include "shardy/dialect/sdy/transforms/common/propagation_options.h"
 #include "shardy/dialect/sdy/transforms/propagation/basic_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/op_priority_propagation.h"
+#include "shardy/dialect/sdy/transforms/propagation/passes.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_group_map.h"
 
 namespace mlir {
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 509398d..4e4978d 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1 +1,516 @@
 Auto generated patch. Do not edit or delete it, even if empty.
+diff -ruN --strip-trailing-cr a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
+--- a/clang/docs/ReleaseNotes.rst
++++ b/clang/docs/ReleaseNotes.rst
+@@ -246,8 +246,6 @@
+ 
+ - ``__builtin_assume_dereferenceable`` now accepts non-constant size operands.
+ 
+-- Fixed a crash when the second argument to ``__builtin_assume_aligned`` was not constant (#GH161314)
+-
+ New Compiler Flags
+ ------------------
+ - New option ``-fno-sanitize-debug-trap-reasons`` added to disable emitting trap reasons into the debug info when compiling with trapping UBSan (e.g. ``-fsanitize-trap=undefined``).
+diff -ruN --strip-trailing-cr a/clang/lib/Analysis/ThreadSafety.cpp b/clang/lib/Analysis/ThreadSafety.cpp
+--- a/clang/lib/Analysis/ThreadSafety.cpp
++++ b/clang/lib/Analysis/ThreadSafety.cpp
+@@ -419,22 +419,28 @@
+     // The expression for this variable, OR
+     const Expr *Exp = nullptr;
+ 
+-    // Reference to another VarDefinition
+-    unsigned Ref = 0;
++    // Direct reference to another VarDefinition
++    unsigned DirectRef = 0;
++
++    // Reference to underlying canonical non-reference VarDefinition.
++    unsigned CanonicalRef = 0;
+ 
+     // The map with which Exp should be interpreted.
+     Context Ctx;
+ 
+     bool isReference() const { return !Exp; }
+ 
++    void invalidateRef() { DirectRef = CanonicalRef = 0; }
++
+   private:
+     // Create ordinary variable definition
+     VarDefinition(const NamedDecl *D, const Expr *E, Context C)
+         : Dec(D), Exp(E), Ctx(C) {}
+ 
+     // Create reference to previous definition
+-    VarDefinition(const NamedDecl *D, unsigned R, Context C)
+-        : Dec(D), Ref(R), Ctx(C) {}
++    VarDefinition(const NamedDecl *D, unsigned DirectRef, unsigned CanonicalRef,
++                  Context C)
++        : Dec(D), DirectRef(DirectRef), CanonicalRef(CanonicalRef), Ctx(C) {}
+   };
+ 
+ private:
+@@ -445,7 +451,7 @@
+ public:
+   LocalVariableMap() {
+     // index 0 is a placeholder for undefined variables (aka phi-nodes).
+-    VarDefinitions.push_back(VarDefinition(nullptr, 0u, getEmptyContext()));
++    VarDefinitions.push_back(VarDefinition(nullptr, 0, 0, getEmptyContext()));
+   }
+ 
+   /// Look up a definition, within the given context.
+@@ -471,7 +477,7 @@
+         Ctx = VarDefinitions[i].Ctx;
+         return VarDefinitions[i].Exp;
+       }
+-      i = VarDefinitions[i].Ref;
++      i = VarDefinitions[i].DirectRef;
+     }
+     return nullptr;
+   }
+@@ -508,7 +514,7 @@
+   void dump() {
+     for (unsigned i = 1, e = VarDefinitions.size(); i < e; ++i) {
+       const Expr *Exp = VarDefinitions[i].Exp;
+-      unsigned Ref = VarDefinitions[i].Ref;
++      unsigned Ref = VarDefinitions[i].DirectRef;
+ 
+       dumpVarDefinitionName(i);
+       llvm::errs() << " = ";
+@@ -539,9 +545,9 @@
+   friend class VarMapBuilder;
+ 
+   // Resolve any definition ID down to its non-reference base ID.
+-  unsigned getCanonicalDefinitionID(unsigned ID) {
++  unsigned getCanonicalDefinitionID(unsigned ID) const {
+     while (ID > 0 && VarDefinitions[ID].isReference())
+-      ID = VarDefinitions[ID].Ref;
++      ID = VarDefinitions[ID].CanonicalRef;
+     return ID;
+   }
+ 
+@@ -564,10 +570,11 @@
+   }
+ 
+   // Add a new reference to an existing definition.
+-  Context addReference(const NamedDecl *D, unsigned i, Context Ctx) {
++  Context addReference(const NamedDecl *D, unsigned Ref, Context Ctx) {
+     unsigned newID = VarDefinitions.size();
+     Context NewCtx = ContextFactory.add(Ctx, D, newID);
+-    VarDefinitions.push_back(VarDefinition(D, i, Ctx));
++    VarDefinitions.push_back(
++        VarDefinition(D, Ref, getCanonicalDefinitionID(Ref), Ctx));
+     return NewCtx;
+   }
+ 
+@@ -769,15 +776,14 @@
+     const unsigned *I2 = C2.lookup(P.first);
+     if (!I2) {
+       // Variable does not exist at the end of the loop, invalidate.
+-      VDef->Ref = 0;
++      VDef->invalidateRef();
+       continue;
+     }
+ 
+     // Compare the canonical IDs. This correctly handles chains of references
+     // and determines if the variable is truly loop-invariant.
+-    if (getCanonicalDefinitionID(VDef->Ref) != getCanonicalDefinitionID(*I2)) {
+-      VDef->Ref = 0; // Mark this variable as undefined
+-    }
++    if (VDef->CanonicalRef != getCanonicalDefinitionID(*I2))
++      VDef->invalidateRef(); // Mark this variable as undefined
+   }
+ }
+ 
+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaChecking.cpp b/clang/lib/Sema/SemaChecking.cpp
+--- a/clang/lib/Sema/SemaChecking.cpp
++++ b/clang/lib/Sema/SemaChecking.cpp
+@@ -5954,9 +5954,6 @@
+     if (Result > Sema::MaximumAlignment)
+       Diag(TheCall->getBeginLoc(), diag::warn_assume_aligned_too_great)
+           << SecondArg->getSourceRange() << Sema::MaximumAlignment;
+-
+-    TheCall->setArg(1,
+-                    ConstantExpr::Create(Context, SecondArg, APValue(Result)));
+   }
+ 
+   if (NumArgs > 2) {
+diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/builtin-assume-aligned.cpp b/clang/test/SemaCXX/builtin-assume-aligned.cpp
+--- a/clang/test/SemaCXX/builtin-assume-aligned.cpp
++++ b/clang/test/SemaCXX/builtin-assume-aligned.cpp
+@@ -47,9 +47,3 @@
+ constexpr void *s2 = __builtin_assume_aligned(x, 32, 5);
+ constexpr void *s3 = __builtin_assume_aligned(x, 32, -1);
+ 
+-
+-constexpr int add(int a, int b) {
+-  return a+b;
+-}
+-constexpr void *c1 = __builtin_assume_aligned(p, add(1,1));
+-constexpr void *c2 = __builtin_assume_aligned(p, add(2,1)); // expected-error {{not a power of 2}}
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/Analysis/MemoryProfileInfo.h b/llvm/include/llvm/Analysis/MemoryProfileInfo.h
+--- a/llvm/include/llvm/Analysis/MemoryProfileInfo.h
++++ b/llvm/include/llvm/Analysis/MemoryProfileInfo.h
+@@ -59,14 +59,6 @@
+ /// True if the AllocTypes bitmask contains just a single type.
+ LLVM_ABI bool hasSingleAllocType(uint8_t AllocTypes);
+ 
+-/// Removes any existing "ambiguous" memprof attribute. Called before we apply a
+-/// specific allocation type such as "cold", "notcold", or "hot".
+-LLVM_ABI void removeAnyExistingAmbiguousAttribute(CallBase *CB);
+-
+-/// Adds an "ambiguous" memprof attribute to call with a matched allocation
+-/// profile but that we haven't yet been able to disambiguate.
+-LLVM_ABI void addAmbiguousAttribute(CallBase *CB);
+-
+ /// Class to build a trie of call stack contexts for a particular profiled
+ /// allocation call, along with their associated allocation types.
+ /// The allocation will be at the root of the trie, which is then used to
+diff -ruN --strip-trailing-cr a/llvm/lib/Analysis/MemoryProfileInfo.cpp b/llvm/lib/Analysis/MemoryProfileInfo.cpp
+--- a/llvm/lib/Analysis/MemoryProfileInfo.cpp
++++ b/llvm/lib/Analysis/MemoryProfileInfo.cpp
+@@ -125,24 +125,6 @@
+   return NumAllocTypes == 1;
+ }
+ 
+-void llvm::memprof::removeAnyExistingAmbiguousAttribute(CallBase *CB) {
+-  if (!CB->hasFnAttr("memprof"))
+-    return;
+-  assert(CB->getFnAttr("memprof").getValueAsString() == "ambiguous");
+-  CB->removeFnAttr("memprof");
+-}
+-
+-void llvm::memprof::addAmbiguousAttribute(CallBase *CB) {
+-  // We may have an existing ambiguous attribute if we are reanalyzing
+-  // after inlining.
+-  if (CB->hasFnAttr("memprof")) {
+-    assert(CB->getFnAttr("memprof").getValueAsString() == "ambiguous");
+-  } else {
+-    auto A = llvm::Attribute::get(CB->getContext(), "memprof", "ambiguous");
+-    CB->addFnAttr(A);
+-  }
+-}
+-
+ void CallStackTrie::addCallStack(
+     AllocationType AllocType, ArrayRef<uint64_t> StackIds,
+     std::vector<ContextTotalSize> ContextSizeInfo) {
+@@ -488,9 +470,6 @@
+                                                 StringRef Descriptor) {
+   auto AllocTypeString = getAllocTypeAttributeString(AT);
+   auto A = llvm::Attribute::get(CI->getContext(), "memprof", AllocTypeString);
+-  // After inlining we may be able to convert an existing ambiguous allocation
+-  // to an unambiguous one.
+-  removeAnyExistingAmbiguousAttribute(CI);
+   CI->addFnAttr(A);
+   if (MemProfReportHintedSizes) {
+     std::vector<ContextTotalSize> ContextSizeInfo;
+@@ -550,7 +529,6 @@
+     assert(MIBCallStack.size() == 1 &&
+            "Should only be left with Alloc's location in stack");
+     CI->setMetadata(LLVMContext::MD_memprof, MDNode::get(Ctx, MIBNodes));
+-    addAmbiguousAttribute(CI);
+     return true;
+   }
+   // If there exists corner case that CallStackTrie has one chain to leaf
+diff -ruN --strip-trailing-cr a/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp b/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
+--- a/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
++++ b/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
+@@ -638,6 +638,11 @@
+   // No support for these operations with v2f32/v2i32
+   setOperationAction(ISD::INSERT_VECTOR_ELT, {MVT::v2f32, MVT::v2i32}, Expand);
+   setOperationAction(ISD::VECTOR_SHUFFLE, {MVT::v2f32, MVT::v2i32}, Expand);
++
++  setOperationAction(ISD::TRUNCATE, MVT::v2i16, Expand);
++  setOperationAction({ISD::ANY_EXTEND, ISD::ZERO_EXTEND, ISD::SIGN_EXTEND},
++                     MVT::v2i32, Expand);
++
+   // Need custom lowering in case the index is dynamic.
+   if (STI.hasF32x2Instructions())
+     setOperationAction(ISD::EXTRACT_VECTOR_ELT, {MVT::v2f32, MVT::v2i32},
+diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
+--- a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
++++ b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
+@@ -3981,7 +3981,6 @@
+ void ModuleCallsiteContextGraph::updateAllocationCall(
+     CallInfo &Call, AllocationType AllocType) {
+   std::string AllocTypeString = getAllocTypeAttributeString(AllocType);
+-  removeAnyExistingAmbiguousAttribute(cast<CallBase>(Call.call()));
+   auto A = llvm::Attribute::get(Call.call()->getFunction()->getContext(),
+                                 "memprof", AllocTypeString);
+   cast<CallBase>(Call.call())->addFnAttr(A);
+@@ -5643,7 +5642,6 @@
+               // clone J-1 (J==0 is the original clone and does not have a VMaps
+               // entry).
+               CBClone = cast<CallBase>((*VMaps[J - 1])[CB]);
+-            removeAnyExistingAmbiguousAttribute(CBClone);
+             CBClone->addFnAttr(A);
+             ORE.emit(OptimizationRemark(DEBUG_TYPE, "MemprofAttribute", CBClone)
+                      << ore::NV("AllocationCall", CBClone) << " in clone "
+diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/f32x2-convert-i32x2.ll b/llvm/test/CodeGen/NVPTX/f32x2-convert-i32x2.ll
+--- a/llvm/test/CodeGen/NVPTX/f32x2-convert-i32x2.ll
++++ b/llvm/test/CodeGen/NVPTX/f32x2-convert-i32x2.ll
+@@ -115,5 +115,150 @@
+   store <2 x float> %mul, ptr %p, align 8
+   ret void
+ }
++
++define ptx_kernel void @trunc_v2i32(<2 x i32> %0) {
++; CHECK-SM90A-LABEL: trunc_v2i32(
++; CHECK-SM90A:       {
++; CHECK-SM90A-NEXT:    .reg .b32 %r<7>;
++; CHECK-SM90A-NEXT:    .reg .b64 %rd<2>;
++; CHECK-SM90A-EMPTY:
++; CHECK-SM90A-NEXT:  // %bb.0:
++; CHECK-SM90A-NEXT:    ld.param.v2.b32 {%r1, %r2}, [trunc_v2i32_param_0];
++; CHECK-SM90A-NEXT:    prmt.b32 %r3, %r1, %r2, 0x3340U;
++; CHECK-SM90A-NEXT:    mov.b32 %r4, 0;
++; CHECK-SM90A-NEXT:    prmt.b32 %r5, %r4, 0, 0x3340U;
++; CHECK-SM90A-NEXT:    prmt.b32 %r6, %r5, %r3, 0x5410U;
++; CHECK-SM90A-NEXT:    mov.b64 %rd1, 0;
++; CHECK-SM90A-NEXT:    st.b32 [%rd1], %r6;
++; CHECK-SM90A-NEXT:    ret;
++;
++; CHECK-SM100-LABEL: trunc_v2i32(
++; CHECK-SM100:       {
++; CHECK-SM100-NEXT:    .reg .b32 %r<7>;
++; CHECK-SM100-NEXT:    .reg .b64 %rd<3>;
++; CHECK-SM100-EMPTY:
++; CHECK-SM100-NEXT:  // %bb.0:
++; CHECK-SM100-NEXT:    ld.param.b64 %rd1, [trunc_v2i32_param_0];
++; CHECK-SM100-NEXT:    mov.b64 {%r1, %r2}, %rd1;
++; CHECK-SM100-NEXT:    mov.b32 %r3, 0;
++; CHECK-SM100-NEXT:    prmt.b32 %r4, %r3, 0, 0x3340U;
++; CHECK-SM100-NEXT:    prmt.b32 %r5, %r1, %r2, 0x3340U;
++; CHECK-SM100-NEXT:    prmt.b32 %r6, %r4, %r5, 0x5410U;
++; CHECK-SM100-NEXT:    mov.b64 %rd2, 0;
++; CHECK-SM100-NEXT:    st.b32 [%rd2], %r6;
++; CHECK-SM100-NEXT:    ret;
++  %2 = trunc <2 x i32> %0 to <2 x i8>
++  %3 = shufflevector <2 x i8> zeroinitializer, <2 x i8> %2, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
++  store <4 x i8> %3, ptr null, align 4
++  ret void
++}
++
++define ptx_kernel void @zextend_to_v2i32(<2 x i8> %0) {
++; CHECK-SM90A-LABEL: zextend_to_v2i32(
++; CHECK-SM90A:       {
++; CHECK-SM90A-NEXT:    .reg .b16 %rs<3>;
++; CHECK-SM90A-NEXT:    .reg .b32 %r<4>;
++; CHECK-SM90A-NEXT:    .reg .b64 %rd<5>;
++; CHECK-SM90A-EMPTY:
++; CHECK-SM90A-NEXT:  // %bb.0:
++; CHECK-SM90A-NEXT:    ld.param.v2.b8 {%rs1, %rs2}, [zextend_to_v2i32_param_0];
++; CHECK-SM90A-NEXT:    mov.b32 %r1, {%rs1, %rs2};
++; CHECK-SM90A-NEXT:    cvt.u32.u16 %r2, %rs1;
++; CHECK-SM90A-NEXT:    cvt.u32.u16 %r3, %rs2;
++; CHECK-SM90A-NEXT:    mov.b64 %rd1, 12;
++; CHECK-SM90A-NEXT:    st.b32 [%rd1], %r3;
++; CHECK-SM90A-NEXT:    mov.b64 %rd2, 8;
++; CHECK-SM90A-NEXT:    st.b32 [%rd2], %r2;
++; CHECK-SM90A-NEXT:    mov.b64 %rd3, 4;
++; CHECK-SM90A-NEXT:    st.b32 [%rd3], 0;
++; CHECK-SM90A-NEXT:    mov.b64 %rd4, 0;
++; CHECK-SM90A-NEXT:    st.b32 [%rd4], 0;
++; CHECK-SM90A-NEXT:    ret;
++;
++; CHECK-SM100-LABEL: zextend_to_v2i32(
++; CHECK-SM100:       {
++; CHECK-SM100-NEXT:    .reg .b16 %rs<3>;
++; CHECK-SM100-NEXT:    .reg .b32 %r<5>;
++; CHECK-SM100-NEXT:    .reg .b64 %rd<8>;
++; CHECK-SM100-EMPTY:
++; CHECK-SM100-NEXT:  // %bb.0:
++; CHECK-SM100-NEXT:    ld.param.v2.b8 {%rs1, %rs2}, [zextend_to_v2i32_param_0];
++; CHECK-SM100-NEXT:    mov.b32 %r1, {%rs1, %rs2};
++; CHECK-SM100-NEXT:    cvt.u32.u16 %r2, %rs2;
++; CHECK-SM100-NEXT:    cvt.u32.u16 %r3, %rs1;
++; CHECK-SM100-NEXT:    mov.b64 %rd1, {%r3, %r2};
++; CHECK-SM100-NEXT:    mov.b32 %r4, 0;
++; CHECK-SM100-NEXT:    mov.b64 %rd2, {%r4, %r4};
++; CHECK-SM100-NEXT:    mov.b64 %rd3, 4;
++; CHECK-SM100-NEXT:    st.b32 [%rd3], %rd2;
++; CHECK-SM100-NEXT:    mov.b64 %rd4, 0;
++; CHECK-SM100-NEXT:    st.b32 [%rd4], %rd2;
++; CHECK-SM100-NEXT:    mov.b64 %rd5, 8;
++; CHECK-SM100-NEXT:    st.b32 [%rd5], %rd1;
++; CHECK-SM100-NEXT:    shr.u64 %rd6, %rd1, 32;
++; CHECK-SM100-NEXT:    mov.b64 %rd7, 12;
++; CHECK-SM100-NEXT:    st.b32 [%rd7], %rd6;
++; CHECK-SM100-NEXT:    ret;
++  %2 = zext <2 x i8> %0 to <2 x i32>
++  %3 = shufflevector <2 x i32> zeroinitializer, <2 x i32> %2, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
++  store <4 x i32> %3, ptr null, align 4
++  ret void
++}
++
++define ptx_kernel void @sextend_to_v2i32(<2 x i8> %0) {
++; CHECK-SM90A-LABEL: sextend_to_v2i32(
++; CHECK-SM90A:       {
++; CHECK-SM90A-NEXT:    .reg .b16 %rs<3>;
++; CHECK-SM90A-NEXT:    .reg .b32 %r<6>;
++; CHECK-SM90A-NEXT:    .reg .b64 %rd<5>;
++; CHECK-SM90A-EMPTY:
++; CHECK-SM90A-NEXT:  // %bb.0:
++; CHECK-SM90A-NEXT:    ld.param.v2.b8 {%rs1, %rs2}, [sextend_to_v2i32_param_0];
++; CHECK-SM90A-NEXT:    mov.b32 %r1, {%rs1, %rs2};
++; CHECK-SM90A-NEXT:    cvt.u32.u16 %r2, %rs1;
++; CHECK-SM90A-NEXT:    cvt.s32.s8 %r3, %r2;
++; CHECK-SM90A-NEXT:    cvt.u32.u16 %r4, %rs2;
++; CHECK-SM90A-NEXT:    cvt.s32.s8 %r5, %r4;
++; CHECK-SM90A-NEXT:    mov.b64 %rd1, 12;
++; CHECK-SM90A-NEXT:    st.b32 [%rd1], %r5;
++; CHECK-SM90A-NEXT:    mov.b64 %rd2, 8;
++; CHECK-SM90A-NEXT:    st.b32 [%rd2], %r3;
++; CHECK-SM90A-NEXT:    mov.b64 %rd3, 4;
++; CHECK-SM90A-NEXT:    st.b32 [%rd3], 0;
++; CHECK-SM90A-NEXT:    mov.b64 %rd4, 0;
++; CHECK-SM90A-NEXT:    st.b32 [%rd4], 0;
++; CHECK-SM90A-NEXT:    ret;
++;
++; CHECK-SM100-LABEL: sextend_to_v2i32(
++; CHECK-SM100:       {
++; CHECK-SM100-NEXT:    .reg .b16 %rs<3>;
++; CHECK-SM100-NEXT:    .reg .b32 %r<7>;
++; CHECK-SM100-NEXT:    .reg .b64 %rd<8>;
++; CHECK-SM100-EMPTY:
++; CHECK-SM100-NEXT:  // %bb.0:
++; CHECK-SM100-NEXT:    ld.param.v2.b8 {%rs1, %rs2}, [sextend_to_v2i32_param_0];
++; CHECK-SM100-NEXT:    mov.b32 %r1, {%rs1, %rs2};
++; CHECK-SM100-NEXT:    cvt.u32.u16 %r2, %rs2;
++; CHECK-SM100-NEXT:    cvt.s32.s8 %r3, %r2;
++; CHECK-SM100-NEXT:    cvt.u32.u16 %r4, %rs1;
++; CHECK-SM100-NEXT:    cvt.s32.s8 %r5, %r4;
++; CHECK-SM100-NEXT:    mov.b64 %rd1, {%r5, %r3};
++; CHECK-SM100-NEXT:    mov.b32 %r6, 0;
++; CHECK-SM100-NEXT:    mov.b64 %rd2, {%r6, %r6};
++; CHECK-SM100-NEXT:    mov.b64 %rd3, 4;
++; CHECK-SM100-NEXT:    st.b32 [%rd3], %rd2;
++; CHECK-SM100-NEXT:    mov.b64 %rd4, 0;
++; CHECK-SM100-NEXT:    st.b32 [%rd4], %rd2;
++; CHECK-SM100-NEXT:    mov.b64 %rd5, 8;
++; CHECK-SM100-NEXT:    st.b32 [%rd5], %rd1;
++; CHECK-SM100-NEXT:    shr.u64 %rd6, %rd1, 32;
++; CHECK-SM100-NEXT:    mov.b64 %rd7, 12;
++; CHECK-SM100-NEXT:    st.b32 [%rd7], %rd6;
++; CHECK-SM100-NEXT:    ret;
++  %2 = sext <2 x i8> %0 to <2 x i32>
++  %3 = shufflevector <2 x i32> zeroinitializer, <2 x i32> %2, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
++  store <4 x i32> %3, ptr null, align 4
++  ret void
++}
+ ;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
+ ; CHECK: {{.*}}
+diff -ruN --strip-trailing-cr a/llvm/unittests/Analysis/FunctionPropertiesAnalysisTest.cpp b/llvm/unittests/Analysis/FunctionPropertiesAnalysisTest.cpp
+--- a/llvm/unittests/Analysis/FunctionPropertiesAnalysisTest.cpp
++++ b/llvm/unittests/Analysis/FunctionPropertiesAnalysisTest.cpp
+@@ -46,8 +46,8 @@
+     MAM.registerPass([VocabVector = std::move(VocabVector)]() mutable {
+       return IR2VecVocabAnalysis(std::move(VocabVector));
+     });
+-    IR2VecVocab =
+-        new ir2vec::Vocabulary(ir2vec::Vocabulary::createDummyVocabForTest(1));
++    IR2VecVocab = std::make_unique<ir2vec::Vocabulary>(
++        ir2vec::Vocabulary::createDummyVocabForTest(1));
+     MAM.registerPass([&] { return PassInstrumentationAnalysis(); });
+     FAM.registerPass([&] { return ModuleAnalysisManagerFunctionProxy(MAM); });
+     FAM.registerPass([&] { return DominatorTreeAnalysis(); });
+@@ -69,7 +69,7 @@
+   std::unique_ptr<LoopInfo> LI;
+   FunctionAnalysisManager FAM;
+   ModuleAnalysisManager MAM;
+-  ir2vec::Vocabulary *IR2VecVocab;
++  std::unique_ptr<ir2vec::Vocabulary> IR2VecVocab;
+ 
+   void TearDown() override {
+     // Restore original IR2Vec weights
+diff -ruN --strip-trailing-cr a/llvm/unittests/Analysis/IR2VecTest.cpp b/llvm/unittests/Analysis/IR2VecTest.cpp
+--- a/llvm/unittests/Analysis/IR2VecTest.cpp
++++ b/llvm/unittests/Analysis/IR2VecTest.cpp
+@@ -295,7 +295,7 @@
+ // Fixture for IR2Vec tests requiring IR setup.
+ class IR2VecTestFixture : public ::testing::Test {
+ protected:
+-  Vocabulary *V;
++  std::unique_ptr<Vocabulary> V;
+   LLVMContext Ctx;
+   std::unique_ptr<Module> M;
+   Function *F = nullptr;
+@@ -304,7 +304,7 @@
+   Instruction *RetInst = nullptr;
+ 
+   void SetUp() override {
+-    V = new Vocabulary(Vocabulary::createDummyVocabForTest(2));
++    V = std::make_unique<Vocabulary>(Vocabulary::createDummyVocabForTest(2));
+ 
+     // Setup IR
+     M = std::make_unique<Module>("TestM", Ctx);
+diff -ruN --strip-trailing-cr a/llvm/unittests/Analysis/MemoryProfileInfoTest.cpp b/llvm/unittests/Analysis/MemoryProfileInfoTest.cpp
+--- a/llvm/unittests/Analysis/MemoryProfileInfoTest.cpp
++++ b/llvm/unittests/Analysis/MemoryProfileInfoTest.cpp
+@@ -230,8 +230,7 @@
+   CallBase *Call = findCall(*Func, "call");
+   Trie.buildAndAttachMIBMetadata(Call);
+ 
+-  EXPECT_TRUE(Call->hasFnAttr("memprof"));
+-  EXPECT_EQ(Call->getFnAttr("memprof").getValueAsString(), "ambiguous");
++  EXPECT_FALSE(Call->hasFnAttr("memprof"));
+   EXPECT_TRUE(Call->hasMetadata(LLVMContext::MD_memprof));
+   MDNode *MemProfMD = Call->getMetadata(LLVMContext::MD_memprof);
+   ASSERT_EQ(MemProfMD->getNumOperands(), 2u);
+@@ -280,8 +279,7 @@
+   CallBase *Call = findCall(*Func, "call");
+   Trie.buildAndAttachMIBMetadata(Call);
+ 
+-  EXPECT_TRUE(Call->hasFnAttr("memprof"));
+-  EXPECT_EQ(Call->getFnAttr("memprof").getValueAsString(), "ambiguous");
++  EXPECT_FALSE(Call->hasFnAttr("memprof"));
+   EXPECT_TRUE(Call->hasMetadata(LLVMContext::MD_memprof));
+   MDNode *MemProfMD = Call->getMetadata(LLVMContext::MD_memprof);
+   ASSERT_EQ(MemProfMD->getNumOperands(), 2u);
+@@ -335,8 +333,7 @@
+   CallBase *Call = findCall(*Func, "call");
+   Trie.buildAndAttachMIBMetadata(Call);
+ 
+-  EXPECT_TRUE(Call->hasFnAttr("memprof"));
+-  EXPECT_EQ(Call->getFnAttr("memprof").getValueAsString(), "ambiguous");
++  EXPECT_FALSE(Call->hasFnAttr("memprof"));
+   EXPECT_TRUE(Call->hasMetadata(LLVMContext::MD_memprof));
+   MDNode *MemProfMD = Call->getMetadata(LLVMContext::MD_memprof);
+   ASSERT_EQ(MemProfMD->getNumOperands(), 2u);
+@@ -395,8 +392,7 @@
+   CallBase *Call = findCall(*Func, "call");
+   Trie.buildAndAttachMIBMetadata(Call);
+ 
+-  EXPECT_TRUE(Call->hasFnAttr("memprof"));
+-  EXPECT_EQ(Call->getFnAttr("memprof").getValueAsString(), "ambiguous");
++  EXPECT_FALSE(Call->hasFnAttr("memprof"));
+   EXPECT_TRUE(Call->hasMetadata(LLVMContext::MD_memprof));
+   MDNode *MemProfMD = Call->getMetadata(LLVMContext::MD_memprof);
+   ASSERT_EQ(MemProfMD->getNumOperands(), 2u);
+@@ -467,8 +463,7 @@
+   ASSERT_NE(Call, nullptr);
+   Trie.buildAndAttachMIBMetadata(Call);
+ 
+-  EXPECT_TRUE(Call->hasFnAttr("memprof"));
+-  EXPECT_EQ(Call->getFnAttr("memprof").getValueAsString(), "ambiguous");
++  EXPECT_FALSE(Call->hasFnAttr("memprof"));
+   EXPECT_TRUE(Call->hasMetadata(LLVMContext::MD_memprof));
+   MDNode *MemProfMD = Call->getMetadata(LLVMContext::MD_memprof);
+   EXPECT_THAT(MemProfMD, MemprofMetadataEquals(ExpectedVals));
+@@ -541,8 +536,7 @@
+   // Restore original option value.
+   MemProfKeepAllNotColdContexts = OrigMemProfKeepAllNotColdContexts;
+ 
+-  EXPECT_TRUE(Call->hasFnAttr("memprof"));
+-  EXPECT_EQ(Call->getFnAttr("memprof").getValueAsString(), "ambiguous");
++  EXPECT_FALSE(Call->hasFnAttr("memprof"));
+   EXPECT_TRUE(Call->hasMetadata(LLVMContext::MD_memprof));
+   MDNode *MemProfMD = Call->getMetadata(LLVMContext::MD_memprof);
+   EXPECT_THAT(MemProfMD, MemprofMetadataEquals(ExpectedVals));
+@@ -670,8 +664,7 @@
+   // The hot allocations will be converted to NotCold and pruned as they
+   // are unnecessary to determine how to clone the cold allocation.
+ 
+-  EXPECT_TRUE(Call->hasFnAttr("memprof"));
+-  EXPECT_EQ(Call->getFnAttr("memprof").getValueAsString(), "ambiguous");
++  EXPECT_FALSE(Call->hasFnAttr("memprof"));
+   EXPECT_TRUE(Call->hasMetadata(LLVMContext::MD_memprof));
+   MemProfMD = Call->getMetadata(LLVMContext::MD_memprof);
+   ASSERT_EQ(MemProfMD->getNumOperands(), 2u);
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 996e2ec..36ba2b4 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "ca84f2aa3be6e46a4dccb1bec56b93f2bb3d8ef0"
-    LLVM_SHA256 = "5cea44df2e0c3dcb6119c2ca5d7a900001e93ec43369ed1b58eb4ed4d4c9f9f0"
+    LLVM_COMMIT = "ac0e99e19124ab720e8837d1500f0c000559a0ef"
+    LLVM_SHA256 = "0e5604fbe1c6d441568fdf3b8b88d4583af23ca6a9cc794fad90414b93aa4a09"
 
     tf_http_archive(
         name = name,
