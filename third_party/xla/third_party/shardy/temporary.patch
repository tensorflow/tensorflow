diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 843d79d..b479bd6 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,1842 +1,575 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/clang/lib/Format/Format.cpp b/clang/lib/Format/Format.cpp
---- a/clang/lib/Format/Format.cpp
-+++ b/clang/lib/Format/Format.cpp
-@@ -2643,13 +2643,14 @@
-       for (FormatToken *Tok = Line->First; Tok && Tok->Next; Tok = Tok->Next) {
-         if (Tok->isNot(TT_PointerOrReference))
-           continue;
--        // Don't treat space in `void foo() &&` as evidence.
-+        // Don't treat space in `void foo() &&` or `void() &&` as evidence.
-         if (const auto *Prev = Tok->getPreviousNonComment()) {
-           if (Prev->is(tok::r_paren) && Prev->MatchingParen) {
-             if (const auto *Func =
-                     Prev->MatchingParen->getPreviousNonComment()) {
-               if (Func->isOneOf(TT_FunctionDeclarationName, TT_StartOfName,
--                                TT_OverloadedOperator)) {
-+                                TT_OverloadedOperator) ||
-+                  Func->isTypeName(LangOpts)) {
-                 continue;
-               }
-             }
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclAttr.cpp b/clang/lib/Sema/SemaDeclAttr.cpp
---- a/clang/lib/Sema/SemaDeclAttr.cpp
-+++ b/clang/lib/Sema/SemaDeclAttr.cpp
-@@ -1970,6 +1970,13 @@
-   if (!FD)
-     return;
- 
-+  // Skip explicit specializations here as they may have
-+  // a user-provided definition that may deliberately differ from the primary
-+  // template. If an explicit specialization truly never returns, the user
-+  // should explicitly mark it with [[noreturn]].
-+  if (FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization)
-+    return;
-+
-   auto *NonConstFD = const_cast<FunctionDecl *>(FD);
-   DiagnosticsEngine &Diags = S.getDiagnostics();
-   if (Diags.isIgnored(diag::warn_falloff_nonvoid, FD->getLocation()) &&
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
---- a/clang/lib/Sema/SemaDecl.cpp
-+++ b/clang/lib/Sema/SemaDecl.cpp
-@@ -3267,6 +3267,14 @@
-     if (isa<UsedAttr>(I) || isa<RetainAttr>(I))
-       continue;
- 
-+    if (isa<InferredNoReturnAttr>(I)) {
-+      if (auto *FD = dyn_cast<FunctionDecl>(New)) {
-+        if (FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization)
-+          continue; // Don't propagate inferred noreturn attributes to explicit
-+                    // specializations.
-+      }
-+    }
-+
-     if (mergeDeclAttribute(*this, New, I, LocalAMK))
-       foundAny = true;
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/MC/MCObjectStreamer.h b/llvm/include/llvm/MC/MCObjectStreamer.h
+--- a/llvm/include/llvm/MC/MCObjectStreamer.h
++++ b/llvm/include/llvm/MC/MCObjectStreamer.h
+@@ -52,10 +52,6 @@
+   DenseMap<const MCSymbol *, SmallVector<PendingAssignment, 1>>
+       pendingAssignments;
+ 
+-  SmallVector<std::unique_ptr<char[]>, 0> FragStorage;
+-  // Available bytes in the current block for trailing data or new fragments.
+-  size_t FragSpace = 0;
+-
+   void emitInstToData(const MCInst &Inst, const MCSubtargetInfo &);
+   void emitCFIStartProcImpl(MCDwarfFrameInfo &Frame) override;
+   void emitCFIEndProcImpl(MCDwarfFrameInfo &Frame) override;
+@@ -88,18 +84,11 @@
+   // Add a fragment with a variable-size tail and start a new empty fragment.
+   void insert(MCFragment *F);
+ 
+-  char *getCurFragEnd() const {
+-    return reinterpret_cast<char *>(CurFrag + 1) + CurFrag->getFixedSize();
+-  }
+-  MCFragment *allocFragSpace(size_t Headroom);
+   // Add a new fragment to the current section without a variable-size tail.
+   void newFragment();
+ 
+-  void ensureHeadroom(size_t Headroom);
+   void appendContents(ArrayRef<char> Contents);
+   void appendContents(size_t Num, char Elt);
+-  // Add a fixup to the current fragment. Call ensureHeadroom beforehand to
+-  // ensure the fixup and appended content apply to the same fragment.
+   void addFixup(const MCExpr *Value, MCFixupKind Kind);
+ 
+   void emitLabel(MCSymbol *Symbol, SMLoc Loc = SMLoc()) override;
+diff -ruN --strip-trailing-cr a/llvm/include/llvm/MC/MCSection.h b/llvm/include/llvm/MC/MCSection.h
+--- a/llvm/include/llvm/MC/MCSection.h
++++ b/llvm/include/llvm/MC/MCSection.h
+@@ -93,7 +93,8 @@
+   // Track content and fixups for the fixed-size part as fragments are
+   // appended to the section. The content remains immutable, except when
+   // modified by applyFixup.
+-  uint32_t FixedSize = 0;
++  uint32_t ContentStart = 0;
++  uint32_t ContentEnd = 0;
+   uint32_t FixupStart = 0;
+   uint32_t FixupEnd = 0;
+ 
+@@ -187,6 +188,18 @@
+   //== Content-related functions manage parent's storage using ContentStart and
+   // ContentSize.
+ 
++  // Get a SmallVector reference. The caller should call doneAppending to update
++  // `ContentEnd`.
++  SmallVectorImpl<char> &getContentsForAppending();
++  void doneAppending();
++  void appendContents(ArrayRef<char> Contents) {
++    getContentsForAppending().append(Contents.begin(), Contents.end());
++    doneAppending();
++  }
++  void appendContents(size_t Num, char Elt) {
++    getContentsForAppending().append(Num, Elt);
++    doneAppending();
++  }
+   MutableArrayRef<char> getContents();
+   ArrayRef<char> getContents() const;
+ 
+@@ -195,10 +208,10 @@
+   MutableArrayRef<char> getVarContents();
+   ArrayRef<char> getVarContents() const;
+ 
+-  size_t getFixedSize() const { return FixedSize; }
++  size_t getFixedSize() const { return ContentEnd - ContentStart; }
+   size_t getVarSize() const { return VarContentEnd - VarContentStart; }
+   size_t getSize() const {
+-    return FixedSize + (VarContentEnd - VarContentStart);
++    return ContentEnd - ContentStart + (VarContentEnd - VarContentStart);
    }
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaOverload.cpp b/clang/lib/Sema/SemaOverload.cpp
---- a/clang/lib/Sema/SemaOverload.cpp
-+++ b/clang/lib/Sema/SemaOverload.cpp
-@@ -8042,8 +8042,8 @@
- 
-     Candidate.IgnoreObjectArgument =
-         isa<CXXMethodDecl>(Candidate.Function) &&
--        cast<CXXMethodDecl>(Candidate.Function)
--            ->isImplicitObjectMemberFunction() &&
-+        !cast<CXXMethodDecl>(Candidate.Function)
-+             ->isExplicitObjectMemberFunction() &&
-         !isa<CXXConstructorDecl>(Candidate.Function);
- 
-     Candidate.ExplicitCallArguments = Args.size();
-diff -ruN --strip-trailing-cr a/clang/test/Driver/offload-target.c b/clang/test/Driver/offload-target.c
---- a/clang/test/Driver/offload-target.c
-+++ b/clang/test/Driver/offload-target.c
-@@ -10,7 +10,7 @@
- // RUN: | FileCheck %s -check-prefix=CUDA
- // CUDA: "nvptx64-nvidia-cuda" - "clang", inputs: ["[[INPUT:.+]]"], output: "[[NV_OBJ:.+]]"
- 
--// RUN: %clang -### --offload-targets=amdgcn-amd-amdhsa,nvptx64-nvidia-cuda -fopenmp \
-+// RUN: %clang -### --offload-targets=amdgcn-amd-amdhsa,nvptx64-nvidia-cuda -fopenmp=libomp \
- // RUN:   -Xarch_amdgcn --offload-arch=gfx90a -Xarch_nvptx64 --offload-arch=sm_89 \
- // RUN:   -nogpulib -nogpuinc %s -ccc-print-bindings 2>&1 \
- // RUN: | FileCheck %s -check-prefix=OPENMP
-diff -ruN --strip-trailing-cr a/clang/test/Interpreter/pretty-print.c b/clang/test/Interpreter/pretty-print.c
---- a/clang/test/Interpreter/pretty-print.c
-+++ b/clang/test/Interpreter/pretty-print.c
-@@ -3,7 +3,7 @@
- // RUN: cat %s | clang-repl -Xcc -xc  | FileCheck %s
- // RUN: cat %s | clang-repl -Xcc -std=c++11 | FileCheck %s
  
--// UNSUPPORTED: hwasan
-+// UNSUPPORTED: hwasan, msan
- 
- 
- char c = 'a'; c
-diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx2b-deducing-this.cpp b/clang/test/SemaCXX/cxx2b-deducing-this.cpp
---- a/clang/test/SemaCXX/cxx2b-deducing-this.cpp
-+++ b/clang/test/SemaCXX/cxx2b-deducing-this.cpp
-@@ -1357,3 +1357,35 @@
- }
- 
- }
-+
-+namespace GH147046_regression {
-+
-+template <typename z> struct ai {
-+    ai(z::ah);
-+};
-+
-+template <typename z> struct ak {
-+    template <typename am> void an(am, z);
-+    template <typename am> static void an(am, ai<z>);
-+};
-+template <typename> struct ao {};
-+
-+template <typename ap>
-+auto ar(ao<ap> at) -> decltype(ak<ap>::an(at, 0));
-+// expected-note@-1 {{candidate template ignored: substitution failure [with ap = GH147046_regression::ay]: no matching function for call to 'an'}}
-+
-+class aw;
-+struct ax {
-+    typedef int ah;
-+};
-+struct ay {
-+    typedef aw ah;
-+};
-+
-+ao<ay> az ;
-+ai<ax> bd(0);
-+void f() {
-+    ar(az); // expected-error {{no matching function for call to 'ar'}}
+   //== Fixup-related functions manage parent's storage using FixupStart and
+@@ -621,11 +634,28 @@
+   bool isBssSection() const { return IsBss; }
+ };
+ 
++inline SmallVectorImpl<char> &MCFragment::getContentsForAppending() {
++  SmallVectorImpl<char> &S = getParent()->ContentStorage;
++  if (LLVM_UNLIKELY(ContentEnd != S.size())) {
++    // Move the elements to the end. Reserve space to avoid invalidating
++    // S.begin()+I for `append`.
++    auto Size = ContentEnd - ContentStart;
++    auto I = std::exchange(ContentStart, S.size());
++    S.reserve(S.size() + Size);
++    S.append(S.begin() + I, S.begin() + I + Size);
++  }
++  return S;
 +}
-+
++inline void MCFragment::doneAppending() {
++  ContentEnd = getParent()->ContentStorage.size();
 +}
-diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/wreturn-always-throws.cpp b/clang/test/SemaCXX/wreturn-always-throws.cpp
---- a/clang/test/SemaCXX/wreturn-always-throws.cpp
-+++ b/clang/test/SemaCXX/wreturn-always-throws.cpp
-@@ -1,4 +1,4 @@
--// RUN: %clang_cc1 -fsyntax-only -fcxx-exceptions -fexceptions -Wreturn-type -verify %s
-+// RUN: %clang_cc1 -fsyntax-only -fcxx-exceptions -fexceptions -Wreturn-type -Winvalid-noreturn -verify %s
- // expected-no-diagnostics
- 
- namespace std {
-@@ -44,3 +44,22 @@
-   throwErrorTemplate("ERROR");
-   (void)ensureZeroTemplate(42);
+ inline MutableArrayRef<char> MCFragment::getContents() {
+-  return {reinterpret_cast<char *>(this + 1), FixedSize};
++  return MutableArrayRef(getParent()->ContentStorage)
++      .slice(ContentStart, ContentEnd - ContentStart);
  }
-+
-+// Ensure that explicit specialization of a member function does not inherit
-+// the warning from the primary template.
-+
-+template<typename T>
-+struct S {
-+  void f();
-+  void g();
-+};
-+
-+template<typename T>
-+void S<T>::f() { throw 0; } 
-+template<>
-+void S<int>::f() {}
-+
-+template<typename T> 
-+void S<T>::g() {}  
-+template<> 
-+void S<int>::g() { throw 0; }
-diff -ruN --strip-trailing-cr a/clang/unittests/Format/FormatTest.cpp b/clang/unittests/Format/FormatTest.cpp
---- a/clang/unittests/Format/FormatTest.cpp
-+++ b/clang/unittests/Format/FormatTest.cpp
-@@ -12103,6 +12103,8 @@
-   Prefix = "void a() const &;\n"
-            "void b() const &;\n";
-   verifyFormat(Prefix + "int *x;", Prefix + "int* x;", DerivePointerAlignment);
-+
-+  verifyGoogleFormat("MACRO(int*, std::function<void() &&>);");
+ inline ArrayRef<char> MCFragment::getContents() const {
+-  return {reinterpret_cast<const char *>(this + 1), FixedSize};
++  return ArrayRef(getParent()->ContentStorage)
++      .slice(ContentStart, ContentEnd - ContentStart);
  }
  
- TEST_F(FormatTest, PointerAlignmentFallback) {
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt b/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
---- a/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
-+++ b/clang-tools-extra/clangd/refactor/tweaks/CMakeLists.txt
-@@ -14,9 +14,9 @@
- add_clang_library(clangDaemonTweaks OBJECT
-   AddUsing.cpp
-   AnnotateHighlightings.cpp
-+  DumpAST.cpp
-   DefineInline.cpp
-   DefineOutline.cpp
--  DumpAST.cpp
-   ExpandDeducedType.cpp
-   ExpandMacro.cpp
-   ExtractFunction.cpp
-@@ -24,7 +24,6 @@
-   MemberwiseConstructor.cpp
-   ObjCLocalizeStringLiteral.cpp
-   ObjCMemberwiseInitializer.cpp
--  OverridePureVirtuals.cpp
-   PopulateSwitch.cpp
-   RawStringLiteral.cpp
-   RemoveUsingNamespace.cpp
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp b/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
---- a/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
-+++ b/clang-tools-extra/clangd/refactor/tweaks/OverridePureVirtuals.cpp
-@@ -1,374 +0,0 @@
--//===--- OverridePureVirtuals.cpp --------------------------------*- C++-*-===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
--//
--// Tweak to automatically generate stubs for pure virtual methods inherited from
--// base classes.
--//
--// Purpose:
--//   - Simplifies making a derived class concrete by automating the creation of
--//     required method overrides from abstract bases.
--//
--// Tweak Summary:
--//
--// 1. Activation Conditions (prepare):
--//    - The tweak activates when the cursor is over a C++ class definition.
--//    - The class must be abstract (it, or its base classes, have unimplemented
--//      pure virtual functions).
--//    - It must also inherit from at least one other abstract class.
--//
--// 2. Identifying Missing Methods:
--//    - The tweak scans the inheritance hierarchy of the current class.
--//    - It identifies all unique pure virtual methods from base classes
--//      that are not yet implemented or overridden.
--//    - These missing methods are then grouped by their original access
--//      specifier (e.g., public, protected).
--//
--// 3. Code Generation and Insertion:
--//    - For each group of missing methods, stubs are inserted.
--//    - If an access specifier section (like `public:`) exists, stubs are
--//      inserted there; otherwise, a new section is created and appended.
--//    - Each generated stub includes the `override` keyword, a `// TODO:`
--//      comment, and a `static_assert(false, ...)` to force a compile-time
--//      error if the method remains unimplemented.
--//    - The base method's signature is adjusted (e.g., `virtual` and `= 0`
--//      are removed for the override).
--//
--// 4. Code Action Provided:
--//    - A single code action titled "Override pure virtual methods" is offered.
--//    - Applying this action results in a single source file modification
--//      containing all the generated method stubs.
--//
--// Example:
--//
--//  class Base {
--//  public:
--//    virtual void publicMethod() = 0;
--//  protected:
--//    virtual auto privateMethod() const -> int = 0;
--//  };
--//
--// Before:
--//                              // cursor here
--//  class Derived : public Base {}^;
--//
--// After:
--//
--// class Derived : public Base {
--//  public:
--//   void publicMethod() override {
--//     // TODO: Implement this pure virtual method.
--//     static_assert(false, "Method `publicMethod` is not implemented.");
--//   }
--//
--//  protected:
--//   auto privateMethod() const -> int override {
--//     // TODO: Implement this pure virtual method.
--//     static_assert(false, "Method `privateMethod` is not implemented.");
--//   }
--// };
--//
--//===----------------------------------------------------------------------===//
--
--#include "refactor/Tweak.h"
--#include "support/Token.h"
--
--#include "clang/AST/ASTContext.h"
--#include "clang/AST/DeclCXX.h"
--#include "clang/AST/Type.h"
--#include "clang/AST/TypeLoc.h"
--#include "clang/Basic/LLVM.h"
--#include "clang/Basic/SourceLocation.h"
--#include "clang/Tooling/Core/Replacement.h"
--#include "llvm/ADT/DenseSet.h"
--#include "llvm/Support/FormatVariadic.h"
--#include <string>
--
--namespace clang {
--namespace clangd {
--namespace {
--
--// This function removes the "virtual" and the "= 0" at the end;
--// e.g.:
--//   "virtual void foo(int var = 0) = 0"  // input.
--//   "void foo(int var = 0)"              // output.
--std::string removePureVirtualSyntax(const std::string &MethodDecl,
--                                    const LangOptions &LangOpts) {
--  assert(!MethodDecl.empty());
--
--  TokenStream TS = lex(MethodDecl, LangOpts);
--
--  std::string DeclString;
--  for (const clangd::Token &Tk : TS.tokens()) {
--    if (Tk.Kind == clang::tok::raw_identifier && Tk.text() == "virtual")
--      continue;
--
--    // If the ending two tokens are "= 0", we break here and we already have the
--    // method's string without the pure virtual syntax.
--    const auto &Next = Tk.next();
--    if (Next.next().Kind == tok::eof && Tk.Kind == clang::tok::equal &&
--        Next.text() == "0")
--      break;
--
--    DeclString += Tk.text();
--    if (Tk.Kind != tok::l_paren && Next.Kind != tok::comma &&
--        Next.Kind != tok::r_paren && Next.Kind != tok::l_paren)
--      DeclString += ' ';
--  }
--  // Trim the last whitespace.
--  if (DeclString.back() == ' ')
--    DeclString.pop_back();
--
--  return DeclString;
--}
--
--class OverridePureVirtuals final : public Tweak {
--public:
--  const char *id() const final; // defined by REGISTER_TWEAK.
--  bool prepare(const Selection &Sel) override;
--  Expected<Effect> apply(const Selection &Sel) override;
--  std::string title() const override { return "Override pure virtual methods"; }
--  llvm::StringLiteral kind() const override {
--    return CodeAction::QUICKFIX_KIND;
--  }
--
--private:
--  // Stores the CXXRecordDecl of the class being modified.
--  const CXXRecordDecl *CurrentDeclDef = nullptr;
--  // Stores pure virtual methods that need overriding, grouped by their original
--  // access specifier.
--  llvm::MapVector<AccessSpecifier, llvm::SmallVector<const CXXMethodDecl *>>
--      MissingMethodsByAccess;
--  // Stores the source locations of existing access specifiers in CurrentDecl.
--  llvm::MapVector<AccessSpecifier, SourceLocation> AccessSpecifierLocations;
--  // Helper function to gather information before applying the tweak.
--  void collectMissingPureVirtuals();
--};
--
--REGISTER_TWEAK(OverridePureVirtuals)
--
--// Function to get all unique pure virtual methods from the entire
--// base class hierarchy of CurrentDeclDef.
--llvm::SmallVector<const clang::CXXMethodDecl *>
--getAllUniquePureVirtualsFromBaseHierarchy(
--    const clang::CXXRecordDecl *CurrentDeclDef) {
--  llvm::SmallVector<const clang::CXXMethodDecl *> AllPureVirtualsInHierarchy;
--  llvm::DenseSet<const clang::CXXMethodDecl *> CanonicalPureVirtualsSeen;
--
--  if (!CurrentDeclDef || !CurrentDeclDef->getDefinition())
--    return AllPureVirtualsInHierarchy;
--
--  const clang::CXXRecordDecl *Def = CurrentDeclDef->getDefinition();
--
--  Def->forallBases([&](const clang::CXXRecordDecl *BaseDefinition) {
--    for (const clang::CXXMethodDecl *Method : BaseDefinition->methods()) {
--      if (Method->isPureVirtual() &&
--          CanonicalPureVirtualsSeen.insert(Method->getCanonicalDecl()).second)
--        AllPureVirtualsInHierarchy.emplace_back(Method);
--    }
--    // Continue iterating through all bases.
--    return true;
--  });
+ inline MutableArrayRef<char> MCFragment::getVarContents() {
+diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCObjectStreamer.cpp b/llvm/lib/MC/MCObjectStreamer.cpp
+--- a/llvm/lib/MC/MCObjectStreamer.cpp
++++ b/llvm/lib/MC/MCObjectStreamer.cpp
+@@ -46,83 +46,27 @@
+   return nullptr;
+ }
+ 
+-constexpr size_t FragBlockSize = 16384;
+-// Ensure the new fragment can at least store a few bytes.
+-constexpr size_t NewFragHeadroom = 8;
 -
--  return AllPureVirtualsInHierarchy;
--}
+-static_assert(NewFragHeadroom >= alignof(MCFragment));
+-static_assert(FragBlockSize >= sizeof(MCFragment) + NewFragHeadroom);
 -
--// Gets canonical declarations of methods already overridden or implemented in
--// class D.
--llvm::SetVector<const CXXMethodDecl *>
--getImplementedOrOverriddenCanonicals(const CXXRecordDecl *D) {
--  llvm::SetVector<const CXXMethodDecl *> ImplementedSet;
--  for (const CXXMethodDecl *M : D->methods()) {
--    // If M provides an implementation for any virtual method it overrides.
--    // A method is an "implementation" if it's virtual and not pure.
--    // Or if it directly overrides a base method.
--    for (const CXXMethodDecl *OverriddenM : M->overridden_methods())
--      ImplementedSet.insert(OverriddenM->getCanonicalDecl());
--  }
--  return ImplementedSet;
+-MCFragment *MCObjectStreamer::allocFragSpace(size_t Headroom) {
+-  auto Size = std::max(FragBlockSize, sizeof(MCFragment) + Headroom);
+-  FragSpace = Size - sizeof(MCFragment);
+-  auto Chunk = std::unique_ptr<char[]>(new char[Size]);
+-  auto *F = reinterpret_cast<MCFragment *>(Chunk.get());
+-  FragStorage.push_back(std::move(Chunk));
+-  return F;
 -}
 -
--// Get the location of every colon of the `AccessSpecifier`.
--llvm::MapVector<AccessSpecifier, SourceLocation>
--getSpecifierLocations(const CXXRecordDecl *D) {
--  llvm::MapVector<AccessSpecifier, SourceLocation> Locs;
--  for (auto *DeclNode : D->decls()) {
--    if (const auto *ASD = llvm::dyn_cast<AccessSpecDecl>(DeclNode))
--      Locs[ASD->getAccess()] = ASD->getColonLoc();
+ void MCObjectStreamer::newFragment() {
+-  MCFragment *F;
+-  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
+-    auto End = reinterpret_cast<size_t>(getCurFragEnd());
+-    F = reinterpret_cast<MCFragment *>(
+-        alignToPowerOf2(End, alignof(MCFragment)));
+-    FragSpace -= size_t(F) - End + sizeof(MCFragment);
+-  } else {
+-    F = allocFragSpace(0);
 -  }
--  return Locs;
+-  new (F) MCFragment();
+-  addFragment(F);
 -}
 -
--bool hasAbstractBaseAncestor(const clang::CXXRecordDecl *CurrentDecl) {
--  assert(CurrentDecl && CurrentDecl->getDefinition());
--
--  return llvm::any_of(
--      CurrentDecl->getDefinition()->bases(), [](CXXBaseSpecifier BaseSpec) {
--        const auto *D = BaseSpec.getType()->getAsCXXRecordDecl();
--        const auto *Def = D ? D->getDefinition() : nullptr;
--        return Def && Def->isAbstract();
--      });
--}
--
--// The tweak is available if the selection is over an abstract C++ class
--// definition that also inherits from at least one other abstract class.
--bool OverridePureVirtuals::prepare(const Selection &Sel) {
--  const SelectionTree::Node *Node = Sel.ASTSelection.commonAncestor();
--  if (!Node)
--    return false;
--
--  // Make sure we have a definition.
--  CurrentDeclDef = Node->ASTNode.get<CXXRecordDecl>();
--  if (!CurrentDeclDef || !CurrentDeclDef->getDefinition())
--    return false;
--
--  // From now on, we should work with the definition.
--  CurrentDeclDef = CurrentDeclDef->getDefinition();
--
--  // Only offer for abstract classes with abstract bases.
--  return CurrentDeclDef->isAbstract() &&
--         hasAbstractBaseAncestor(CurrentDeclDef);
--}
--
--// Collects all pure virtual methods from base classes that `CurrentDeclDef` has
--// not yet overridden, grouped by their original access specifier.
--//
--// Results are stored in `MissingMethodsByAccess` and `AccessSpecifierLocations`
--// is also populated.
--void OverridePureVirtuals::collectMissingPureVirtuals() {
--  if (!CurrentDeclDef)
+-void MCObjectStreamer::ensureHeadroom(size_t Headroom) {
+-  if (Headroom <= FragSpace)
 -    return;
--
--  AccessSpecifierLocations = getSpecifierLocations(CurrentDeclDef);
--  MissingMethodsByAccess.clear();
--
--  // Get all unique pure virtual methods from the entire base class hierarchy.
--  llvm::SmallVector<const CXXMethodDecl *> AllPureVirtualsInHierarchy =
--      getAllUniquePureVirtualsFromBaseHierarchy(CurrentDeclDef);
--
--  // Get methods already implemented or overridden in CurrentDecl.
--  const auto ImplementedOrOverriddenSet =
--      getImplementedOrOverriddenCanonicals(CurrentDeclDef);
--
--  // Filter AllPureVirtualsInHierarchy to find those not in
--  // ImplementedOrOverriddenSet, which needs to be overriden.
--  for (const CXXMethodDecl *BaseMethod : AllPureVirtualsInHierarchy) {
--    bool AlreadyHandled = ImplementedOrOverriddenSet.contains(BaseMethod);
--    if (!AlreadyHandled)
--      MissingMethodsByAccess[BaseMethod->getAccess()].emplace_back(BaseMethod);
--  }
--}
--
--std::string generateOverrideString(const CXXMethodDecl *Method,
--                                   const LangOptions &LangOpts) {
--  std::string MethodDecl;
--  auto OS = llvm::raw_string_ostream(MethodDecl);
--  Method->print(OS);
--
--  return llvm::formatv(
--             "\n  {0} override {{\n"
--             "    // TODO: Implement this pure virtual method.\n"
--             "    static_assert(false, \"Method `{1}` is not implemented.\");\n"
--             "  }",
--             removePureVirtualSyntax(MethodDecl, LangOpts), Method->getName())
--      .str();
--}
--
--// Free function to generate the string for a group of method overrides.
--std::string generateOverridesStringForGroup(
--    llvm::SmallVector<const CXXMethodDecl *> Methods,
--    const LangOptions &LangOpts) {
--  llvm::SmallVector<std::string> MethodsString;
--  MethodsString.reserve(Methods.size());
--
--  for (const CXXMethodDecl *Method : Methods) {
--    MethodsString.emplace_back(generateOverrideString(Method, LangOpts));
--  }
--
--  return llvm::join(MethodsString, "\n") + '\n';
--}
--
--Expected<Tweak::Effect> OverridePureVirtuals::apply(const Selection &Sel) {
--  // The correctness of this tweak heavily relies on the accurate population of
--  // these members.
--  collectMissingPureVirtuals();
--  // The `prepare` should prevent this. If the prepare identifies an abstract
--  // method, then is must have missing methods.
--  assert(!MissingMethodsByAccess.empty());
--
--  const auto &SM = Sel.AST->getSourceManager();
--  const auto &LangOpts = Sel.AST->getLangOpts();
--
--  tooling::Replacements EditReplacements;
--  // Stores text for new access specifier sections that are not already present
--  // in the class.
--  // Example:
--  //  public:    // ...
--  //  protected: // ...
--  std::string NewSectionsToAppendText;
--
--  for (const auto &[AS, Methods] : MissingMethodsByAccess) {
--    assert(!Methods.empty());
--
--    std::string MethodsGroupString =
--        generateOverridesStringForGroup(Methods, LangOpts);
--
--    auto *ExistingSpecLocIter = AccessSpecifierLocations.find(AS);
--    bool ASExists = ExistingSpecLocIter != AccessSpecifierLocations.end();
--    if (ASExists) {
--      // Access specifier section already exists in the class.
--      // Get location immediately *after* the colon.
--      SourceLocation InsertLoc =
--          ExistingSpecLocIter->second.getLocWithOffset(1);
--
--      // Create a replacement to insert the method declarations.
--      // The replacement is at InsertLoc, has length 0 (insertion), and uses
--      // InsertionText.
--      std::string InsertionText = MethodsGroupString;
--      tooling::Replacement Rep(SM, InsertLoc, 0, InsertionText);
--      if (auto Err = EditReplacements.add(Rep))
--        return llvm::Expected<Tweak::Effect>(std::move(Err));
--    } else {
--      // Access specifier section does not exist in the class.
--      // These methods will be grouped into NewSectionsToAppendText and added
--      // towards the end of the class definition.
--      NewSectionsToAppendText +=
--          getAccessSpelling(AS).str() + ':' + MethodsGroupString;
--    }
--  }
--
--  // After processing all access specifiers, add any newly created sections
--  // (stored in NewSectionsToAppendText) to the end of the class.
--  if (!NewSectionsToAppendText.empty()) {
--    // AppendLoc is the SourceLocation of the closing brace '}' of the class.
--    // The replacement will insert text *before* this closing brace.
--    SourceLocation AppendLoc = CurrentDeclDef->getBraceRange().getEnd();
--    std::string FinalAppendText = std::move(NewSectionsToAppendText);
--
--    if (!CurrentDeclDef->decls_empty() || !EditReplacements.empty()) {
--      FinalAppendText = '\n' + FinalAppendText;
--    }
--
--    // Create a replacement to append the new sections.
--    tooling::Replacement Rep(SM, AppendLoc, 0, FinalAppendText);
--    if (auto Err = EditReplacements.add(Rep))
--      return llvm::Expected<Tweak::Effect>(std::move(Err));
--  }
--
--  if (EditReplacements.empty()) {
--    return llvm::make_error<llvm::StringError>(
--        "No changes to apply (internal error or no methods generated).",
--        llvm::inconvertibleErrorCode());
--  }
--
--  // Return the collected replacements as the effect of this tweak.
--  return Effect::mainFileEdit(SM, EditReplacements);
--}
--
--} // namespace
--} // namespace clangd
--} // namespace clang
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/unittests/CMakeLists.txt b/clang-tools-extra/clangd/unittests/CMakeLists.txt
---- a/clang-tools-extra/clangd/unittests/CMakeLists.txt
-+++ b/clang-tools-extra/clangd/unittests/CMakeLists.txt
-@@ -131,7 +131,6 @@
-   tweaks/MemberwiseConstructorTests.cpp
-   tweaks/ObjCLocalizeStringLiteralTests.cpp
-   tweaks/ObjCMemberwiseInitializerTests.cpp
--  tweaks/OverridePureVirtualsTests.cpp
-   tweaks/PopulateSwitchTests.cpp
-   tweaks/RawStringLiteralTests.cpp
-   tweaks/RemoveUsingNamespaceTests.cpp
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp b/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
---- a/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
-+++ b/clang-tools-extra/clangd/unittests/tweaks/OverridePureVirtualsTests.cpp
-@@ -1,720 +0,0 @@
--//===-- OverridePureVirtualsTests.cpp ---------------------------*- C++ -*-===//
--//
--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
--// See https://llvm.org/LICENSE.txt for license information.
--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--//
--//===----------------------------------------------------------------------===//
--
--#include "TweakTesting.h"
--#include "gtest/gtest.h"
--
--namespace clang {
--namespace clangd {
--namespace {
--
--class OverridePureVirtualsTests : public TweakTest {
--protected:
--  OverridePureVirtualsTests() : TweakTest("OverridePureVirtuals") {}
--};
--
--TEST_F(OverridePureVirtualsTests, MinimalUnavailable) {
--  EXPECT_UNAVAILABLE("class ^C {};");
--}
--
--TEST_F(OverridePureVirtualsTests, MinimalAvailable) {
--  EXPECT_AVAILABLE(R"cpp(
--class B { public: virtual void Foo() = 0; };
--class ^C : public B {};
--)cpp");
--}
--
--TEST_F(OverridePureVirtualsTests, UnavailableWhenOverriden) {
--  EXPECT_UNAVAILABLE(
--      R"cpp(
--class B {
--public:
--  virtual void foo() = 0;
--};
--
--class ^D : public B {
--public:
--  void foo() override;
--};
--)cpp");
--}
--
--TEST_F(OverridePureVirtualsTests, AvailabilityNoOverride) {
--  EXPECT_AVAILABLE(R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2() = 0;
--};
--
--class ^Derived : public Base {
--public:
--};
--
--)cpp");
--}
--
--TEST_F(OverridePureVirtualsTests, AvailabilityPartiallyOverridden) {
--  EXPECT_AVAILABLE(R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2() = 0;
--};
--
--class ^Derived : public Base {
--public:
--void F1() override;
--};
--)cpp");
--}
--
--TEST_F(OverridePureVirtualsTests, EmptyDerivedClass) {
--  const char *Before = R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2(int P1, const int &P2) = 0;
--};
--
--class ^Derived : public Base {};
--)cpp";
--  const auto *Expected = R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2(int P1, const int &P2) = 0;
--};
--
--class Derived : public Base {
--public:
--  void F1() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `F1` is not implemented.");
--  }
--
--  void F2(int P1, const int & P2) override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `F2` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, SingleBaseClassPartiallyImplemented) {
--  auto Applied = apply(
--      R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2() = 0;
--};
--
--class ^Derived : public Base {
--public:
--  void F1() override;
--};
--)cpp");
--
--  const auto *Expected = R"cpp(
--class Base {
--public:
--virtual ~Base() = default;
--virtual void F1() = 0;
--virtual void F2() = 0;
--};
--
--class Derived : public Base {
--public:
--  void F2() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `F2` is not implemented.");
--  }
--
--  void F1() override;
--};
--)cpp";
--  EXPECT_EQ(Applied, Expected) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, MultipleDirectBaseClasses) {
--  const char *Before = R"cpp(
--class Base1 {
--public:
--  virtual void func1() = 0;
--};
--class Base2 {
--protected:
--  virtual bool func2(char c) const = 0;
--};
--
--class ^Derived : public Base1, public Base2 {};
--)cpp";
--  const auto *Expected = R"cpp(
--class Base1 {
--public:
--  virtual void func1() = 0;
--};
--class Base2 {
--protected:
--  virtual bool func2(char c) const = 0;
--};
--
--class Derived : public Base1, public Base2 {
--public:
--  void func1() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `func1` is not implemented.");
--  }
--protected:
--  bool func2(char c) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `func2` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, UnnamedParametersInBase) {
--  const char *Before = R"cpp(
--struct S {};
--class Base {
--public:
--  virtual void func(int, const S&, char*) = 0;
--};
--
--class ^Derived : public Base {};
--)cpp";
--
--  const auto *Expected = R"cpp(
--struct S {};
--class Base {
--public:
--  virtual void func(int, const S&, char*) = 0;
--};
--
--class Derived : public Base {
--public:
--  void func(int, const S &, char *) override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `func` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, DiamondInheritance) {
--  const char *Before = R"cpp(
--class Top {
--public:
--  virtual ~Top() = default;
--  virtual void diamond_func() = 0;
--};
--class Left : virtual public Top {};
--class Right : virtual public Top {};
--class ^Bottom : public Left, public Right {};
--)cpp";
--  const auto *Expected = R"cpp(
--class Top {
--public:
--  virtual ~Top() = default;
--  virtual void diamond_func() = 0;
--};
--class Left : virtual public Top {};
--class Right : virtual public Top {};
--class Bottom : public Left, public Right {
--public:
--  void diamond_func() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `diamond_func` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, MixedAccessSpecifiers) {
--  const char *Before = R"cpp(
--class Base {
--public:
--  virtual void pub_func() = 0;
--  virtual void pub_func2(char) const = 0;
--protected:
--  virtual int prot_func(int x) const = 0;
--};
--
--class ^Derived : public Base {
--  int member; // Existing member
--public:
--  Derived(int m) : member(m) {}
--};
--)cpp";
--  const auto *Expected = R"cpp(
--class Base {
--public:
--  virtual void pub_func() = 0;
--  virtual void pub_func2(char) const = 0;
--protected:
--  virtual int prot_func(int x) const = 0;
--};
--
--class Derived : public Base {
--  int member; // Existing member
--public:
--  void pub_func() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `pub_func` is not implemented.");
--  }
--
--  void pub_func2(char) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `pub_func2` is not implemented.");
--  }
--
--  Derived(int m) : member(m) {}
--
--protected:
--  int prot_func(int x) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `prot_func` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, OutOfOrderMixedAccessSpecifiers) {
--  const char *Before = R"cpp(
--class Base {
--public:
--  virtual void pub_func() = 0;
--  virtual void pub_func2(char) const = 0;
--protected:
--  virtual int prot_func(int x) const = 0;
--};
--
--class ^Derived : public Base {
--  int member; // Existing member
--protected:
--  void foo();
--public:
--  Derived(int m) : member(m) {}
--};
--)cpp";
--  const auto *Expected = R"cpp(
--class Base {
--public:
--  virtual void pub_func() = 0;
--  virtual void pub_func2(char) const = 0;
--protected:
--  virtual int prot_func(int x) const = 0;
--};
--
--class Derived : public Base {
--  int member; // Existing member
--protected:
--  int prot_func(int x) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `prot_func` is not implemented.");
--  }
--
--  void foo();
--public:
--  void pub_func() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `pub_func` is not implemented.");
--  }
--
--  void pub_func2(char) const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `pub_func2` is not implemented.");
--  }
--
--  Derived(int m) : member(m) {}
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, MultiAccessSpecifiersOverride) {
--  constexpr auto Before = R"cpp(
--class Base {
--public:
--  virtual void foo() = 0;
--protected:
--  virtual void bar() = 0;
--};
--
--class ^Derived : public Base {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class Base {
--public:
--  virtual void foo() = 0;
--protected:
--  virtual void bar() = 0;
--};
--
--class Derived : public Base {
--public:
--  void foo() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `foo` is not implemented.");
--  }
--protected:
--  void bar() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `bar` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, AccessSpecifierAlreadyExisting) {
--  const char *Before = R"cpp(
--class Base {
--public:
--  virtual void func1() = 0;
--};
--
--class ^Derived : public Base {
--public:
--};
--)cpp";
--
--  const auto *Expected = R"cpp(
--class Base {
--public:
--  virtual void func1() = 0;
--};
--
--class Derived : public Base {
--public:
--  void func1() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `func1` is not implemented.");
--  }
--
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, ConstexprSpecifier) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  constexpr virtual int getValue() const = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  constexpr virtual int getValue() const = 0;
--};
--
--class D : public B {
--public:
--  constexpr int getValue() const override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `getValue` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, ConstevalSpecifier) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual consteval float calculate() = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual consteval float calculate() = 0;
--};
--
--class D : public B {
--public:
--  consteval float calculate() override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `calculate` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, LValueRefQualifier) {
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual void process() & = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual void process() & = 0;
--};
--
--class D : public B {
--public:
--  void process() & override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `process` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, RValueRefQualifier) {
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual bool isValid() && = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual bool isValid() && = 0;
--};
--
--class D : public B {
--public:
--  bool isValid() && override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `isValid` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, SimpleTrailingReturnType) {
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual auto getStatus() -> bool = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual auto getStatus() -> bool = 0;
--};
--
--class D : public B {
--public:
--  auto getStatus() -> bool override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `getStatus` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, ConstexprLValueRefAndTrailingReturn) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  constexpr virtual auto getData() & -> const char * = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  constexpr virtual auto getData() & -> const char * = 0;
--};
--
--class D : public B {
--public:
--  constexpr auto getData() & -> const char * override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `getData` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, ConstevalRValueRefAndTrailingReturn) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual consteval auto foo() && -> double = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual consteval auto foo() && -> double = 0;
--};
--
--class D : public B {
--public:
--  consteval auto foo() && -> double override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `foo` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, CombinedFeaturesWithTrailingReturnTypes) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual auto f1() & -> int = 0;
--  constexpr virtual auto f2() && -> int = 0;
--  virtual consteval auto f3() -> int = 0;
--  virtual auto f4() const & -> char = 0;
--  constexpr virtual auto f5() const && -> bool = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual auto f1() & -> int = 0;
--  constexpr virtual auto f2() && -> int = 0;
--  virtual consteval auto f3() -> int = 0;
--  virtual auto f4() const & -> char = 0;
--  constexpr virtual auto f5() const && -> bool = 0;
--};
--
--class D : public B {
--public:
--  auto f1() & -> int override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f1` is not implemented.");
--  }
--
--  constexpr auto f2() && -> int override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f2` is not implemented.");
--  }
--
--  consteval auto f3() -> int override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f3` is not implemented.");
--  }
--
--  auto f4() const & -> char override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f4` is not implemented.");
--  }
--
--  constexpr auto f5() const && -> bool override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `f5` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--TEST_F(OverridePureVirtualsTests, DefaultParameters) {
--  ExtraArgs.push_back("-std=c++20");
--
--  constexpr auto Before = R"cpp(
--class B {
--public:
--  virtual void foo(int var = 0) = 0;
--};
--
--class ^D : public B {};
--)cpp";
--
--  constexpr auto Expected = R"cpp(
--class B {
--public:
--  virtual void foo(int var = 0) = 0;
--};
--
--class D : public B {
--public:
--  void foo(int var = 0) override {
--    // TODO: Implement this pure virtual method.
--    static_assert(false, "Method `foo` is not implemented.");
--  }
--};
--)cpp";
--  auto Applied = apply(Before);
--  EXPECT_EQ(Expected, Applied) << "Applied result:\n" << Applied;
--}
--
--} // namespace
--} // namespace clangd
--} // namespace clang
-diff -ruN --strip-trailing-cr a/libc/src/__support/FPUtil/bfloat16.h b/libc/src/__support/FPUtil/bfloat16.h
---- a/libc/src/__support/FPUtil/bfloat16.h
-+++ b/libc/src/__support/FPUtil/bfloat16.h
-@@ -12,6 +12,7 @@
- #include "src/__support/CPP/bit.h"
- #include "src/__support/CPP/type_traits.h"
- #include "src/__support/FPUtil/cast.h"
-+#include "src/__support/FPUtil/comparison_operations.h"
- #include "src/__support/FPUtil/dyadic_float.h"
- #include "src/__support/macros/config.h"
- #include "src/__support/macros/properties/types.h"
-@@ -57,6 +58,30 @@
-     uint32_t x_bits = static_cast<uint32_t>(bits) << 16U;
-     return cpp::bit_cast<float>(x_bits);
-   }
-+
-+  LIBC_INLINE constexpr bool operator==(BFloat16 other) const {
-+    return fputil::equals(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator!=(BFloat16 other) const {
-+    return !fputil::equals(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator<(BFloat16 other) const {
-+    return fputil::less_than(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator<=(BFloat16 other) const {
-+    return fputil::less_than_or_equals(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator>(BFloat16 other) const {
-+    return fputil::greater_than(*this, other);
-+  }
-+
-+  LIBC_INLINE constexpr bool operator>=(BFloat16 other) const {
-+    return fputil::greater_than_or_equals(*this, other);
-+  }
- }; // struct BFloat16
- 
- } // namespace fputil
-diff -ruN --strip-trailing-cr a/libc/src/__support/FPUtil/CMakeLists.txt b/libc/src/__support/FPUtil/CMakeLists.txt
---- a/libc/src/__support/FPUtil/CMakeLists.txt
-+++ b/libc/src/__support/FPUtil/CMakeLists.txt
-@@ -274,6 +274,7 @@
-     bfloat16.h
-   DEPENDS
-     .cast
-+    .comparison_operations
-     .dyadic_float
-     libc.src.__support.CPP.bit
-     libc.src.__support.CPP.type_traits
-diff -ruN --strip-trailing-cr a/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp b/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
---- a/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
-+++ b/lldb/source/Plugins/ObjectFile/Minidump/MinidumpFileBuilder.cpp
-@@ -201,7 +201,7 @@
-     return error;
-   };
- 
--  llvm::minidump::SystemInfo sys_info;
-+  llvm::minidump::SystemInfo sys_info{};
-   sys_info.ProcessorArch =
-       static_cast<llvm::support::little_t<ProcessorArchitecture>>(arch);
-   // Global offset to beginning of a csd_string in a data section
-@@ -378,7 +378,7 @@
-     helper_data.AppendData(&signature, sizeof(llvm::support::ulittle32_t));
-     helper_data.AppendData(uuid.begin(), uuid.size());
- 
--    llvm::minidump::Module m;
-+    llvm::minidump::Module m{};
-     m.BaseOfImage = static_cast<llvm::support::ulittle64_t>(
-         mod->GetObjectFile()->GetBaseAddress().GetLoadAddress(&target));
-     m.SizeOfImage = static_cast<llvm::support::ulittle32_t>(mod_size);
-@@ -745,7 +745,7 @@
-   if (error.Fail())
-     return error;
- 
--  lldb_private::minidump::MinidumpMiscInfo misc_info;
-+  lldb_private::minidump::MinidumpMiscInfo misc_info{};
-   misc_info.size = static_cast<llvm::support::ulittle32_t>(
-       sizeof(lldb_private::minidump::MinidumpMiscInfo));
-   // Default set flags1 to 0, in case that we will not be able to
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/pr126337.ll b/llvm/test/CodeGen/NVPTX/pr126337.ll
---- a/llvm/test/CodeGen/NVPTX/pr126337.ll
-+++ b/llvm/test/CodeGen/NVPTX/pr126337.ll
-@@ -1,6 +1,6 @@
- ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
- ; RUN: llc < %s -mtriple=nvptx64 -mcpu=sm_70 | FileCheck %s
--; RUN: %if ptxas %{ llc < %s -mtriple=nvptx64 -mcpu=sm_70 | %ptxas-verify %}
-+; RUN: %if ptxas %{ llc < %s -mtriple=nvptx64 -mcpu=sm_70 | %ptxas -arch=sm_70 -c - %}
- 
- ; This IR should compile without triggering assertions in LICM
- ; when the CopyToReg from %0 in the first BB gets eliminated
-diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
---- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
-+++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
-@@ -1002,6 +1002,19 @@
- )
- 
- libc_support_library(
-+    name = "__support_fputil_comparison_operations",
-+    hdrs = [
-+        "src/__support/FPUtil/comparison_operations.h",
-+    ],
-+    deps = [
-+        ":__support_cpp_type_traits",
-+        ":__support_fputil_fenv_impl",
-+        ":__support_fputil_fp_bits",
-+        ":__support_macros_config",
-+    ],
-+)
-+
-+libc_support_library(
-     name = "__support_file_file",
-     srcs = [
-         "include/llvm-libc-types/off_t.h",
-@@ -1085,6 +1098,7 @@
-         ":__support_cpp_bit",
-         ":__support_cpp_type_traits",
-         ":__support_fputil_cast",
-+        ":__support_fputil_comparison_operations",
-         ":__support_fputil_dyadic_float",
-         ":__support_macros_config",
-         ":__support_macros_properties_types",
-@@ -1159,6 +1173,7 @@
-     name = "__support_fputil_rounding_mode",
-     hdrs = ["src/__support/FPUtil/rounding_mode.h"],
-     deps = [
-+        ":__support_cpp_type_traits",
-         ":__support_macros_attributes",
-         ":__support_macros_config",
-         ":hdr_fenv_macros",
-@@ -1919,8 +1934,8 @@
-     srcs = ["src/math/generic/common_constants.cpp"],
-     hdrs = ["src/math/generic/common_constants.h"],
-     deps = [
--        ":__support_math_exp_constants",
-         ":__support_math_acosh_float_constants",
-+        ":__support_math_exp_constants",
-         ":__support_number_pair",
-     ],
- )
-@@ -2003,10 +2018,10 @@
-         ":__support_fputil_fma",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_nearest_integer",
--        ":__support_math_exp_utils",
--        ":__support_math_exp10f_utils",
--        ":__support_math_acoshf_utils",
-         ":__support_macros_properties_cpu_features",
-+        ":__support_math_acoshf_utils",
-+        ":__support_math_exp10f_utils",
-+        ":__support_math_exp_utils",
-         ":common_constants",
-     ],
- )
-@@ -2058,8 +2073,8 @@
-         ":__support_fputil_cast",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_nearest_integer",
--        ":__support_math_expf16_utils",
-         ":__support_math_exp10_float16_constants",
-+        ":__support_math_expf16_utils",
-     ],
- )
- 
-@@ -2067,7 +2082,6 @@
-     name = "__support_math_acos",
-     hdrs = ["src/__support/math/acos.h"],
-     deps = [
--        ":__support_math_asin_utils",
-         ":__support_fputil_double_double",
-         ":__support_fputil_dyadic_float",
-         ":__support_fputil_fenv_impl",
-@@ -2076,8 +2090,9 @@
-         ":__support_fputil_polyeval",
-         ":__support_fputil_sqrt",
-         ":__support_macros_optimization",
--        ":__support_macros_properties_types",
-         ":__support_macros_properties_cpu_features",
-+        ":__support_macros_properties_types",
-+        ":__support_math_asin_utils",
-     ],
- )
- 
-@@ -2085,13 +2100,13 @@
-     name = "__support_math_acosf",
-     hdrs = ["src/__support/math/acosf.h"],
-     deps = [
--        ":__support_math_inv_trigf_utils",
-         ":__support_fputil_except_value_utils",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_polyeval",
-         ":__support_fputil_sqrt",
-         ":__support_macros_optimization",
-+        ":__support_math_inv_trigf_utils",
-     ],
- )
- 
-@@ -2100,6 +2115,7 @@
-     hdrs = ["src/__support/math/acosf16.h"],
-     deps = [
-         ":__support_fputil_cast",
-+        ":__support_fputil_except_value_utils",
-         ":__support_fputil_fma",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_nearest_integer",
-@@ -2121,10 +2137,10 @@
-     name = "__support_math_acoshf_utils",
-     hdrs = ["src/__support/math/acoshf_utils.h"],
-     deps = [
--        ":__support_math_acosh_float_constants",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_polyeval",
-+        ":__support_math_acosh_float_constants",
-     ],
- )
- 
-@@ -2132,12 +2148,12 @@
-     name = "__support_math_acoshf",
-     hdrs = ["src/__support/math/acoshf.h"],
-     deps = [
--        ":__support_math_acoshf_utils",
-         ":__support_fputil_fenv_impl",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_sqrt",
-         ":__support_macros_optimization",
-+        ":__support_math_acoshf_utils",
-     ],
- )
- 
-@@ -2145,7 +2161,6 @@
-     name = "__support_math_acoshf16",
-     hdrs = ["src/__support/math/acoshf16.h"],
-     deps = [
--        ":__support_math_acoshf_utils",
-         ":__support_fputil_cast",
-         ":__support_fputil_except_value_utils",
-         ":__support_fputil_fenv_impl",
-@@ -2154,6 +2169,7 @@
-         ":__support_fputil_polyeval",
-         ":__support_fputil_sqrt",
-         ":__support_macros_optimization",
-+        ":__support_math_acoshf_utils",
-     ],
- )
- 
-@@ -2161,12 +2177,12 @@
-     name = "__support_math_asin_utils",
-     hdrs = ["src/__support/math/asin_utils.h"],
-     deps = [
--        ":__support_integer_literals",
-         ":__support_fputil_double_double",
-         ":__support_fputil_dyadic_float",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_nearest_integer",
-         ":__support_fputil_polyeval",
-+        ":__support_integer_literals",
-         ":__support_macros_optimization",
-     ],
- )
-@@ -2175,6 +2191,8 @@
-     name = "__support_math_erff",
-     hdrs = ["src/__support/math/erff.h"],
-     deps = [
-+        ":__support_fputil_except_value_utils",
-+        ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_polyeval",
-         ":__support_macros_optimization",
-@@ -2215,7 +2233,7 @@
-         ":__support_fputil_nearest_integer",
-         ":__support_fputil_polyeval",
-         ":__support_macros_attributes",
--        ":llvm_libc_macros_float16_macros"
-+        ":llvm_libc_macros_float16_macros",
-     ],
- )
+-  auto *F = allocFragSpace(Headroom);
+-  new (F) MCFragment();
+-  addFragment(F);
++  addFragment(getContext().allocFragment<MCFragment>());
+ }
  
-@@ -2224,7 +2242,6 @@
-     hdrs = ["src/__support/math/expf16.h"],
-     deps = [
-         ":__support_common",
--        ":__support_libc_errno",
-         ":__support_cpp_array",
-         ":__support_fputil_cast",
-         ":__support_fputil_except_value_utils",
-@@ -2234,9 +2251,10 @@
-         ":__support_fputil_nearest_integer",
-         ":__support_fputil_polyeval",
-         ":__support_fputil_rounding_mode",
-+        ":__support_libc_errno",
-         ":__support_macros_optimization",
-         ":__support_math_expf16_utils",
--        ":llvm_libc_macros_float16_macros"
-+        ":llvm_libc_macros_float16_macros",
-     ],
- )
+-void MCObjectStreamer::insert(MCFragment *Frag) {
+-  assert(Frag->getKind() != MCFragment::FT_Data &&
++void MCObjectStreamer::insert(MCFragment *F) {
++  assert(F->getKind() != MCFragment::FT_Data &&
+          "F should have a variable-size tail");
+-  // Frag is not connected to FragSpace. Before modifying CurFrag with
+-  // addFragment(Frag), allocate an empty fragment to maintain FragSpace
+-  // connectivity, potentially reusing CurFrag's associated space.
+-  MCFragment *F;
+-  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
+-    auto End = reinterpret_cast<size_t>(getCurFragEnd());
+-    F = reinterpret_cast<MCFragment *>(
+-        alignToPowerOf2(End, alignof(MCFragment)));
+-    FragSpace -= size_t(F) - End + sizeof(MCFragment);
+-  } else {
+-    F = allocFragSpace(0);
+-  }
+-  new (F) MCFragment();
+-
+-  addFragment(Frag);
+   addFragment(F);
++  newFragment();
+ }
  
-@@ -2244,8 +2262,8 @@
-     name = "__support_math_frexpf128",
-     hdrs = ["src/__support/math/frexpf128.h"],
-     deps = [
--        ":__support_macros_properties_types",
-         ":__support_fputil_manipulation_functions",
-+        ":__support_macros_properties_types",
-     ],
- )
+ void MCObjectStreamer::appendContents(ArrayRef<char> Contents) {
+-  ensureHeadroom(Contents.size());
+-  assert(FragSpace >= Contents.size());
+-  llvm::copy(Contents, getCurFragEnd());
+-  CurFrag->FixedSize += Contents.size();
+-  FragSpace -= Contents.size();
++  CurFrag->appendContents(Contents);
+ }
  
-@@ -2253,9 +2271,9 @@
-     name = "__support_math_inv_trigf_utils",
-     hdrs = ["src/__support/math/inv_trigf_utils.h"],
-     deps = [
-+        ":__support_common",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_polyeval",
--        ":__support_common",
-     ],
- )
+ void MCObjectStreamer::appendContents(size_t Num, char Elt) {
+-  ensureHeadroom(Num);
+-  MutableArrayRef<char> Data(getCurFragEnd(), Num);
+-  llvm::fill(Data, Elt);
+-  CurFrag->FixedSize += Num;
+-  FragSpace -= Num;
++  CurFrag->appendContents(Num, Elt);
+ }
  
-@@ -2263,10 +2281,10 @@
-     name = "__support_math_frexpf16",
-     hdrs = ["src/__support/math/frexpf16.h"],
-     deps = [
-+        ":__support_fputil_manipulation_functions",
-         ":__support_macros_config",
-         ":__support_macros_properties_types",
--        ":__support_fputil_manipulation_functions",
--        ":llvm_libc_macros_float16_macros"
-+        ":llvm_libc_macros_float16_macros",
-     ],
- )
+ void MCObjectStreamer::addFixup(const MCExpr *Value, MCFixupKind Kind) {
+-  CurFrag->addFixup(MCFixup::create(getCurFragSize(), Value, Kind));
++  CurFrag->addFixup(MCFixup::create(CurFrag->getFixedSize(), Value, Kind));
+ }
  
-@@ -2284,7 +2302,7 @@
-     deps = [
-         ":__support_fputil_manipulation_functions",
-         ":__support_macros_properties_types",
--        ":llvm_libc_types_float128"
-+        ":llvm_libc_types_float128",
-     ],
- )
+ // As a compile-time optimization, avoid allocating and evaluating an MCExpr
+@@ -171,8 +115,6 @@
+   }
+   EmitEHFrame = true;
+   EmitDebugFrame = false;
+-  FragStorage.clear();
+-  FragSpace = 0;
+   MCStreamer::reset();
+ }
  
-@@ -2292,9 +2310,9 @@
-     name = "__support_math_ldexpf16",
-     hdrs = ["src/__support/math/ldexpf16.h"],
-     deps = [
--        ":__support_macros_properties_types",
-         ":__support_fputil_manipulation_functions",
--        ":llvm_libc_macros_float16_macros"
-+        ":__support_macros_properties_types",
-+        ":llvm_libc_macros_float16_macros",
-     ],
- )
+@@ -201,6 +143,7 @@
+ void MCObjectStreamer::emitValueImpl(const MCExpr *Value, unsigned Size,
+                                      SMLoc Loc) {
+   MCStreamer::emitValueImpl(Value, Size, Loc);
++  MCFragment *DF = getCurrentFragment();
  
-@@ -2318,8 +2336,8 @@
-     name = "__support_math_exp_utils",
-     hdrs = ["src/__support/math/exp_utils.h"],
-     deps = [
--        ":__support_cpp_optional",
-         ":__support_cpp_bit",
-+        ":__support_cpp_optional",
-         ":__support_fputil_fp_bits",
-     ],
- )
-@@ -2328,10 +2346,9 @@
-     name = "__support_math_exp",
-     hdrs = ["src/__support/math/exp.h"],
-     deps = [
--        ":__support_math_exp_constants",
--        ":__support_math_exp_utils",
-         ":__support_cpp_bit",
-         ":__support_cpp_optional",
-+        ":__support_fputil_double_double",
-         ":__support_fputil_dyadic_float",
-         ":__support_fputil_fenv_impl",
-         ":__support_fputil_fp_bits",
-@@ -2340,9 +2357,10 @@
-         ":__support_fputil_polyeval",
-         ":__support_fputil_rounding_mode",
-         ":__support_fputil_triple_double",
--        ":__support_fputil_double_double",
-         ":__support_integer_literals",
-         ":__support_macros_optimization",
-+        ":__support_math_exp_constants",
-+        ":__support_math_exp_utils",
-     ],
- )
+   MCDwarfLineEntry::make(this, getCurrentSectionOnly());
  
-@@ -2350,8 +2368,6 @@
-     name = "__support_math_exp10",
-     hdrs = ["src/__support/math/exp10.h"],
-     deps = [
--        ":__support_math_exp_constants",
--        ":__support_math_exp_utils",
-         ":__support_fputil_double_double",
-         ":__support_fputil_dyadic_float",
-         ":__support_fputil_multiply_add",
-@@ -2361,6 +2377,8 @@
-         ":__support_fputil_triple_double",
-         ":__support_integer_literals",
-         ":__support_macros_optimization",
-+        ":__support_math_exp_constants",
-+        ":__support_math_exp_utils",
-     ],
- )
+@@ -215,9 +158,9 @@
+     emitIntValue(AbsValue, Size);
+     return;
+   }
+-  ensureHeadroom(Size);
+-  addFixup(Value, MCFixup::getDataKindForSize(Size));
+-  appendContents(Size, 0);
++  DF->addFixup(MCFixup::create(DF->getContents().size(), Value,
++                               MCFixup::getDataKindForSize(Size)));
++  DF->appendContents(Size, 0);
+ }
  
-@@ -2368,12 +2386,12 @@
-     name = "__support_math_exp10f_utils",
-     hdrs = ["src/__support/math/exp10f_utils.h"],
-     deps = [
-+        ":__support_common",
-         ":__support_fputil_basic_operations",
-         ":__support_fputil_fenv_impl",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_nearest_integer",
-         ":__support_fputil_polyeval",
--        ":__support_common",
-         ":__support_math_exp_utils",
-     ],
- )
-@@ -2382,12 +2400,12 @@
-     name = "__support_math_exp10f",
-     hdrs = ["src/__support/math/exp10f.h"],
-     deps = [
--        ":__support_math_exp10f_utils",
-         ":__support_fputil_fenv_impl",
-         ":__support_fputil_fp_bits",
-         ":__support_fputil_multiply_add",
-         ":__support_fputil_rounding_mode",
-         ":__support_macros_optimization",
-+        ":__support_math_exp10f_utils",
-     ],
- )
+ MCSymbol *MCObjectStreamer::emitCFILabel() {
+@@ -251,7 +194,7 @@
+   // section.
+   MCFragment *F = CurFrag;
+   Symbol->setFragment(F);
+-  Symbol->setOffset(F->getFixedSize());
++  Symbol->setOffset(F->getContents().size());
  
-@@ -2403,9 +2421,9 @@
-     name = "__support_math_exp10f16_utils",
-     hdrs = ["src/__support/math/exp10f16_utils.h"],
-     deps = [
-+        ":__support_fputil_fp_bits",
-         ":__support_math_exp10_float16_constants",
-         ":__support_math_expf16_utils",
--        ":__support_fputil_fp_bits",
-     ],
- )
+   emitPendingAssignments(Symbol);
+ }
+@@ -317,21 +260,6 @@
+     F0 = CurFrag;
+   }
  
-@@ -2413,13 +2431,13 @@
-     name = "__support_math_exp10f16",
-     hdrs = ["src/__support/math/exp10f16.h"],
-     deps = [
--        ":__support_math_exp10f16_utils",
--        ":__support_fputil_fp_bits",
-         ":__support_fputil_cast",
--        ":__support_fputil_rounding_mode",
-         ":__support_fputil_except_value_utils",
-+        ":__support_fputil_fp_bits",
-+        ":__support_fputil_rounding_mode",
-         ":__support_macros_optimization",
-         ":__support_macros_properties_cpu_features",
-+        ":__support_math_exp10f16_utils",
-     ],
- )
+-  // To maintain connectivity between CurFrag and FragSpace when CurFrag is
+-  // modified, allocate an empty fragment and append it to the fragment list.
+-  // (Subsections[I].second.Tail is not connected to FragSpace.)
+-  MCFragment *F;
+-  if (LLVM_LIKELY(sizeof(MCFragment) + NewFragHeadroom <= FragSpace)) {
+-    auto End = reinterpret_cast<size_t>(getCurFragEnd());
+-    F = reinterpret_cast<MCFragment *>(
+-        alignToPowerOf2(End, alignof(MCFragment)));
+-    FragSpace -= size_t(F) - End + sizeof(MCFragment);
+-  } else {
+-    F = allocFragSpace(0);
+-  }
+-  new (F) MCFragment();
+-  F->setParent(Section);
+-
+   auto &Subsections = Section->Subsections;
+   size_t I = 0, E = Subsections.size();
+   while (I != E && Subsections[I].first < Subsection)
+@@ -339,16 +267,13 @@
+   // If the subsection number is not in the sorted Subsections list, create a
+   // new fragment list.
+   if (I == E || Subsections[I].first != Subsection) {
++    auto *F = getContext().allocFragment<MCFragment>();
++    F->setParent(Section);
+     Subsections.insert(Subsections.begin() + I,
+                        {Subsection, MCSection::FragList{F, F}});
+-    Section->CurFragList = &Subsections[I].second;
+-    CurFrag = F;
+-  } else {
+-    Section->CurFragList = &Subsections[I].second;
+-    CurFrag = Subsections[I].second.Tail;
+-    // Ensure CurFrag is associated with FragSpace.
+-    addFragment(F);
+   }
++  Section->CurFragList = &Subsections[I].second;
++  CurFrag = Section->CurFragList->Tail;
+ 
+   // Define the section symbol at subsection 0's initial fragment if required.
+   if (!NewSec)
+@@ -419,15 +344,11 @@
+   MCFragment *F = getCurrentFragment();
+ 
+   // Append the instruction to the data fragment.
+-  size_t CodeOffset = getCurFragSize();
+-  SmallString<16> Content;
++  size_t CodeOffset = F->getContents().size();
+   SmallVector<MCFixup, 1> Fixups;
+-  getAssembler().getEmitter().encodeInstruction(Inst, Content, Fixups, STI);
+-  appendContents(Content);
+-  if (CurFrag != F) {
+-    F = CurFrag;
+-    CodeOffset = 0;
+-  }
++  getAssembler().getEmitter().encodeInstruction(
++      Inst, F->getContentsForAppending(), Fixups, STI);
++  F->doneAppending();
+   F->setHasInstructions(STI);
+ 
+   if (Fixups.empty())
+diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCWin64EH.cpp b/llvm/lib/MC/MCWin64EH.cpp
+--- a/llvm/lib/MC/MCWin64EH.cpp
++++ b/llvm/lib/MC/MCWin64EH.cpp
+@@ -318,9 +318,6 @@
+ 
+   // Emit the epilog instructions.
+   if (EnableUnwindV2) {
+-    // Ensure the fixups and appended content apply to the same fragment.
+-    OS->ensureHeadroom(info->EpilogMap.size() * 2);
+-
+     bool IsLast = true;
+     for (const auto &Epilog : llvm::reverse(info->EpilogMap)) {
+       if (IsLast) {
+diff -ruN --strip-trailing-cr a/llvm/lib/MC/MCWinCOFFStreamer.cpp b/llvm/lib/MC/MCWinCOFFStreamer.cpp
+--- a/llvm/lib/MC/MCWinCOFFStreamer.cpp
++++ b/llvm/lib/MC/MCWinCOFFStreamer.cpp
+@@ -280,7 +280,6 @@
+ void MCWinCOFFStreamer::emitCOFFSectionIndex(const MCSymbol *Symbol) {
+   visitUsedSymbol(*Symbol);
+   const MCSymbolRefExpr *SRE = MCSymbolRefExpr::create(Symbol, getContext());
+-  ensureHeadroom(2);
+   addFixup(SRE, FK_SecRel_2);
+   appendContents(2, 0);
+ }
+@@ -294,7 +293,6 @@
+   if (Offset)
+     MCE = MCBinaryExpr::createAdd(
+         MCE, MCConstantExpr::create(Offset, getContext()), getContext());
+-  ensureHeadroom(4);
+   addFixup(MCE, FK_SecRel_4);
+   // Emit 4 bytes (zeros) to the object file.
+   appendContents(4, 0);
+@@ -310,7 +308,6 @@
+   if (Offset)
+     MCE = MCBinaryExpr::createAdd(
+         MCE, MCConstantExpr::create(Offset, getContext()), getContext());
+-  ensureHeadroom(4);
+   addFixup(MCE, FK_Data_4);
+   // Emit 4 bytes (zeros) to the object file.
+   appendContents(4, 0);
+@@ -321,7 +318,6 @@
+   // Create Symbol for section number.
+   const MCExpr *MCE = MCCOFFSectionNumberTargetExpr::create(
+       *Symbol, this->getWriter(), getContext());
+-  ensureHeadroom(4);
+   addFixup(MCE, FK_Data_4);
+   // Emit 4 bytes (zeros) to the object file.
+   appendContents(4, 0);
+@@ -332,7 +328,6 @@
+   // Create Symbol for section offset.
+   const MCExpr *MCE =
+       MCCOFFSectionOffsetTargetExpr::create(*Symbol, getContext());
+-  ensureHeadroom(4);
+   addFixup(MCE, FK_Data_4);
+   // Emit 4 bytes (zeros) to the object file.
+   appendContents(4, 0);
+diff -ruN --strip-trailing-cr a/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp b/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
+--- a/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
++++ b/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
+@@ -1034,14 +1034,12 @@
+ 
+ void MipsTargetELFStreamer::emitGPRel32Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(4);
+   S.addFixup(Value, Mips::fixup_Mips_GPREL32);
+   S.appendContents(4, 0);
+ }
  
-@@ -2991,7 +3009,7 @@
- libc_math_function(
-     name = "erff",
-     additional_deps = [
--        ":__support_math_erff"
-+        ":__support_math_erff",
-     ],
- )
+ void MipsTargetELFStreamer::emitGPRel64Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(8);
+   // fixup_Mips_GPREL32 desginates R_MIPS_GPREL32+R_MIPS_64 on MIPS64.
+   S.addFixup(Value, Mips::fixup_Mips_GPREL32);
+   S.appendContents(8, 0);
+@@ -1049,28 +1047,24 @@
+ 
+ void MipsTargetELFStreamer::emitDTPRel32Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(4);
+   S.addFixup(Value, Mips::fixup_Mips_DTPREL32);
+   S.appendContents(4, 0);
+ }
  
-@@ -3462,13 +3480,13 @@
-     name = "frexpf128",
-     additional_deps = [
-         ":__support_math_frexpf128",
--    ]
-+    ],
- )
+ void MipsTargetELFStreamer::emitDTPRel64Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(8);
+   S.addFixup(Value, Mips::fixup_Mips_DTPREL64);
+   S.appendContents(8, 0);
+ }
  
- libc_math_function(
-     name = "frexpf16",
-     additional_deps = [
--        ":__support_math_frexpf16"
-+        ":__support_math_frexpf16",
-     ],
- )
+ void MipsTargetELFStreamer::emitTPRel32Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(4);
+   S.addFixup(Value, Mips::fixup_Mips_TPREL32);
+   S.appendContents(4, 0);
+ }
  
-@@ -3563,7 +3581,7 @@
-     name = "ldexpf",
-     additional_deps = [
-         ":__support_math_ldexpf",
--    ]
-+    ],
- )
+ void MipsTargetELFStreamer::emitTPRel64Value(const MCExpr *Value) {
+   auto &S = getStreamer();
+-  S.ensureHeadroom(8);
+   S.addFixup(Value, Mips::fixup_Mips_TPREL64);
+   S.appendContents(8, 0);
+ }
+diff -ruN --strip-trailing-cr a/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td b/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
+--- a/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
++++ b/llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
+@@ -1830,6 +1830,18 @@
+ def : Pat<(declare_scalar_param externalsym:$a, imm:$size),
+           (DECLARE_PARAM_scalar (to_texternsym $a), imm:$size)>;
+ 
++// Call prototype wrapper, this is a dummy instruction that just prints it's
++// operand which is string defining the prototype.
++def SDTCallPrototype : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
++def CallPrototype :
++  SDNode<"NVPTXISD::CallPrototype", SDTCallPrototype,
++         [SDNPHasChain, SDNPOutGlue, SDNPInGlue, SDNPSideEffect]>;
++def ProtoIdent : Operand<i32> { let PrintMethod = "printProtoIdent"; }
++def CALL_PROTOTYPE :
++  NVPTXInst<(outs), (ins ProtoIdent:$ident),
++            "$ident", [(CallPrototype (i32 texternalsym:$ident))]>;
++
++
+ foreach t = [I32RT, I64RT] in {
+   defvar inst_name = "MOV" # t.Size # "_PARAM";
+   def inst_name : BasicNVPTXInst<(outs t.RC:$dst), (ins t.RC:$src), "mov.b" # t.Size>;
+@@ -1849,6 +1861,32 @@
+ defm ProxyRegB32 : ProxyRegInst<"b32",  B32>;
+ defm ProxyRegB64 : ProxyRegInst<"b64",  B64>;
  
- libc_math_function(name = "ldexpl")
-diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
---- a/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
-+++ b/utils/bazel/llvm-project-overlay/libc/test/src/__support/FPUtil/BUILD.bazel
-@@ -58,3 +58,15 @@
-         "//libc/utils/MPFRWrapper:mpfr_wrapper",
-     ],
- )
 +
-+libc_test(
-+    name = "comparison_operations_test",
-+    srcs = ["comparison_operations_test.cpp"],
-+    deps = [
-+        "//libc:__support_fputil_bfloat16",
-+        "//libc:__support_fputil_comparison_operations",
-+        "//libc:__support_fputil_rounding_mode",
-+        "//libc:__support_macros_properties_types",
-+        "//libc/test/UnitTest:fp_test_helpers",
-+    ],
-+)
-diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
---- a/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
-+++ b/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
-@@ -44,6 +44,7 @@
-         "//libc:__support_cpp_type_traits",
-         "//libc:__support_fputil_bfloat16",
-         "//libc:__support_fputil_cast",
-+        "//libc:__support_fputil_comparison_operations",
-         "//libc:__support_fputil_fp_bits",
-         "//libc:__support_macros_config",
-         "//libc:__support_macros_properties_types",
++// Callseq start and end
++
++// Note: these nodes are marked as SDNPMayStore and SDNPMayLoad because
++// they define the scope in which the declared params may be used. Therefore
++// we add these flags to ensure ld.param and st.param are not sunk or hoisted
++// out of that scope.
++
++def callseq_start : SDNode<"ISD::CALLSEQ_START",
++                           SDCallSeqStart<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>,
++                           [SDNPHasChain, SDNPOutGlue,
++                            SDNPSideEffect, SDNPMayStore, SDNPMayLoad]>;
++def callseq_end   : SDNode<"ISD::CALLSEQ_END",
++                           SDCallSeqEnd<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>,
++                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
++                            SDNPSideEffect, SDNPMayStore, SDNPMayLoad]>;
++
++def Callseq_Start :
++  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
++            "\\{ // callseq $amt1, $amt2",
++            [(callseq_start timm:$amt1, timm:$amt2)]>;
++def Callseq_End :
++  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
++            "\\} // callseq $amt1",
++            [(callseq_end timm:$amt1, timm:$amt2)]>;
++
+ //
+ // Load / Store Handling
+ //
+@@ -2392,26 +2430,6 @@
+ def : Pat<(brcond (i1 (setne i1:$a, -1)), bb:$target),
+           (CBranchOther $a, bb:$target)>;
+ 
+-// Call
+-def SDT_NVPTXCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>,
+-                                            SDTCisVT<1, i32>]>;
+-def SDT_NVPTXCallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>;
+-
+-def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_NVPTXCallSeqStart,
+-                           [SDNPHasChain, SDNPOutGlue, SDNPSideEffect]>;
+-def callseq_end   : SDNode<"ISD::CALLSEQ_END", SDT_NVPTXCallSeqEnd,
+-                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
+-                            SDNPSideEffect]>;
+-
+-def Callseq_Start :
+-  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
+-            "\\{ // callseq $amt1, $amt2",
+-            [(callseq_start timm:$amt1, timm:$amt2)]>;
+-def Callseq_End :
+-  NVPTXInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
+-            "\\} // callseq $amt1",
+-            [(callseq_end timm:$amt1, timm:$amt2)]>;
+-
+ // trap instruction
+ def trapinst : BasicNVPTXInst<(outs), (ins), "trap", [(trap)]>, Requires<[noPTXASUnreachableBug]>;
+ // Emit an `exit` as well to convey to ptxas that `trap` exits the CFG.
+@@ -2420,18 +2438,6 @@
+ // brkpt instruction
+ def debugtrapinst : BasicNVPTXInst<(outs), (ins), "brkpt", [(debugtrap)]>;
+ 
+-// Call prototype wrapper
+-def SDTCallPrototype : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
+-def CallPrototype :
+-  SDNode<"NVPTXISD::CallPrototype", SDTCallPrototype,
+-         [SDNPHasChain, SDNPOutGlue, SDNPInGlue, SDNPSideEffect]>;
+-def ProtoIdent : Operand<i32> {
+-  let PrintMethod = "printProtoIdent";
+-}
+-def CALL_PROTOTYPE :
+-  NVPTXInst<(outs), (ins ProtoIdent:$ident),
+-            "$ident", [(CallPrototype (i32 texternalsym:$ident))]>;
+-
+ def SDTDynAllocaOp :
+   SDTypeProfile<1, 2, [SDTCisSameAs<0, 1>, SDTCisInt<1>, SDTCisVT<2, i32>]>;
+ 
+diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/NVPTX/ld-param-sink.ll b/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
+--- a/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
++++ b/llvm/test/CodeGen/NVPTX/ld-param-sink.ll
+@@ -0,0 +1,47 @@
++; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
++; RUN: llc < %s -verify-machineinstrs | FileCheck %s
++; RUN: %if ptxas %{ llc < %s | %ptxas-verify %}
++
++target triple = "nvptx64-nvidia-cuda"
++
++declare ptr @bar(i64)
++declare i64 @baz()
++
++define ptr @foo(i1 %cond) {
++; CHECK-LABEL: foo(
++; CHECK:       {
++; CHECK-NEXT:    .reg .pred %p<2>;
++; CHECK-NEXT:    .reg .b16 %rs<3>;
++; CHECK-NEXT:    .reg .b64 %rd<3>;
++; CHECK-EMPTY:
++; CHECK-NEXT:  // %bb.0: // %entry
++; CHECK-NEXT:    ld.param.b8 %rs1, [foo_param_0];
++; CHECK-NEXT:    and.b16 %rs2, %rs1, 1;
++; CHECK-NEXT:    setp.ne.b16 %p1, %rs2, 0;
++; CHECK-NEXT:    { // callseq 0, 0
++; CHECK-NEXT:    .param .b64 retval0;
++; CHECK-NEXT:    call.uni (retval0), baz, ();
++; CHECK-NEXT:    ld.param.b64 %rd2, [retval0];
++; CHECK-NEXT:    } // callseq 0
++; CHECK-NEXT:    @%p1 bra $L__BB0_2;
++; CHECK-NEXT:  // %bb.1: // %bb
++; CHECK-NEXT:    { // callseq 1, 0
++; CHECK-NEXT:    .param .b64 param0;
++; CHECK-NEXT:    .param .b64 retval0;
++; CHECK-NEXT:    st.param.b64 [param0], %rd2;
++; CHECK-NEXT:    call.uni (retval0), bar, (param0);
++; CHECK-NEXT:    } // callseq 1
++; CHECK-NEXT:  $L__BB0_2: // %common.ret
++; CHECK-NEXT:    st.param.b64 [func_retval0], 0;
++; CHECK-NEXT:    ret;
++entry:
++  %call = call i64 @baz()
++  br i1 %cond, label %common.ret, label %bb
++
++bb:
++  %tmp = call ptr @bar(i64 %call)
++  br label %common.ret
++
++common.ret:
++  ret ptr null
++}
+diff -ruN --strip-trailing-cr a/llvm/test/MC/ELF/many-instructions.s b/llvm/test/MC/ELF/many-instructions.s
+--- a/llvm/test/MC/ELF/many-instructions.s
++++ b/llvm/test/MC/ELF/many-instructions.s
+@@ -1,10 +0,0 @@
+-# REQUIRES: asserts
+-# RUN: llvm-mc -filetype=obj -triple=x86_64 %s -o /dev/null -debug-only=mc-dump
+-
+-## Test that encodeInstruction may cause a new fragment to be created.
+-# CHECK: 0 Data Size:16200
+-# CHECK: 16200 Data Size:180
+-
+-.rept 16384/10
+-movabsq $foo, %rax
+-.endr
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 189d649..cc271d4 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "22b0835390516c2150c040521885c473f3a1e87e"
-    LLVM_SHA256 = "963953aedf9f6e5fdc16cdb3a64d93d80ab6159078c307216f4f49ab7be81d2b"
+    LLVM_COMMIT = "fa6965f722e0573f62e4d1e533dfa5b3a2ce2c4f"
+    LLVM_SHA256 = "26239cc6dfb65fdd65d2249484de9a7ca6df16617310637d3b951b0132fc0e30"
 
     tf_http_archive(
         name = name,
