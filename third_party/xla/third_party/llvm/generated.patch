Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaCXXScopeSpec.cpp b/clang/lib/Sema/SemaCXXScopeSpec.cpp
--- a/clang/lib/Sema/SemaCXXScopeSpec.cpp
+++ b/clang/lib/Sema/SemaCXXScopeSpec.cpp
@@ -220,10 +220,11 @@
 ///
 bool Sema::RequireCompleteEnumDecl(EnumDecl *EnumD, SourceLocation L,
                                    CXXScopeSpec *SS) {
-  if (EnumD->isCompleteDefinition()) {
+  if (EnumDecl *Def = EnumD->getDefinition();
+      Def && Def->isCompleteDefinition()) {
     // If we know about the definition but it is not visible, complain.
     NamedDecl *SuggestedDef = nullptr;
-    if (!hasReachableDefinition(EnumD, &SuggestedDef,
+    if (!hasReachableDefinition(Def, &SuggestedDef,
                                 /*OnlyNeedComplete*/ false)) {
       // If the user is going to see an error here, recover by making the
       // definition visible.
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx20-using-enum.cpp b/clang/test/SemaCXX/cxx20-using-enum.cpp
--- a/clang/test/SemaCXX/cxx20-using-enum.cpp
+++ b/clang/test/SemaCXX/cxx20-using-enum.cpp
@@ -288,4 +288,14 @@
   };
 };
 }
+
+namespace Redecl {
+  enum class A : int { X };
+  enum class A : int;
+  template <class> struct B {
+    using enum A;
+    using Z = decltype(X);
+  };
+  template struct B<int>;
+} // namespace Redecl
 #endif
diff -ruN --strip-trailing-cr a/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp b/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp
--- a/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp
+++ b/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp
@@ -69,6 +69,9 @@
 }
 
 void TracePC::HandlePCsInit(const uintptr_t *Start, const uintptr_t *Stop) {
+  if (Start == Stop) {
+    return;
+  }
   const PCTableEntry *B = reinterpret_cast<const PCTableEntry *>(Start);
   const PCTableEntry *E = reinterpret_cast<const PCTableEntry *>(Stop);
   if (NumPCTables && ModulePCTable[NumPCTables - 1].Start == B) return;
diff -ruN --strip-trailing-cr a/compiler-rt/test/fuzzer/empty-module.test b/compiler-rt/test/fuzzer/empty-module.test
--- a/compiler-rt/test/fuzzer/empty-module.test
+++ b/compiler-rt/test/fuzzer/empty-module.test
@@ -0,0 +1,7 @@
+CHECK: BINGO
+RUN: %cpp_compiler %S/SimulateEmptyModuleTest.cpp -o %t-SimulateEmptyModuleTest
+
+RUN: not %run %t-SimulateEmptyModuleTest         2>&1 | FileCheck %s
+
+# only_ascii mode. Will perform some minimal self-validation.
+RUN: not %run %t-SimulateEmptyModuleTest -only_ascii=1 2>&1
diff -ruN --strip-trailing-cr a/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp b/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp
--- a/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp
+++ b/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp
@@ -0,0 +1,60 @@
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+
+// Like SimpleTest, but simulates an "empty" module (i.e. one without any functions to instrument).
+// This reproduces a previous bug (when libFuzzer is compiled with assertions enabled).
+
+#include <assert.h>
+#include <cstddef>
+#include <cstdint>
+#include <cstdlib>
+#include <iostream>
+#include <ostream>
+
+extern "C" {
+void __sanitizer_cov_8bit_counters_init(uint8_t *Start, uint8_t *Stop);
+void __sanitizer_cov_pcs_init(const uintptr_t *pcs_beg,
+                              const uintptr_t *pcs_end);
+}
+
+void dummy_func() {}
+
+uint8_t empty_8bit_counters[0];
+uintptr_t empty_pcs[0];
+
+uint8_t fake_8bit_counters[1] = {0};
+uintptr_t fake_pcs[2] = {reinterpret_cast<uintptr_t>(&dummy_func),
+                         reinterpret_cast<uintptr_t>(&dummy_func)};
+
+// Register two modules at program launch (same time they'd normally be registered).
+// Triggering the bug requires loading an empty module, then a non-empty module after it.
+bool dummy = []() {
+  // First, simulate loading an empty module.
+  __sanitizer_cov_8bit_counters_init(empty_8bit_counters, empty_8bit_counters);
+  __sanitizer_cov_pcs_init(empty_pcs, empty_pcs);
+
+  // Next, simulate loading a non-empty module.
+  __sanitizer_cov_8bit_counters_init(fake_8bit_counters,
+                                     fake_8bit_counters + 1);
+  __sanitizer_cov_pcs_init(fake_pcs, fake_pcs + 2);
+
+  return true;
+}();
+
+static volatile int Sink;
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
+  assert(Data);
+  if (Size > 0 && Data[0] == 'H') {
+    Sink = 1;
+    if (Size > 1 && Data[1] == 'i') {
+      Sink = 2;
+      if (Size > 2 && Data[2] == '!') {
+        std::cout << "BINGO; Found the target, exiting\n" << std::flush;
+        exit(0);
+      }
+    }
+  }
+  return 0;
+}
diff -ruN --strip-trailing-cr a/llvm/lib/IR/Metadata.cpp b/llvm/lib/IR/Metadata.cpp
--- a/llvm/lib/IR/Metadata.cpp
+++ b/llvm/lib/IR/Metadata.cpp
@@ -986,10 +986,15 @@
 }
 
 template <class NodeTy> struct MDNode::HasCachedHash {
+  using Yes = char[1];
+  using No = char[2];
+  template <class U, U Val> struct SFINAE {};
+
   template <class U>
-  using check = decltype(static_cast<void (U::*)(unsigned)>(&U::setHash));
+  static Yes &check(SFINAE<void (U::*)(unsigned), &U::setHash> *);
+  template <class U> static No &check(...);
 
-  static constexpr bool value = is_detected<check, NodeTy>::value;
+  static const bool value = sizeof(check<NodeTy>(nullptr)) == sizeof(Yes);
 };
 
 MDNode *MDNode::uniquify() {
diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp b/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
--- a/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
+++ b/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
@@ -796,18 +796,19 @@
       if (Count && !ProfcheckDisableMetadataFixes) {
         std::optional<llvm::Function::ProfileCount> MaybeCloneCount =
             Clone->getEntryCount();
-        assert(MaybeCloneCount && "Clone entry count was not set!");
-        uint64_t CallCount = *Count + MaybeCloneCount->getCount();
-        Clone->setEntryCount(CallCount);
-        if (std::optional<llvm::Function::ProfileCount> MaybeOriginalCount =
-                S.F->getEntryCount()) {
-          uint64_t OriginalCount = MaybeOriginalCount->getCount();
-          if (OriginalCount >= *Count) {
-            S.F->setEntryCount(OriginalCount - *Count);
-          } else {
-            // This should generally not happen as that would mean there are
-            // more computed calls to the function than what was recorded.
-            LLVM_DEBUG(S.F->setEntryCount(0));
+        if (MaybeCloneCount) {
+          uint64_t CallCount = *Count + MaybeCloneCount->getCount();
+          Clone->setEntryCount(CallCount);
+          if (std::optional<llvm::Function::ProfileCount> MaybeOriginalCount =
+                  S.F->getEntryCount()) {
+            uint64_t OriginalCount = MaybeOriginalCount->getCount();
+            if (OriginalCount >= *Count) {
+              S.F->setEntryCount(OriginalCount - *Count);
+            } else {
+              // This should generally not happen as that would mean there are
+              // more computed calls to the function than what was recorded.
+              LLVM_DEBUG(S.F->setEntryCount(0));
+            }
           }
         }
       }
