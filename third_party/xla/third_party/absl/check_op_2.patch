# Remove this once the following makes it to a release.
# Github-Commit-Id: e8c1a5ff2346d40be5f2450044c01c845777cc02
# PiperOrigin-RevId: 806567586
# Change-Id: I5e0694d52296b33a4d3689fa464139319f48429e
diff --git a/absl/log/internal/check_op.h b/absl/log/internal/check_op.h
--- a/absl/log/internal/check_op.h
+++ b/absl/log/internal/check_op.h
@@ -367,6 +367,18 @@ std::enable_if_t<std::negation_v<std::disjunction<
                  UnprintableWrapper>
 Detect(...);
 
+// Equivalent to the updated std::underlying_type from C++20, which is no
+// longer undefined behavior for non-enum types.
+template <typename T, typename EnableT = void>
+struct UnderlyingType {};
+
+template <typename T>
+struct UnderlyingType<T, std::enable_if_t<std::is_enum_v<T>>> {
+  using type = std::underlying_type_t<T>;
+};
+template <typename T>
+using UnderlyingTypeT = typename UnderlyingType<T>::type;
+
 // This overload triggers when T is a scoped enum that has not defined an output
 // stream operator (operator<<) or AbslStringify. It causes the enum value to be
 // converted to a type that can be streamed. For consistency with other enums, a
@@ -378,14 +390,13 @@ std::enable_if_t<
                        std::negation<std::is_convertible<T, int>>,
                        std::negation<HasOstreamOperator<T>>,
                        std::negation<HasAbslStringify<T>>>,
-    std::conditional_t<
-        std::is_same_v<std::underlying_type_t<T>, bool> ||
-            std::is_same_v<std::underlying_type_t<T>, char> ||
-            std::is_same_v<std::underlying_type_t<T>, signed char> ||
-            std::is_same_v<std::underlying_type_t<T>, unsigned char>,
-        std::underlying_type_t<T>,
-        std::conditional_t<std::is_signed_v<std::underlying_type_t<T>>, int64_t,
-                           uint64_t>>>
+    std::conditional_t<std::is_same_v<UnderlyingTypeT<T>, bool> ||
+                           std::is_same_v<UnderlyingTypeT<T>, char> ||
+                           std::is_same_v<UnderlyingTypeT<T>, signed char> ||
+                           std::is_same_v<UnderlyingTypeT<T>, unsigned char>,
+                       UnderlyingTypeT<T>,
+                       std::conditional_t<std::is_signed_v<UnderlyingTypeT<T>>,
+                                          int64_t, uint64_t>>>
 Detect(...);
 }  // namespace detect_specialization
 
