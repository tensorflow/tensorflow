
--- a/lib/Dialect/TritonGPU/IR/Ops.cpp	2025-08-22 04:02:56.000000000 -0700
+++ b/lib/Dialect/TritonGPU/IR/Ops.cpp	2025-09-08 07:22:55.000000000 -0700
@@ -1,3 +1,5 @@
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/LogicalResult.h"
 #include "mlir/IR/BuiltinTypes.h"
 #include "mlir/IR/Diagnostics.h"
 #include "mlir/Support/DebugStringHelper.h"
@@ -9,9 +11,8 @@
 #include "triton/Dialect/TritonGPU/IR/Types.h"
 #include "triton/Dialect/TritonGPU/Transforms/Utility.h"
 #include "triton/Dialect/TritonNvidiaGPU/IR/Dialect.h"
+#include "triton/Dialect/TritonNvidiaGPU/Transforms/TMAUtilities.h"
 #include "triton/Tools/LayoutUtils.h"
-#include "llvm/Support/Casting.h"
-#include "llvm/Support/LogicalResult.h"

 // Provide custom directive handlers for declarative assemblyFormat.
 // They must be visible before including the generated op classes.
@@ -517,10 +518,47 @@ LogicalResult MemDescReshapeOp::verify() {
   return success();
 }

-static LogicalResult inferMemDescReshapeOpEncoding(ArrayRef<int64_t> srcShape,
+// Verification copied from nvmmaSharedToLinearLayout().
+LogicalResult verifyNVMMASharedEncoding(std::optional<Location> loc,
+                                        NVMMASharedEncodingAttr attr,
+                                        ArrayRef<int64_t> shape,
+                                        int elementBitWidth) {
+  if (attr.getSwizzlingByteWidth() == 0) return success();
+  if (shape.size() < 2)
+    return emitOptionalError(loc, "nvmma_shared encoding requires rank >= 2");
+
+  auto shapePerCTA = getShapePerCTA(attr, shape);
+  auto tmaShape = triton::nvidia_gpu::getTMABlockShape(attr, shapePerCTA,
+                                                       /*packedSize=*/true);
+  std::array<int64_t, 2> collapsedTmaShape{1, tmaShape.back()};
+  for (int i = 0; i + 1 < shape.size(); i++)
+    collapsedTmaShape[0] *= tmaShape[i];
+  if (attr.getTransposed()) {
+    std::swap(collapsedTmaShape[0], collapsedTmaShape[1]);
+  }
+
+  int tileRows = 8;
+  int tileCols = 8 * attr.getSwizzlingByteWidth() / elementBitWidth;
+  if (attr.getFp4Padded()) tileCols /= 2;
+
+  int packingFactor = attr.getFp4Padded() ? 2 : 1;
+  if (collapsedTmaShape[1] * packingFactor < tileCols ||
+      collapsedTmaShape[0] < tileRows) {
+    return emitOptionalError(
+        loc,
+        "Illegal shared layout; expected collapsed shapePerCTA to "
+        "be at least [",
+        tileRows, ", ", (tileCols / packingFactor), "], collapsedTmaShape: [",
+        collapsedTmaShape[0], ", ", collapsedTmaShape[1], "]");
+  }
+  return success();
+}
+
+static LogicalResult inferMemDescReshapeOpEncoding(std::optional<Location> loc,
+                                                   ArrayRef<int64_t> srcShape,
                                                    Attribute srcEnc,
                                                    ArrayRef<int64_t> dstShape,
-                                                   Attribute &dstEnc) {
+                                                   Attribute& dstEnc) {
   if (auto mmaEncoding = dyn_cast<NVMMASharedEncodingAttr>(srcEnc)) {
     // TODO: supporting reshape of CTA layouts is non-trivial.
     if (getNumCTAs(mmaEncoding) > 1)
@@ -544,6 +582,11 @@ static LogicalResult inferMemDescReshapeOpEncoding(ArrayRef<int64_t> srcShape,
         ctx, mmaEncoding.getSwizzlingByteWidth(), mmaEncoding.getTransposed(),
         mmaEncoding.getElementBitWidth(), mmaEncoding.getFp4Padded(),
         CTALayout);
+    if (failed(verifyNVMMASharedEncoding(
+            loc, cast<NVMMASharedEncodingAttr>(dstEnc), dstShape,
+            mmaEncoding.getElementBitWidth()))) {
+      return failure();
+    }
     // Big guns, check linear layouts are equivalent
     // We disallow reshaping memdesc_subslice in the verifier
     // so allocShape == shape
@@ -566,8 +609,8 @@ LogicalResult MemDescReshapeOp::inferReturnTypes(

   Attribute dstEncoding;
   if (Attribute srcEnc = srcTy.getEncoding()) {
-    if (failed(inferMemDescReshapeOpEncoding(srcTy.getShape(), srcEnc, dstShape,
-                                             dstEncoding)))
+    if (failed(inferMemDescReshapeOpEncoding(loc, srcTy.getShape(), srcEnc,
+                                             dstShape, dstEncoding)))
       return failure();
   }

