This fix should be upstreamed.

--- a/lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp	2025-08-28 04:30:50.000000000 -0700
+++ b/lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp	2025-09-10 06:50:50.000000000 -0700
@@ -331,11 +331,11 @@
     // Pack registers if possible.
     int elemsPerVec = 1 << nPack;
     int bitsPerVecElem = 32 / elemsPerVec;
+    bool packTwo16Bit = bitwidth < bitsPerVecElem && elemsPerVec == 2;
     if (elemsPerVec > 1) {
       SmallVector<Value> packedVals;
       packedVals.reserve(regDim / elemsPerVec);
-      if (bitwidth < bitsPerVecElem) {
-        // Should have bitsPerVecElem == 16 here.
+      if (packTwo16Bit) {
         for (int i = 0; i < regDim; i += elemsPerVec) {
           Value x0 = b.zext(i32_ty, b.bitcast(inVals[i], int_ty(bitwidth)));
           Value x1 = b.zext(i32_ty, b.bitcast(inVals[i + 1], int_ty(bitwidth)));
@@ -343,6 +343,10 @@
           packedVals.emplace_back(b.or_(x0, x1));
         }
       } else {
+        // For small types, we need to extend the values to i8.
+        if (bitwidth < 8) {
+          llvm::for_each(inVals, [&](Value& v) { v = b.zext(i8_ty, v); });
+        }
         for (int i = 0; i < regDim; i += elemsPerVec) {
           auto slice = ArrayRef<Value>(inVals).slice(i, elemsPerVec);
           Value v = packLLVector(loc, slice, rewriter);
@@ -376,9 +380,21 @@
     if (elemsPerVec > 1) {
       SmallVector<Value> unpackedVals;
       unpackedVals.reserve(regDim);
-      if (bitwidth >= bitsPerVecElem) {
+      if (packTwo16Bit) {
+        for (auto packedVal : outVals) {
+          Value x0 =
+              b.trunc(int_ty(bitwidth), b.and_(packedVal, b.i32_val(0xFF)));
+          Value x1 =
+              b.trunc(int_ty(bitwidth), b.lshr(packedVal, b.i32_val(16)));
+          unpackedVals.push_back(b.bitcast(x0, elemTy));
+          unpackedVals.push_back(b.bitcast(x1, elemTy));
+        }
+      } else {
         auto packedTy =
             bitwidth < bitsPerVecElem ? int_ty(bitsPerVecElem) : elemTy;
+        if (bitwidth < 8) {
+          packedTy = i8_ty;
+        }
         auto vecTy = vec_ty(packedTy, elemsPerVec);
         auto unpackVal = [&](Value v) {
           v = b.bitcast(v, vecTy);
@@ -388,14 +404,10 @@
           auto unpacked = unpackVal(v);
           unpackedVals.append(unpacked.begin(), unpacked.end());
         }
-      } else {
-        for (auto packedVal : outVals) {
-          Value x0 =
-              b.trunc(int_ty(bitwidth), b.and_(packedVal, b.i32_val(0xFF)));
-          Value x1 =
-              b.trunc(int_ty(bitwidth), b.lshr(packedVal, b.i32_val(16)));
-          unpackedVals.push_back(b.bitcast(x0, elemTy));
-          unpackedVals.push_back(b.bitcast(x1, elemTy));
+        if (bitwidth < 8) {
+          // Truncate the values to the original bitwidth from i8.
+          llvm::for_each(unpackedVals,
+                         [&](Value& v) { v = b.trunc(elemTy, v); });
         }
       }
       outVals = std::move(unpackedVals);
