# patch to match https://github.com/triton-lang/triton/pull/8155

--- a/lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp	2025-09-11 02:55:30.000000000 -0700
+++ b/lib/Conversion/TritonGPUToLLVM/ConvertLayoutOpToLLVM.cpp	2025-09-11 23:33:17.000000000 -0700
@@ -331,11 +331,11 @@
     // Pack registers if possible.
     int elemsPerVec = 1 << nPack;
     int bitsPerVecElem = 32 / elemsPerVec;
-    bool packTwo16Bit = bitwidth < bitsPerVecElem && elemsPerVec == 2;
     if (elemsPerVec > 1) {
       SmallVector<Value> packedVals;
       packedVals.reserve(regDim / elemsPerVec);
-      if (packTwo16Bit) {
+      if (bitwidth == 8 && bitsPerVecElem == 16) {
+        // TODO: Can remove `if` part of `if-else` once ptxas bugfix lands.
         for (int i = 0; i < regDim; i += elemsPerVec) {
           Value x0 = b.zext(i32_ty, b.bitcast(inVals[i], int_ty(bitwidth)));
           Value x1 = b.zext(i32_ty, b.bitcast(inVals[i + 1], int_ty(bitwidth)));
@@ -343,9 +343,12 @@
           packedVals.emplace_back(b.or_(x0, x1));
         }
       } else {
-        // For small types, we need to extend the values to i8.
-        if (bitwidth < 8) {
-          llvm::for_each(inVals, [&](Value& v) { v = b.zext(i8_ty, v); });
+        if (bitwidth < bitsPerVecElem) {
+          for (Value &v : inVals) {
+            if (elemTy != int_ty(bitwidth))
+              v = b.bitcast(v, int_ty(bitwidth));
+            v = b.zext(int_ty(bitsPerVecElem), v);
+          }
         }
         for (int i = 0; i < regDim; i += elemsPerVec) {
           auto slice = ArrayRef<Value>(inVals).slice(i, elemsPerVec);
@@ -380,21 +383,8 @@
     if (elemsPerVec > 1) {
       SmallVector<Value> unpackedVals;
       unpackedVals.reserve(regDim);
-      if (packTwo16Bit) {
-        for (auto packedVal : outVals) {
-          Value x0 =
-              b.trunc(int_ty(bitwidth), b.and_(packedVal, b.i32_val(0xFF)));
-          Value x1 =
-              b.trunc(int_ty(bitwidth), b.lshr(packedVal, b.i32_val(16)));
-          unpackedVals.push_back(b.bitcast(x0, elemTy));
-          unpackedVals.push_back(b.bitcast(x1, elemTy));
-        }
-      } else {
         auto packedTy =
             bitwidth < bitsPerVecElem ? int_ty(bitsPerVecElem) : elemTy;
-        if (bitwidth < 8) {
-          packedTy = i8_ty;
-        }
         auto vecTy = vec_ty(packedTy, elemsPerVec);
         auto unpackVal = [&](Value v) {
           v = b.bitcast(v, vecTy);
@@ -404,10 +394,11 @@
           auto unpacked = unpackVal(v);
           unpackedVals.append(unpacked.begin(), unpacked.end());
         }
-        if (bitwidth < 8) {
-          // Truncate the values to the original bitwidth from i8.
-          llvm::for_each(unpackedVals,
-                         [&](Value& v) { v = b.trunc(elemTy, v); });
+      if (bitwidth < bitsPerVecElem) {
+        for (Value &v : unpackedVals) {
+          v = b.trunc(int_ty(bitwidth), v);
+          if (elemTy != int_ty(bitwidth))
+            v = b.bitcast(v, elemTy);
         }
       }
       outVals = std::move(unpackedVals);
