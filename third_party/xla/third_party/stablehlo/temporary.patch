diff --ruN a/stablehlo/stablehlo/dialect/Serialization.cpp b/stablehlo/stablehlo/dialect/Serialization.cpp
--- stablehlo/stablehlo/dialect/Serialization.cpp
+++ stablehlo/stablehlo/dialect/Serialization.cpp
@@ -32,20 +32,25 @@
 #include "stablehlo/dialect/VhloOps.h"
 #include "stablehlo/transforms/Passes.h"
 
-#define DEBUG_TYPE "compat-passes"
+#define DEBUG_TYPE "stablehlo-compat"
 
 namespace mlir {
 namespace stablehlo {
 
 LogicalResult serializePortableArtifact(ModuleOp module,
                                         StringRef targetVersion,
-                                        raw_ostream& os) {
+                                        raw_ostream& os,
+                                        bool allowOtherDialects) {
   MLIRContext* context = module.getContext();
 
-  // Convert StableHLO --> VHLO. Will fail if entire program is not StableHLO.
+  // Convert StableHLO --> VHLO.
+  // If allowOtherDialects is true, we will allow other dialects to be present
+  // in the module, otherwise will fail if there are any other dialects present.
   {
     PassManager pm(context);
-    pm.addPass(stablehlo::createStablehloLegalizeToVhloPass());
+    StablehloLegalizeToVhloPassOptions options;
+    options.allowOtherDialects = allowOtherDialects;
+    pm.addPass(stablehlo::createStablehloLegalizeToVhloPass(options));
     if (!succeeded(pm.run(module))) {
       return failure();
     }
diff --ruN a/stablehlo/stablehlo/dialect/Serialization.h b/stablehlo/stablehlo/dialect/Serialization.h
--- stablehlo/stablehlo/dialect/Serialization.h
+++ stablehlo/stablehlo/dialect/Serialization.h
@@ -34,7 +34,8 @@
 // unsupported dialects.
 LogicalResult serializePortableArtifact(ModuleOp module,
                                         StringRef targetVersion,
-                                        raw_ostream& os);
+                                        raw_ostream& os,
+                                        bool allowOtherDialects = false);
 
 // Read StableHLO portable artifact
 //
diff --ruN a/stablehlo/stablehlo/dialect/VhloTypes.cpp b/stablehlo/stablehlo/dialect/VhloTypes.cpp
--- stablehlo/stablehlo/dialect/VhloTypes.cpp
+++ stablehlo/stablehlo/dialect/VhloTypes.cpp
@@ -323,6 +323,20 @@
 }
 
 namespace {
+Value materializeIllegalCast(OpBuilder& builder, Type type, ValueRange inputs,
+                             Location loc) {
+  return builder.create<UnrealizedConversionCastOp>(loc, type, inputs)
+      ->getResult(0);
+}
+}  // namespace
+
+void VhloTypeConverter::addUnrealizedMaterializations() {
+  addTargetMaterialization(materializeIllegalCast);
+  addSourceMaterialization(materializeIllegalCast);
+  addArgumentMaterialization(materializeIllegalCast);
+}
+
+namespace {
 // Helper functions for VHLO verifiers
 template <typename TypeOrAttr>
 bool isFromVhlo(TypeOrAttr t) {
diff --ruN a/stablehlo/stablehlo/dialect/VhloTypes.h b/stablehlo/stablehlo/dialect/VhloTypes.h
--- stablehlo/stablehlo/dialect/VhloTypes.h
+++ stablehlo/stablehlo/dialect/VhloTypes.h
@@ -55,6 +55,9 @@
   // it is likely that a subclass should call this last, especially if a default
   // `Type -> Type` fallback conversion is registered.
   void addBuiltinToVhloConversions();
+
+  // Mark unrealized casts as legal. Useful for dialect mixing.
+  void addUnrealizedMaterializations();
 };
 
 // Autogenerated VHLO type printers and parsers.
diff --ruN a/stablehlo/stablehlo/tests/ops_stablehlo_quantized.mlir b/stablehlo/stablehlo/tests/ops_stablehlo_quantized.mlir
--- stablehlo/stablehlo/tests/ops_stablehlo_quantized.mlir
+++ stablehlo/stablehlo/tests/ops_stablehlo_quantized.mlir
@@ -1338,7 +1338,7 @@
 
 // -----
 
-// expected-error@+1 {{scale out of expressed type range}}
+// expected-error@+1 {{scale 1.055040e+05 out of expressed type range}}
 func.func @quantized_element_type_c6(%arg0: tensor<1x2x!quant.uniform<i4:f16, 10.550400e+04>>) {
    %0 = stablehlo.add %arg0,  %arg0 : tensor<1x2x!quant.uniform<i4:f16, 10.550400e+04>>
    func.return
@@ -1346,7 +1346,7 @@
 
 // -----
 
-// expected-error@+1 {{scale out of expressed type range}}
+// expected-error@+1 {{scale 4.960464e-08 out of expressed type range}}
 func.func @quantized_element_type_c6(%arg0: tensor<1x2x!quant.uniform<i4:f16, 4.960464e-08>>) {
    %0 = stablehlo.add %arg0,  %arg0 : tensor<1x2x!quant.uniform<i4:f16, 4.960464e-08>>
    func.return
diff --ruN a/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir b/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
--- stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
+++ stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
@@ -0,0 +1,189 @@
+// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
+
+// The script is designed to make adding checks to
+// a test case fast, it is *not* designed to be authoritative
+// about what constitutes a good test! The CHECK should be
+// minimized and named to reflect the test intent.
+
+// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
+
+// The script is designed to make adding checks to
+// a test case fast, it is *not* designed to be authoritative
+// minimized and named to reflect the test intent.
+
+// RUN: stablehlo-opt %s --stablehlo-legalize-to-vhlo=allow-other-dialects | FileCheck %s
+// RUN: stablehlo-opt %s > %t.0
+// RUN: stablehlo-opt %s --stablehlo-legalize-to-vhlo=allow-other-dialects | stablehlo-opt --vhlo-legalize-to-stablehlo > %t.1
+// RUN: diff %t.0 %t.1
+
+// CHECK-LABEL:   vhlo.func_v1 @op_other(
+// CHECK-SAME:                           %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>) {
+// CHECK:           %[[VAL_1:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !vhlo.tensor_v1<!vhlo.f32_v1> to tensor<f32>
+// CHECK:           %[[VAL_2:.*]] = arith.addf %[[VAL_1]], %[[VAL_1]] : tensor<f32>
+// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : tensor<f32> to !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:           "vhlo.return_v1"(%[[VAL_3]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:         }
+func.func @op_other(%arg0: tensor<f32>) -> tensor<f32> {
+  %0 = arith.addf %arg0, %arg0 : tensor<f32>
+  return %0 : tensor<f32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @op_shlo(
+// CHECK-SAME:                          %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>) {
+// CHECK:           %[[VAL_1:.*]] = "vhlo.add_v1"(%[[VAL_0]], %[[VAL_0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:           "vhlo.return_v1"(%[[VAL_1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:         }
+func.func @op_shlo(%arg0: tensor<f32>) -> tensor<f32> {
+  %0 = stablehlo.add %arg0, %arg0 : tensor<f32>
+  return %0 : tensor<f32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @mixed_shlo_other_shlo(
+// CHECK-SAME:                                        %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>) {
+// CHECK:           %[[VAL_1:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !vhlo.tensor_v1<!vhlo.f32_v1> to tensor<f32>
+// CHECK:           %[[VAL_2:.*]] = "vhlo.abs_v1"(%[[VAL_0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : !vhlo.tensor_v1<!vhlo.f32_v1> to tensor<f32>
+// CHECK:           %[[VAL_4:.*]] = arith.addf %[[VAL_3]], %[[VAL_1]] : tensor<f32>
+// CHECK:           %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_4]] : tensor<f32> to !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:           %[[VAL_6:.*]] = "vhlo.abs_v1"(%[[VAL_5]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:           "vhlo.return_v1"(%[[VAL_6]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:         }
+func.func @mixed_shlo_other_shlo(%arg0: tensor<f32>) -> tensor<f32> {
+  %0 = stablehlo.abs %arg0 : tensor<f32>
+  %1 = arith.addf %0, %arg0 : tensor<f32>
+  %2 = stablehlo.abs %1 : tensor<f32>
+  return %2 : tensor<f32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @mixed_other_shlo_other(
+// CHECK-SAME:                                         %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>) {
+// CHECK:           %[[VAL_1:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !vhlo.tensor_v1<!vhlo.f32_v1> to tensor<f32>
+// CHECK:           %[[VAL_2:.*]] = arith.addf %[[VAL_1]], %[[VAL_1]] : tensor<f32>
+// CHECK:           %[[VAL_3:.*]] = builtin.unrealized_conversion_cast %[[VAL_2]] : tensor<f32> to !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:           %[[VAL_4:.*]] = "vhlo.add_v1"(%[[VAL_3]], %[[VAL_0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:           %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_4]] : !vhlo.tensor_v1<!vhlo.f32_v1> to tensor<f32>
+// CHECK:           %[[VAL_6:.*]] = arith.addf %[[VAL_5]], %[[VAL_1]] : tensor<f32>
+// CHECK:           %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_6]] : tensor<f32> to !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:           "vhlo.return_v1"(%[[VAL_7]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:         }
+func.func @mixed_other_shlo_other(%arg0: tensor<f32>) -> tensor<f32> {
+  %0 = arith.addf %arg0, %arg0 : tensor<f32>
+  %1 = stablehlo.add %0, %arg0 : tensor<f32>
+  %2 = arith.addf %1, %arg0 : tensor<f32>
+  return %2 : tensor<f32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @op_with_region(
+// CHECK-SAME:                                 %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<1x16x16x320x!vhlo.f32_v1>,
+// CHECK-SAME:                                 %[[VAL_1:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<1x320x!vhlo.f32_v1>) {
+// CHECK:           %[[VAL_2:.*]] = "vhlo.reduce_v1"(%[[VAL_0]], %[[VAL_1]]) <{dimensions = #{{.*}}<dense<[1, 2]> : tensor<2xi64>>}> ({
+// CHECK:           ^bb0(%[[VAL_3:.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[VAL_4:.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
+// CHECK:             %[[VAL_5:.*]] = "vhlo.add_v1"(%[[VAL_3]], %[[VAL_4]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
+// CHECK:             "vhlo.return_v1"(%[[VAL_5]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:           }) : (!vhlo.tensor_v1<1x16x16x320x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<1x320x!vhlo.f32_v1>
+// CHECK:           "vhlo.return_v1"(%[[VAL_2]]) : (!vhlo.tensor_v1<1x320x!vhlo.f32_v1>) -> ()
+// CHECK:         }
+func.func @op_with_region(%arg0: tensor<1x16x16x320xf32>, %arg1: tensor<f32>) -> tensor<1x320xf32> {
+  %0 = stablehlo.reduce(%arg0 init: %arg1) applies stablehlo.add across dimensions = [1, 2] : (tensor<1x16x16x320xf32>, tensor<f32>) -> tensor<1x320xf32>
+  return %0 : tensor<1x320xf32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @op_with_region_mixed_other_shlo_other(
+// CHECK-SAME:                                                        %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<7x5x!vhlo.f32_v1>,
+// CHECK-SAME:                                                        %[[VAL_1:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<5x!vhlo.f32_v1>) -> (!vhlo.tensor_v1<5x!vhlo.f32_v1>) {
+// CHECK:           %[[VAL_2:.*]] = "vhlo.reduce_v1"(%[[VAL_0]], %[[VAL_1]]) <{dimensions = #{{.*}}<dense<0> : tensor<1xi64>>}> ({
+// CHECK:           ^bb0(%[[VAL_3:.*]]: !vhlo.tensor_v1<5x!vhlo.f32_v1>, %[[VAL_4:.*]]: !vhlo.tensor_v1<5x!vhlo.f32_v1>):
+// CHECK:             %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_4]] : !vhlo.tensor_v1<5x!vhlo.f32_v1> to tensor<5xf32>
+// CHECK:             %[[VAL_6:.*]] = builtin.unrealized_conversion_cast %[[VAL_3]] : !vhlo.tensor_v1<5x!vhlo.f32_v1> to tensor<5xf32>
+// CHECK:             %[[VAL_7:.*]] = arith.addf %[[VAL_6]], %[[VAL_5]] : tensor<5xf32>
+// CHECK:             %[[VAL_8:.*]] = builtin.unrealized_conversion_cast %[[VAL_7]] : tensor<5xf32> to !vhlo.tensor_v1<5x!vhlo.f32_v1>
+// CHECK:             %[[VAL_9:.*]] = "vhlo.add_v1"(%[[VAL_8]], %[[VAL_3]]) : (!vhlo.tensor_v1<5x!vhlo.f32_v1>, !vhlo.tensor_v1<5x!vhlo.f32_v1>) -> !vhlo.tensor_v1<5x!vhlo.f32_v1>
+// CHECK:             %[[VAL_10:.*]] = builtin.unrealized_conversion_cast %[[VAL_9]] : !vhlo.tensor_v1<5x!vhlo.f32_v1> to tensor<5xf32>
+// CHECK:             %[[VAL_11:.*]] = arith.addf %[[VAL_10]], %[[VAL_5]] : tensor<5xf32>
+// CHECK:             %[[VAL_12:.*]] = builtin.unrealized_conversion_cast %[[VAL_11]] : tensor<5xf32> to !vhlo.tensor_v1<5x!vhlo.f32_v1>
+// CHECK:             "vhlo.return_v1"(%[[VAL_12]]) : (!vhlo.tensor_v1<5x!vhlo.f32_v1>) -> ()
+// CHECK:           }) : (!vhlo.tensor_v1<7x5x!vhlo.f32_v1>, !vhlo.tensor_v1<5x!vhlo.f32_v1>) -> !vhlo.tensor_v1<5x!vhlo.f32_v1>
+// CHECK:           "vhlo.return_v1"(%[[VAL_2]]) : (!vhlo.tensor_v1<5x!vhlo.f32_v1>) -> ()
+// CHECK:         }
+func.func @op_with_region_mixed_other_shlo_other(%arg0: tensor<7x5xf32>, %arg1: tensor<5xf32>) -> tensor<5xf32> {
+  %0 = stablehlo.reduce(%arg0 init: %arg1) across dimensions = [0] : (tensor<7x5xf32>, tensor<5xf32>) -> tensor<5xf32>
+    reducer(%arg2: tensor<5xf32>, %arg3: tensor<5xf32>)  {
+    %1 = arith.addf %arg2, %arg3 : tensor<5xf32>
+    %2 = stablehlo.add %1, %arg2 : tensor<5xf32>
+    %3 = arith.addf %2, %arg3 : tensor<5xf32>
+    stablehlo.return %3 : tensor<5xf32>
+  }
+  return %0 : tensor<5xf32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @op_with_region_mixed_shlo_other_shlo(
+// CHECK-SAME:                                                       %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<7x5x!vhlo.f32_v1>,
+// CHECK-SAME:                                                       %[[VAL_1:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<5x!vhlo.f32_v1>) -> (!vhlo.tensor_v1<5x!vhlo.f32_v1>) {
+// CHECK:           %[[VAL_2:.*]] = "vhlo.reduce_v1"(%[[VAL_0]], %[[VAL_1]]) <{dimensions = #{{.*}}<dense<0> : tensor<1xi64>>}> ({
+// CHECK:           ^bb0(%[[VAL_3:.*]]: !vhlo.tensor_v1<5x!vhlo.f32_v1>, %[[VAL_4:.*]]: !vhlo.tensor_v1<5x!vhlo.f32_v1>):
+// CHECK:             %[[VAL_5:.*]] = builtin.unrealized_conversion_cast %[[VAL_4]] : !vhlo.tensor_v1<5x!vhlo.f32_v1> to tensor<5xf32>
+// CHECK:             %[[VAL_6:.*]] = "vhlo.abs_v1"(%[[VAL_3]]) : (!vhlo.tensor_v1<5x!vhlo.f32_v1>) -> !vhlo.tensor_v1<5x!vhlo.f32_v1>
+// CHECK:             %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_6]] : !vhlo.tensor_v1<5x!vhlo.f32_v1> to tensor<5xf32>
+// CHECK:             %[[VAL_8:.*]] = arith.addf %[[VAL_7]], %[[VAL_5]] : tensor<5xf32>
+// CHECK:             %[[VAL_9:.*]] = builtin.unrealized_conversion_cast %[[VAL_8]] : tensor<5xf32> to !vhlo.tensor_v1<5x!vhlo.f32_v1>
+// CHECK:             %[[VAL_10:.*]] = "vhlo.abs_v1"(%[[VAL_9]]) : (!vhlo.tensor_v1<5x!vhlo.f32_v1>) -> !vhlo.tensor_v1<5x!vhlo.f32_v1>
+// CHECK:             "vhlo.return_v1"(%[[VAL_10]]) : (!vhlo.tensor_v1<5x!vhlo.f32_v1>) -> ()
+// CHECK:           }) : (!vhlo.tensor_v1<7x5x!vhlo.f32_v1>, !vhlo.tensor_v1<5x!vhlo.f32_v1>) -> !vhlo.tensor_v1<5x!vhlo.f32_v1>
+// CHECK:           "vhlo.return_v1"(%[[VAL_2]]) : (!vhlo.tensor_v1<5x!vhlo.f32_v1>) -> ()
+// CHECK:         }
+func.func @op_with_region_mixed_shlo_other_shlo(%arg0: tensor<7x5xf32>, %arg1: tensor<5xf32>) -> tensor<5xf32> {
+  %0 = stablehlo.reduce(%arg0 init: %arg1) across dimensions = [0] : (tensor<7x5xf32>, tensor<5xf32>) -> tensor<5xf32>
+    reducer(%arg2: tensor<5xf32>, %arg3: tensor<5xf32>)  {
+    %1 = stablehlo.abs %arg2 : tensor<5xf32>
+    %2 = arith.addf %1, %arg3 : tensor<5xf32>
+    %3 = stablehlo.abs %2 : tensor<5xf32>
+    stablehlo.return %3 : tensor<5xf32>
+  }
+  return %0 : tensor<5xf32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @stablehlo_in_other_op_region(
+// CHECK-SAME:                                               %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<2x!vhlo.f32_v1>,
+// CHECK-SAME:                                               %[[VAL_1:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.index_v1) -> (!vhlo.tensor_v1<2x!vhlo.f32_v1>) {
+// CHECK:           %[[VAL_2:.*]] = builtin.unrealized_conversion_cast %[[VAL_0]] : !vhlo.tensor_v1<2x!vhlo.f32_v1> to tensor<2xf32>
+// CHECK:           %[[VAL_3:.*]] = arith.constant 0 : index
+// CHECK:           %[[VAL_4:.*]] = arith.constant 1 : index
+// CHECK:           %[[VAL_5:.*]] = arith.constant 2 : index
+// CHECK:           %[[VAL_6:.*]] = arith.constant 0.000000e+00 : f32
+// CHECK:           %[[VAL_7:.*]] = scf.for %[[VAL_8:.*]] = %[[VAL_3]] to %[[VAL_5]] step %[[VAL_4]] iter_args(%[[VAL_9:.*]] = %[[VAL_2]]) -> (tensor<2xf32>) {
+// CHECK:             %[[VAL_10:.*]] = tensor.insert %[[VAL_6]] into %[[VAL_9]]{{\[}}%[[VAL_8]]] : tensor<2xf32>
+// CHECK:             %[[VAL_11:.*]] = builtin.unrealized_conversion_cast %[[VAL_10]] : tensor<2xf32> to !vhlo.tensor_v1<2x!vhlo.f32_v1>
+// CHECK:             %[[VAL_12:.*]] = "vhlo.add_v1"(%[[VAL_11]], %[[VAL_11]]) : (!vhlo.tensor_v1<2x!vhlo.f32_v1>, !vhlo.tensor_v1<2x!vhlo.f32_v1>) -> !vhlo.tensor_v1<2x!vhlo.f32_v1>
+// CHECK:             %[[VAL_13:.*]] = builtin.unrealized_conversion_cast %[[VAL_12]] : !vhlo.tensor_v1<2x!vhlo.f32_v1> to tensor<2xf32>
+// CHECK:             scf.yield %[[VAL_13]] : tensor<2xf32>
+// CHECK:           }
+// CHECK:           %[[VAL_14:.*]] = builtin.unrealized_conversion_cast %[[VAL_7]] : tensor<2xf32> to !vhlo.tensor_v1<2x!vhlo.f32_v1>
+// CHECK:           "vhlo.return_v1"(%[[VAL_14]]) : (!vhlo.tensor_v1<2x!vhlo.f32_v1>) -> ()
+// CHECK:         }
+func.func @stablehlo_in_other_op_region(%arg0: tensor<2xf32>, %arg1: index) -> tensor<2xf32> {
+  %c0 = arith.constant 0 : index
+  %c1 = arith.constant 1 : index
+  %c2 = arith.constant 2 : index
+  %cst = arith.constant 0.0 : f32
+
+  %for = scf.for %i = %c0 to %c2 step %c1 iter_args(%arg2 = %arg0) -> tensor<2xf32> {
+    %new_out = tensor.insert %cst into %arg2[%i] : tensor<2xf32>
+    %new_out_add = stablehlo.add %new_out, %new_out : tensor<2xf32>
+    scf.yield %new_out_add : tensor<2xf32>
+  }
+  return %for : tensor<2xf32>
+}
diff --ruN a/stablehlo/stablehlo/transforms/Passes.td b/stablehlo/stablehlo/transforms/Passes.td
--- stablehlo/stablehlo/transforms/Passes.td
+++ stablehlo/stablehlo/transforms/Passes.td
@@ -308,7 +308,26 @@
 
 def StablehloLegalizeToVhloPass : Pass<"stablehlo-legalize-to-vhlo", "ModuleOp"> {
   let summary = "Legalize StableHLO to VHLO.";
+  let description = [{
+    Legalize StableHLO to the latest version of ops in VHLO. These ops can then
+    be downgraded to older versions of VHLO for forward compatibility using
+    `VhloToVersionPass`.
+
+    ```mlir
+    stablehlo.exponential %[[ARG0]] <{result_accuracy = DEFAULT}> : tensor<f32>
+    # ====>
+    "vhlo.exponential_v2"(%[[ARG0]]) <{result_accuracy = #vhlo.DEFAULT_v1}> : !vhlo.tensor_v1<!vhlo.f32_v1>
+    ```
+
+    See [vhlo.md > The VHLO dialect](https://github.com/openxla/stablehlo/blob/main/docs/vhlo.md)
+    for full details on how VHLO is used to preserve forward and backward
+    compatibility.
+  }];
   let dependentDialects = ["mlir::vhlo::VhloDialect"];
+  let options = [
+    Option<"allowOtherDialects", "allow-other-dialects", "bool", /*default=*/"false",
+           "Allow serialization to use other (potentially unstable) dialects, inserts unrealized casts between dialects.">,
+  ];
 }
 
 def StablehloRefineArgumentsPass : Pass<"stablehlo-refine-arguments", "ModuleOp"> {
@@ -330,6 +349,7 @@
       %0 = stablehlo.custom_call @stablehlo.shape_refinement_operand_wrapper(%arg0, %c) {...}
         : (tensor<16xf32>, tensor<1xi64>) -> tensor<?xf32>
       ...
+    }
     ```
 
     The `refinedTypesOption` can be used to specify a list of refined types.
@@ -402,7 +422,23 @@
 }
 
 def VhloToVersionPass : Pass<"vhlo-to-version"> {
-  let summary = "Convert between versions of VHLO.";
+  let summary = "Convert between versions of VHLO for compatibility.";
+  let description = [{
+    Converts between versions of VHLO for IR upgrading and downgrading to
+    preserve forward and backward compatibility.
+
+    ```mlir
+    "vhlo.exponential_v2"(%[[ARG0]]) <{result_accuracy = DEFAULT}>
+    # ==( -target=1.0.0 )==>
+    "vhlo.exponential_v1"(%[[ARG0]])
+    # ==( -target=1.9.0 )==>
+    "vhlo.exponential_v2"(%[[ARG0]]) <{result_accuracy = DEFAULT}>
+    ```
+
+    See [vhlo.md > The VHLO dialect](https://github.com/openxla/stablehlo/blob/main/docs/vhlo.md)
+    for full details on how VHLO is used to preserve forward and backward
+    compatibility.
+  }];
   let options = [
     Option<"targetVersionOption", "target", "std::string", "",
            "The target version. Must be a version of the form #.#.# .">,
diff --ruN a/stablehlo/stablehlo/transforms/StablehloCompatibilityExpander.cpp b/stablehlo/stablehlo/transforms/StablehloCompatibilityExpander.cpp
--- stablehlo/stablehlo/transforms/StablehloCompatibilityExpander.cpp
+++ stablehlo/stablehlo/transforms/StablehloCompatibilityExpander.cpp
@@ -47,7 +47,7 @@
 #include "stablehlo/transforms/PassUtils.h"  // IWYU pragma: keep
 #include "stablehlo/transforms/Passes.h"
 
-#define DEBUG_TYPE "compat-passes"
+#define DEBUG_TYPE "stablehlo-compat"
 
 namespace mlir {
 namespace stablehlo {
diff --ruN a/stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp b/stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
--- stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
+++ stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
@@ -12,6 +12,7 @@
 limitations under the License.
 ==============================================================================*/
 
+#include <cstddef>
 #include <cstdint>
 #include <memory>
 #include <type_traits>
@@ -24,6 +25,8 @@
 #include "mlir/IR/Attributes.h"
 #include "mlir/IR/Builders.h"
 #include "mlir/IR/BuiltinAttributes.h"
+#include "mlir/IR/BuiltinDialect.h"
+#include "mlir/IR/BuiltinOps.h"
 #include "mlir/IR/BuiltinTypes.h"
 #include "mlir/IR/PatternMatch.h"
 #include "mlir/IR/ValueRange.h"
@@ -37,7 +40,7 @@
 #include "stablehlo/transforms/MapStablehloToVhlo.h"
 #include "stablehlo/transforms/Passes.h"
 
-#define DEBUG_TYPE "compat-passes"
+#define DEBUG_TYPE "stablehlo-compat"
 
 namespace mlir {
 namespace stablehlo {
@@ -53,17 +56,33 @@
 
 class StablehloToVhloTypeConverter : public vhlo::VhloTypeConverter {
  public:
-  StablehloToVhloTypeConverter() : vhlo::VhloTypeConverter() {
-    addConversion([](Type type) -> Type {
-      if (llvm::isa<vhlo::VhloDialect>(type.getDialect())) return type;
-
-      LLVM_DEBUG(llvm::dbgs() << "Invalid type: " << type << '\n');
+  StablehloToVhloTypeConverter(bool allowOtherDialects)
+      : vhlo::VhloTypeConverter() {
+    LLVM_DEBUG(
+        llvm::dbgs()
+        << "[StablehloToVhloTypeConverter] Creating with allowOtherDialects: "
+        << allowOtherDialects << '\n');
+
+    addConversion([&allowOtherDialects](Type type) -> Type {
+      if (isa<vhlo::VhloDialect>(type.getDialect())) return type;
+
+      if (allowOtherDialects &&
+          !isa<BuiltinDialect, StablehloDialect>(type.getDialect())) {
+        LLVM_DEBUG(llvm::dbgs()
+                   << "[StablehloToVhloTypeConverter] Valid non-VHLO type: "
+                   << type << '\n');
+        return type;
+      }
+
+      LLVM_DEBUG(llvm::dbgs() << "[StablehloToVhloTypeConverter] Invalid type: "
+                              << type << '\n');
       return {};
     });
     addConversion([](TokenType token) -> Type {
       return vhlo::TokenV1Type::get(token.getContext());
     });
     addBuiltinToVhloConversions();
+    if (allowOtherDialects) addUnrealizedMaterializations();
   }
 
   Attribute convertEncoding(Attribute attr) const final {
@@ -1021,14 +1040,27 @@
 struct StablehloLegalizeToVhloPass
     : public impl::StablehloLegalizeToVhloPassBase<
           StablehloLegalizeToVhloPass> {
+  using StablehloLegalizeToVhloPassBase::StablehloLegalizeToVhloPassBase;
+
   LogicalResult initialize(MLIRContext* context) override {
     target = std::make_shared<ConversionTarget>(*context);
     target->addIllegalDialect<stablehlo::StablehloDialect>();
     target->addIllegalDialect<func::FuncDialect>();
     target->addLegalDialect<vhlo::VhloDialect>();
+    LLVM_DEBUG(llvm::dbgs()
+               << "allowOtherDialects: " << allowOtherDialects << "\n");
+
+    converter =
+        std::make_shared<StablehloToVhloTypeConverter>(allowOtherDialects);
+    if (allowOtherDialects) {
+      target->addLegalOp<UnrealizedConversionCastOp>();
+    } else {
+      target->addIllegalOp<UnrealizedConversionCastOp>();
+    }
 
     RewritePatternSet patterns_(context);
-    stablehlo::populateStablehloToVhloPatterns(&patterns_, &converter, context);
+    stablehlo::populateStablehloToVhloPatterns(&patterns_, converter.get(),
+                                               context);
     patterns = std::move(patterns_);
 
     return success();
@@ -1043,7 +1075,7 @@
   }
 
  private:
-  StablehloToVhloTypeConverter converter;
+  std::shared_ptr<StablehloToVhloTypeConverter> converter;
   FrozenRewritePatternSet patterns;
   std::shared_ptr<ConversionTarget> target;
 };
diff --ruN a/stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp b/stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
--- stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
+++ stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
@@ -27,6 +27,7 @@
 #include "mlir/Dialect/Func/IR/FuncOps.h"
 #include "mlir/IR/Attributes.h"
 #include "mlir/IR/BuiltinAttributes.h"
+#include "mlir/IR/BuiltinOps.h"
 #include "mlir/IR/BuiltinTypeInterfaces.h"
 #include "mlir/IR/PatternMatch.h"
 #include "mlir/IR/ValueRange.h"
@@ -40,7 +41,7 @@
 #include "stablehlo/transforms/MapStablehloToVhlo.h"
 #include "stablehlo/transforms/Passes.h"
 
-#define DEBUG_TYPE "compat-passes"
+#define DEBUG_TYPE "stablehlo-compat"
 
 namespace mlir {
 namespace stablehlo {
@@ -63,6 +64,7 @@
       return stablehlo::TokenType::get(token.getContext());
     });
     addVhloToBuiltinConversions();
+    addUnrealizedMaterializations();
   }
 
   Attribute convertEncoding(Attribute attr) const final {
@@ -1021,6 +1023,36 @@
   }
 };
 
+// Fold unnecessary unrealized conversion casts.
+// unrealized_conversion(unrealized_conversion(X) : Y) : X -> X
+// Not as complicated at mlir::reconcileUnrealizedCasts because we know that the
+// types must be the same and shouldn't be in chains greater than 2.
+struct ReconcileUnrealizedConversionCasts
+    : public OpRewritePattern<UnrealizedConversionCastOp> {
+  using OpRewritePattern<UnrealizedConversionCastOp>::OpRewritePattern;
+  LogicalResult matchAndRewrite(UnrealizedConversionCastOp op,
+                                PatternRewriter& rewriter) const override {
+    SmallVector<UnrealizedConversionCastOp> unrealizedCasts(
+        op->getNumOperands() + 1);
+    unrealizedCasts.push_back(op);
+    for (auto operand : op.getOperands()) {
+      auto unrealizedOperand =
+          operand.getDefiningOp<UnrealizedConversionCastOp>();
+      if (!unrealizedOperand) {
+        LLVM_DEBUG(llvm::dbgs() << "Failed to reconcile unrealized conversion "
+                                   "casts: "
+                                << op.getOperationName() << "\n");
+        return success();
+      }
+      unrealizedCasts.push_back(unrealizedOperand);
+    }
+    LLVM_DEBUG(llvm::dbgs() << "Reconciling unrealized conversion casts: "
+                            << op.getOperationName() << "\n");
+    mlir::reconcileUnrealizedCasts(unrealizedCasts);
+    return success();
+  }
+};
+
 template <typename... StablehloOpTypes>
 void populateVhloToStablehloPatterns(RewritePatternSet* patterns,
                                      TypeConverter* converter,
@@ -1043,6 +1075,7 @@
 
     RewritePatternSet patterns_(context);
     stablehlo::populateVhloToStablehloPatterns(&patterns_, &converter, context);
+    patterns_.add<ReconcileUnrealizedConversionCasts>(context);
     patterns = std::move(patterns_);
 
     return success();
@@ -1055,6 +1088,12 @@
     if (failed(applyPartialConversion(getOperation(), *target, patterns))) {
       return signalPassFailure();
     }
+
+    // Cleanup unrealized conversion casts (if any, in case of dialect mixing)
+    SmallVector<UnrealizedConversionCastOp> ops;
+    getOperation().walk(
+        [&ops](UnrealizedConversionCastOp op) { ops.push_back(op); });
+    reconcileUnrealizedCasts(ops);
   }
 
  private:
diff --ruN a/stablehlo/stablehlo/transforms/VhloToVersion.cpp b/stablehlo/stablehlo/transforms/VhloToVersion.cpp
--- stablehlo/stablehlo/transforms/VhloToVersion.cpp
+++ stablehlo/stablehlo/transforms/VhloToVersion.cpp
@@ -40,7 +40,7 @@
 #include "stablehlo/dialect/VhloTypes.h"
 #include "stablehlo/transforms/Passes.h"
 
-#define DEBUG_TYPE "compat-passes"
+#define DEBUG_TYPE "stablehlo-compat"
 
 namespace mlir {
 namespace stablehlo {

