diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/StablehloToLinalgRandom.cpp b/stablehlo/stablehlo/conversions/linalg/transforms/StablehloToLinalgRandom.cpp
--- stablehlo/stablehlo/conversions/linalg/transforms/StablehloToLinalgRandom.cpp
+++ stablehlo/stablehlo/conversions/linalg/transforms/StablehloToLinalgRandom.cpp
@@ -313,26 +313,7 @@
 
 Value reshapeToTarget(OpBuilder &builder, Location loc, ShapedType destTy,
                       Value src) {
-  auto srcTy = cast<ShapedType>(src.getType());
-  // Expand out to the target shape.
-
-  auto reassociationIndices =
-      getReassociationIndicesForCollapse(destTy.getShape(), srcTy.getShape());
-  if (reassociationIndices.has_value()) {
-    src = builder.create<tensor::ExpandShapeOp>(loc, destTy, src,
-                                                reassociationIndices.value());
-  }
-
-  // It is also possible our target is Rank-0, then we would
-  // need to collapse.
-  reassociationIndices =
-      getReassociationIndicesForCollapse(srcTy.getShape(), destTy.getShape());
-  if (reassociationIndices.has_value()) {
-    src = builder.create<tensor::CollapseShapeOp>(loc, destTy, src,
-                                                  reassociationIndices.value());
-  }
-
-  return src;
+  return builder.create<stablehlo::ReshapeOp>(loc, destTy, src);
 }
 
 // Compute the shape for computing three fry.
diff --ruN a/stablehlo/stablehlo/dialect/Version.h b/stablehlo/stablehlo/dialect/Version.h
--- stablehlo/stablehlo/dialect/Version.h
+++ stablehlo/stablehlo/dialect/Version.h
@@ -38,7 +38,7 @@
   static FailureOr<Version> fromString(llvm::StringRef versionRef);
 
   /// Return a Version representing the current VHLO dialect version.
-  static Version getCurrentVersion() { return Version(1, 10, 10); }
+  static Version getCurrentVersion() { return Version(1, 11, 0); }
 
   /// Return a Version representing the minimum supported VHLO dialect version.
   static Version getMinimumVersion() { return Version(0, 9, 0); }
diff --ruN a/stablehlo/stablehlo/dialect/VhloAttrs.td b/stablehlo/stablehlo/dialect/VhloAttrs.td
--- stablehlo/stablehlo/dialect/VhloAttrs.td
+++ stablehlo/stablehlo/dialect/VhloAttrs.td
@@ -45,14 +45,6 @@
 def VHLO_ArrayAttrV1 : VHLO_AttrDef<"ArrayV1", "0.9.0", "current"> {
   let mnemonic = "array_v1";
   let parameters = (ins ArrayRefParameter<"mlir::Attribute">:$value);
-  let genVerifyDecl = 1;
-  let extraClassDefinition = [{
-    LogicalResult ArrayV1Attr::verify(
-        llvm::function_ref<mlir::InFlightDiagnostic ()> errFn, ArrayRef<mlir::Attribute> value) {
-      if (!allFromVhlo(value)) return errFn() << "expected array of VHLO attriutes";
-      return success();
-    }
-  }];
   let assemblyFormat = "`<` custom<AttributeArray>($value) `>`";
 }
 
@@ -75,9 +67,9 @@
     LogicalResult DictionaryV1Attr::verify(
         llvm::function_ref<mlir::InFlightDiagnostic ()> errFn,
         ArrayRef<std::pair<mlir::Attribute, mlir::Attribute>> value) {
-      for (auto & entry : value)
-        if (!isFromVhlo(entry.first) || !isFromVhlo(entry.second))
-          errFn() << "expected VHLO attribute";
+      for (auto & entry : value) {
+        if (!isFromVhlo(entry.first)) errFn() << "expected VHLO key attribute";
+      }
       return success();
     }
   }];
diff --ruN a/stablehlo/stablehlo/dialect/VhloDialect.td b/stablehlo/stablehlo/dialect/VhloDialect.td
--- stablehlo/stablehlo/dialect/VhloDialect.td
+++ stablehlo/stablehlo/dialect/VhloDialect.td
@@ -49,6 +49,7 @@
       1.8.0: Introduce `f4E2M1FN`, `f6E2M3FN`, `f6E3M2FN` and `f8E8M0FNU` types.
       1.9.0: Add `ResultAccuracy` attribute to `exp` op.
       1.10.0: Add `ResultAccuracy` attribute to `cbrt`, `cosine`, `exponential`, `exponential_minus_one`, `log`, `log_plus_one`, `logistic`, `rsqrt`, `sine`, `sqrt`, `tan` and `tanh` ops.
+      1.11.0: Allow (de)serializing VHLO programs mixed with potentially unstable dialects.
   }];
 
   let useDefaultAttributePrinterParser = 0;
diff --ruN a/stablehlo/stablehlo/dialect/VhloTypes.h b/stablehlo/stablehlo/dialect/VhloTypes.h
--- stablehlo/stablehlo/dialect/VhloTypes.h
+++ stablehlo/stablehlo/dialect/VhloTypes.h
@@ -27,20 +27,23 @@
 namespace mlir {
 namespace vhlo {
 
-class VhloTypeConverterBase : public TypeConverter {
- public:
-  VhloTypeConverterBase() : TypeConverter(){};
-
-  virtual ~VhloTypeConverterBase() = default;
-
-  virtual Attribute convertEncoding(Attribute attr) const = 0;
-};
 
 // This class is used to manage conversions between VHLO and Builtin
 // dialects.
-class VhloTypeConverter : public VhloTypeConverterBase {
+class VhloTypeConverter : public TypeConverter {
  public:
-  VhloTypeConverter() : VhloTypeConverterBase() {}
+  VhloTypeConverter() : TypeConverter(), allowOtherDialects(false) {}
+  VhloTypeConverter(bool allowOtherDialects)
+      : TypeConverter(), allowOtherDialects(allowOtherDialects) {}
+
+  virtual ~VhloTypeConverter() = default;
+
+  virtual Attribute convertEncoding(Attribute attr) const = 0;
+
+  Attribute convertUnknownAttribute(Attribute attr) const {
+    if (allowOtherDialects) return attr;
+    return {};
+  }
 
   // A subclass can call this method to add conversions from VHLO -> Builtin
   // types. Note that conversions are applied in reverse order, with the most
@@ -58,6 +61,9 @@
 
   // Mark unrealized casts as legal. Useful for dialect mixing.
   void addUnrealizedMaterializations();
+
+ private:
+  bool allowOtherDialects;
 };
 
 // Autogenerated VHLO type printers and parsers.
diff --ruN a/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir b/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir
--- stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir
+++ stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir
@@ -1,4 +1,4 @@
-// RUN: stablehlo-opt --stablehlo-aggressive-folder --split-input-file --verify-diagnostics %s | FileCheck %s
+// RUN: stablehlo-opt --stablehlo-aggressive-folder=fold-op-element-limit=100 --split-input-file --verify-diagnostics %s | FileCheck %s
 
 ////////
 // AddOp
@@ -42,6 +42,21 @@
 // -----
 
 ////////
+// ClampOp
+
+// CHECK-LABEL: func.func @clamp_fold
+func.func @clamp_fold(%arg0: tensor<3xi32>) -> tensor<3xi32> {
+  %min = stablehlo.constant dense<[1, 5, 10]> : tensor<3xi32>
+  %max = stablehlo.constant dense<[10, 25, 12]> : tensor<3xi32>
+  %operand = stablehlo.constant dense<[0, 30, 11]> : tensor<3xi32>
+  // CHECK: stablehlo.constant dense<[1, 25, 11]> : tensor<3xi32>
+  %0 = "stablehlo.clamp"(%min, %operand, %max) : (tensor<3xi32>, tensor<3xi32>, tensor<3xi32>) -> tensor<3xi32>
+  func.return %0: tensor<3xi32>
+}
+
+// -----
+
+////////
 // CompareOp
 
 // CHECK-LABEL: func.func @compare_folds
@@ -98,6 +113,26 @@
   // CHECK-DAG:  [[R3:%.+]] = stablehlo.constant dense<{{\[\[0, 1, 2, 11, 12\], \[3, 4, 5, 13, 14\]\]}}> : tensor<2x5xi32>
   // CHECK-NEXT: return [[R0]], [[R1]], [[R2]], [[R3]]
   return %0, %1, %2, %3 : tensor<6xi32>, tensor<3xi32>, tensor<3x3xi32>, tensor<2x5xi32>
+}
+
+// -----
+
+////////
+// DivOp
+
+// CHECK-LABEL: @div_fold_cst
+func.func @div_fold_cst() -> (tensor<i32>, tensor<ui32>, tensor<f32>) {
+  %cst = stablehlo.constant dense<2> : tensor<i32>
+  %cst_1 = stablehlo.constant dense<2> : tensor<ui32>
+  %cst_2 = stablehlo.constant dense<2.0> : tensor<f32>
+  // CHECK: stablehlo.constant dense<1> : tensor<i32>
+  // CHECK: stablehlo.constant dense<1> : tensor<ui32>
+  // CHECK: stablehlo.divide{{.*}} : tensor<f32>
+  // DISABLED-CHECK: stablehlo.constant dense<1.0{{.*}}> : tensor<f32>
+  %0 = stablehlo.divide %cst, %cst : tensor<i32>
+  %1 = stablehlo.divide %cst_1, %cst_1 : tensor<ui32>
+  %2 = stablehlo.divide %cst_2, %cst_2 : tensor<f32>
+  return %0, %1, %2 : tensor<i32>, tensor<ui32>, tensor<f32>
 }
 
 // -----
diff --ruN a/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_simplification.mlir b/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_simplification.mlir
--- stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_simplification.mlir
+++ stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_simplification.mlir
@@ -1,4 +1,4 @@
-// RUN: stablehlo-opt --stablehlo-aggressive-simplification --allow-unregistered-dialect --split-input-file %s | FileCheck %s
+// RUN: stablehlo-opt --stablehlo-aggressive-simplification=fold-op-element-limit=100 --allow-unregistered-dialect --split-input-file %s | FileCheck %s
 
 /////////
 // AddOp
diff --ruN a/stablehlo/stablehlo/tests/transforms/stablehlo_refine_shapes.mlir b/stablehlo/stablehlo/tests/transforms/stablehlo_refine_shapes.mlir
--- stablehlo/stablehlo/tests/transforms/stablehlo_refine_shapes.mlir
+++ stablehlo/stablehlo/tests/transforms/stablehlo_refine_shapes.mlir
@@ -521,16 +521,16 @@
 // -----
 
 // CHECK-LABEL: func @eval_slice_zerorank
-func.func @eval_slice_zerorank() -> tensor<f32> {
-  // CHECK: [[RESULT:%.*]] = stablehlo.constant dense<3.300000e+01> : tensor<f32>
-  // CHECK: return [[RESULT]]
-  %0 = stablehlo.constant dense<33.0> : tensor<f32>
+func.func @eval_slice_zerorank() -> tensor<i32> {
+  // CHECK: [[RESULT:%.*]] = stablehlo.constant dense<33> : tensor<i32>
+  // CHECK: return [[RESULT]]
+  %0 = stablehlo.constant dense<33> : tensor<i32>
   %1 = "stablehlo.slice"(%0) {
     start_indices = array<i64>,
     limit_indices = array<i64>,
     strides = array<i64>
-  } : (tensor<f32>) -> tensor<f32>
-  func.return %1 : tensor<f32>
+  } : (tensor<i32>) -> tensor<i32>
+  func.return %1 : tensor<i32>
 }
 
 // -----
diff --ruN a/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir b/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
--- stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
+++ stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo_mixed.mlir
@@ -5,15 +5,9 @@
 // about what constitutes a good test! The CHECK should be
 // minimized and named to reflect the test intent.
 
-// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
-
-// The script is designed to make adding checks to
-// a test case fast, it is *not* designed to be authoritative
-// minimized and named to reflect the test intent.
-
-// RUN: stablehlo-opt %s --stablehlo-legalize-to-vhlo=allow-other-dialects | FileCheck %s
+// RUN: stablehlo-opt %s --stablehlo-legalize-to-vhlo=allow-other-dialects --mlir-print-local-scope | FileCheck %s
 // RUN: stablehlo-opt %s > %t.0
-// RUN: stablehlo-opt %s --stablehlo-legalize-to-vhlo=allow-other-dialects | stablehlo-opt --vhlo-legalize-to-stablehlo > %t.1
+// RUN: stablehlo-translate %s --serialize --target=1.0.0 --allow-other-dialects | stablehlo-translate --deserialize | stablehlo-opt > %t.1
 // RUN: diff %t.0 %t.1
 
 // CHECK-LABEL:   vhlo.func_v1 @op_other(
@@ -26,6 +20,34 @@
 func.func @op_other(%arg0: tensor<f32>) -> tensor<f32> {
   %0 = arith.addf %arg0, %arg0 : tensor<f32>
   return %0 : tensor<f32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @func_attributes(
+// CHECK-SAME:                                  %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>) {
+// CHECK:           "vhlo.return_v1"(%[[VAL_0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:          } {arg_attrs = #vhlo.array_v1<[]>, builtin.map = affine_map<(d0) -> (d0)>, mhlo.sharding = #vhlo.string_v1<"{replicated}">, res_attrs = #vhlo.array_v1<[]>, sym_visibility = #vhlo.string_v1<"">}
+func.func @func_attributes(%arg0: tensor<f32>) -> tensor<f32> attributes {
+  mhlo.sharding = "{replicated}",
+  builtin.map = affine_map<(d0) -> (d0)>
+} {
+  return %arg0 : tensor<f32>
+}
+
+// -----
+
+// CHECK-LABEL:   vhlo.func_v1 @func_mixed_attributes(
+// CHECK-SAME:                                        %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>) {
+// CHECK:           "vhlo.return_v1"(%[[VAL_0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
+// CHECK:         }
+// CHECK-SAME:    vhlo.mixed_array = #vhlo.array_v1<[affine_map<(d0) -> (d0)>, #vhlo.string_v1<"STR_ATTR">]>
+// CHECK-SAME:    vhlo.mixed_dict = #vhlo.dict_v1<{#vhlo.string_v1<"affine_map"> = affine_map<(d0) -> (d0)>, #vhlo.string_v1<"str_attr"> = #vhlo.string_v1<"STR_ATTR">}
+func.func @func_mixed_attributes(%arg0: tensor<f32>) -> tensor<f32> attributes {
+  vhlo.mixed_array = [affine_map<(d0) -> (d0)>, "STR_ATTR"],
+  vhlo.mixed_dict = {affine_map = affine_map<(d0) -> (d0)>, str_attr = "STR_ATTR"}
+} {
+  return %arg0 : tensor<f32>
 }
 
 // -----
diff --ruN a/stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir b/stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
--- stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
+++ stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
@@ -1,17 +1,8 @@
 // RUN: stablehlo-opt --vhlo-to-version=target=1.9.0 -verify-diagnostics --split-input-file %s
 
-func.func @invalid_array_element() -> () attributes {
-  // expected-error @+1 {{expected array of VHLO attriutes}}
-  vhlo.attr = #vhlo.array_v1<[#stablehlo<precision DEFAULT>]>
-} {
-  return
-}
-
-// -----
-
 func.func @invalid_dict_element_value() -> () attributes {
-  // expected-error @+1 {{expected VHLO attribute}}
-  vhlo.attr = #vhlo.dict_v1<{#vhlo.string_v1<"attr1"> = 3 : i32}>
+  // expected-error @+1 {{expected VHLO key attribute}}
+  vhlo.attr = #vhlo.dict_v1<{"attr1" = #vhlo.array_v1<[]>}>
 } {
   return
 }
diff --ruN a/stablehlo/stablehlo/tools/StablehloTranslateMain.cpp b/stablehlo/stablehlo/tools/StablehloTranslateMain.cpp
--- stablehlo/stablehlo/tools/StablehloTranslateMain.cpp
+++ stablehlo/stablehlo/tools/StablehloTranslateMain.cpp
@@ -76,6 +76,11 @@
     "target", llvm::cl::desc("Target version for serialization"),
     llvm::cl::init(""));
 
+llvm::cl::opt<bool> allowOtherDialectsOption(
+    "allow-other-dialects",
+    llvm::cl::desc("Allow mixed dialect in serialization"),
+    llvm::cl::init(false));
+
 llvm::cl::opt<std::string> argsOption(
     "args", llvm::cl::desc("Arguments to pass to the interpreter"),
     llvm::cl::init(""));
@@ -317,7 +322,8 @@
           return module.emitError("failed to strip debuginfo");
       }
 
-      return stablehlo::serializePortableArtifact(module, targetVersion, os);
+      return stablehlo::serializePortableArtifact(
+          module, targetVersion, os, allowOtherDialectsOption.getValue());
     },
     [](DialectRegistry &registry) {
       mlir::registerAllDialects(registry);
diff --ruN a/stablehlo/stablehlo/transforms/Passes.h b/stablehlo/stablehlo/transforms/Passes.h
--- stablehlo/stablehlo/transforms/Passes.h
+++ stablehlo/stablehlo/transforms/Passes.h
@@ -35,6 +35,7 @@
 #include "mlir/Transforms/DialectConversion.h"
 #include "stablehlo/dialect/StablehloOps.h"
 #include "stablehlo/dialect/Version.h"
+#include "stablehlo/dialect/VhloTypes.h"
 
 namespace mlir {
 namespace stablehlo {
@@ -54,17 +55,17 @@
 // Populates StableHLO ops to VHLO ops rewriting patterns.
 void populateStablehloToVhloPatterns(MLIRContext *context,
                                      RewritePatternSet *patterns,
-                                     TypeConverter *converter);
+                                     vhlo::VhloTypeConverter *converter);
 
 // Populates VHLO ops to StableHLO ops rewriting patterns.
 void populateVhloToStablehloPatterns(MLIRContext *context,
                                      RewritePatternSet *patterns,
-                                     TypeConverter *converter);
+                                     vhlo::VhloTypeConverter *converter);
 
 // Populates VHLO downgrade rewriting patterns.
 void populateVhloToVersionPatterns(MLIRContext *context,
                                    RewritePatternSet *patterns,
-                                   TypeConverter *converter);
+                                   vhlo::VhloTypeConverter *converter);
 
 /// Collection of rewrite patterns for lowering of CHLO ops to StableHLO and
 /// Shape ops.
diff --ruN a/stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp b/stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
--- stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
+++ stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
@@ -57,7 +57,7 @@
 class StablehloToVhloTypeConverter : public vhlo::VhloTypeConverter {
  public:
   StablehloToVhloTypeConverter(bool allowOtherDialects)
-      : vhlo::VhloTypeConverter() {
+      : vhlo::VhloTypeConverter(allowOtherDialects) {
     LLVM_DEBUG(
         llvm::dbgs()
         << "[StablehloToVhloTypeConverter] Creating with allowOtherDialects: "
@@ -82,7 +82,15 @@
       return vhlo::TokenV1Type::get(token.getContext());
     });
     addBuiltinToVhloConversions();
-    if (allowOtherDialects) addUnrealizedMaterializations();
+    if (allowOtherDialects) {
+      addUnrealizedMaterializations();
+
+      // Attribute conversion fallback uses the type converter.
+      addTypeAttributeConversion(
+          [](Type, Attribute attr) -> TypeConverter::AttributeConversionResult {
+            return attr;
+          });
+    }
   }
 
   Attribute convertEncoding(Attribute attr) const final {
@@ -114,7 +122,7 @@
   return vhlo::Name##Version##Attr::get(attr.getContext(), vhloValue.value())
 
 Attribute convertGeneric(Attribute stablehloAttr,
-                         const TypeConverter* typeConverter) {
+                         const vhlo::VhloTypeConverter* typeConverter) {
   LLVM_DEBUG(llvm::dbgs() << "Convert generic: " << stablehloAttr << '\n');
 
   // Handle StableHLO attributes.
@@ -241,6 +249,10 @@
     return vhlo::TypeV1Attr::get(attr.getContext(), vhloType);
   }
 
+  // Fall back to type converter for unknown attributes.
+  auto unknownAttr = typeConverter->convertUnknownAttribute(stablehloAttr);
+  if (unknownAttr) return unknownAttr;
+
   LLVM_DEBUG(llvm::dbgs() << "Failed to convert: " << stablehloAttr << '\n');
   return {};  // Failed to convert attribute.
 }
@@ -268,13 +280,15 @@
 Attribute convertBool(const ConversionPattern& pattern, int64_t stablehloDim) {
   auto stablehloType = IntegerType::get(pattern.getContext(), 1);
   auto stablehloAttr = IntegerAttr::get(stablehloType, stablehloDim);
-  return convertGeneric(stablehloAttr, pattern.getTypeConverter());
+  return convertGeneric(stablehloAttr,
+                        pattern.getTypeConverter<vhlo::VhloTypeConverter>());
 }
 
 Attribute convertInt(const ConversionPattern& pattern, int64_t stablehloDim) {
   auto stablehloType = IntegerType::get(pattern.getContext(), 64);
   auto stablehloAttr = IntegerAttr::get(stablehloType, stablehloDim);
-  return convertGeneric(stablehloAttr, pattern.getTypeConverter());
+  return convertGeneric(stablehloAttr,
+                        pattern.getTypeConverter<vhlo::VhloTypeConverter>());
 }
 
 Attribute convertInts(const ConversionPattern& pattern,
@@ -282,7 +296,8 @@
   auto stablehloType = RankedTensorType::get(
       stablehloDims.size(), IntegerType::get(pattern.getContext(), 64));
   auto stablehloAttr = DenseIntElementsAttr::get(stablehloType, stablehloDims);
-  return convertGeneric(stablehloAttr, pattern.getTypeConverter());
+  return convertGeneric(stablehloAttr,
+                        pattern.getTypeConverter<vhlo::VhloTypeConverter>());
 }
 
 Attribute convertSymbol(const ConversionPattern& pattern,
@@ -290,7 +305,7 @@
   auto stablehloSymbolAttr = dyn_cast<FlatSymbolRefAttr>(stablehloAttr);
   if (!stablehloSymbolAttr) return {};
   return convertGeneric(stablehloSymbolAttr.getAttr(),
-                        pattern.getTypeConverter());
+                        pattern.getTypeConverter<vhlo::VhloTypeConverter>());
 }
 
 SpecialResult convertChannelHandle(const ConversionPattern& pattern,
@@ -445,15 +460,15 @@
   vhloAttrs.emplace_back(
       StringAttr::get(pattern.getContext(), "lhs_precision_type"),
       convertGeneric(TypeAttr::get(attr.getLhsPrecisionType()),
-                     pattern.getTypeConverter()));
+                     pattern.getTypeConverter<vhlo::VhloTypeConverter>()));
   vhloAttrs.emplace_back(
       StringAttr::get(pattern.getContext(), "rhs_precision_type"),
       convertGeneric(TypeAttr::get(attr.getRhsPrecisionType()),
-                     pattern.getTypeConverter()));
+                     pattern.getTypeConverter<vhlo::VhloTypeConverter>()));
   vhloAttrs.emplace_back(
       StringAttr::get(pattern.getContext(), "accumulation_type"),
       convertGeneric(TypeAttr::get(attr.getAccumulationType()),
-                     pattern.getTypeConverter()));
+                     pattern.getTypeConverter<vhlo::VhloTypeConverter>()));
 
   // Components
   auto vhloLhsComponentCount = convertInt(pattern, attr.getLhsComponentCount());
@@ -712,7 +727,9 @@
   auto addDefaultAttr = [&](StringRef vhloName, Attribute stablehloAttr) {
     vhloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), vhloName),
-        convertGeneric(stablehloAttr, pattern.getTypeConverter()));
+        convertGeneric(
+            stablehloAttr,
+            pattern.template getTypeConverter<vhlo::VhloTypeConverter>()));
   };
   if constexpr (std::is_same<StablehloOpTy, func::FuncOp>::value) {
     if (!stablehloOp.getSymVisibilityAttr())
@@ -987,8 +1004,9 @@
         case SpecialResult::SPECIAL_FAILURE:
           return failure();
         case SpecialResult::NOT_SPECIAL:
-          auto vhloAttr = convertGeneric(stablehloAttr.getValue(),
-                                         this->getTypeConverter());
+          auto vhloAttr = convertGeneric(
+              stablehloAttr.getValue(),
+              this->template getTypeConverter<vhlo::VhloTypeConverter>());
           if (!vhloAttr) return failure();
           vhloAttrs.push_back({stablehloAttr.getName(), vhloAttr});
           break;
@@ -1075,14 +1093,14 @@
   }
 
  private:
-  std::shared_ptr<StablehloToVhloTypeConverter> converter;
+  std::shared_ptr<vhlo::VhloTypeConverter> converter;
   FrozenRewritePatternSet patterns;
   std::shared_ptr<ConversionTarget> target;
 };
 
 void populateStablehloToVhloPatterns(MLIRContext* context,
                                      RewritePatternSet* patterns,
-                                     TypeConverter* converter) {
+                                     vhlo::VhloTypeConverter* converter) {
   populateStablehloToVhloPatterns<
 #define GET_OP_LIST
 #include "stablehlo/dialect/StablehloOps.cpp.inc"
diff --ruN a/stablehlo/stablehlo/transforms/StablehloRefineShapes.cpp b/stablehlo/stablehlo/transforms/StablehloRefineShapes.cpp
--- stablehlo/stablehlo/transforms/StablehloRefineShapes.cpp
+++ stablehlo/stablehlo/transforms/StablehloRefineShapes.cpp
@@ -16,6 +16,7 @@
 
 #include <cstddef>
 #include <cstdint>
+#include <limits>
 #include <tuple>
 #include <utility>
 
@@ -1038,8 +1039,11 @@
   // Populate additional patterns for StableHLO extensions.
   state.addAdditionalPatterns(patterns);
 
+  // No float folding and fold as much as possible. Shape refinement will fail
+  // if int shape computations are unable to be folded.
   StablehloAggressiveFolderPassOptions folderOptions;
   folderOptions.optimizeFloat = false;
+  folderOptions.foldOpElementLimit = std::numeric_limits<int64_t>::max();
 
   // The folding patterns implement partial evaluation of shape computations
   // which is a critical part of implementing type refinement for ops like
diff --ruN a/stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp b/stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
--- stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
+++ stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
@@ -57,7 +57,10 @@
 
 class VhloToStablehloTypeConverter : public vhlo::VhloTypeConverter {
  public:
-  VhloToStablehloTypeConverter() : vhlo::VhloTypeConverter() {
+  // Safe to allow other dialects since the StableHLO->VHLO conversion guards
+  // the legality of types / attributes.
+  VhloToStablehloTypeConverter()
+      : vhlo::VhloTypeConverter(/*allowOtherDialects=*/true) {
     addConversion([](Type type) -> Type { return type; });
     addConversion([](vhlo::TokenV1Type token) -> Type {
       LLVM_DEBUG(llvm::dbgs() << "Converting TokenType\n");
@@ -90,7 +93,7 @@
   return stablehlo::Name##Attr::get(attr.getContext(), stablehloValue.value())
 
 Attribute convertGeneric(Attribute vhloAttr,
-                         const TypeConverter* typeConverter) {
+                         const vhlo::VhloTypeConverter* typeConverter) {
   LLVM_DEBUG(llvm::dbgs() << "Converting attr " << vhloAttr);
   if (auto vhloAttrs = dyn_cast<vhlo::ArrayV1Attr>(vhloAttr)) {
     SmallVector<Attribute> stablehloAttrs;
@@ -189,6 +192,10 @@
     // All VHLO attributes must have counterparts in StableHLO.
     return {};
   }
+
+  // Fall back to type converter for unknown attributes.
+  auto unknownAttr = typeConverter->convertUnknownAttribute(vhloAttr);
+  if (unknownAttr) return unknownAttr;
 
   // This should be unreachable unless program is a mix of VHLO and other
   // dialects, e.g. due to user edits to textual assembly format.
@@ -229,7 +236,7 @@
 }
 
 LogicalResult convertTypeAttr(Attribute vhloAttr, Type& result,
-                              const TypeConverter* typeConverter) {
+                              const vhlo::VhloTypeConverter* typeConverter) {
   auto stablehloAttr = convertGeneric(vhloAttr, typeConverter);
   if (!stablehloAttr || !isa<TypeAttr>(stablehloAttr)) return failure();
   result = cast<TypeAttr>(stablehloAttr).getValue();
@@ -244,7 +251,7 @@
 }
 
 LogicalResult convertInts(Attribute vhloAttr,
-                          const TypeConverter* typeConverter,
+                          const vhlo::VhloTypeConverter* typeConverter,
                           SmallVector<int64_t>& result) {
   auto vhloTensorAttr = dyn_cast<vhlo::TensorV1Attr>(vhloAttr);
   if (!vhloTensorAttr) return failure();
@@ -256,7 +263,7 @@
 }
 
 Attribute convertSymbol(Attribute vhloAttr,
-                        const TypeConverter* typeConverter) {
+                        const vhlo::VhloTypeConverter* typeConverter) {
   auto vhloStringAttr = dyn_cast<vhlo::StringV1Attr>(vhloAttr);
   if (!vhloStringAttr) return {};
   auto stablehloStringAttr = dyn_cast_or_null<StringAttr>(
@@ -267,7 +274,7 @@
 
 template <typename OpType>
 Attribute convertChannelHandle(OpType vhloOp,
-                               const TypeConverter* typeConverter) {
+                               const vhlo::VhloTypeConverter* typeConverter) {
   int64_t channelId, channelType;
   if (failed(convertInt(vhloOp.getChannelId(), channelId)) ||
       failed(convertInt(vhloOp.getChannelType(), channelType)))
@@ -277,7 +284,7 @@
 }
 
 Attribute convertChannelId(Attribute vhloAttr,
-                           const TypeConverter* typeConverter) {
+                           const vhlo::VhloTypeConverter* typeConverter) {
   int64_t channelId;
   if (failed(convertInt(vhloAttr, channelId))) return {};
   return stablehlo::ChannelHandleAttr::get(vhloAttr.getContext(), channelId,
@@ -285,8 +292,8 @@
 }
 
 template <typename OpType>
-Attribute convertConvDimensionNumbers(OpType vhloOp,
-                                      const TypeConverter* typeConverter) {
+Attribute convertConvDimensionNumbers(
+    OpType vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   int64_t stablehloInputBatchDimension, stablehloInputFeatureDimension;
   SmallVector<int64_t> stablehloInputSpatialDimensions;
   int64_t stablehloKernelInputFeatureDimension,
@@ -323,7 +330,7 @@
 }
 
 Attribute convertCustomCallCalledComputations(
-    Attribute vhloAttr, const TypeConverter* typeConverter) {
+    Attribute vhloAttr, const vhlo::VhloTypeConverter* typeConverter) {
   if (auto vhloArrayAttr = dyn_cast<vhlo::ArrayV1Attr>(vhloAttr)) {
     SmallVector<Attribute> stablehloAttrs;
     for (auto vhloAttr : vhloArrayAttr.getValue()) {
@@ -336,8 +343,8 @@
   return {};
 }
 
-FailureOr<Attribute> convertDotAlgorithm(vhlo::DotGeneralOpV2 vhloOp,
-                                         const TypeConverter* typeConverter) {
+FailureOr<Attribute> convertDotAlgorithm(
+    vhlo::DotGeneralOpV2 vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   Type lhsPrecisionType, rhsPrecisionType, accumulationType;
   if (isNoneType(vhloOp.getLhsComponentCount())) {
     // All must be nonetype
@@ -373,8 +380,8 @@
       numPrimitiveOperations, allowImpreciseAccumulation);
 }
 
-Attribute convertDotDimensionNumbers(vhlo::DotGeneralOpV2 vhloOp,
-                                     const TypeConverter* typeConverter) {
+Attribute convertDotDimensionNumbers(
+    vhlo::DotGeneralOpV2 vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   SmallVector<int64_t> stablehloLhsBatchingDimensions,
       stablehloRhsBatchingDimensions, stablehloLhsContractingDimensions,
       stablehloRhsContractingDimensions;
@@ -394,13 +401,13 @@
 }
 
 Attribute convertFuncCallee(Attribute vhloAttr,
-                            const TypeConverter* typeConverter) {
+                            const vhlo::VhloTypeConverter* typeConverter) {
   return convertSymbol(vhloAttr, typeConverter);
 }
 
 template <typename OpType>
-Attribute convertGatherDimensionNumbers(OpType vhloOp,
-                                        const TypeConverter* typeConverter) {
+Attribute convertGatherDimensionNumbers(
+    OpType vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   SmallVector<int64_t> stablehloOffsetDims, stablehloCollapsedSliceDims,
       stablehloOperandBatchingDims, stablehloStartIndicesBatchingDims,
       stablehloStartIndexMap;
@@ -423,8 +430,8 @@
       stablehloStartIndexMap, stablehloIndexVectorDim);
 }
 
-Attribute convertScatterDimensionNumbers(vhlo::ScatterOpV2 vhloOp,
-                                         const TypeConverter* typeConverter) {
+Attribute convertScatterDimensionNumbers(
+    vhlo::ScatterOpV2 vhloOp, const vhlo::VhloTypeConverter* typeConverter) {
   SmallVector<int64_t> stablehloUpdateWindowDims, stablehloInsertedWindowDims,
       stablehloInputBatchingDims, stablehloScatterIndicesBatchingDims,
       stablehloScatterDimsToOperandDims;
@@ -463,10 +470,11 @@
                              VhloOpTy vhloOp,
                              SmallVector<NamedAttribute>& vhloAttrs,
                              SmallVector<NamedAttribute>& stablehloAttrs) {
+  auto typeConverter =
+      pattern.template getTypeConverter<vhlo::VhloTypeConverter>();
   if constexpr (std::is_same<VhloOpTy, vhlo::ConvolutionOpV1>::value ||
                 std::is_same<VhloOpTy, vhlo::DynamicConvOpV2>::value) {
-    auto stablehloAttr =
-        convertConvDimensionNumbers(vhloOp, pattern.getTypeConverter());
+    auto stablehloAttr = convertConvDimensionNumbers(vhloOp, typeConverter);
     if (!stablehloAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "dimension_numbers"),
@@ -480,7 +488,7 @@
   if constexpr (std::is_same<VhloOpTy, vhlo::DotGeneralOpV2>::value) {
     // Dot Dimension Numbers
     auto stablehloDotDimAttr =
-        convertDotDimensionNumbers(vhloOp, pattern.getTypeConverter());
+        convertDotDimensionNumbers(vhloOp, typeConverter);
     if (!stablehloDotDimAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "dot_dimension_numbers"),
@@ -489,8 +497,7 @@
                "lhs_contracting_dimensions", "rhs_contracting_dimensions");
 
     // Dot Algorithm
-    auto stablehloDotAlgorithmAttr =
-        convertDotAlgorithm(vhloOp, pattern.getTypeConverter());
+    auto stablehloDotAlgorithmAttr = convertDotAlgorithm(vhloOp, typeConverter);
     if (failed(stablehloDotAlgorithmAttr)) return failure();
     if (stablehloDotAlgorithmAttr.value())
       stablehloAttrs.emplace_back(
@@ -503,8 +510,7 @@
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::DynamicGatherOpV2>::value ||
                 std::is_same<VhloOpTy, vhlo::GatherOpV2>::value) {
-    auto stablehloAttr =
-        convertGatherDimensionNumbers(vhloOp, pattern.getTypeConverter());
+    auto stablehloAttr = convertGatherDimensionNumbers(vhloOp, typeConverter);
     if (!stablehloAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "dimension_numbers"),
@@ -514,8 +520,7 @@
                "start_index_map", "index_vector_dim");
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::ScatterOpV2>::value) {
-    auto stablehloAttr =
-        convertScatterDimensionNumbers(vhloOp, pattern.getTypeConverter());
+    auto stablehloAttr = convertScatterDimensionNumbers(vhloOp, typeConverter);
     if (!stablehloAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "scatter_dimension_numbers"),
@@ -526,8 +531,7 @@
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::RecvOpV1>::value ||
                 std::is_same<VhloOpTy, vhlo::SendOpV1>::value) {
-    auto stablehloAttr =
-        convertChannelHandle(vhloOp, pattern.getTypeConverter());
+    auto stablehloAttr = convertChannelHandle(vhloOp, typeConverter);
     if (!stablehloAttr) return failure();
     stablehloAttrs.emplace_back(
         StringAttr::get(pattern.getContext(), "channel_handle"), stablehloAttr);
@@ -537,7 +541,7 @@
 }
 
 template <typename T, typename DenseArrayAttr>
-SpecialResult convertDenseArray(const TypeConverter* typeConverter,
+SpecialResult convertDenseArray(const vhlo::VhloTypeConverter* typeConverter,
                                 StringAttr vhloName, Attribute vhloAttr,
                                 SmallVector<NamedAttribute>& stablehloAttrs) {
   auto tensorAttr = dyn_cast<vhlo::TensorV1Attr>(vhloAttr);
@@ -556,15 +560,15 @@
 }
 
 SpecialResult convertDenseBoolArray(
-    const TypeConverter* typeConverter, StringAttr vhloName, Attribute vhloAttr,
-    SmallVector<NamedAttribute>& stablehloAttrs) {
+    const vhlo::VhloTypeConverter* typeConverter, StringAttr vhloName,
+    Attribute vhloAttr, SmallVector<NamedAttribute>& stablehloAttrs) {
   return convertDenseArray<bool, DenseBoolArrayAttr>(typeConverter, vhloName,
                                                      vhloAttr, stablehloAttrs);
 }
 
 SpecialResult convertDenseI64Array(
-    const TypeConverter* typeConverter, StringAttr vhloName, Attribute vhloAttr,
-    SmallVector<NamedAttribute>& stablehloAttrs) {
+    const vhlo::VhloTypeConverter* typeConverter, StringAttr vhloName,
+    Attribute vhloAttr, SmallVector<NamedAttribute>& stablehloAttrs) {
   return convertDenseArray<int64_t, DenseI64ArrayAttr>(
       typeConverter, vhloName, vhloAttr, stablehloAttrs);
 }
@@ -575,7 +579,8 @@
                              SmallVector<NamedAttribute>& stablehloAttrs) {
   StringAttr stablehloName = vhloName;
   Attribute stablehloAttr;
-  auto typeConverter = pattern.getTypeConverter();
+  auto typeConverter =
+      pattern.template getTypeConverter<vhlo::VhloTypeConverter>();
 
   if constexpr (std::is_same<VhloOpTy, vhlo::AllGatherOpV2>::value ||
                 std::is_same<VhloOpTy, vhlo::AllReduceOpV2>::value ||
@@ -585,7 +590,7 @@
                 std::is_same<VhloOpTy, vhlo::CollectiveBroadcastOpV1>::value) {
     if (vhloName == "channel_id") {
       stablehloName = StringAttr::get(pattern.getContext(), "channel_handle");
-      stablehloAttr = convertChannelId(vhloAttr, pattern.getTypeConverter());
+      stablehloAttr = convertChannelId(vhloAttr, typeConverter);
       if (!stablehloAttr) return specialFailure();
     }
     if (vhloName == "use_global_device_ids") {
@@ -597,20 +602,20 @@
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::CustomCallOpV1>::value) {
     if (vhloName == "called_computations") {
-      stablehloAttr = convertCustomCallCalledComputations(
-          vhloAttr, pattern.getTypeConverter());
+      stablehloAttr =
+          convertCustomCallCalledComputations(vhloAttr, typeConverter);
       if (!stablehloAttr) return specialFailure();
     }
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::CompositeOpV1>::value) {
     if (vhloName == "decomposition") {
-      stablehloAttr = convertSymbol(vhloAttr, pattern.getTypeConverter());
+      stablehloAttr = convertSymbol(vhloAttr, typeConverter);
       if (!stablehloAttr) return specialFailure();
     }
   }
   if constexpr (std::is_same<VhloOpTy, vhlo::CallOpV1>::value) {
     if (vhloName == "callee") {
-      stablehloAttr = convertFuncCallee(vhloAttr, pattern.getTypeConverter());
+      stablehloAttr = convertFuncCallee(vhloAttr, typeConverter);
       if (!stablehloAttr) return specialFailure();
     }
   }
@@ -760,8 +765,8 @@
 template <typename T>
 bool isSplatTensor(const ConversionPattern& pattern, Attribute vhloAttr,
                    T splatValue) {
-  auto attr = dyn_cast_or_null<DenseElementsAttr>(
-      convertGeneric(vhloAttr, pattern.getTypeConverter()));
+  auto attr = dyn_cast_or_null<DenseElementsAttr>(convertGeneric(
+      vhloAttr, pattern.getTypeConverter<vhlo::VhloTypeConverter>()));
   return attr && attr.isSplat() &&
          attr.template getSplatValue<T>() == splatValue;
 }
@@ -977,8 +982,9 @@
         case SpecialResult::SPECIAL_FAILURE:
           return failure();
         case SpecialResult::NOT_SPECIAL:
-          auto stablehloAttr =
-              convertGeneric(vhloAttr.getValue(), this->getTypeConverter());
+          auto stablehloAttr = convertGeneric(
+              vhloAttr.getValue(),
+              this->template getTypeConverter<vhlo::VhloTypeConverter>());
           if (!stablehloAttr) return failure();
           stablehloAttrs.push_back({vhloAttr.getName(), stablehloAttr});
           break;
@@ -1056,7 +1062,7 @@
 template <typename... StablehloOpTypes>
 void populateVhloToStablehloPatterns(MLIRContext* context,
                                      RewritePatternSet* patterns,
-                                     TypeConverter* converter) {
+                                     vhlo::VhloTypeConverter* converter) {
   patterns
       ->add<VhloToStablehloOpConverter<StablehloToVhloOp<StablehloOpTypes>>...>(
           *converter, context);
@@ -1104,7 +1110,7 @@
 
 void populateVhloToStablehloPatterns(MLIRContext* context,
                                      RewritePatternSet* patterns,
-                                     TypeConverter* converter) {
+                                     vhlo::VhloTypeConverter* converter) {
   populateVhloToStablehloPatterns<
 #define GET_OP_LIST
 #include "stablehlo/dialect/StablehloOps.cpp.inc"
diff --ruN a/stablehlo/stablehlo/transforms/VhloToVersion.cpp b/stablehlo/stablehlo/transforms/VhloToVersion.cpp
--- stablehlo/stablehlo/transforms/VhloToVersion.cpp
+++ stablehlo/stablehlo/transforms/VhloToVersion.cpp
@@ -56,15 +56,23 @@
 
 // Currently there are no type-to-version conversions so this class
 // simply validates that all types are from the VHLO dialect.
-class VhloToVersionConverter : public TypeConverter {
+class VhloToVersionConverter : public VhloTypeConverter {
  public:
-  VhloToVersionConverter() : TypeConverter() {
-    addConversion([](Type type) -> Type {
-      if (llvm::isa<vhlo::VhloDialect>(type.getDialect())) return type;
-      LLVM_DEBUG(llvm::dbgs() << "Invalid type: " << type << '\n');
-      return {};
+  // Safe to allow other dialects since the StableHLO->VHLO conversion guards
+  // the legality of types / attributes.
+  VhloToVersionConverter() : VhloTypeConverter(/*allowOtherDialects=*/true) {
+    addConversion([&](Type type) -> Type {
+      if (llvm::isa<vhlo::VhloDialect>(type.getDialect())) {
+        // Once a type becomes versioned we will check the version here.
+        return type;
+      }
+
+      LLVM_DEBUG(llvm::dbgs() << "Not VHLO type, allowed: " << type << '\n');
+      return type;
     });
   }
+
+  Attribute convertEncoding(Attribute attr) const override { return attr; };
 };
 
 // Check user-specified target version. Emit error if invalid.
@@ -111,6 +119,10 @@
 LogicalResult isLegalType(Type type, const Version& targetVersion);
 
 LogicalResult isLegalAttribute(const Attribute& attr, Version targetVersion) {
+  // StableHLO->VHLO conversion guards the legality of types / attributes.
+  // Other dialect types that make it past that step are valid here.
+  if (!mlir::isa<vhlo::VhloDialect>(attr.getDialect())) return success();
+
   auto attrInterface = dyn_cast<VersionedAttrInterface>(attr);
   if (!attrInterface || !isLegalVersion(attrInterface, targetVersion)) {
     LLVM_DEBUG(llvm::dbgs() << "failed to legalize attribute " << attr
@@ -119,10 +131,11 @@
   }
 
   // Recursively check attrs if VHLO attr is a container
-  if (auto arrAttr = dyn_cast<ArrayV1Attr>(attr))
+  if (auto arrAttr = dyn_cast<ArrayV1Attr>(attr)) {
     return success(llvm::all_of(arrAttr.getValue(), [&](Attribute ele) {
       return succeeded(isLegalAttribute(ele, targetVersion));
     }));
+  }
   if (auto arrAttr = dyn_cast<DictionaryV1Attr>(attr)) {
     return success(llvm::all_of(
         arrAttr.getValue(), [&](std::pair<Attribute, Attribute> entry) {
@@ -146,6 +159,10 @@
 }
 
 LogicalResult isLegalType(Type type, const Version& targetVersion) {
+  // StableHLO->VHLO conversion guards the legality of types / attributes.
+  // Other dialect types that make it past that step are valid here.
+  if (!mlir::isa<vhlo::VhloDialect>(type.getDialect())) return success();
+
   // All valid VHLO types must have versioned type interface.
   auto typeInterface = dyn_cast<VersionedTypeInterface>(type);
   if (!typeInterface || !isLegalVersion(typeInterface, targetVersion)) {
@@ -170,10 +187,11 @@
       return failure();
     return isLegalType(ranked.getElementType(), targetVersion);
   }
-  if (auto tuple = dyn_cast<TupleV1Type>(type))
+  if (auto tuple = dyn_cast<TupleV1Type>(type)) {
     return success(llvm::all_of(tuple.getTypes(), [&](Type ele) {
       return succeeded(isLegalType(ele, targetVersion));
     }));
+  }
   if (auto quant = dyn_cast<UniformQuantizedV1Type>(type))
     return success(
         succeeded(isLegalType(quant.getStorageType(), targetVersion)) &&
@@ -213,7 +231,7 @@
 bool isLegalOperation(Operation* op, const Version& targetVersion) {
   // Validate op
   auto opInterface = dyn_cast<VersionedOpInterface>(op);
-  if (!opInterface) return false;
+  if (!opInterface) return true;
   if (!isLegalVersion(opInterface, targetVersion)) return false;
   LLVM_DEBUG(llvm::dbgs() << "Legal op version for target. " << op << '\n');
 
@@ -454,7 +472,7 @@
 namespace stablehlo {
 void populateVhloToVersionPatterns(MLIRContext* context,
                                    RewritePatternSet* patterns,
-                                   TypeConverter* converter) {
+                                   vhlo::VhloTypeConverter* converter) {
   vhlo::populateWithGenerated(*patterns);
   patterns->add<vhlo::ScatterOpV1ToV2, vhlo::ScatterOpV2ToV1>(context);
   patterns->add<vhlo::AllReduceOpV1ToV2, vhlo::AllReduceOpV2ToV1>(context);
diff --ruN a/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFolder.cpp b/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFolder.cpp
--- stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFolder.cpp
+++ stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFolder.cpp
@@ -19,6 +19,7 @@
 #include <memory>
 #include <numeric>
 #include <optional>
+#include <string>
 #include <utility>
 
 #include "llvm/ADT/APInt.h"
@@ -47,6 +48,7 @@
 #include "mlir/IR/TypeUtilities.h"
 #include "mlir/IR/Types.h"
 #include "mlir/IR/Value.h"
+#include "mlir/IR/ValueRange.h"
 #include "mlir/Interfaces/SideEffectInterfaces.h"
 #include "mlir/Pass/Pass.h"
 #include "mlir/Rewrite/FrozenRewritePatternSet.h"
@@ -98,29 +100,88 @@
   return success();
 }
 
+template <typename Fn>
+static TypedAttr foldUnaryOpIntOrFloat(Type resultType, TypedAttr operand,
+                                       Fn&& folder) {
+  Type elemTy = getElementTypeOrSelf(operand);
+
+  Attribute res;
+  if (isa<IntegerType>(elemTy))
+    res = constFoldUnaryOp<IntegerAttr, IntegerAttr::ValueType, void>(operand,
+                                                                      folder);
+  if (isa<FloatType>(elemTy))
+    res = constFoldUnaryOp<FloatAttr, FloatAttr::ValueType, void>(operand,
+                                                                  folder);
+  if (res) return cast<TypedAttr>(res);
+
+  return nullptr;
+}
+
 /// Binary constant folder that used a generic folder function to handle both
 /// ints and floats.
 template <typename Fn>
-static TypedAttr foldBinaryOpIntOrFloat(TypedAttr lhs, TypedAttr rhs,
-                                        Fn&& folder) {
+FailureOr<TypedAttr> foldUnaryOpIntOrFloat(PatternRewriter& rewriter,
+                                            Operation* op, Fn&& folder) {
+  if (op->getNumOperands() != 1 || op->getNumResults() != 1)
+    return rewriter.notifyMatchFailure(op, "expected unary op");
+
+  TypedAttr attr;
+  matchPattern(op->getOperand(0), m_Constant(&attr));
+
+  if (!attr) return rewriter.notifyMatchFailure(op, "operand not constants");
+
+  TypedAttr res = foldUnaryOpIntOrFloat(op->getResultTypes()[0], attr, folder);
+  if (!res) return rewriter.notifyMatchFailure(op, "folding failed");
+
+  return res;
+}
+
+/// Binary constant folder that used a generic folder function to handle both
+/// ints and floats.
+template <typename Fn>
+static TypedAttr foldBinaryOpIntOrFloat(Type resultType, TypedAttr lhs,
+                                        TypedAttr rhs, Fn&& folder) {
   Attribute operands[2] = {lhs, rhs};
   Type elemTy = getElementTypeOrSelf(lhs);
 
   Attribute res;
   if (isa<IntegerType>(elemTy))
-    res = constFoldBinaryOp<IntegerAttr, IntegerAttr::ValueType, void>(operands,
-                                                                       folder);
+    res = constFoldBinaryOp<IntegerAttr, IntegerAttr::ValueType, void>(
+        operands, resultType, folder);
   if (isa<FloatType>(elemTy))
-    res = constFoldBinaryOp<FloatAttr, FloatAttr::ValueType, void>(operands,
-                                                                   folder);
+    res = constFoldBinaryOp<FloatAttr, FloatAttr::ValueType, void>(
+        operands, resultType, folder);
   if (res) return cast<TypedAttr>(res);
 
   return nullptr;
+}
+
+
+/// Binary constant folder that used a generic folder function to handle both
+/// ints and floats.
+template <typename Fn>
+FailureOr<TypedAttr> foldBinaryOpIntOrFloat(PatternRewriter& rewriter,
+                                            Operation* op, Fn&& folder) {
+  if (op->getNumOperands() != 2 || op->getNumResults() != 1)
+    return rewriter.notifyMatchFailure(op, "expected binary op");
+
+  TypedAttr lhsAttr, rhsAttr;
+  matchPattern(op->getOperand(0), m_Constant(&lhsAttr));
+  matchPattern(op->getOperand(1), m_Constant(&rhsAttr));
+
+  if (!lhsAttr || !rhsAttr)
+    return rewriter.notifyMatchFailure(op, "lhs & rhs operands not constants");
+
+  TypedAttr res =
+      foldBinaryOpIntOrFloat(op->getResultTypes()[0], lhsAttr, rhsAttr, folder);
+  if (!res) return rewriter.notifyMatchFailure(op, "folding failed");
+
+  return res;
 }
 
 template <class AttrElementT, class TargetAttrElementT, class CalculationT,
           typename OpType>
-LogicalResult evalConvertHelper(PatternRewriter& rewriter, OpType op,
+LogicalResult foldConvertHelper(PatternRewriter& rewriter, OpType op,
                                 DenseIntOrFPElementsAttr elements, Type resType,
                                 CalculationT&& calculate) {
   auto result = constFoldCastOp<AttrElementT, TargetAttrElementT,
@@ -128,18 +189,19 @@
                                 typename TargetAttrElementT::ValueType, void>(
       elements, resType, calculate);
 
-  if (!result)
+  if (!result) {
     return rewriter.notifyMatchFailure(op, [&](Diagnostic& diag) {
       diag << "cast of " << elements.getElementType() << " to " << resType
            << " failed";
     });
+  }
 
   rewriter.replaceOpWithNewOp<ConstantOp>(op, result);
   return success();
 }
 
 template <typename OpType>
-LogicalResult evalConvert(PatternRewriter& rewriter, OpType op,
+LogicalResult foldConvert(PatternRewriter& rewriter, OpType op,
                           DenseIntOrFPElementsAttr elements,
                           RankedTensorType resultType) {
   auto oldType = getElementTypeOrSelf(elements);
@@ -153,7 +215,7 @@
     if (auto newFloatType = dyn_cast<FloatType>(newType)) {
       // Float -> Float
       const auto& targetSemantics = newFloatType.getFloatSemantics();
-      return evalConvertHelper<FloatAttr, FloatAttr>(
+      return foldConvertHelper<FloatAttr, FloatAttr>(
           rewriter, op, elements, resultType,
           [&targetSemantics](const APFloat& operand, bool& castStatus) {
             bool losesInfo;
@@ -167,7 +229,7 @@
     }
 
     // Float -> Int
-    return evalConvertHelper<FloatAttr, IntegerAttr>(
+    return foldConvertHelper<FloatAttr, IntegerAttr>(
         rewriter, op, elements, resultType,
         [&newBitWidth, &isNewTypeUnsigned](const APFloat& operand,
                                            bool& castStatus) {
@@ -186,7 +248,7 @@
 
   if (auto newFloatType = dyn_cast<FloatType>(newType)) {
     // Int -> Float
-    return evalConvertHelper<IntegerAttr, FloatAttr>(
+    return foldConvertHelper<IntegerAttr, FloatAttr>(
         rewriter, op, elements, resultType,
         [&newFloatType, &isOldTypeUnsigned](const APInt& operand,
                                             bool& /*castStatus*/) {
@@ -199,64 +261,12 @@
   }
 
   // Int -> Int
-  return evalConvertHelper<IntegerAttr, IntegerAttr>(
+  return foldConvertHelper<IntegerAttr, IntegerAttr>(
       rewriter, op, elements, resultType,
       [&newBitWidth, &isOldTypeUnsigned](const APInt& operand,
                                          bool& /*castStatus*/) {
         return APSInt(operand, isOldTypeUnsigned).extOrTrunc(newBitWidth);
       });
-}
-
-// The patterns below implement partial evaluation of shape computations which
-// is a critical part of implementing type refinement for ops like
-// dynamic_broadcast_in_dim, dynamic_iota and dynamic_reshape whose shape
-// depends on the value of their shape operands.
-
-template <typename OpType, typename FuncType>
-LogicalResult evalElementwise(PatternRewriter& rewriter, OpType op,
-                              FuncType fn) {
-  auto resultType = op.getType();
-  if (failed(validateStaticShapeResult(rewriter, op, resultType)))
-    return failure();
-
-  if (!isa<IntegerType>(resultType.getElementType()))
-    return rewriter.notifyMatchFailure(op,
-                                       "expected integer result tensor type");
-
-  SmallVector<APSInt> result;
-  if constexpr (OpType::template hasTrait<OpTrait::OneOperand>()) {
-    SmallVector<APSInt> operand;
-    if (failed(hlo::matchInts(op.getOperand(), operand)))
-      return rewriter.notifyMatchFailure(op, "expected constant operand");
-    for (const auto& operandEl : operand) {
-      result.push_back(fn(operandEl));
-    }
-  } else if constexpr (OpType::template hasTrait<
-                           OpTrait::NOperands<2>::Impl>()) {
-    SmallVector<APSInt> lhs, rhs;
-    if (failed(hlo::matchInts(op.getLhs(), lhs)) ||
-        failed(hlo::matchInts(op.getRhs(), rhs)))
-      return rewriter.notifyMatchFailure(op, "expected constant operands");
-    for (auto [lhsEl, rhsEl] : llvm::zip(lhs, rhs)) {
-      result.push_back(fn(lhsEl, rhsEl));
-    }
-  } else if constexpr (OpType::template hasTrait<
-                           OpTrait::NOperands<3>::Impl>()) {
-    SmallVector<APSInt> x, y, z;
-    if (failed(hlo::matchInts(op->getOperand(0), x)) ||
-        failed(hlo::matchInts(op->getOperand(1), y)) ||
-        failed(hlo::matchInts(op->getOperand(2), z)))
-      return rewriter.notifyMatchFailure(op, "expected constant operands");
-    for (auto [xEl, yEl, zEl] : llvm::zip(x, y, z)) {
-      result.push_back(fn(xEl, yEl, zEl));
-    }
-  } else {
-    llvm::report_fatal_error("unsupported number of operands");
-  }
-
-  rewriter.replaceOpWithNewOp<ConstantOp>(op,
-                                          getTensorAttr(resultType, result));
-  return success();
 }
 
 template <typename OpType>
@@ -275,29 +285,18 @@
                        ArrayRef<StringRef> generatedNames = {}) = delete;
 
   const StablehloAggressiveFolderPassOptions& options;
-};
-
-struct FoldAddOpPattern final : FoldOpRewritePattern<mlir::stablehlo::AddOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
-
-  LogicalResult matchAndRewrite(mlir::stablehlo::AddOp op,
-                                PatternRewriter& rewriter) const override {
-    Value lhs = op.getLhs();
-    Value rhs = op.getRhs();
-
-    // Pattern: add(cst,cst) -> cst
-    TypedAttr lhsAttr, rhsAttr;
-    matchPattern(lhs, m_Constant(&lhsAttr));
-    matchPattern(rhs, m_Constant(&rhsAttr));
-
-    if (TypedAttr res;
-        lhsAttr && rhsAttr &&
-        (res = foldBinaryOpIntOrFloat(lhsAttr, rhsAttr, std::plus<>{}))) {
-      rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res);
-      return success();
-    }
-
-    return failure();
+
+  LogicalResult validateElementCountForFold(PatternRewriter& rewriter,
+                                            Operation* op,
+                                            ShapedType resultType) const {
+    size_t numElems = resultType.getNumElements();
+    if (numElems > static_cast<size_t>(options.foldOpElementLimit))
+      return rewriter.notifyMatchFailure(
+          op,
+          "too many elements, fold "
+          "limit is " +
+              std::to_string(options.foldOpElementLimit));
+    return success();
   }
 };
 
@@ -318,100 +317,102 @@
   }
 };
 
-struct EvalAddOpShapePattern : public FoldOpRewritePattern<AddOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
-
-  LogicalResult matchAndRewrite(AddOp op,
-                                PatternRewriter& rewriter) const override {
-    return evalElementwise(rewriter, op,
-                           [&](APSInt lhs, APSInt rhs) { return lhs + rhs; });
-  }
-};
-
-struct EvalAndOpPattern : public FoldOpRewritePattern<AndOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
-
-  LogicalResult matchAndRewrite(AndOp op,
-                                PatternRewriter& rewriter) const override {
+struct FoldAddOpPattern final
+    : public ShapeOpRewritePattern<mlir::stablehlo::AddOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
+
+  LogicalResult matchAndRewrite(mlir::stablehlo::AddOp op,
+                                PatternRewriter& rewriter) const override {
+    if (failed(validateShapeFoldDtype(rewriter, op, op.getType())))
+      return failure();
+
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, std::plus<>{});
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+};
+
+struct FoldAndOpPattern : public ShapeOpRewritePattern<AndOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
+
+  LogicalResult matchAndRewrite(mlir::stablehlo::AndOp op,
+                                PatternRewriter& rewriter) const override {
+    // TODO: Support more int types
     auto resultType = op.getType();
     if (!resultType.getElementType().isInteger(1))
       return rewriter.notifyMatchFailure(op, "expected boolean element type");
 
-    return evalElementwise(rewriter, op, [&](APSInt lhsInt, APSInt rhsInt) {
-      return getAPSInt(resultType.getElementType(), lhsInt != 0 && rhsInt != 0);
-    });
-  }
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, FoldAnd{});
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+
+  struct FoldAnd {
+    APInt operator()(APInt lhs, APInt rhs) const {
+      return APInt(lhs.getBitWidth(), !lhs.isZero() && !rhs.isZero());
+    }
+    std::optional<APFloat> operator()(APFloat lhs, APFloat rhs) const {
+      return std::nullopt;
+    }
+  };
 };
 
 // Pattern: broadcast_in_dim(splat, _) -> constant(splat)
-struct FoldBroadcastInDimSplatPattern final
-    : FoldOpRewritePattern<mlir::stablehlo::BroadcastInDimOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
-
-  LogicalResult matchAndRewrite(mlir::stablehlo::BroadcastInDimOp op,
-                                PatternRewriter& rewriter) const override {
-    TypedValue<RankedTensorType> operand = op.getOperand();
-
-    if (SplatElementsAttr cstAttr;
-        matchPattern(operand, m_Constant(&cstAttr))) {
-      rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(
-          op, SplatElementsAttr::get(op.getType(),
-                                     cstAttr.getSplatValue<Attribute>()));
-      return success();
-    }
-    return failure();
-  }
-};
-
-struct EvalBroadcastInDimOpPattern
-    : public FoldOpRewritePattern<BroadcastInDimOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+struct FoldBroadcastInDimOpSplatPattern
+    : public ShapeOpRewritePattern<BroadcastInDimOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(BroadcastInDimOp op,
                                 PatternRewriter& rewriter) const override {
     auto resultType = op.getType();
-    if (failed(validateStaticShapeResult(rewriter, op, resultType)))
-      return failure();
-
-    auto operandType = op.getOperand().getType();
-    if (operandType.getRank() != 0)
-      return rewriter.notifyMatchFailure(op, "expected 0-dimensional type");
-
-    SmallVector<APSInt> operand;
-    if (failed(hlo::matchInts(op.getOperand(), operand)))
-      return rewriter.notifyMatchFailure(op, "expected constant operands");
-    auto scalar = operand[0];
-
-    rewriter.replaceOpWithNewOp<ConstantOp>(
-        op, getTensorAttr(op.getType(), scalar));
-    return success();
-  }
-};
-
-struct EvalClampOpPattern : public FoldOpRewritePattern<ClampOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
-
-  LogicalResult matchAndRewrite(ClampOp op,
-                                PatternRewriter& rewriter) const override {
-    return evalElementwise(rewriter, op,
-                           [&](APSInt min, APSInt operand, APSInt max) {
-                             if (operand < min) return min;
-                             if (max < operand) return max;
-                             return operand;
-                           });
-  }
-};
-
-struct EvalCompareOpPattern : public FoldOpRewritePattern<CompareOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    if (failed(validateStaticShapeResult(rewriter, op, resultType)) ||
+        failed(validateShapeFoldDtype(rewriter, op, resultType)))
+      return failure();
+
+    SplatElementsAttr cstAttr;
+    matchPattern(op.getOperand(), m_Constant(&cstAttr));
+    if (!cstAttr) return rewriter.notifyMatchFailure(op, "operand not splat");
+
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(
+        op, SplatElementsAttr::get(op.getType(),
+                                   cstAttr.getSplatValue<Attribute>()));
+    return success();
+  }
+};
+
+struct FoldCompareOpPattern : public ShapeOpRewritePattern<CompareOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(CompareOp op,
                                 PatternRewriter& rewriter) const override {
     auto resultType = op.getType();
-    auto kind = op.getCompareType();
-    return evalElementwise(rewriter, op, [&](APInt lhs, APInt rhs) {
+    if (failed(validateShapeFoldDtype(rewriter, op, resultType)))
+      return failure();
+
+    auto res = foldBinaryOpIntOrFloat(
+        rewriter, op,
+        FoldCompare(op.getComparisonDirection(), op.getCompareType()));
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+
+  struct FoldCompare {
+    FoldCompare(ComparisonDirection direction,
+                std::optional<ComparisonType> kind)
+        : direction(direction), kind(kind) {}
+    ComparisonDirection direction;
+    std::optional<ComparisonType> kind;
+
+    // TODO: Enable float folding.
+    std::optional<APFloat> operator()(APFloat lhs, APFloat rhs) {
+      return std::nullopt;
+    }
+    APInt operator()(APInt lhs, APInt rhs) {
       bool result = false;
-      switch (op.getComparisonDirection()) {
+      switch (direction) {
         case ComparisonDirection::EQ:
           result = lhs == rhs;
           break;
@@ -431,9 +432,9 @@
           result = kind == ComparisonType::SIGNED ? lhs.slt(rhs) : lhs.ult(rhs);
           break;
       }
-      return getAPSInt(resultType.getElementType(), result);
-    });
-  }
+      return APInt(/*bitwidth=*/1, result);
+    }
+  };
 };
 
 //////////////////////////////////
@@ -441,16 +442,15 @@
 /////////////////////////////////
 
 struct FoldConcatenateOpPattern final
-    : FoldOpRewritePattern<mlir::stablehlo::ConcatenateOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    : ShapeOpRewritePattern<mlir::stablehlo::ConcatenateOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(mlir::stablehlo::ConcatenateOp op,
                                 PatternRewriter& rewriter) const override {
     RankedTensorType type = op.getType();
-    if (!type.hasStaticShape()) return failure();
-
-    size_t numElems = type.getNumElements();
-    if (numElems > static_cast<size_t>(options.foldOpElementLimit))
+    if (failed(validateStaticShapeResult(rewriter, op, type)) ||
+        failed(validateShapeFoldDtype(rewriter, op, type)) ||
+        failed(validateElementCountForFold(rewriter, op, type)))
       return failure();
 
     // Fold concatenate when all inputs are constants.
@@ -466,6 +466,7 @@
                                       int64_t{1}, std::multiplies<>{});
 
     SmallVector<Attribute> newElems;
+    size_t numElems = type.getNumElements();
     newElems.reserve(numElems);
 
     for (int64_t i = 0; i != topSize; ++i) {
@@ -485,31 +486,7 @@
   int64_t foldOpElementLimit;
 };
 
-struct EvalConcatenateOpPattern : public FoldOpRewritePattern<ConcatenateOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
-
-  LogicalResult matchAndRewrite(ConcatenateOp op,
-                                PatternRewriter& rewriter) const override {
-    auto resultType = op.getType();
-    if (failed(validateStaticShapeResult(rewriter, op, resultType)))
-      return failure();
-
-    if (op.getDimension() != 0)
-      return rewriter.notifyMatchFailure(op, "expected dimension = 0");
-
-    SmallVector<APSInt> result;
-    for (Value operand : op->getOperands()) {
-      if (failed(hlo::matchInts(operand, result)))
-        return rewriter.notifyMatchFailure(op, "expected constant operands");
-    }
-
-    rewriter.replaceOpWithNewOp<ConstantOp>(op,
-                                            getTensorAttr(resultType, result));
-    return success();
-  }
-};
-
-struct EvalConvertOpPattern : public ShapeOpRewritePattern<ConvertOp> {
+struct FoldConvertOpPattern : public ShapeOpRewritePattern<ConvertOp> {
   using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(ConvertOp op,
@@ -532,28 +509,50 @@
       return rewriter.notifyMatchFailure(
           op, "expected constant integer or float operand");
 
-    return evalConvert(rewriter, op, elements, resultType);
-  }
-};
-
-struct EvalDivOpPattern : public FoldOpRewritePattern<DivOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    return foldConvert(rewriter, op, elements, resultType);
+  }
+};
+
+struct FoldDivOpPattern : public ShapeOpRewritePattern<DivOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(DivOp op,
                                 PatternRewriter& rewriter) const override {
-    return evalElementwise(rewriter, op,
-                           [&](APSInt lhs, APSInt rhs) { return lhs / rhs; });
-  }
-};
-
-struct EvalGetDimensionSizeOpPattern
-    : public FoldOpRewritePattern<GetDimensionSizeOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    auto resultType = op.getType();
+    if (failed(validateShapeFoldDtype(rewriter, op, resultType)))
+      return failure();
+
+    bool isUnsignedInt = resultType.getElementType().isUnsignedInteger();
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, FoldDivide(isUnsignedInt));
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+
+  struct FoldDivide {
+    FoldDivide(bool isUnsignedInt)
+        : foldIntFn(isUnsignedInt ? foldUint : foldSint) {}
+    std::function<APInt(APInt, APInt)> foldIntFn;
+
+    // TODO: Enable float folding.
+    std::optional<APFloat> operator()(APFloat lhs, APFloat rhs) {
+      return std::nullopt;  // return lhs / rhs;
+    }
+    APInt operator()(APInt lhs, APInt rhs) { return foldIntFn(lhs, rhs); }
+    static APInt foldUint(APInt lhs, APInt rhs) { return lhs.udiv(rhs); }
+    static APInt foldSint(APInt lhs, APInt rhs) { return lhs.sdiv(rhs); }
+  };
+};
+
+struct FoldGetDimensionSizeOpPattern
+    : public ShapeOpRewritePattern<GetDimensionSizeOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(GetDimensionSizeOp op,
                                 PatternRewriter& rewriter) const override {
     auto resultType = op.getType();
-    if (failed(validateStaticShapeResult(rewriter, op, resultType)))
+    if (failed(validateStaticShapeResult(rewriter, op, resultType)) ||
+        failed(validateShapeFoldDtype(rewriter, op, resultType)))
       return failure();
 
     auto operandType = op.getOperand().getType();
@@ -567,86 +566,187 @@
   }
 };
 
-struct EvalMaxOpPattern : public FoldOpRewritePattern<MaxOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+/////
+// Max/Min/Clamp
+/////
+
+struct FoldMax {
+  FoldMax(bool isUnsignedInt)
+      : foldIntFn(isUnsignedInt ? foldUint : foldSint) {}
+  std::function<APInt(APInt, APInt)> foldIntFn;
+
+  // TODO: Enable float folding.
+  std::optional<APFloat> operator()(APFloat lhs, APFloat rhs) {
+    return std::nullopt;  // return lhs >= rhs ? lhs : rhs;
+  }
+  APInt operator()(APInt lhs, APInt rhs) { return foldIntFn(lhs, rhs); }
+  static APInt foldUint(APInt lhs, APInt rhs) {
+    return lhs.uge(rhs) ? lhs : rhs;
+  }
+  static APInt foldSint(APInt lhs, APInt rhs) {
+    return lhs.sge(rhs) ? lhs : rhs;
+  }
+};
+
+struct FoldMin {
+  FoldMin(bool isUnsignedInt)
+      : foldIntFn(isUnsignedInt ? foldUint : foldSint) {}
+  std::function<APInt(APInt, APInt)> foldIntFn;
+
+  // TODO: Enable float folding.
+  std::optional<APFloat> operator()(APFloat lhs, APFloat rhs) {
+    return std::nullopt;  // return lhs <= rhs ? lhs : rhs;
+  }
+  APInt operator()(APInt lhs, APInt rhs) { return foldIntFn(lhs, rhs); }
+  static APInt foldUint(APInt lhs, APInt rhs) {
+    return lhs.ule(rhs) ? lhs : rhs;
+  }
+  static APInt foldSint(APInt lhs, APInt rhs) {
+    return lhs.sle(rhs) ? lhs : rhs;
+  }
+};
+
+
+struct FoldMaxOpPattern : public ShapeOpRewritePattern<MaxOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(MaxOp op,
                                 PatternRewriter& rewriter) const override {
-    return evalElementwise(rewriter, op, [&](APSInt lhs, APSInt rhs) {
-      return lhs >= rhs ? lhs : rhs;
-    });
-  }
-};
-
-struct EvalMinOpPattern : public FoldOpRewritePattern<MinOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    auto resultType = op.getType();
+    if (failed(validateShapeFoldDtype(rewriter, op, resultType)))
+      return failure();
+
+    bool isUnsignedInt = resultType.getElementType().isUnsignedInteger();
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, FoldMax(isUnsignedInt));
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+};
+
+struct FoldMinOpPattern : public ShapeOpRewritePattern<MinOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(MinOp op,
                                 PatternRewriter& rewriter) const override {
-    return evalElementwise(rewriter, op, [&](APSInt lhs, APSInt rhs) {
-      return lhs <= rhs ? lhs : rhs;
-    });
-  }
-};
-
-struct FoldMulOpPattern final : FoldOpRewritePattern<mlir::stablehlo::MulOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    auto resultType = op.getType();
+    if (failed(validateShapeFoldDtype(rewriter, op, resultType)))
+      return failure();
+
+    bool isUnsignedInt = resultType.getElementType().isUnsignedInteger();
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, FoldMin(isUnsignedInt));
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+};
+
+// Clamp is folded using Min and Max folders.
+struct FoldClampOpPattern : public ShapeOpRewritePattern<ClampOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
+
+  LogicalResult matchAndRewrite(ClampOp op,
+                                PatternRewriter& rewriter) const override {
+    auto resultType = op.getType();
+    if (failed(validateShapeFoldDtype(rewriter, op, resultType)))
+      return failure();
+
+    TypedAttr minAttr, operandAttr, maxAttr;
+    matchPattern(op.getMin(), m_Constant(&minAttr));
+    matchPattern(op.getOperand(), m_Constant(&operandAttr));
+    matchPattern(op.getMax(), m_Constant(&maxAttr));
+
+    if (!minAttr || !operandAttr || !maxAttr)
+      return rewriter.notifyMatchFailure(op, "operands not constant");
+
+    // Fold clamp using:
+    //   res = max(min, operand)
+    //   res = min(max, res)
+    bool isUnsignedInt = resultType.getElementType().isUnsignedInteger();
+    auto res = foldBinaryOpIntOrFloat(resultType, minAttr, operandAttr,
+                                      FoldMax(isUnsignedInt));
+    res = foldBinaryOpIntOrFloat(resultType, maxAttr, res,
+                                 FoldMin(isUnsignedInt));
+    if (!res) return rewriter.notifyMatchFailure(op, "failed to fold clamp");
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res);
+    return success();
+  }
+};
+
+struct FoldMulOpPattern final : ShapeOpRewritePattern<mlir::stablehlo::MulOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(mlir::stablehlo::MulOp op,
                                 PatternRewriter& rewriter) const override {
-    TypedAttr lhsAttr;
-    matchPattern(op.getLhs(), m_Constant(&lhsAttr));
-
-    TypedAttr rhsAttr;
-    matchPattern(op.getRhs(), m_Constant(&rhsAttr));
-
-    if (TypedAttr res;
-        lhsAttr && rhsAttr &&
-        (res = foldBinaryOpIntOrFloat(lhsAttr, rhsAttr, std::multiplies<>{}))) {
-      rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res);
-      return success();
-    }
-
-    return failure();
-  }
-};
-
-struct EvalMulOpPattern : public FoldOpRewritePattern<MulOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
-
-  LogicalResult matchAndRewrite(MulOp op,
-                                PatternRewriter& rewriter) const override {
-    return evalElementwise(rewriter, op,
-                           [&](APSInt lhs, APSInt rhs) { return lhs * rhs; });
-  }
-};
-
-struct EvalOrOpPattern : public FoldOpRewritePattern<OrOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    if (failed(validateShapeFoldDtype(rewriter, op, op.getType())))
+      return failure();
+
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, std::multiplies<>{});
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+};
+
+struct FoldOrOpPattern : public ShapeOpRewritePattern<OrOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(OrOp op,
                                 PatternRewriter& rewriter) const override {
+    // TODO: Support more int types
     auto resultType = op.getType();
     if (!resultType.getElementType().isInteger(1))
       return rewriter.notifyMatchFailure(op, "expected boolean element type");
 
-    return evalElementwise(rewriter, op, [&](APSInt lhsInt, APSInt rhsInt) {
-      return getAPSInt(resultType.getElementType(), lhsInt != 0 || rhsInt != 0);
-    });
-  }
-};
-
-struct EvalRemOpPattern : public FoldOpRewritePattern<RemOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, FoldOr{});
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+
+  struct FoldOr {
+    APInt operator()(APInt lhs, APInt rhs) const {
+      return APInt(lhs.getBitWidth(), !lhs.isZero() || !rhs.isZero());
+    }
+    std::optional<APFloat> operator()(APFloat lhs, APFloat rhs) const {
+      return std::nullopt;
+    }
+  };
+};
+
+struct FoldRemOpPattern : public ShapeOpRewritePattern<RemOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(RemOp op,
                                 PatternRewriter& rewriter) const override {
-    return evalElementwise(rewriter, op,
-                           [&](APSInt lhs, APSInt rhs) { return lhs % rhs; });
-  }
-};
-
-struct EvalReshapeOpPattern : public ShapeOpRewritePattern<ReshapeOp> {
+    auto resultType = op.getType();
+    if (failed(validateShapeFoldDtype(rewriter, op, resultType)))
+      return failure();
+
+    bool isUnsignedInt = resultType.getElementType().isUnsignedInteger();
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, FoldRem(isUnsignedInt));
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+
+  struct FoldRem {
+    FoldRem(bool isUnsignedInt)
+        : foldIntFn(isUnsignedInt ? foldUint : foldSint) {}
+    std::function<APInt(APInt, APInt)> foldIntFn;
+
+    // TODO: Enable float folding.
+    std::optional<APFloat> operator()(APFloat lhs, APFloat rhs) {
+      return std::nullopt;  // return lhs.remainder(rhs);
+    }
+    APInt operator()(APInt lhs, APInt rhs) { return foldIntFn(lhs, rhs); }
+    static APInt foldUint(APInt lhs, APInt rhs) { return lhs.urem(rhs); }
+    static APInt foldSint(APInt lhs, APInt rhs) { return lhs.srem(rhs); }
+  };
+};
+
+// Pattern: reshape(cst, shape) -> cst
+struct FoldReshapeOpPattern : public ShapeOpRewritePattern<ReshapeOp> {
   using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(ReshapeOp op,
@@ -656,7 +756,6 @@
         failed(validateShapeFoldDtype(rewriter, op, resultType)))
       return failure();
 
-    // Pattern: reshape(cst, shape) -> cst
     DenseIntOrFPElementsAttr attr;
     if (!matchPattern(op.getOperand(), m_Constant(&attr)))
       return rewriter.notifyMatchFailure(op, "expected constant operand");
@@ -665,53 +764,98 @@
   }
 };
 
-struct EvalSelectOpPattern : public FoldOpRewritePattern<SelectOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+struct FoldSelectOpPattern : public ShapeOpRewritePattern<SelectOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(SelectOp op,
                                 PatternRewriter& rewriter) const override {
     auto resultType = op.getType();
-    if (failed(validateStaticShapeResult(rewriter, op, resultType)))
-      return failure();
-
-    SmallVector<APSInt> pred, onTrue, onFalse;
-    if (failed(hlo::matchInts(op.getPred(), pred)) ||
-        failed(hlo::matchInts(op.getOnTrue(), onTrue)) ||
-        failed(hlo::matchInts(op.getOnFalse(), onFalse)))
+    if (failed(validateStaticShapeResult(rewriter, op, resultType)) ||
+        failed(validateShapeFoldDtype(rewriter, op, resultType)))
+      return failure();
+
+    DenseIntElementsAttr predAttr;
+    DenseElementsAttr onTrueAttr, onFalseAttr;
+    matchPattern(op.getPred(), m_Constant(&predAttr));
+    matchPattern(op.getOnTrue(), m_Constant(&onTrueAttr));
+    matchPattern(op.getOnFalse(), m_Constant(&onFalseAttr));
+    if (!predAttr || !onTrueAttr || !onFalseAttr)
       return rewriter.notifyMatchFailure(op, "expected constant operands");
 
-    SmallVector<APSInt> result;
+    // Optimization, handle splat predicate
+    if (isa<SplatElementsAttr>(predAttr)) {
+      auto pred = predAttr.getSplatValue<APInt>();
+      rewriter.replaceOpWithNewOp<ConstantOp>(
+          op, pred.isZero() ? onFalseAttr : onTrueAttr);
+      return success();
+    }
+
+    // TODO: Enable float folding.
+    if (op.getType().getElementType().isFloat())
+      return rewriter.notifyMatchFailure(op, "float select not supported yet");
+
+    // Fall back to verbose folding
+    if (failed(validateElementCountForFold(rewriter, op, resultType)))
+      return failure();
+
+    SmallVector<APInt> result;
     for (auto [predEl, onTrueEl, onFalseEl] :
-         llvm::zip(pred, onTrue, onFalse)) {
-      result.push_back(predEl != 0 ? onTrueEl : onFalseEl);
-    }
-
+         llvm::zip(predAttr.getValues<APInt>(), onTrueAttr.getValues<APInt>(),
+                   onFalseAttr.getValues<APInt>())) {
+      result.push_back(!predEl.isZero() ? onTrueEl : onFalseEl);
+    }
     rewriter.replaceOpWithNewOp<ConstantOp>(
-        op, getTensorAttr(op.getType(), result));
-    return success();
-  }
-};
-
-struct EvalSignOpPattern : public FoldOpRewritePattern<SignOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+        op, DenseIntElementsAttr::get(resultType, result));
+
+    return success();
+  }
+
+  struct FoldSelect {
+    std::optional<APFloat> operator()(APFloat pred, APFloat onTrue,
+                                      APFloat onFalse) {
+      return std::nullopt;
+    }
+
+    APInt operator()(APInt pred, APInt onTrue, APInt onFalse) {
+      return pred != 0 ? onTrue : onFalse;
+    }
+  };
+};
+
+struct FoldSignOpPattern : public ShapeOpRewritePattern<SignOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(SignOp op,
                                 PatternRewriter& rewriter) const override {
-    auto resultType = op.getType();
-    if (!isa<IntegerType>(resultType.getElementType()))
-      return rewriter.notifyMatchFailure(op,
-                                         "expected integer result tensor type");
-    return evalElementwise(rewriter, op, [&](APSInt operand) {
+    if (failed(validateShapeFoldDtype(rewriter, op, op.getType())))
+      return failure();
+
+    auto elementType = op.getType().getElementType();
+    auto res = foldUnaryOpIntOrFloat(rewriter, op, FoldSign(elementType));
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+
+  struct FoldSign {
+    FoldSign(Type elementType) : elementType(elementType) {}
+    Type elementType;
+    // TODO: Enable float folding.
+    std::optional<APFloat> operator()(APFloat operand) { return std::nullopt; }
+
+    APInt operator()(APInt operand) {
+      // SignOp only supports signed integers.
+      APSInt signedInt = getAPSInt(elementType, operand.getSExtValue());
       int64_t result;
-      if (operand.isNegative())
+      if (signedInt.isNegative())
         result = -1;
-      else if (operand.isZero())
+      else if (signedInt.isZero())
         result = 0;
       else
         result = 1;
-      return getAPSInt(resultType.getElementType(), result);
-    });
-  }
+      return getAPSInt(elementType, result);
+    }
+  };
 };
 
 template <typename RangeType>
@@ -749,13 +893,14 @@
                                 ArrayRef<ElementType>(result));
 }
 
-struct EvalSliceOpPattern : public FoldOpRewritePattern<SliceOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+struct FoldSliceOpPattern : public ShapeOpRewritePattern<SliceOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(SliceOp op,
                                 PatternRewriter& rewriter) const override {
     auto resultType = op.getType();
-    if (failed(validateStaticShapeResult(rewriter, op, resultType)))
+    if (failed(validateStaticShapeResult(rewriter, op, resultType)) ||
+        failed(validateShapeFoldDtype(rewriter, op, resultType)))
       return failure();
 
     auto operand = op.getOperand();
@@ -784,36 +929,18 @@
 };
 
 struct FoldSubtractOpPattern final
-    : FoldOpRewritePattern<mlir::stablehlo::SubtractOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
+    : ShapeOpRewritePattern<mlir::stablehlo::SubtractOp> {
+  using ShapeOpRewritePattern::ShapeOpRewritePattern;
 
   LogicalResult matchAndRewrite(mlir::stablehlo::SubtractOp op,
                                 PatternRewriter& rewriter) const override {
-    Value lhs = op.getLhs();
-    Value rhs = op.getRhs();
-
-    TypedAttr lhsAttr, rhsAttr;
-    matchPattern(lhs, m_Constant(&lhsAttr));
-    matchPattern(rhs, m_Constant(&rhsAttr));
-
-    if (TypedAttr res;
-        lhsAttr && rhsAttr &&
-        (res = foldBinaryOpIntOrFloat(lhsAttr, rhsAttr, std::minus<>{}))) {
-      rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res);
-      return success();
-    }
-
-    return failure();
-  }
-};
-
-struct EvalSubtractOpPattern : public FoldOpRewritePattern<SubtractOp> {
-  using FoldOpRewritePattern::FoldOpRewritePattern;
-
-  LogicalResult matchAndRewrite(SubtractOp op,
-                                PatternRewriter& rewriter) const override {
-    return evalElementwise(rewriter, op,
-                           [&](APSInt lhs, APSInt rhs) { return lhs - rhs; });
+    if (failed(validateShapeFoldDtype(rewriter, op, op.getType())))
+      return failure();
+
+    auto res = foldBinaryOpIntOrFloat(rewriter, op, std::minus<>{});
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
   }
 };
 
@@ -823,42 +950,38 @@
 
   LogicalResult matchAndRewrite(mlir::stablehlo::SqrtOp op,
                                 PatternRewriter& rewriter) const final {
-    TypedAttr lhsAttr;
-    matchPattern(op.getOperand(), m_Constant(&lhsAttr));
-
-    if (!lhsAttr)
-      return rewriter.notifyMatchFailure(op, "operand not constant");
-
-    if (auto res = constFoldUnaryOp<FloatAttr, FloatAttr::ValueType, void>(
-            lhsAttr, foldSqrt)) {
-      rewriter.replaceOpWithNewOp<stablehlo::ConstantOp>(
-          op, op.getType(), llvm::cast<ElementsAttr>(res));
-      return success();
-    }
-
-    return rewriter.notifyMatchFailure(op, "unable to fold sqrt");
-  }
-
-  static std::optional<APFloat> foldSqrt(const APFloat& a) {
-    if (a.getSizeInBits(a.getSemantics()) == 64)
-      return APFloat(std::sqrt(a.convertToDouble()));
-
-    if (a.getSizeInBits(a.getSemantics()) == 32)
-      return APFloat(sqrtf(a.convertToFloat()));
-    return {};
-  }
-};
-
-struct EvalIotaOpPattern : public FoldOpRewritePattern<IotaOp> {
+    auto res = foldUnaryOpIntOrFloat(rewriter, op, FoldSqrt());
+    if (failed(res)) return failure();
+    rewriter.replaceOpWithNewOp<mlir::stablehlo::ConstantOp>(op, res.value());
+    return success();
+  }
+
+  struct FoldSqrt {
+    std::optional<APFloat> operator()(APFloat operand) {
+      if (operand.getSizeInBits(operand.getSemantics()) == 64)
+        return APFloat(std::sqrt(operand.convertToDouble()));
+
+      if (operand.getSizeInBits(operand.getSemantics()) == 32)
+        return APFloat(sqrtf(operand.convertToFloat()));
+      return std::nullopt;
+    }
+
+    // TODO: Enable int folding.
+    std::optional<APInt> operator()(APInt operand) {
+      return std::nullopt;
+    }
+  };
+};
+
+struct FoldIotaOpPattern : public FoldOpRewritePattern<IotaOp> {
   using FoldOpRewritePattern::FoldOpRewritePattern;
 
   LogicalResult matchAndRewrite(IotaOp op,
                                 PatternRewriter& rewriter) const override {
-    LLVM_DEBUG(llvm::dbgs() << "EvalIotaOpPattern folding: " << op << '\n');
+    LLVM_DEBUG(llvm::dbgs() << "FoldIotaOpPattern folding: " << op << '\n');
     auto resultType = cast<RankedTensorType>(op.getType());
-    size_t numElems = resultType.getNumElements();
-    if (numElems > static_cast<size_t>(options.foldOpElementLimit))
-      return rewriter.notifyMatchFailure(op, "too many elements to fold");
+    if (failed(validateElementCountForFold(rewriter, op, resultType)))
+      return failure();
 
     auto elementType = resultType.getElementType();
 
@@ -929,7 +1052,7 @@
 // transpose(constant) => constant with permuted dimensions
 // This covers ranked tensor types with 0 dimensions(zero elements) and 0
 // rank(scalar), as well as splat values.
-struct EvalTransposeOpPattern : public FoldOpRewritePattern<TransposeOp> {
+struct FoldTransposeOpPattern : public FoldOpRewritePattern<TransposeOp> {
   using FoldOpRewritePattern::FoldOpRewritePattern;
 
   LogicalResult matchAndRewrite(TransposeOp op,
@@ -943,6 +1066,7 @@
       return rewriter.notifyMatchFailure(
           op, "expected constant integer or float operand");
 
+    // TODO: Does this expand splat values? Should we special case splats?
     DenseElementsAttr resAttr;
     if (auto data = els.tryGetValues<APInt>())
       resAttr = transposeType(op, *data);
@@ -957,6 +1081,7 @@
   }
 };
 
+// TODO: Consider moving this into aggressive simplifications.
 struct LowerBoolSplatConstantsIntoReduceOpRegion
     : public FoldOpRewritePattern<ReduceOp> {
   using FoldOpRewritePattern::FoldOpRewritePattern;
@@ -1160,7 +1285,7 @@
   return true;
 }
 
-struct RemoveDeadWhileOpWithNoSideEffects
+struct FoldWhileOpDeadWithNoSideEffects
     : public FoldOpRewritePattern<WhileOp> {
   using FoldOpRewritePattern::FoldOpRewritePattern;
 
@@ -1233,23 +1358,16 @@
     PatternBenefit benefit) {
   populateStablehloShapeFolderPatterns(context, patterns, options, benefit);
 
-  patterns->add<EvalIotaOpPattern,                          //
-                EvalTransposeOpPattern,                     //
-                FoldReduceOpReducingZeroDims,               //
-                FoldReduceOpToConstantInitializer,          //
-                FoldReduceOpWithRedundantResults,           //
-                FoldWhileOpPattern,                         //
-                LowerBoolSplatConstantsIntoReduceOpRegion,  //
-                RemoveDeadWhileOpWithNoSideEffects>(context, options, benefit);
-
-  // TODO: Consolidate FoldOp patterns
-  // One is used by Shape Refinement, the other is a generic folder.
-  patterns->add<FoldAddOpPattern,                //
-                FoldBroadcastInDimSplatPattern,  //
-                FoldConcatenateOpPattern,        //
-                FoldMulOpPattern,                //
-                FoldSqrtOpPattern,               //
-                FoldSubtractOpPattern>(context, options);
+  patterns->add<FoldIotaOpPattern,                  //
+                FoldReduceOpReducingZeroDims,       //
+                FoldReduceOpToConstantInitializer,  //
+                FoldReduceOpWithRedundantResults,   //
+                FoldSqrtOpPattern,                  //
+                FoldTransposeOpPattern,             //
+                FoldWhileOpPattern,                 //
+                FoldWhileOpDeadWithNoSideEffects,   //
+                LowerBoolSplatConstantsIntoReduceOpRegion>(context, options,
+                                                           benefit);
 }
 
 class StablehloTargetIndependentOptimizationPass {
@@ -1266,25 +1384,25 @@
     MLIRContext* context, RewritePatternSet* patterns,
     const StablehloAggressiveFolderPassOptions& options,
     PatternBenefit benefit) {
-  patterns->add<EvalAddOpShapePattern>(context, options, benefit);
-  patterns->add<EvalAndOpPattern>(context, options, benefit);
-  patterns->add<EvalBroadcastInDimOpPattern>(context, options, benefit);
-  patterns->add<EvalClampOpPattern>(context, options, benefit);
-  patterns->add<EvalCompareOpPattern>(context, options, benefit);
-  patterns->add<EvalConcatenateOpPattern>(context, options, benefit);
-  patterns->add<EvalConvertOpPattern>(context, options, benefit);
-  patterns->add<EvalDivOpPattern>(context, options, benefit);
-  patterns->add<EvalGetDimensionSizeOpPattern>(context, options, benefit);
-  patterns->add<EvalMaxOpPattern>(context, options, benefit);
-  patterns->add<EvalMinOpPattern>(context, options, benefit);
-  patterns->add<EvalMulOpPattern>(context, options, benefit);
-  patterns->add<EvalOrOpPattern>(context, options, benefit);
-  patterns->add<EvalRemOpPattern>(context, options, benefit);
-  patterns->add<EvalReshapeOpPattern>(context, options, benefit);
-  patterns->add<EvalSelectOpPattern>(context, options, benefit);
-  patterns->add<EvalSignOpPattern>(context, options, benefit);
-  patterns->add<EvalSliceOpPattern>(context, options, benefit);
-  patterns->add<EvalSubtractOpPattern>(context, options, benefit);
+  patterns->add<FoldAddOpPattern>(context, options, benefit);
+  patterns->add<FoldAndOpPattern>(context, options, benefit);
+  patterns->add<FoldBroadcastInDimOpSplatPattern>(context, options, benefit);
+  patterns->add<FoldClampOpPattern>(context, options, benefit);
+  patterns->add<FoldCompareOpPattern>(context, options, benefit);
+  patterns->add<FoldConcatenateOpPattern>(context, options, benefit);
+  patterns->add<FoldConvertOpPattern>(context, options, benefit);
+  patterns->add<FoldDivOpPattern>(context, options, benefit);
+  patterns->add<FoldGetDimensionSizeOpPattern>(context, options, benefit);
+  patterns->add<FoldMaxOpPattern>(context, options, benefit);
+  patterns->add<FoldMinOpPattern>(context, options, benefit);
+  patterns->add<FoldMulOpPattern>(context, options, benefit);
+  patterns->add<FoldOrOpPattern>(context, options, benefit);
+  patterns->add<FoldRemOpPattern>(context, options, benefit);
+  patterns->add<FoldReshapeOpPattern>(context, options, benefit);
+  patterns->add<FoldSelectOpPattern>(context, options, benefit);
+  patterns->add<FoldSignOpPattern>(context, options, benefit);
+  patterns->add<FoldSliceOpPattern>(context, options, benefit);
+  patterns->add<FoldSubtractOpPattern>(context, options, benefit);
 }
 
 void populateStablehloShapeFolderPatterns(MLIRContext* context,
diff --ruN a/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveSimplificationPatterns.td b/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveSimplificationPatterns.td
--- stablehlo/stablehlo/transforms/optimization/StablehloAggressiveSimplificationPatterns.td
+++ stablehlo/stablehlo/transforms/optimization/StablehloAggressiveSimplificationPatterns.td
@@ -48,6 +48,8 @@
 def RankEqual : Constraint<
     CPred<"llvm::cast<ShapedType>($0.getType()).getRank() == llvm::cast<ShapedType>($1.getType()).getRank()">,
     "same rank">;
+
+def TensorDimsAllOne : Constraint<CPred<"tensorDimsAllOne($0, $1)">, "all tensor dims are 1">;
 
 def TypesEqual : Constraint<CPred<"$0.getType() == $1.getType()">, "operands are equal">;
 
@@ -100,6 +102,8 @@
 def ZeroExtent : AttrConstraint<
     CPred<"cast<DenseElementsAttr>($_self).getNumElements() == 0">,
     "is zero extent">;
+
+def AnyStaticShapeIntTensor : StaticShapeTensorOf<[HLO_Int]>;
 
 ///////////
 //// Native Code Call Utilities
@@ -503,7 +507,7 @@
 // Must be static shape, otherwise would require broadcasting via
 // CHLO_ConstantLike.
 def SubtractOp_FoldToZero
-  : Pat<(StableHLO_SubtractOp AnyStaticShapeTensor:$operand, $operand),
+  : Pat<(StableHLO_SubtractOp AnyStaticShapeIntTensor:$operand, $operand),
         (StableHLO_ConstantLike<"0"> $operand)>;
 
 // Pattern: subtract(X, 0) -> X

