Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -40,8 +40,6 @@
 - Setting the deprecated CMake variable ``GCC_INSTALL_PREFIX`` (which sets the
   default ``--gcc-toolchain=``) now leads to a fatal error.
 
-- The ``le32`` and ``le64`` targets have been removed.
-
 C/C++ Language Potentially Breaking Changes
 -------------------------------------------
 
@@ -313,10 +311,6 @@
 - Clang now considers ``noexcept(typeid(expr))`` more carefully, instead of always assuming that ``std::bad_typeid`` can be thrown.
   (`CWG2191: Incorrect result for noexcept(typeid(v)) <https://cplusplus.github.io/CWG/issues/2191.html>`_).
 
-- Clang now correctly implements lookup for the terminal name of a member-qualified nested-name-specifier.
-  (`CWG1835: Dependent member lookup before < <https://cplusplus.github.io/CWG/issues/1835.html>`_).
-  The warning can be disabled via `-Wno-missing-dependent-template-keyword`.
-
 C Language Changes
 ------------------
 
diff -ruN --strip-trailing-cr a/clang/docs/tools/clang-formatted-files.txt b/clang/docs/tools/clang-formatted-files.txt
--- a/clang/docs/tools/clang-formatted-files.txt
+++ b/clang/docs/tools/clang-formatted-files.txt
@@ -362,6 +362,7 @@
 clang/lib/Basic/Targets/BPF.h
 clang/lib/Basic/Targets/Hexagon.h
 clang/lib/Basic/Targets/Lanai.h
+clang/lib/Basic/Targets/Le64.h
 clang/lib/Basic/Targets/M68k.h
 clang/lib/Basic/Targets/MSP430.h
 clang/lib/Basic/Targets/NVPTX.cpp
diff -ruN --strip-trailing-cr a/clang/include/clang/AST/ExprCXX.h b/clang/include/clang/AST/ExprCXX.h
--- a/clang/include/clang/AST/ExprCXX.h
+++ b/clang/include/clang/AST/ExprCXX.h
@@ -3676,9 +3676,9 @@
 /// an implicit access if a qualifier is provided.
 class CXXDependentScopeMemberExpr final
     : public Expr,
-      private llvm::TrailingObjects<
-          CXXDependentScopeMemberExpr, NestedNameSpecifierLoc, DeclAccessPair,
-          ASTTemplateKWAndArgsInfo, TemplateArgumentLoc> {
+      private llvm::TrailingObjects<CXXDependentScopeMemberExpr,
+                                    ASTTemplateKWAndArgsInfo,
+                                    TemplateArgumentLoc, NamedDecl *> {
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
   friend TrailingObjects;
@@ -3691,15 +3691,17 @@
   /// implicit accesses.
   QualType BaseType;
 
+  /// The nested-name-specifier that precedes the member name, if any.
+  /// FIXME: This could be in principle store as a trailing object.
+  /// However the performance impact of doing so should be investigated first.
+  NestedNameSpecifierLoc QualifierLoc;
+
   /// The member to which this member expression refers, which
   /// can be name, overloaded operator, or destructor.
   ///
   /// FIXME: could also be a template-id
   DeclarationNameInfo MemberNameInfo;
 
-  /// The location of the '->' or '.' operator.
-  SourceLocation OperatorLoc;
-
   // CXXDependentScopeMemberExpr is followed by several trailing objects,
   // some of which optional. They are in order:
   //
@@ -3719,16 +3721,8 @@
     return CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo;
   }
 
-  unsigned getNumUnqualifiedLookups() const {
-    return CXXDependentScopeMemberExprBits.NumUnqualifiedLookups;
-  }
-
-  unsigned numTrailingObjects(OverloadToken<NestedNameSpecifierLoc>) const {
-    return hasQualifier();
-  }
-
-  unsigned numTrailingObjects(OverloadToken<DeclAccessPair>) const {
-    return getNumUnqualifiedLookups();
+  bool hasFirstQualifierFoundInScope() const {
+    return CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope;
   }
 
   unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {
@@ -3739,32 +3733,33 @@
     return getNumTemplateArgs();
   }
 
+  unsigned numTrailingObjects(OverloadToken<NamedDecl *>) const {
+    return hasFirstQualifierFoundInScope();
+  }
+
   CXXDependentScopeMemberExpr(const ASTContext &Ctx, Expr *Base,
                               QualType BaseType, bool IsArrow,
                               SourceLocation OperatorLoc,
                               NestedNameSpecifierLoc QualifierLoc,
                               SourceLocation TemplateKWLoc,
-                              ArrayRef<DeclAccessPair> UnqualifiedLookups,
+                              NamedDecl *FirstQualifierFoundInScope,
                               DeclarationNameInfo MemberNameInfo,
                               const TemplateArgumentListInfo *TemplateArgs);
 
-  CXXDependentScopeMemberExpr(EmptyShell Empty, bool HasQualifier,
-                              unsigned NumUnqualifiedLookups,
-                              bool HasTemplateKWAndArgsInfo);
+  CXXDependentScopeMemberExpr(EmptyShell Empty, bool HasTemplateKWAndArgsInfo,
+                              bool HasFirstQualifierFoundInScope);
 
 public:
   static CXXDependentScopeMemberExpr *
   Create(const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,
          SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,
-         SourceLocation TemplateKWLoc,
-         ArrayRef<DeclAccessPair> UnqualifiedLookups,
+         SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,
          DeclarationNameInfo MemberNameInfo,
          const TemplateArgumentListInfo *TemplateArgs);
 
   static CXXDependentScopeMemberExpr *
-  CreateEmpty(const ASTContext &Ctx, bool HasQualifier,
-              unsigned NumUnqualifiedLookups, bool HasTemplateKWAndArgsInfo,
-              unsigned NumTemplateArgs);
+  CreateEmpty(const ASTContext &Ctx, bool HasTemplateKWAndArgsInfo,
+              unsigned NumTemplateArgs, bool HasFirstQualifierFoundInScope);
 
   /// True if this is an implicit access, i.e. one in which the
   /// member being accessed was not written in the source.  The source
@@ -3789,35 +3784,34 @@
   bool isArrow() const { return CXXDependentScopeMemberExprBits.IsArrow; }
 
   /// Retrieve the location of the '->' or '.' operator.
-  SourceLocation getOperatorLoc() const { return OperatorLoc; }
-
-  /// Determines whether this member expression had a nested-name-specifier
-  /// prior to the name of the member, e.g., x->Base::foo.
-  bool hasQualifier() const {
-    return CXXDependentScopeMemberExprBits.HasQualifier;
-  }
-
-  /// If the member name was qualified, retrieves the nested-name-specifier
-  /// that precedes the member name, with source-location information.
-  NestedNameSpecifierLoc getQualifierLoc() const {
-    if (!hasQualifier())
-      return NestedNameSpecifierLoc();
-    return *getTrailingObjects<NestedNameSpecifierLoc>();
+  SourceLocation getOperatorLoc() const {
+    return CXXDependentScopeMemberExprBits.OperatorLoc;
   }
 
-  /// If the member name was qualified, retrieves the
-  /// nested-name-specifier that precedes the member name. Otherwise, returns
-  /// NULL.
+  /// Retrieve the nested-name-specifier that qualifies the member name.
   NestedNameSpecifier *getQualifier() const {
-    return getQualifierLoc().getNestedNameSpecifier();
+    return QualifierLoc.getNestedNameSpecifier();
   }
 
-  /// Retrieve the declarations found by unqualified lookup for the first
-  /// component name of the nested-name-specifier, if any.
-  ArrayRef<DeclAccessPair> unqualified_lookups() const {
-    if (!getNumUnqualifiedLookups())
-      return std::nullopt;
-    return {getTrailingObjects<DeclAccessPair>(), getNumUnqualifiedLookups()};
+  /// Retrieve the nested-name-specifier that qualifies the member
+  /// name, with source location information.
+  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }
+
+  /// Retrieve the first part of the nested-name-specifier that was
+  /// found in the scope of the member access expression when the member access
+  /// was initially parsed.
+  ///
+  /// This function only returns a useful result when member access expression
+  /// uses a qualified member name, e.g., "x.Base::f". Here, the declaration
+  /// returned by this function describes what was found by unqualified name
+  /// lookup for the identifier "Base" within the scope of the member access
+  /// expression itself. At template instantiation time, this information is
+  /// combined with the results of name lookup into the type of the object
+  /// expression itself (the class type of x).
+  NamedDecl *getFirstQualifierFoundInScope() const {
+    if (!hasFirstQualifierFoundInScope())
+      return nullptr;
+    return *getTrailingObjects<NamedDecl *>();
   }
 
   /// Retrieve the name of the member that this expression refers to.
diff -ruN --strip-trailing-cr a/clang/include/clang/AST/Stmt.h b/clang/include/clang/AST/Stmt.h
--- a/clang/include/clang/AST/Stmt.h
+++ b/clang/include/clang/AST/Stmt.h
@@ -1020,19 +1020,18 @@
     LLVM_PREFERRED_TYPE(bool)
     unsigned IsArrow : 1;
 
-    /// True if this member expression used a nested-name-specifier to
-    /// refer to the member, e.g., "x->Base::f".
-    LLVM_PREFERRED_TYPE(bool)
-    unsigned HasQualifier : 1;
-
     /// Whether this member expression has info for explicit template
     /// keyword and arguments.
     LLVM_PREFERRED_TYPE(bool)
     unsigned HasTemplateKWAndArgsInfo : 1;
 
-    /// Number of declarations found by unqualified lookup for the
-    /// first component name of the nested-name-specifier.
-    unsigned NumUnqualifiedLookups;
+    /// See getFirstQualifierFoundInScope() and the comment listing
+    /// the trailing objects.
+    LLVM_PREFERRED_TYPE(bool)
+    unsigned HasFirstQualifierFoundInScope : 1;
+
+    /// The location of the '->' or '.' operator.
+    SourceLocation OperatorLoc;
   };
 
   class OverloadExprBitfields {
diff -ruN --strip-trailing-cr a/clang/include/clang/AST/UnresolvedSet.h b/clang/include/clang/AST/UnresolvedSet.h
--- a/clang/include/clang/AST/UnresolvedSet.h
+++ b/clang/include/clang/AST/UnresolvedSet.h
@@ -97,10 +97,6 @@
     decls().push_back(DeclAccessPair::make(D, AS));
   }
 
-  void addAllDecls(ArrayRef<DeclAccessPair> Other) {
-    append(iterator(Other.begin()), iterator(Other.end()));
-  }
-
   /// Replaces the given declaration with the new one, once.
   ///
   /// \return true if the set changed
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/DiagnosticParseKinds.td b/clang/include/clang/Basic/DiagnosticParseKinds.td
--- a/clang/include/clang/Basic/DiagnosticParseKinds.td
+++ b/clang/include/clang/Basic/DiagnosticParseKinds.td
@@ -895,9 +895,10 @@
   "keyword">, InGroup<DiagGroup<"missing-template-arg-list-after-template-kw">>,
   DefaultError;
 
-def ext_missing_dependent_template_keyword : ExtWarn<
-  "use 'template' keyword to treat '%0' as a dependent template name">,
-  InGroup<DiagGroup<"missing-dependent-template-keyword">>;
+def err_missing_dependent_template_keyword : Error<
+  "use 'template' keyword to treat '%0' as a dependent template name">;
+def warn_missing_dependent_template_keyword : ExtWarn<
+  "use 'template' keyword to treat '%0' as a dependent template name">;
 
 def ext_extern_template : Extension<
   "extern templates are a C++11 extension">, InGroup<CXX11>;
diff -ruN --strip-trailing-cr a/clang/include/clang/Parse/Parser.h b/clang/include/clang/Parse/Parser.h
--- a/clang/include/clang/Parse/Parser.h
+++ b/clang/include/clang/Parse/Parser.h
@@ -3368,11 +3368,15 @@
   BaseResult ParseBaseSpecifier(Decl *ClassDecl);
   AccessSpecifier getAccessSpecifierIfPresent() const;
 
-  bool ParseUnqualifiedIdTemplateId(
-      CXXScopeSpec &SS, ParsedType ObjectType, bool ObjectHadErrors,
-      SourceLocation TemplateKWLoc, SourceLocation TildeLoc,
-      IdentifierInfo *Name, SourceLocation NameLoc, bool EnteringContext,
-      UnqualifiedId &Id, bool AssumeTemplateId);
+  bool ParseUnqualifiedIdTemplateId(CXXScopeSpec &SS,
+                                    ParsedType ObjectType,
+                                    bool ObjectHadErrors,
+                                    SourceLocation TemplateKWLoc,
+                                    IdentifierInfo *Name,
+                                    SourceLocation NameLoc,
+                                    bool EnteringContext,
+                                    UnqualifiedId &Id,
+                                    bool AssumeTemplateId);
   bool ParseUnqualifiedIdOperator(CXXScopeSpec &SS, bool EnteringContext,
                                   ParsedType ObjectType,
                                   UnqualifiedId &Result);
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/DeclSpec.h b/clang/include/clang/Sema/DeclSpec.h
--- a/clang/include/clang/Sema/DeclSpec.h
+++ b/clang/include/clang/Sema/DeclSpec.h
@@ -75,7 +75,6 @@
   SourceRange Range;
   NestedNameSpecifierLocBuilder Builder;
   ArrayRef<TemplateParameterList *> TemplateParamLists;
-  ArrayRef<DeclAccessPair> UnqualifiedLookups;
 
 public:
   SourceRange getRange() const { return Range; }
@@ -92,13 +91,6 @@
     return TemplateParamLists;
   }
 
-  void setUnqualifiedLookups(ArrayRef<DeclAccessPair> Found) {
-    UnqualifiedLookups = Found;
-  }
-  ArrayRef<DeclAccessPair> getUnqualifiedLookups() const {
-    return UnqualifiedLookups;
-  }
-
   /// Retrieve the representation of the nested-name-specifier.
   NestedNameSpecifier *getScopeRep() const {
     return Builder.getRepresentation();
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Lookup.h b/clang/include/clang/Sema/Lookup.h
--- a/clang/include/clang/Sema/Lookup.h
+++ b/clang/include/clang/Sema/Lookup.h
@@ -483,15 +483,11 @@
     ResultKind = Found;
   }
 
-  void addAllDecls(ArrayRef<DeclAccessPair> Other) {
-    Decls.addAllDecls(Other);
-    ResultKind = Found;
-  }
-
   /// Add all the declarations from another set of lookup
   /// results.
   void addAllDecls(const LookupResult &Other) {
-    addAllDecls(Other.Decls.pairs());
+    Decls.append(Other.Decls.begin(), Other.Decls.end());
+    ResultKind = Found;
   }
 
   /// Determine whether no result was found because we could not
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h
--- a/clang/include/clang/Sema/Sema.h
+++ b/clang/include/clang/Sema/Sema.h
@@ -2802,8 +2802,7 @@
   /// (e.g., Base::), perform name lookup for that identifier as a
   /// nested-name-specifier within the given scope, and return the result of
   /// that name lookup.
-  bool LookupFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS,
-                                   UnresolvedSetImpl &R);
+  NamedDecl *FindFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS);
 
   /// Keeps information about an identifier in a nested-name-spec.
   ///
@@ -2843,6 +2842,9 @@
   /// \param EnteringContext If true, enter the context specified by the
   ///        nested-name-specifier.
   /// \param SS Optional nested name specifier preceding the identifier.
+  /// \param ScopeLookupResult Provides the result of name lookup within the
+  ///        scope of the nested-name-specifier that was computed at template
+  ///        definition time.
   /// \param ErrorRecoveryLookup Specifies if the method is called to improve
   ///        error recovery and what kind of recovery is performed.
   /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'
@@ -2851,6 +2853,11 @@
   ///        not '::'.
   /// \param OnlyNamespace If true, only considers namespaces in lookup.
   ///
+  /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in
+  /// that it contains an extra parameter \p ScopeLookupResult, which provides
+  /// the result of name lookup within the scope of the nested-name-specifier
+  /// that was computed at template definition time.
+  ///
   /// If ErrorRecoveryLookup is true, then this call is used to improve error
   /// recovery.  This means that it should not emit diagnostics, it should
   /// just return true on failure.  It also means it should only return a valid
@@ -2859,6 +2866,7 @@
   /// specifier.
   bool BuildCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
                                    bool EnteringContext, CXXScopeSpec &SS,
+                                   NamedDecl *ScopeLookupResult,
                                    bool ErrorRecoveryLookup,
                                    bool *IsCorrectedToColon = nullptr,
                                    bool OnlyNamespace = false);
@@ -8558,12 +8566,11 @@
                           const TemplateArgumentListInfo *TemplateArgs,
                           bool IsDefiniteInstance, const Scope *S);
 
-  ExprResult
-  ActOnDependentMemberExpr(Expr *Base, QualType BaseType, bool IsArrow,
-                           SourceLocation OpLoc, const CXXScopeSpec &SS,
-                           SourceLocation TemplateKWLoc,
-                           const DeclarationNameInfo &NameInfo,
-                           const TemplateArgumentListInfo *TemplateArgs);
+  ExprResult ActOnDependentMemberExpr(
+      Expr *Base, QualType BaseType, bool IsArrow, SourceLocation OpLoc,
+      const CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
+      NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,
+      const TemplateArgumentListInfo *TemplateArgs);
 
   /// The main callback when the parser finds something like
   ///   expression . [nested-name-specifier] identifier
@@ -8619,14 +8626,15 @@
   ExprResult BuildMemberReferenceExpr(
       Expr *Base, QualType BaseType, SourceLocation OpLoc, bool IsArrow,
       CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-      const DeclarationNameInfo &NameInfo,
+      NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,
       const TemplateArgumentListInfo *TemplateArgs, const Scope *S,
       ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);
 
   ExprResult
   BuildMemberReferenceExpr(Expr *Base, QualType BaseType, SourceLocation OpLoc,
                            bool IsArrow, const CXXScopeSpec &SS,
-                           SourceLocation TemplateKWLoc, LookupResult &R,
+                           SourceLocation TemplateKWLoc,
+                           NamedDecl *FirstQualifierInScope, LookupResult &R,
                            const TemplateArgumentListInfo *TemplateArgs,
                            const Scope *S, bool SuppressQualifierCheck = false,
                            ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);
@@ -11114,14 +11122,15 @@
                      QualType ObjectType, bool EnteringContext,
                      RequiredTemplateKind RequiredTemplate = SourceLocation(),
                      AssumedTemplateKind *ATK = nullptr,
-                     bool AllowTypoCorrection = true, bool MayBeNNS = false);
+                     bool AllowTypoCorrection = true);
 
-  TemplateNameKind
-  isTemplateName(Scope *S, CXXScopeSpec &SS, bool hasTemplateKeyword,
-                 const UnqualifiedId &Name, ParsedType ObjectType,
-                 bool EnteringContext, TemplateTy &Template,
-                 bool &MemberOfUnknownSpecialization,
-                 bool Disambiguation = false, bool MayBeNNS = false);
+  TemplateNameKind isTemplateName(Scope *S, CXXScopeSpec &SS,
+                                  bool hasTemplateKeyword,
+                                  const UnqualifiedId &Name,
+                                  ParsedType ObjectType, bool EnteringContext,
+                                  TemplateTy &Template,
+                                  bool &MemberOfUnknownSpecialization,
+                                  bool Disambiguation = false);
 
   /// Try to resolve an undeclared template name as a type template.
   ///
@@ -11450,11 +11459,12 @@
   /// For example, given "x.MetaFun::template apply", the scope specifier
   /// \p SS will be "MetaFun::", \p TemplateKWLoc contains the location
   /// of the "template" keyword, and "apply" is the \p Name.
-  TemplateNameKind
-  ActOnTemplateName(Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-                    const UnqualifiedId &Name, ParsedType ObjectType,
-                    bool EnteringContext, TemplateTy &Template,
-                    bool AllowInjectedClassName = false, bool MayBeNNS = false);
+  TemplateNameKind ActOnTemplateName(Scope *S, CXXScopeSpec &SS,
+                                     SourceLocation TemplateKWLoc,
+                                     const UnqualifiedId &Name,
+                                     ParsedType ObjectType,
+                                     bool EnteringContext, TemplateTy &Template,
+                                     bool AllowInjectedClassName = false);
 
   DeclResult ActOnClassTemplateSpecialization(
       Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,
diff -ruN --strip-trailing-cr a/clang/lib/AST/ASTImporter.cpp b/clang/lib/AST/ASTImporter.cpp
--- a/clang/lib/AST/ASTImporter.cpp
+++ b/clang/lib/AST/ASTImporter.cpp
@@ -8439,14 +8439,8 @@
   auto ToOperatorLoc = importChecked(Err, E->getOperatorLoc());
   auto ToQualifierLoc = importChecked(Err, E->getQualifierLoc());
   auto ToTemplateKeywordLoc = importChecked(Err, E->getTemplateKeywordLoc());
-
-  UnresolvedSet<8> ToUnqualifiedLookups;
-  for (auto D : E->unqualified_lookups())
-    if (auto ToDOrErr = import(D.getDecl()))
-      ToUnqualifiedLookups.addDecl(*ToDOrErr);
-    else
-      return ToDOrErr.takeError();
-
+  auto ToFirstQualifierFoundInScope =
+      importChecked(Err, E->getFirstQualifierFoundInScope());
   if (Err)
     return std::move(Err);
 
@@ -8480,7 +8474,7 @@
 
   return CXXDependentScopeMemberExpr::Create(
       Importer.getToContext(), ToBase, ToType, E->isArrow(), ToOperatorLoc,
-      ToQualifierLoc, ToTemplateKeywordLoc, ToUnqualifiedLookups.pairs(),
+      ToQualifierLoc, ToTemplateKeywordLoc, ToFirstQualifierFoundInScope,
       ToMemberNameInfo, ResInfo);
 }
 
diff -ruN --strip-trailing-cr a/clang/lib/AST/ExprCXX.cpp b/clang/lib/AST/ExprCXX.cpp
--- a/clang/lib/AST/ExprCXX.cpp
+++ b/clang/lib/AST/ExprCXX.cpp
@@ -1489,27 +1489,19 @@
 CXXDependentScopeMemberExpr::CXXDependentScopeMemberExpr(
     const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,
     SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,
-    SourceLocation TemplateKWLoc, ArrayRef<DeclAccessPair> UnqualifiedLookups,
+    SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,
     DeclarationNameInfo MemberNameInfo,
     const TemplateArgumentListInfo *TemplateArgs)
     : Expr(CXXDependentScopeMemberExprClass, Ctx.DependentTy, VK_LValue,
            OK_Ordinary),
-      Base(Base), BaseType(BaseType), MemberNameInfo(MemberNameInfo),
-      OperatorLoc(OperatorLoc) {
+      Base(Base), BaseType(BaseType), QualifierLoc(QualifierLoc),
+      MemberNameInfo(MemberNameInfo) {
   CXXDependentScopeMemberExprBits.IsArrow = IsArrow;
-  CXXDependentScopeMemberExprBits.HasQualifier = QualifierLoc.hasQualifier();
-  CXXDependentScopeMemberExprBits.NumUnqualifiedLookups =
-      UnqualifiedLookups.size();
   CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo =
       (TemplateArgs != nullptr) || TemplateKWLoc.isValid();
-
-  if (hasQualifier())
-    new (getTrailingObjects<NestedNameSpecifierLoc>())
-        NestedNameSpecifierLoc(QualifierLoc);
-
-  std::uninitialized_copy_n(UnqualifiedLookups.data(),
-                            UnqualifiedLookups.size(),
-                            getTrailingObjects<DeclAccessPair>());
+  CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope =
+      FirstQualifierFoundInScope != nullptr;
+  CXXDependentScopeMemberExprBits.OperatorLoc = OperatorLoc;
 
   if (TemplateArgs) {
     auto Deps = TemplateArgumentDependence::None;
@@ -1521,59 +1513,54 @@
         TemplateKWLoc);
   }
 
+  if (hasFirstQualifierFoundInScope())
+    *getTrailingObjects<NamedDecl *>() = FirstQualifierFoundInScope;
   setDependence(computeDependence(this));
 }
 
 CXXDependentScopeMemberExpr::CXXDependentScopeMemberExpr(
-    EmptyShell Empty, bool HasQualifier, unsigned NumUnqualifiedLookups,
-    bool HasTemplateKWAndArgsInfo)
+    EmptyShell Empty, bool HasTemplateKWAndArgsInfo,
+    bool HasFirstQualifierFoundInScope)
     : Expr(CXXDependentScopeMemberExprClass, Empty) {
-  CXXDependentScopeMemberExprBits.HasQualifier = HasQualifier;
-  CXXDependentScopeMemberExprBits.NumUnqualifiedLookups = NumUnqualifiedLookups;
   CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo =
       HasTemplateKWAndArgsInfo;
+  CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope =
+      HasFirstQualifierFoundInScope;
 }
 
 CXXDependentScopeMemberExpr *CXXDependentScopeMemberExpr::Create(
     const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,
     SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,
-    SourceLocation TemplateKWLoc, ArrayRef<DeclAccessPair> UnqualifiedLookups,
+    SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,
     DeclarationNameInfo MemberNameInfo,
     const TemplateArgumentListInfo *TemplateArgs) {
-  bool HasQualifier = QualifierLoc.hasQualifier();
-  unsigned NumUnqualifiedLookups = UnqualifiedLookups.size();
-  assert(!NumUnqualifiedLookups || HasQualifier);
   bool HasTemplateKWAndArgsInfo =
       (TemplateArgs != nullptr) || TemplateKWLoc.isValid();
   unsigned NumTemplateArgs = TemplateArgs ? TemplateArgs->size() : 0;
-  unsigned Size =
-      totalSizeToAlloc<NestedNameSpecifierLoc, DeclAccessPair,
-                       ASTTemplateKWAndArgsInfo, TemplateArgumentLoc>(
-          HasQualifier, NumUnqualifiedLookups, HasTemplateKWAndArgsInfo,
-          NumTemplateArgs);
+  bool HasFirstQualifierFoundInScope = FirstQualifierFoundInScope != nullptr;
+
+  unsigned Size = totalSizeToAlloc<ASTTemplateKWAndArgsInfo,
+                                   TemplateArgumentLoc, NamedDecl *>(
+      HasTemplateKWAndArgsInfo, NumTemplateArgs, HasFirstQualifierFoundInScope);
 
   void *Mem = Ctx.Allocate(Size, alignof(CXXDependentScopeMemberExpr));
   return new (Mem) CXXDependentScopeMemberExpr(
       Ctx, Base, BaseType, IsArrow, OperatorLoc, QualifierLoc, TemplateKWLoc,
-      UnqualifiedLookups, MemberNameInfo, TemplateArgs);
+      FirstQualifierFoundInScope, MemberNameInfo, TemplateArgs);
 }
 
 CXXDependentScopeMemberExpr *CXXDependentScopeMemberExpr::CreateEmpty(
-    const ASTContext &Ctx, bool HasQualifier, unsigned NumUnqualifiedLookups,
-    bool HasTemplateKWAndArgsInfo, unsigned NumTemplateArgs) {
-  assert(!NumTemplateArgs || HasTemplateKWAndArgsInfo);
-  assert(!NumUnqualifiedLookups || HasQualifier);
-
-  unsigned Size =
-      totalSizeToAlloc<NestedNameSpecifierLoc, DeclAccessPair,
-                       ASTTemplateKWAndArgsInfo, TemplateArgumentLoc>(
-          HasQualifier, NumUnqualifiedLookups, HasTemplateKWAndArgsInfo,
-          NumTemplateArgs);
+    const ASTContext &Ctx, bool HasTemplateKWAndArgsInfo,
+    unsigned NumTemplateArgs, bool HasFirstQualifierFoundInScope) {
+  assert(NumTemplateArgs == 0 || HasTemplateKWAndArgsInfo);
+
+  unsigned Size = totalSizeToAlloc<ASTTemplateKWAndArgsInfo,
+                                   TemplateArgumentLoc, NamedDecl *>(
+      HasTemplateKWAndArgsInfo, NumTemplateArgs, HasFirstQualifierFoundInScope);
 
   void *Mem = Ctx.Allocate(Size, alignof(CXXDependentScopeMemberExpr));
-  return new (Mem) CXXDependentScopeMemberExpr(EmptyShell(), HasQualifier,
-                                               NumUnqualifiedLookups,
-                                               HasTemplateKWAndArgsInfo);
+  return new (Mem) CXXDependentScopeMemberExpr(
+      EmptyShell(), HasTemplateKWAndArgsInfo, HasFirstQualifierFoundInScope);
 }
 
 CXXThisExpr *CXXThisExpr::Create(const ASTContext &Ctx, SourceLocation L,
diff -ruN --strip-trailing-cr a/clang/lib/AST/ItaniumMangle.cpp b/clang/lib/AST/ItaniumMangle.cpp
--- a/clang/lib/AST/ItaniumMangle.cpp
+++ b/clang/lib/AST/ItaniumMangle.cpp
@@ -594,10 +594,11 @@
   void mangleMemberExprBase(const Expr *base, bool isArrow);
   void mangleMemberExpr(const Expr *base, bool isArrow,
                         NestedNameSpecifier *qualifier,
-                        ArrayRef<DeclAccessPair> UnqualifiedLookups,
+                        NamedDecl *firstQualifierLookup,
                         DeclarationName name,
                         const TemplateArgumentLoc *TemplateArgs,
-                        unsigned NumTemplateArgs, unsigned knownArity);
+                        unsigned NumTemplateArgs,
+                        unsigned knownArity);
   void mangleCastExpression(const Expr *E, StringRef CastEncoding);
   void mangleInitListElements(const InitListExpr *InitList);
   void mangleRequirement(SourceLocation RequiresExprLoc,
@@ -4495,11 +4496,14 @@
 }
 
 /// Mangles a member expression.
-void CXXNameMangler::mangleMemberExpr(
-    const Expr *base, bool isArrow, NestedNameSpecifier *qualifier,
-    ArrayRef<DeclAccessPair> UnqualifiedLookups, DeclarationName member,
-    const TemplateArgumentLoc *TemplateArgs, unsigned NumTemplateArgs,
-    unsigned arity) {
+void CXXNameMangler::mangleMemberExpr(const Expr *base,
+                                      bool isArrow,
+                                      NestedNameSpecifier *qualifier,
+                                      NamedDecl *firstQualifierLookup,
+                                      DeclarationName member,
+                                      const TemplateArgumentLoc *TemplateArgs,
+                                      unsigned NumTemplateArgs,
+                                      unsigned arity) {
   // <expression> ::= dt <expression> <unresolved-name>
   //              ::= pt <expression> <unresolved-name>
   if (base)
@@ -4981,9 +4985,11 @@
   case Expr::MemberExprClass: {
     NotPrimaryExpr();
     const MemberExpr *ME = cast<MemberExpr>(E);
-    mangleMemberExpr(ME->getBase(), ME->isArrow(), ME->getQualifier(),
-                     std::nullopt, ME->getMemberDecl()->getDeclName(),
-                     ME->getTemplateArgs(), ME->getNumTemplateArgs(), Arity);
+    mangleMemberExpr(ME->getBase(), ME->isArrow(),
+                     ME->getQualifier(), nullptr,
+                     ME->getMemberDecl()->getDeclName(),
+                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),
+                     Arity);
     break;
   }
 
@@ -4991,9 +4997,10 @@
     NotPrimaryExpr();
     const UnresolvedMemberExpr *ME = cast<UnresolvedMemberExpr>(E);
     mangleMemberExpr(ME->isImplicitAccess() ? nullptr : ME->getBase(),
-                     ME->isArrow(), ME->getQualifier(), std::nullopt,
-                     ME->getMemberName(), ME->getTemplateArgs(),
-                     ME->getNumTemplateArgs(), Arity);
+                     ME->isArrow(), ME->getQualifier(), nullptr,
+                     ME->getMemberName(),
+                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),
+                     Arity);
     break;
   }
 
@@ -5003,8 +5010,10 @@
       = cast<CXXDependentScopeMemberExpr>(E);
     mangleMemberExpr(ME->isImplicitAccess() ? nullptr : ME->getBase(),
                      ME->isArrow(), ME->getQualifier(),
-                     ME->unqualified_lookups(), ME->getMember(),
-                     ME->getTemplateArgs(), ME->getNumTemplateArgs(), Arity);
+                     ME->getFirstQualifierFoundInScope(),
+                     ME->getMember(),
+                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),
+                     Arity);
     break;
   }
 
diff -ruN --strip-trailing-cr a/clang/lib/Basic/CMakeLists.txt b/clang/lib/Basic/CMakeLists.txt
--- a/clang/lib/Basic/CMakeLists.txt
+++ b/clang/lib/Basic/CMakeLists.txt
@@ -102,6 +102,7 @@
   Targets/DirectX.cpp
   Targets/Hexagon.cpp
   Targets/Lanai.cpp
+  Targets/Le64.cpp
   Targets/LoongArch.cpp
   Targets/M68k.cpp
   Targets/MSP430.cpp
diff -ruN --strip-trailing-cr a/clang/lib/Basic/Targets/Le64.cpp b/clang/lib/Basic/Targets/Le64.cpp
--- a/clang/lib/Basic/Targets/Le64.cpp
+++ b/clang/lib/Basic/Targets/Le64.cpp
@@ -0,0 +1,30 @@
+//===--- Le64.cpp - Implement Le64 target feature support -----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements Le64 TargetInfo objects.
+//
+//===----------------------------------------------------------------------===//
+
+#include "Le64.h"
+#include "Targets.h"
+#include "clang/Basic/Builtins.h"
+#include "clang/Basic/MacroBuilder.h"
+#include "clang/Basic/TargetBuiltins.h"
+
+using namespace clang;
+using namespace clang::targets;
+
+ArrayRef<Builtin::Info> Le64TargetInfo::getTargetBuiltins() const {
+  return {};
+}
+
+void Le64TargetInfo::getTargetDefines(const LangOptions &Opts,
+                                      MacroBuilder &Builder) const {
+  DefineStd(Builder, "unix", Opts);
+  defineCPUMacros(Builder, "le64", /*Tuning=*/false);
+}
diff -ruN --strip-trailing-cr a/clang/lib/Basic/Targets/Le64.h b/clang/lib/Basic/Targets/Le64.h
--- a/clang/lib/Basic/Targets/Le64.h
+++ b/clang/lib/Basic/Targets/Le64.h
@@ -0,0 +1,64 @@
+//===--- Le64.h - Declare Le64 target feature support -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares Le64 TargetInfo objects.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_BASIC_TARGETS_LE64_H
+#define LLVM_CLANG_LIB_BASIC_TARGETS_LE64_H
+
+#include "clang/Basic/TargetInfo.h"
+#include "clang/Basic/TargetOptions.h"
+#include "llvm/Support/Compiler.h"
+#include "llvm/TargetParser/Triple.h"
+
+namespace clang {
+namespace targets {
+
+class LLVM_LIBRARY_VISIBILITY Le64TargetInfo : public TargetInfo {
+
+public:
+  Le64TargetInfo(const llvm::Triple &Triple, const TargetOptions &)
+      : TargetInfo(Triple) {
+    NoAsmVariants = true;
+    LongWidth = LongAlign = PointerWidth = PointerAlign = 64;
+    MaxAtomicPromoteWidth = MaxAtomicInlineWidth = 64;
+    resetDataLayout("e-m:e-v128:32-v16:16-v32:32-v96:32-n8:16:32:64-S128");
+  }
+
+  void getTargetDefines(const LangOptions &Opts,
+                        MacroBuilder &Builder) const override;
+
+  ArrayRef<Builtin::Info> getTargetBuiltins() const override;
+
+  BuiltinVaListKind getBuiltinVaListKind() const override {
+    return TargetInfo::PNaClABIBuiltinVaList;
+  }
+
+  std::string_view getClobbers() const override { return ""; }
+
+  ArrayRef<const char *> getGCCRegNames() const override {
+    return std::nullopt;
+  }
+
+  ArrayRef<TargetInfo::GCCRegAlias> getGCCRegAliases() const override {
+    return std::nullopt;
+  }
+
+  bool validateAsmConstraint(const char *&Name,
+                             TargetInfo::ConstraintInfo &Info) const override {
+    return false;
+  }
+
+  bool hasProtectedVisibility() const override { return false; }
+};
+
+} // namespace targets
+} // namespace clang
+#endif // LLVM_CLANG_LIB_BASIC_TARGETS_LE64_H
diff -ruN --strip-trailing-cr a/clang/lib/Basic/Targets/OSTargets.h b/clang/lib/Basic/Targets/OSTargets.h
--- a/clang/lib/Basic/Targets/OSTargets.h
+++ b/clang/lib/Basic/Targets/OSTargets.h
@@ -841,6 +841,9 @@
                             "i64:64-i128:128-n8:16:32:64-S128");
     } else if (Triple.getArch() == llvm::Triple::mipsel) {
       // Handled on mips' setDataLayout.
+    } else {
+      assert(Triple.getArch() == llvm::Triple::le32);
+      this->resetDataLayout("e-p:32:32-i64:64");
     }
   }
 };
diff -ruN --strip-trailing-cr a/clang/lib/Basic/Targets.cpp b/clang/lib/Basic/Targets.cpp
--- a/clang/lib/Basic/Targets.cpp
+++ b/clang/lib/Basic/Targets.cpp
@@ -23,6 +23,7 @@
 #include "Targets/DirectX.h"
 #include "Targets/Hexagon.h"
 #include "Targets/Lanai.h"
+#include "Targets/Le64.h"
 #include "Targets/LoongArch.h"
 #include "Targets/M68k.h"
 #include "Targets/MSP430.h"
@@ -343,6 +344,17 @@
       return std::make_unique<M68kTargetInfo>(Triple, Opts);
     }
 
+  case llvm::Triple::le32:
+    switch (os) {
+    case llvm::Triple::NaCl:
+      return std::make_unique<NaClTargetInfo<PNaClTargetInfo>>(Triple, Opts);
+    default:
+      return nullptr;
+    }
+
+  case llvm::Triple::le64:
+    return std::make_unique<Le64TargetInfo>(Triple, Opts);
+
   case llvm::Triple::ppc:
     switch (os) {
     case llvm::Triple::Linux:
diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CodeGenModule.cpp b/clang/lib/CodeGen/CodeGenModule.cpp
--- a/clang/lib/CodeGen/CodeGenModule.cpp
+++ b/clang/lib/CodeGen/CodeGenModule.cpp
@@ -116,6 +116,8 @@
   default:
     return createDefaultTargetCodeGenInfo(CGM);
 
+  case llvm::Triple::le32:
+    return createPNaClTargetCodeGenInfo(CGM);
   case llvm::Triple::m68k:
     return createM68kTargetCodeGenInfo(CGM);
   case llvm::Triple::mips:
diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/ItaniumCXXABI.cpp b/clang/lib/CodeGen/ItaniumCXXABI.cpp
--- a/clang/lib/CodeGen/ItaniumCXXABI.cpp
+++ b/clang/lib/CodeGen/ItaniumCXXABI.cpp
@@ -576,6 +576,13 @@
     return new XLCXXABI(CGM);
 
   case TargetCXXABI::GenericItanium:
+    if (CGM.getContext().getTargetInfo().getTriple().getArch()
+        == llvm::Triple::le32) {
+      // For PNaCl, use ARM-style method pointers so that PNaCl code
+      // does not assume anything about the alignment of function
+      // pointers.
+      return new ItaniumCXXABI(CGM, /*UseARMMethodPtrABI=*/true);
+    }
     return new ItaniumCXXABI(CGM);
 
   case TargetCXXABI::Microsoft:
diff -ruN --strip-trailing-cr a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
--- a/clang/lib/Driver/ToolChains/Clang.cpp
+++ b/clang/lib/Driver/ToolChains/Clang.cpp
@@ -3815,6 +3815,12 @@
     if (UseBuiltins)
       A->render(Args, CmdArgs);
   }
+
+  // le32-specific flags:
+  //  -fno-math-builtin: clang should not convert math builtins to intrinsics
+  //                     by default.
+  if (TC.getArch() == llvm::Triple::le32)
+    CmdArgs.push_back("-fno-math-builtin");
 }
 
 bool Driver::getDefaultModuleCachePath(SmallVectorImpl<char> &Result) {
diff -ruN --strip-trailing-cr a/clang/lib/Parse/ParseExpr.cpp b/clang/lib/Parse/ParseExpr.cpp
--- a/clang/lib/Parse/ParseExpr.cpp
+++ b/clang/lib/Parse/ParseExpr.cpp
@@ -2343,9 +2343,10 @@
       }
 
       if (!LHS.isInvalid())
-        LHS = Actions.ActOnMemberAccessExpr(
-            getCurScope(), LHS.get(), OpLoc, OpKind, SS, TemplateKWLoc, Name,
-            CurParsedObjCImpl ? CurParsedObjCImpl->Dcl : nullptr);
+        LHS = Actions.ActOnMemberAccessExpr(getCurScope(), LHS.get(), OpLoc,
+                                            OpKind, SS, TemplateKWLoc, Name,
+                                 CurParsedObjCImpl ? CurParsedObjCImpl->Dcl
+                                                   : nullptr);
       if (!LHS.isInvalid()) {
         if (Tok.is(tok::less))
           checkPotentialAngleBracket(LHS);
diff -ruN --strip-trailing-cr a/clang/lib/Parse/ParseExprCXX.cpp b/clang/lib/Parse/ParseExprCXX.cpp
--- a/clang/lib/Parse/ParseExprCXX.cpp
+++ b/clang/lib/Parse/ParseExprCXX.cpp
@@ -100,8 +100,7 @@
   bool MemberOfUnknownSpecialization;
   if (!Actions.isTemplateName(getCurScope(), SS, /*hasTemplateKeyword=*/false,
                               TemplateName, ObjectType, EnteringContext,
-                              Template, MemberOfUnknownSpecialization,
-                              /*Disambiguation=*/false, /*MayBeNNS=*/true))
+                              Template, MemberOfUnknownSpecialization))
     return;
 
   FixDigraph(*this, PP, Next, SecondToken, tok::unknown,
@@ -354,8 +353,7 @@
       TemplateTy Template;
       TemplateNameKind TNK = Actions.ActOnTemplateName(
           getCurScope(), SS, TemplateKWLoc, TemplateName, ObjectType,
-          EnteringContext, Template, /*AllowInjectedClassName*/ true,
-          /*MayBeNNS=*/true);
+          EnteringContext, Template, /*AllowInjectedClassName*/ true);
       if (AnnotateTemplateIdToken(Template, TNK, SS, TemplateKWLoc,
                                   TemplateName, false))
         return true;
@@ -407,6 +405,7 @@
                                       : TemplateId->TemplateNameLoc;
         SS.SetInvalid(SourceRange(StartLoc, CCLoc));
       }
+
       continue;
     }
 
@@ -529,19 +528,18 @@
       UnqualifiedId TemplateName;
       TemplateName.setIdentifier(&II, Tok.getLocation());
       bool MemberOfUnknownSpecialization;
-      if (TemplateNameKind TNK = Actions.isTemplateName(
-              getCurScope(), SS,
-              /*hasTemplateKeyword=*/false, TemplateName, ObjectType,
-              EnteringContext, Template, MemberOfUnknownSpecialization,
-              /*Disambiguation=*/false,
-              /*MayBeNNS=*/true)) {
+      if (TemplateNameKind TNK = Actions.isTemplateName(getCurScope(), SS,
+                                              /*hasTemplateKeyword=*/false,
+                                                        TemplateName,
+                                                        ObjectType,
+                                                        EnteringContext,
+                                                        Template,
+                                              MemberOfUnknownSpecialization)) {
         // If lookup didn't find anything, we treat the name as a template-name
         // anyway. C++20 requires this, and in prior language modes it improves
         // error recovery. But before we commit to this, check that we actually
         // have something that looks like a template-argument-list next.
-        if (!IsTypename &&
-            (TNK == TNK_Undeclared_template ||
-             (!HasScopeSpecifier && ObjectType)) &&
+        if (!IsTypename && TNK == TNK_Undeclared_template &&
             isTemplateArgumentList(1) == TPResult::False)
           break;
 
@@ -568,7 +566,11 @@
           // member of an unknown specialization. However, this will only
           // parse correctly as a template, so suggest the keyword 'template'
           // before 'getAs' and treat this as a dependent template name.
-          Diag(Tok.getLocation(), diag::ext_missing_dependent_template_keyword)
+          unsigned DiagID = diag::err_missing_dependent_template_keyword;
+          if (getLangOpts().MicrosoftExt)
+            DiagID = diag::warn_missing_dependent_template_keyword;
+
+          Diag(Tok.getLocation(), DiagID)
               << II.getName()
               << FixItHint::CreateInsertion(Tok.getLocation(), "template ");
         }
@@ -1918,12 +1920,12 @@
   // argument list. This affects examples such as
   //   void f(auto *p) { p->~X<int>(); }
   // ... but there's no ambiguity, and nowhere to write 'template' in such an
-  // example, so we accept it anyway
-  if (Tok.is(tok::less) && ParseUnqualifiedIdTemplateId(
-                               SS, ObjectType, Base && Base->containsErrors(),
-                               /*TemplateKWLoc=*/SourceLocation(), TildeLoc,
-                               Name, NameLoc, false, SecondTypeName,
-                               /*AssumeTemplateId=*/true))
+  // example, so we accept it anyway.
+  if (Tok.is(tok::less) &&
+      ParseUnqualifiedIdTemplateId(
+          SS, ObjectType, Base && Base->containsErrors(), SourceLocation(),
+          Name, NameLoc, false, SecondTypeName,
+          /*AssumeTemplateId=*/true))
     return ExprError();
 
   return Actions.ActOnPseudoDestructorExpr(getCurScope(), Base, OpLoc, OpKind,
@@ -2530,9 +2532,8 @@
 /// \returns true if a parse error occurred, false otherwise.
 bool Parser::ParseUnqualifiedIdTemplateId(
     CXXScopeSpec &SS, ParsedType ObjectType, bool ObjectHadErrors,
-    SourceLocation TemplateKWLoc, SourceLocation TildeLoc, IdentifierInfo *Name,
-    SourceLocation NameLoc, bool EnteringContext, UnqualifiedId &Id,
-    bool AssumeTemplateId) {
+    SourceLocation TemplateKWLoc, IdentifierInfo *Name, SourceLocation NameLoc,
+    bool EnteringContext, UnqualifiedId &Id, bool AssumeTemplateId) {
   assert(Tok.is(tok::less) && "Expected '<' to finish parsing a template-id");
 
   TemplateTy Template;
@@ -2546,14 +2547,13 @@
       // this template-id is used to form a nested-name-specifier or not.
       TNK = Actions.ActOnTemplateName(getCurScope(), SS, TemplateKWLoc, Id,
                                       ObjectType, EnteringContext, Template,
-                                      /*AllowInjectedClassName=*/true,
-                                      TildeLoc.isValid());
+                                      /*AllowInjectedClassName*/ true);
     } else {
       bool MemberOfUnknownSpecialization;
-      TNK = Actions.isTemplateName(
-          getCurScope(), SS, TemplateKWLoc.isValid(), Id, ObjectType,
-          EnteringContext, Template, MemberOfUnknownSpecialization,
-          /*Disambiguation=*/false, TildeLoc.isValid());
+      TNK = Actions.isTemplateName(getCurScope(), SS,
+                                   TemplateKWLoc.isValid(), Id,
+                                   ObjectType, EnteringContext, Template,
+                                   MemberOfUnknownSpecialization);
       // If lookup found nothing but we're assuming that this is a template
       // name, double-check that makes sense syntactically before committing
       // to it.
@@ -2580,13 +2580,13 @@
             else
               Name += Id.Identifier->getName();
           }
-          Diag(Id.StartLocation, diag::ext_missing_dependent_template_keyword)
+          Diag(Id.StartLocation, diag::err_missing_dependent_template_keyword)
               << Name
               << FixItHint::CreateInsertion(Id.StartLocation, "template ");
         }
         TNK = Actions.ActOnTemplateName(
             getCurScope(), SS, TemplateKWLoc, Id, ObjectType, EnteringContext,
-            Template, /*AllowInjectedClassName=*/true, TildeLoc.isValid());
+            Template, /*AllowInjectedClassName*/ true);
       } else if (TNK == TNK_Non_template) {
         return false;
       }
@@ -2611,16 +2611,14 @@
     bool MemberOfUnknownSpecialization;
     TemplateName.setIdentifier(Name, NameLoc);
     if (ObjectType) {
-      TNK = Actions.ActOnTemplateName(getCurScope(), SS, TemplateKWLoc,
-                                      TemplateName, ObjectType, EnteringContext,
-                                      Template, /*AllowInjectedClassName=*/true,
-                                      /*MayBeNNS=*/true);
+      TNK = Actions.ActOnTemplateName(
+          getCurScope(), SS, TemplateKWLoc, TemplateName, ObjectType,
+          EnteringContext, Template, /*AllowInjectedClassName*/ true);
     } else {
       TNK = Actions.isTemplateName(getCurScope(), SS, TemplateKWLoc.isValid(),
-                                   TemplateName, ObjectType, EnteringContext,
-                                   Template, MemberOfUnknownSpecialization,
-                                   /*Disambiguation=*/false,
-                                   /*MayBeNNS=*/true);
+                                   TemplateName, ObjectType,
+                                   EnteringContext, Template,
+                                   MemberOfUnknownSpecialization);
 
       if (TNK == TNK_Non_template && !Id.DestructorName.get()) {
         Diag(NameLoc, diag::err_destructor_template_id)
@@ -2682,7 +2680,7 @@
   if (Id.getKind() == UnqualifiedIdKind::IK_ConstructorName)
     Id.setConstructorName(Type.get(), NameLoc, RAngleLoc);
   else
-    Id.setDestructorName(TildeLoc, Type.get(), RAngleLoc);
+    Id.setDestructorName(Id.StartLocation, Type.get(), RAngleLoc);
 
   return false;
 }
@@ -3030,9 +3028,8 @@
     if (Tok.is(tok::less))
       return ParseUnqualifiedIdTemplateId(
           SS, ObjectType, ObjectHadErrors,
-          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(),
-          /*TildeLoc=*/SourceLocation(), Id, IdLoc, EnteringContext, Result,
-          TemplateSpecified);
+          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(), Id, IdLoc,
+          EnteringContext, Result, TemplateSpecified);
 
     if (TemplateSpecified) {
       TemplateNameKind TNK =
@@ -3127,15 +3124,13 @@
         Tok.is(tok::less))
       return ParseUnqualifiedIdTemplateId(
           SS, ObjectType, ObjectHadErrors,
-          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(),
-          /*TildeLoc=*/SourceLocation(), /*Name=*/nullptr,
-          /*NameLoc=*/SourceLocation(), EnteringContext, Result,
-          TemplateSpecified);
+          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(), nullptr,
+          SourceLocation(), EnteringContext, Result, TemplateSpecified);
     else if (TemplateSpecified &&
              Actions.ActOnTemplateName(
                  getCurScope(), SS, *TemplateKWLoc, Result, ObjectType,
                  EnteringContext, Template,
-                 /*AllowInjectedClassName=*/true) == TNK_Non_template)
+                 /*AllowInjectedClassName*/ true) == TNK_Non_template)
       return true;
 
     return false;
@@ -3225,8 +3220,8 @@
       Result.setDestructorName(TildeLoc, nullptr, ClassNameLoc);
       return ParseUnqualifiedIdTemplateId(
           SS, ObjectType, ObjectHadErrors,
-          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(), TildeLoc,
-          ClassName, ClassNameLoc, EnteringContext, Result, TemplateSpecified);
+          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(), ClassName,
+          ClassNameLoc, EnteringContext, Result, TemplateSpecified);
     }
 
     // Note that this is a destructor name.
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaCoroutine.cpp b/clang/lib/Sema/SemaCoroutine.cpp
--- a/clang/lib/Sema/SemaCoroutine.cpp
+++ b/clang/lib/Sema/SemaCoroutine.cpp
@@ -306,8 +306,8 @@
   // FIXME: Fix BuildMemberReferenceExpr to take a const CXXScopeSpec&.
   CXXScopeSpec SS;
   ExprResult Result = S.BuildMemberReferenceExpr(
-      Base, Base->getType(), Loc, /*IsPtr=*/false, SS, SourceLocation(),
-      NameInfo, /*TemplateArgs=*/nullptr,
+      Base, Base->getType(), Loc, /*IsPtr=*/false, SS,
+      SourceLocation(), nullptr, NameInfo, /*TemplateArgs=*/nullptr,
       /*Scope=*/nullptr);
   if (Result.isInvalid())
     return ExprError();
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaCXXScopeSpec.cpp b/clang/lib/Sema/SemaCXXScopeSpec.cpp
--- a/clang/lib/Sema/SemaCXXScopeSpec.cpp
+++ b/clang/lib/Sema/SemaCXXScopeSpec.cpp
@@ -356,41 +356,29 @@
   return false;
 }
 
-/// If the given nested-name-specifier begins with a bare identifier
-/// (e.g., Base::), perform name lookup for that identifier as a
-/// nested-name-specifier within the given scope, and return the result of that
-/// name lookup.
-bool Sema::LookupFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS,
-                                       UnresolvedSetImpl &R) {
-  if (!S)
-    return false;
+NamedDecl *Sema::FindFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS) {
+  if (!S || !NNS)
+    return nullptr;
 
   while (NNS->getPrefix())
     NNS = NNS->getPrefix();
 
-  // FIXME: This is a rather nasty hack! Ideally we should get the results
-  // from LookupTemplateName/BuildCXXNestedNameSpecifier.
-  const IdentifierInfo *II = NNS->getAsIdentifier();
-  if (!II) {
-    if (const auto *DTST =
-            dyn_cast_if_present<DependentTemplateSpecializationType>(
-                NNS->getAsType()))
-      II = DTST->getIdentifier();
-    else
-      return false;
-  }
-  assert(II && "Missing first qualifier in scope");
-  LookupResult Found(*this, II, SourceLocation(),
-                     NNS->getAsIdentifier() ? LookupNestedNameSpecifierName
-                                            : LookupOrdinaryName);
+  if (NNS->getKind() != NestedNameSpecifier::Identifier)
+    return nullptr;
+
+  LookupResult Found(*this, NNS->getAsIdentifier(), SourceLocation(),
+                     LookupNestedNameSpecifierName);
   LookupName(Found, S);
+  assert(!Found.isAmbiguous() && "Cannot handle ambiguities here yet");
 
-  if (Found.empty())
-    return false;
+  if (!Found.isSingleResult())
+    return nullptr;
 
-  R.addAllDecls(Found.asUnresolvedSet().pairs());
-  Found.suppressDiagnostics();
-  return true;
+  NamedDecl *Result = Found.getFoundDecl();
+  if (isAcceptableNestedNameSpecifier(Result))
+    return Result;
+
+  return nullptr;
 }
 
 namespace {
@@ -419,82 +407,112 @@
 
 bool Sema::BuildCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
                                        bool EnteringContext, CXXScopeSpec &SS,
+                                       NamedDecl *ScopeLookupResult,
                                        bool ErrorRecoveryLookup,
                                        bool *IsCorrectedToColon,
                                        bool OnlyNamespace) {
   if (IdInfo.Identifier->isEditorPlaceholder())
     return true;
-  if (IsCorrectedToColon)
-    *IsCorrectedToColon = false;
-
-  QualType ObjectType = GetTypeFromParser(IdInfo.ObjectType);
   LookupResult Found(*this, IdInfo.Identifier, IdInfo.IdentifierLoc,
                      OnlyNamespace ? LookupNamespaceName
                                    : LookupNestedNameSpecifierName);
+  QualType ObjectType = GetTypeFromParser(IdInfo.ObjectType);
 
-  // C++ [basic.lookup.qual.general]p3:
-  //   Qualified name lookup in a class, namespace, or enumeration performs a
-  //   search of the scope associated with it except as specified below.
-  LookupParsedName(Found, S, &SS, ObjectType,
-                   /*AllowBuiltinCreation=*/false, EnteringContext);
-
-  // C++ [basic.lookup.qual.general]p3:
-  //   [...] Unless otherwise specified, a qualified name undergoes qualified
-  //   name lookup in its lookup context from the point where it appears unless
-  //   the lookup context either is dependent and is not the current
-  //   instantiation or is not a class or class template.
-  if (Found.wasNotFoundInCurrentInstantiation()) {
-    // Don't speculate if we're just trying to improve error recovery.
-    if (ErrorRecoveryLookup)
-      return true;
-
-    // The lookup context is dependent and either:
-    // - it is not the current instantiation, or
-    // - it is the current instantiation, it has at least one dependent base
-    //   class, and qualified lookup found nothing.
-    // Build a dependent nested-name-specifier. We will lookup the name again
-    // during instantiation.
-    SS.Extend(Context, IdInfo.Identifier, IdInfo.IdentifierLoc, IdInfo.CCLoc);
-    return false;
+  // Determine where to perform name lookup
+  DeclContext *LookupCtx = nullptr;
+  bool isDependent = false;
+  if (IsCorrectedToColon)
+    *IsCorrectedToColon = false;
+  if (!ObjectType.isNull()) {
+    // This nested-name-specifier occurs in a member access expression, e.g.,
+    // x->B::f, and we are looking into the type of the object.
+    assert(!SS.isSet() && "ObjectType and scope specifier cannot coexist");
+    LookupCtx = computeDeclContext(ObjectType);
+    isDependent = ObjectType->isDependentType();
+  } else if (SS.isSet()) {
+    // This nested-name-specifier occurs after another nested-name-specifier,
+    // so look into the context associated with the prior nested-name-specifier.
+    LookupCtx = computeDeclContext(SS, EnteringContext);
+    isDependent = isDependentScopeSpecifier(SS);
+    Found.setContextRange(SS.getRange());
   }
 
   bool ObjectTypeSearchedInScope = false;
+  if (LookupCtx) {
+    // Perform "qualified" name lookup into the declaration context we
+    // computed, which is either the type of the base of a member access
+    // expression or the declaration context associated with a prior
+    // nested-name-specifier.
+
+    // The declaration context must be complete.
+    if (!LookupCtx->isDependentContext() &&
+        RequireCompleteDeclContext(SS, LookupCtx))
+      return true;
 
-  // C++ [basic.lookup.qual.general]p2:
-  //   A member-qualified name is the (unique) component name, if any, of
-  //   - an unqualified-id or
-  //   - a nested-name-specifier of the form type-name :: or namespace-name ::
-  //   in the id-expression of a class member access expression.
-  //
-  // C++ [basic.lookup.qual.general]p3:
-  //   [...] If nothing is found by qualified lookup for a member-qualified
-  //   name that is the terminal name of a nested-name-specifier and is not
-  //   dependent, it undergoes unqualified lookup.
-  //
-  // In 'x.A::B::y', 'A' will undergo unqualified lookup if qualified lookup
-  // in the type of 'x' finds nothing. If the lookup context is dependent,
-  // we perform the unqualified lookup in the template definition context
-  // and store the results so we can replicate the lookup during instantiation.
-  if (Found.empty() && !ObjectType.isNull()) {
-    if (S) {
-      LookupName(Found, S);
-    } else if (!SS.getUnqualifiedLookups().empty()) {
-      Found.addAllDecls(SS.getUnqualifiedLookups());
-      Found.resolveKind();
+    LookupQualifiedName(Found, LookupCtx);
+
+    if (!ObjectType.isNull() && Found.empty()) {
+      // C++ [basic.lookup.classref]p4:
+      //   If the id-expression in a class member access is a qualified-id of
+      //   the form
+      //
+      //        class-name-or-namespace-name::...
+      //
+      //   the class-name-or-namespace-name following the . or -> operator is
+      //   looked up both in the context of the entire postfix-expression and in
+      //   the scope of the class of the object expression. If the name is found
+      //   only in the scope of the class of the object expression, the name
+      //   shall refer to a class-name. If the name is found only in the
+      //   context of the entire postfix-expression, the name shall refer to a
+      //   class-name or namespace-name. [...]
+      //
+      // Qualified name lookup into a class will not find a namespace-name,
+      // so we do not need to diagnose that case specifically. However,
+      // this qualified name lookup may find nothing. In that case, perform
+      // unqualified name lookup in the given scope (if available) or
+      // reconstruct the result from when name lookup was performed at template
+      // definition time.
+      if (S)
+        LookupName(Found, S);
+      else if (ScopeLookupResult)
+        Found.addDecl(ScopeLookupResult);
+
+      ObjectTypeSearchedInScope = true;
     }
-    ObjectTypeSearchedInScope = true;
+  } else if (!isDependent) {
+    // Perform unqualified name lookup in the current scope.
+    LookupName(Found, S);
   }
 
   if (Found.isAmbiguous())
     return true;
 
+  // If we performed lookup into a dependent context and did not find anything,
+  // that's fine: just build a dependent nested-name-specifier.
+  if (Found.empty() && isDependent &&
+      !(LookupCtx && LookupCtx->isRecord() &&
+        (!cast<CXXRecordDecl>(LookupCtx)->hasDefinition() ||
+         !cast<CXXRecordDecl>(LookupCtx)->hasAnyDependentBases()))) {
+    // Don't speculate if we're just trying to improve error recovery.
+    if (ErrorRecoveryLookup)
+      return true;
+
+    // We were not able to compute the declaration context for a dependent
+    // base object type or prior nested-name-specifier, so this
+    // nested-name-specifier refers to an unknown specialization. Just build
+    // a dependent nested-name-specifier.
+    SS.Extend(Context, IdInfo.Identifier, IdInfo.IdentifierLoc, IdInfo.CCLoc);
+    return false;
+  }
+
   if (Found.empty() && !ErrorRecoveryLookup) {
     // If identifier is not found as class-name-or-namespace-name, but is found
     // as other entity, don't look for typos.
     LookupResult R(*this, Found.getLookupNameInfo(), LookupOrdinaryName);
-    LookupParsedName(R, S, &SS, ObjectType,
-                     /*AllowBuiltinCreation=*/false, EnteringContext);
-
+    if (LookupCtx)
+      LookupQualifiedName(R, LookupCtx);
+    else if (S && !isDependent)
+      LookupName(R, S);
     if (!R.empty()) {
       // Don't diagnose problems with this speculative lookup.
       R.suppressDiagnostics();
@@ -521,11 +539,6 @@
     }
   }
 
-  DeclContext *LookupCtx =
-      SS.isSet()
-          ? computeDeclContext(SS, EnteringContext)
-          : (!ObjectType.isNull() ? computeDeclContext(ObjectType) : nullptr);
-
   if (Found.empty() && !ErrorRecoveryLookup && !getLangOpts().MSVCCompat) {
     // We haven't found anything, and we're not recovering from a
     // different kind of error, so look for typos.
@@ -581,14 +594,14 @@
       // scope, reconstruct the result from the template instantiation itself.
       //
       // Note that C++11 does *not* perform this redundant lookup.
-      NamedDecl *OuterDecl = nullptr;
+      NamedDecl *OuterDecl;
       if (S) {
         LookupResult FoundOuter(*this, IdInfo.Identifier, IdInfo.IdentifierLoc,
                                 LookupNestedNameSpecifierName);
         LookupName(FoundOuter, S);
         OuterDecl = FoundOuter.getAsSingle<NamedDecl>();
-      } else if (!SS.getUnqualifiedLookups().empty())
-        OuterDecl = SS.getUnqualifiedLookups().front().getDecl();
+      } else
+        OuterDecl = ScopeLookupResult;
 
       if (isAcceptableNestedNameSpecifier(OuterDecl) &&
           OuterDecl->getCanonicalDecl() != SD->getCanonicalDecl() &&
@@ -766,7 +779,7 @@
     return true;
 
   return BuildCXXNestedNameSpecifier(S, IdInfo, EnteringContext, SS,
-                                     /*ErrorRecoveryLookup=*/false,
+                                     /*ScopeLookupResult=*/nullptr, false,
                                      IsCorrectedToColon, OnlyNamespace);
 }
 
@@ -827,7 +840,7 @@
     return false;
 
   return !BuildCXXNestedNameSpecifier(S, IdInfo, EnteringContext, SS,
-                                      /*ErrorRecoveryLookup=*/true);
+                                      /*ScopeLookupResult=*/nullptr, true);
 }
 
 bool Sema::ActOnCXXNestedNameSpecifier(Scope *S,
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclCXX.cpp b/clang/lib/Sema/SemaDeclCXX.cpp
--- a/clang/lib/Sema/SemaDeclCXX.cpp
+++ b/clang/lib/Sema/SemaDeclCXX.cpp
@@ -1275,11 +1275,9 @@
     if (UseMemberGet) {
       //   if [lookup of member get] finds at least one declaration, the
       //   initializer is e.get<i-1>().
-      E = S.BuildMemberReferenceExpr(E.get(), DecompType, Loc,
-                                     /*IsArrow=*/false,
-                                     /*SS=*/CXXScopeSpec(),
-                                     /*TemplateKWLoc=*/SourceLocation(),
-                                     MemberGet, &Args, /*S=*/nullptr);
+      E = S.BuildMemberReferenceExpr(E.get(), DecompType, Loc, false,
+                                     CXXScopeSpec(), SourceLocation(), nullptr,
+                                     MemberGet, &Args, nullptr);
       if (E.isInvalid())
         return true;
 
@@ -4903,12 +4901,16 @@
     MemberLookup.addDecl(Indirect ? cast<ValueDecl>(Indirect)
                                   : cast<ValueDecl>(Field), AS_public);
     MemberLookup.resolveKind();
-    ExprResult CtorArg = SemaRef.BuildMemberReferenceExpr(
-        MemberExprBase, ParamType, Loc,
-        /*IsArrow=*/false, SS,
-        /*TemplateKWLoc=*/SourceLocation(), MemberLookup,
-        /*TemplateArgs=*/nullptr,
-        /*S=*/nullptr);
+    ExprResult CtorArg
+      = SemaRef.BuildMemberReferenceExpr(MemberExprBase,
+                                         ParamType, Loc,
+                                         /*IsArrow=*/false,
+                                         SS,
+                                         /*TemplateKWLoc=*/SourceLocation(),
+                                         /*FirstQualifierInScope=*/nullptr,
+                                         MemberLookup,
+                                         /*TemplateArgs=*/nullptr,
+                                         /*S*/nullptr);
     if (CtorArg.isInvalid())
       return true;
 
@@ -14334,10 +14336,8 @@
 public:
   Expr *build(Sema &S, SourceLocation Loc) const override {
     return assertNotNull(S.BuildMemberReferenceExpr(
-                              Builder.build(S, Loc), Type, Loc, IsArrow, SS,
-                              /*TemplateKwLoc=*/SourceLocation(), MemberLookup,
-                              /*TemplateArgs=*/nullptr, /*S=*/nullptr)
-                             .get());
+        Builder.build(S, Loc), Type, Loc, IsArrow, SS, SourceLocation(),
+        nullptr, MemberLookup, nullptr, nullptr).get());
   }
 
   MemberBuilder(const ExprBuilder &Builder, QualType Type, bool IsArrow,
@@ -14543,11 +14543,13 @@
                    Loc);
 
     // Create the reference to operator=.
-    ExprResult OpEqualRef = S.BuildMemberReferenceExpr(
-        To.build(S, Loc), T, Loc, /*IsArrow=*/false, SS,
-        /*TemplateKWLoc=*/SourceLocation(), OpLookup,
-        /*TemplateArgs=*/nullptr, /*S*/ nullptr,
-        /*SuppressQualifierCheck=*/true);
+    ExprResult OpEqualRef
+      = S.BuildMemberReferenceExpr(To.build(S, Loc), T, Loc, /*IsArrow=*/false,
+                                   SS, /*TemplateKWLoc=*/SourceLocation(),
+                                   /*FirstQualifierInScope=*/nullptr,
+                                   OpLookup,
+                                   /*TemplateArgs=*/nullptr, /*S*/nullptr,
+                                   /*SuppressQualifierCheck=*/true);
     if (OpEqualRef.isInvalid())
       return StmtError();
 
@@ -17153,9 +17155,8 @@
 
   auto BuildExpr = [&](LookupResult &LR) {
     ExprResult Res = BuildMemberReferenceExpr(
-        Message, Message->getType(), Message->getBeginLoc(), /*IsArrow=*/false,
-        /*SS=*/CXXScopeSpec(), /*TemplateKWLoc=*/SourceLocation(), LR,
-        /*TemplateArgs=*/nullptr, /*S=*/nullptr);
+        Message, Message->getType(), Message->getBeginLoc(), false,
+        CXXScopeSpec(), SourceLocation(), nullptr, LR, nullptr, nullptr);
     if (Res.isInvalid())
       return ExprError();
     Res = BuildCallExpr(nullptr, Res.get(), Loc, std::nullopt, Loc, nullptr,
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaExpr.cpp b/clang/lib/Sema/SemaExpr.cpp
--- a/clang/lib/Sema/SemaExpr.cpp
+++ b/clang/lib/Sema/SemaExpr.cpp
@@ -2624,7 +2624,7 @@
     return CXXDependentScopeMemberExpr::Create(
         Context, /*This=*/nullptr, ThisType, /*IsArrow=*/true,
         /*Op=*/SourceLocation(), NestedNameSpecifierLoc(), TemplateKWLoc,
-        /*UnqualifiedLookups=*/std::nullopt, NameInfo, TemplateArgs);
+        /*FirstQualifierFoundInScope=*/nullptr, NameInfo, TemplateArgs);
   }
 
   // Synthesize a fake NNS that points to the derived class.  This will
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaExprMember.cpp b/clang/lib/Sema/SemaExprMember.cpp
--- a/clang/lib/Sema/SemaExprMember.cpp
+++ b/clang/lib/Sema/SemaExprMember.cpp
@@ -552,9 +552,11 @@
 }
 
 ExprResult
-Sema::ActOnDependentMemberExpr(Expr *BaseExpr, QualType BaseType, bool IsArrow,
-                               SourceLocation OpLoc, const CXXScopeSpec &SS,
+Sema::ActOnDependentMemberExpr(Expr *BaseExpr, QualType BaseType,
+                               bool IsArrow, SourceLocation OpLoc,
+                               const CXXScopeSpec &SS,
                                SourceLocation TemplateKWLoc,
+                               NamedDecl *FirstQualifierInScope,
                                const DeclarationNameInfo &NameInfo,
                                const TemplateArgumentListInfo *TemplateArgs) {
   // Even in dependent contexts, try to diagnose base expressions with
@@ -588,8 +590,8 @@
   // must have pointer type, and the accessed type is the pointee.
   return CXXDependentScopeMemberExpr::Create(
       Context, BaseExpr, BaseType, IsArrow, OpLoc,
-      SS.getWithLocInContext(Context), TemplateKWLoc,
-      SS.getUnqualifiedLookups(), NameInfo, TemplateArgs);
+      SS.getWithLocInContext(Context), TemplateKWLoc, FirstQualifierInScope,
+      NameInfo, TemplateArgs);
 }
 
 /// We know that the given qualified member reference points only to
@@ -765,9 +767,8 @@
           R.addDecl(ND);
         R.resolveKind();
         return SemaRef.BuildMemberReferenceExpr(
-            BaseExpr, BaseExpr->getType(), OpLoc, IsArrow, SS,
-            /*TemplateKWLoc=*/SourceLocation(), R, /*TemplateArgs=*/nullptr,
-            /*S=*/nullptr);
+            BaseExpr, BaseExpr->getType(), OpLoc, IsArrow, SS, SourceLocation(),
+            nullptr, R, nullptr, nullptr);
       },
       Sema::CTK_ErrorRecovery, DC);
 
@@ -783,7 +784,7 @@
 ExprResult Sema::BuildMemberReferenceExpr(
     Expr *Base, QualType BaseType, SourceLocation OpLoc, bool IsArrow,
     CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-    const DeclarationNameInfo &NameInfo,
+    NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,
     const TemplateArgumentListInfo *TemplateArgs, const Scope *S,
     ActOnMemberAccessExtraArgs *ExtraArgs) {
   LookupResult R(*this, NameInfo, LookupMemberName);
@@ -827,9 +828,10 @@
   if (SS.isInvalid())
     return ExprError();
 
-  return BuildMemberReferenceExpr(Base, BaseType, OpLoc, IsArrow, SS,
-                                  TemplateKWLoc, R, TemplateArgs, S,
-                                  /*SuppressQualifierCheck=*/false, ExtraArgs);
+  return BuildMemberReferenceExpr(Base, BaseType,
+                                  OpLoc, IsArrow, SS, TemplateKWLoc,
+                                  FirstQualifierInScope, R, TemplateArgs, S,
+                                  false, ExtraArgs);
 }
 
 ExprResult
@@ -967,11 +969,17 @@
   return false;
 }
 
-ExprResult Sema::BuildMemberReferenceExpr(
-    Expr *BaseExpr, QualType BaseExprType, SourceLocation OpLoc, bool IsArrow,
-    const CXXScopeSpec &SS, SourceLocation TemplateKWLoc, LookupResult &R,
-    const TemplateArgumentListInfo *TemplateArgs, const Scope *S,
-    bool SuppressQualifierCheck, ActOnMemberAccessExtraArgs *ExtraArgs) {
+ExprResult
+Sema::BuildMemberReferenceExpr(Expr *BaseExpr, QualType BaseExprType,
+                               SourceLocation OpLoc, bool IsArrow,
+                               const CXXScopeSpec &SS,
+                               SourceLocation TemplateKWLoc,
+                               NamedDecl *FirstQualifierInScope,
+                               LookupResult &R,
+                               const TemplateArgumentListInfo *TemplateArgs,
+                               const Scope *S,
+                               bool SuppressQualifierCheck,
+                               ActOnMemberAccessExtraArgs *ExtraArgs) {
   assert(!SS.isInvalid() && "nested-name-specifier cannot be invalid");
   // If the member wasn't found in the current instantiation, or if the
   // arrow operator was used with a dependent non-pointer object expression,
@@ -981,8 +989,8 @@
        (SS.isSet() ? SS.getScopeRep()->isDependent()
                    : BaseExprType->isDependentType())))
     return ActOnDependentMemberExpr(BaseExpr, BaseExprType, IsArrow, OpLoc, SS,
-                                    TemplateKWLoc, R.getLookupNameInfo(),
-                                    TemplateArgs);
+                                    TemplateKWLoc, FirstQualifierInScope,
+                                    R.getLookupNameInfo(), TemplateArgs);
 
   QualType BaseType = BaseExprType;
   if (IsArrow) {
@@ -1187,9 +1195,9 @@
 
     // Non-dependent member, but dependent template arguments.
     if (!VDecl.get())
-      return ActOnDependentMemberExpr(BaseExpr, BaseExpr->getType(), IsArrow,
-                                      OpLoc, SS, TemplateKWLoc, MemberNameInfo,
-                                      TemplateArgs);
+      return ActOnDependentMemberExpr(
+          BaseExpr, BaseExpr->getType(), IsArrow, OpLoc, SS, TemplateKWLoc,
+          FirstQualifierInScope, MemberNameInfo, TemplateArgs);
 
     VarDecl *Var = cast<VarDecl>(VDecl.get());
     if (!Var->getTemplateSpecializationKind())
@@ -1755,16 +1763,15 @@
   const TemplateArgumentListInfo *TemplateArgs;
   DecomposeUnqualifiedId(Id, TemplateArgsBuffer,
                          NameInfo, TemplateArgs);
-  bool IsArrow = OpKind == tok::arrow;
+
+  bool IsArrow = (OpKind == tok::arrow);
 
   if (getLangOpts().HLSL && IsArrow)
     return ExprError(Diag(OpLoc, diag::err_hlsl_operator_unsupported) << 2);
 
-  UnresolvedSet<4> UnqualifiedLookups;
-  if (SS.isValid() &&
-      LookupFirstQualifierInScope(S, SS.getScopeRep(), UnqualifiedLookups)) {
-    SS.setUnqualifiedLookups(UnqualifiedLookups.pairs());
-  }
+  NamedDecl *FirstQualifierInScope
+    = (!SS.isSet() ? nullptr : FindFirstQualifierInScope(S, SS.getScopeRep()));
+
   // This is a postfix expression, so get rid of ParenListExprs.
   ExprResult Result = MaybeConvertParenListExprToParenExpr(S, Base);
   if (Result.isInvalid()) return ExprError();
@@ -1772,8 +1779,8 @@
 
   ActOnMemberAccessExtraArgs ExtraArgs = {S, Id, ObjCImpDecl};
   ExprResult Res = BuildMemberReferenceExpr(
-      Base, Base->getType(), OpLoc, IsArrow, SS, TemplateKWLoc, NameInfo,
-      TemplateArgs, S, &ExtraArgs);
+      Base, Base->getType(), OpLoc, IsArrow, SS, TemplateKWLoc,
+      FirstQualifierInScope, NameInfo, TemplateArgs, S, &ExtraArgs);
 
   if (!Res.isInvalid() && isa<MemberExpr>(Res.get()))
     CheckMemberAccessOfNoDeref(cast<MemberExpr>(Res.get()));
@@ -1917,8 +1924,9 @@
     baseExpr = BuildCXXThisExpr(loc, ThisTy, /*IsImplicit=*/true);
   }
 
-  return BuildMemberReferenceExpr(baseExpr, ThisTy,
-                                  /*OpLoc=*/SourceLocation(),
-                                  /*IsArrow=*/!getLangOpts().HLSL, SS,
-                                  TemplateKWLoc, R, TemplateArgs, S);
+  return BuildMemberReferenceExpr(
+      baseExpr, ThisTy,
+      /*OpLoc=*/SourceLocation(),
+      /*IsArrow=*/!getLangOpts().HLSL, SS, TemplateKWLoc,
+      /*FirstQualifierInScope=*/nullptr, R, TemplateArgs, S);
 }
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaOverload.cpp b/clang/lib/Sema/SemaOverload.cpp
--- a/clang/lib/Sema/SemaOverload.cpp
+++ b/clang/lib/Sema/SemaOverload.cpp
@@ -16043,11 +16043,13 @@
 
   CandidateSet->clear(OverloadCandidateSet::CSK_Normal);
   if (!MemberLookup.empty()) {
-    ExprResult MemberRef = BuildMemberReferenceExpr(
-        Range, Range->getType(), Loc,
-        /*IsPtr=*/false, /*SS=*/CXXScopeSpec(),
-        /*TemplateKWLoc=*/SourceLocation(), MemberLookup,
-        /*TemplateArgs=*/nullptr, S);
+    ExprResult MemberRef =
+        BuildMemberReferenceExpr(Range, Range->getType(), Loc,
+                                 /*IsPtr=*/false, CXXScopeSpec(),
+                                 /*TemplateKWLoc=*/SourceLocation(),
+                                 /*FirstQualifierInScope=*/nullptr,
+                                 MemberLookup,
+                                 /*TemplateArgs=*/nullptr, S);
     if (MemberRef.isInvalid()) {
       *CallExpr = ExprError();
       return FRS_DiagnosticIssued;
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaStmtAsm.cpp b/clang/lib/Sema/SemaStmtAsm.cpp
--- a/clang/lib/Sema/SemaStmtAsm.cpp
+++ b/clang/lib/Sema/SemaStmtAsm.cpp
@@ -900,8 +900,7 @@
     return CXXDependentScopeMemberExpr::Create(
         Context, E, T, /*IsArrow=*/false, AsmLoc, NestedNameSpecifierLoc(),
         SourceLocation(),
-        /*UnqualifiedLookups=*/std::nullopt, NameInfo,
-        /*TemplateArgs=*/nullptr);
+        /*FirstQualifierFoundInScope=*/nullptr, NameInfo, /*TemplateArgs=*/nullptr);
   }
 
   const RecordType *RT = T->getAs<RecordType>();
@@ -924,9 +923,8 @@
 
   // Make an Expr to thread through OpDecl.
   ExprResult Result = BuildMemberReferenceExpr(
-      E, E->getType(), AsmLoc, /*IsArrow=*/false, /*SS=*/CXXScopeSpec(),
-      /*TemplateKWLoc*/ SourceLocation(), FieldResult,
-      /*TemplateArgs=*/nullptr, /*S=*/nullptr);
+      E, E->getType(), AsmLoc, /*IsArrow=*/false, CXXScopeSpec(),
+      SourceLocation(), nullptr, FieldResult, nullptr, nullptr);
 
   return Result;
 }
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTemplate.cpp b/clang/lib/Sema/SemaTemplate.cpp
--- a/clang/lib/Sema/SemaTemplate.cpp
+++ b/clang/lib/Sema/SemaTemplate.cpp
@@ -174,12 +174,15 @@
   return false;
 }
 
-TemplateNameKind
-Sema::isTemplateName(Scope *S, CXXScopeSpec &SS, bool hasTemplateKeyword,
-                     const UnqualifiedId &Name, ParsedType ObjectTypePtr,
-                     bool EnteringContext, TemplateTy &TemplateResult,
-                     bool &MemberOfUnknownSpecialization, bool Disambiguation,
-                     bool MayBeNNS) {
+TemplateNameKind Sema::isTemplateName(Scope *S,
+                                      CXXScopeSpec &SS,
+                                      bool hasTemplateKeyword,
+                                      const UnqualifiedId &Name,
+                                      ParsedType ObjectTypePtr,
+                                      bool EnteringContext,
+                                      TemplateTy &TemplateResult,
+                                      bool &MemberOfUnknownSpecialization,
+                                      bool Disambiguation) {
   assert(getLangOpts().CPlusPlus && "No template names in C!");
 
   DeclarationName TName;
@@ -210,9 +213,8 @@
   if (LookupTemplateName(R, S, SS, ObjectType, EnteringContext,
                          /*RequiredTemplate=*/SourceLocation(),
                          &AssumedTemplate,
-                         /*AllowTypoCorrection=*/!Disambiguation, MayBeNNS))
+                         /*AllowTypoCorrection=*/!Disambiguation))
     return TNK_Non_template;
-
   MemberOfUnknownSpecialization = R.wasNotFoundInCurrentInstantiation();
 
   if (AssumedTemplate != AssumedTemplateKind::None) {
@@ -378,7 +380,7 @@
                               QualType ObjectType, bool EnteringContext,
                               RequiredTemplateKind RequiredTemplate,
                               AssumedTemplateKind *ATK,
-                              bool AllowTypoCorrection, bool MayBeNNS) {
+                              bool AllowTypoCorrection) {
   if (ATK)
     *ATK = AssumedTemplateKind::None;
 
@@ -387,89 +389,92 @@
 
   Found.setTemplateNameLookup(true);
 
-  // Template names cannot appear inside an Objective-C class or object type
-  // or a vector type.
-  //
-  // FIXME: This is wrong. For example:
-  //
-  //   template<typename T> using Vec = T __attribute__((ext_vector_type(4)));
-  //   Vec<int> vi;
-  //   vi.Vec<int>::~Vec<int>();
-  //
-  // ... should be accepted but we will not treat 'Vec' as a template name
-  // here. The right thing to do would be to check if the name is a valid
-  // vector component name, and look up a template name if not. And similarly
-  // for lookups into Objective-C class and object types, where the same
-  // problem can arise.
-  if (!ObjectType.isNull() && (ObjectType->isVectorType() ||
-                               ObjectType->isObjCObjectOrInterfaceType())) {
-    Found.clear();
-    return false;
-  }
+  // Determine where to perform name lookup
+  DeclContext *LookupCtx = nullptr;
+  bool IsDependent = false;
+  if (!ObjectType.isNull()) {
+    // This nested-name-specifier occurs in a member access expression, e.g.,
+    // x->B::f, and we are looking into the type of the object.
+    assert(SS.isEmpty() && "ObjectType and scope specifier cannot coexist");
+    LookupCtx = computeDeclContext(ObjectType);
+    IsDependent = !LookupCtx && ObjectType->isDependentType();
+    assert((IsDependent || !ObjectType->isIncompleteType() ||
+            !ObjectType->getAs<TagType>() ||
+            ObjectType->castAs<TagType>()->isBeingDefined()) &&
+           "Caller should have completed object type");
 
-  LookupParsedName(Found, S, &SS, ObjectType,
-                   /*AllowBuiltinCreation=*/false, EnteringContext);
+    // Template names cannot appear inside an Objective-C class or object type
+    // or a vector type.
+    //
+    // FIXME: This is wrong. For example:
+    //
+    //   template<typename T> using Vec = T __attribute__((ext_vector_type(4)));
+    //   Vec<int> vi;
+    //   vi.Vec<int>::~Vec<int>();
+    //
+    // ... should be accepted but we will not treat 'Vec' as a template name
+    // here. The right thing to do would be to check if the name is a valid
+    // vector component name, and look up a template name if not. And similarly
+    // for lookups into Objective-C class and object types, where the same
+    // problem can arise.
+    if (ObjectType->isObjCObjectOrInterfaceType() ||
+        ObjectType->isVectorType()) {
+      Found.clear();
+      return false;
+    }
+  } else if (SS.isNotEmpty()) {
+    // This nested-name-specifier occurs after another nested-name-specifier,
+    // so long into the context associated with the prior nested-name-specifier.
+    LookupCtx = computeDeclContext(SS, EnteringContext);
+    IsDependent = !LookupCtx && isDependentScopeSpecifier(SS);
 
-  // C++ [basic.lookup.qual.general]p3:
-  //   [...] Unless otherwise specified, a qualified name undergoes qualified
-  //   name lookup in its lookup context from the point where it appears unless
-  //   the lookup context either is dependent and is not the current
-  //   instantiation or is not a class or class template.
-  //
-  // The lookup context is dependent and either:
-  // - it is not the current instantiation, or
-  // - it is the current instantiation, it has at least one dependent base
-  //   class, and qualified lookup found nothing.
-  //
-  // If this is a member-qualified name that is the terminal name of a
-  // nested-name-specifier, we perform unqualified lookup and store the results
-  // so we can replicate the lookup during instantiation. The results of the
-  // unqualified loookup are *not* used to determine whether '<' is interpreted
-  // as the delimiter of a template-argument-list.
-  //
-  // For example:
-  //
-  //   template<typename T>
-  //   struct A {
-  //     int x;
-  //   };
-  //
-  //   template<typename T>
-  //   using B = A<T>;
-  //
-  //   template<typename T>
-  //   void f(A<T> a, A<int> b) {
-  //     a.B<T>::x; // error: missing 'template' before 'B'
-  //     b.B<int>::x; // ok, lookup context is not dependent
-  //   }
-  if (Found.wasNotFoundInCurrentInstantiation())
-    return false;
+    // The declaration context must be complete.
+    if (LookupCtx && RequireCompleteDeclContext(SS, LookupCtx))
+      return true;
+  }
 
   bool ObjectTypeSearchedInScope = false;
-
-  // C++ [basic.lookup.qual.general]p2:
-  //   A member-qualified name is the (unique) component name, if any, of
-  //   - an unqualified-id or
-  //   - a nested-name-specifier of the form type-name :: or namespace-name ::
-  //   in the id-expression of a class member access expression.
-  //
-  // C++ [basic.lookup.qual.general]p3:
-  //   [...] If nothing is found by qualified lookup for a member-qualified
-  //   name that is the terminal name of a nested-name-specifier and is not
-  //   dependent, it undergoes unqualified lookup.
-  //
-  // In 'x.A::B::y', 'A' will undergo unqualified lookup if qualified lookup
-  // in the type of 'x' finds nothing. If the lookup context is dependent,
-  // we perform the unqualified lookup in the template definition context
-  // and store the results so we can replicate the lookup during instantiation.
-  if (MayBeNNS && Found.empty() && !ObjectType.isNull()) {
-    if (S) {
+  bool AllowFunctionTemplatesInLookup = true;
+  if (LookupCtx) {
+    // Perform "qualified" name lookup into the declaration context we
+    // computed, which is either the type of the base of a member access
+    // expression or the declaration context associated with a prior
+    // nested-name-specifier.
+    LookupQualifiedName(Found, LookupCtx);
+
+    // FIXME: The C++ standard does not clearly specify what happens in the
+    // case where the object type is dependent, and implementations vary. In
+    // Clang, we treat a name after a . or -> as a template-name if lookup
+    // finds a non-dependent member or member of the current instantiation that
+    // is a type template, or finds no such members and lookup in the context
+    // of the postfix-expression finds a type template. In the latter case, the
+    // name is nonetheless dependent, and we may resolve it to a member of an
+    // unknown specialization when we come to instantiate the template.
+    IsDependent |= Found.wasNotFoundInCurrentInstantiation();
+  }
+
+  if (SS.isEmpty() && (ObjectType.isNull() || Found.empty())) {
+    // C++ [basic.lookup.classref]p1:
+    //   In a class member access expression (5.2.5), if the . or -> token is
+    //   immediately followed by an identifier followed by a <, the
+    //   identifier must be looked up to determine whether the < is the
+    //   beginning of a template argument list (14.2) or a less-than operator.
+    //   The identifier is first looked up in the class of the object
+    //   expression. If the identifier is not found, it is then looked up in
+    //   the context of the entire postfix-expression and shall name a class
+    //   template.
+    if (S)
       LookupName(Found, S);
-    } else if (!SS.getUnqualifiedLookups().empty()) {
-      Found.addAllDecls(SS.getUnqualifiedLookups());
-      Found.resolveKind();
+
+    if (!ObjectType.isNull()) {
+      //  FIXME: We should filter out all non-type templates here, particularly
+      //  variable templates and concepts. But the exclusion of alias templates
+      //  and template template parameters is a wording defect.
+      AllowFunctionTemplatesInLookup = false;
+      ObjectTypeSearchedInScope = true;
     }
-    ObjectTypeSearchedInScope = true;
+
+    IsDependent |= Found.wasNotFoundInCurrentInstantiation();
   }
 
   if (Found.isAmbiguous())
@@ -489,7 +494,7 @@
         getLangOpts().CPlusPlus20 && llvm::all_of(Found, [](NamedDecl *ND) {
           return isa<FunctionDecl>(ND->getUnderlyingDecl());
         });
-    if (AllFunctions || Found.empty()) {
+    if (AllFunctions || (Found.empty() && !IsDependent)) {
       // If lookup found any functions, or if this is a name that can only be
       // used for a function, then strongly assume this is a function
       // template-id.
@@ -501,15 +506,11 @@
     }
   }
 
-  if (Found.empty() && AllowTypoCorrection) {
+  if (Found.empty() && !IsDependent && AllowTypoCorrection) {
     // If we did not find any names, and this is not a disambiguation, attempt
     // to correct any typos.
     DeclarationName Name = Found.getLookupName();
     Found.clear();
-    DeclContext *LookupCtx =
-        SS.isSet()
-            ? computeDeclContext(SS, EnteringContext)
-            : (!ObjectType.isNull() ? computeDeclContext(ObjectType) : nullptr);
     // Simple filter callback that, for keywords, only accepts the C++ *_cast
     DefaultFilterCCC FilterCCC{};
     FilterCCC.WantTypeSpecifiers = false;
@@ -542,8 +543,13 @@
 
   NamedDecl *ExampleLookupResult =
       Found.empty() ? nullptr : Found.getRepresentativeDecl();
-  FilterAcceptableTemplateNames(Found);
+  FilterAcceptableTemplateNames(Found, AllowFunctionTemplatesInLookup);
   if (Found.empty()) {
+    if (IsDependent) {
+      Found.setNotFoundInCurrentInstantiation();
+      return false;
+    }
+
     // If a 'template' keyword was used, a lookup that finds only non-template
     // names is an error.
     if (ExampleLookupResult && RequiredTemplate) {
@@ -735,7 +741,7 @@
         /*IsArrow=*/!Context.getLangOpts().HLSL,
         /*OperatorLoc=*/SourceLocation(),
         /*QualifierLoc=*/NestedNameSpecifierLoc(), TemplateKWLoc,
-        /*UnqualifiedLookups=*/std::nullopt, NameInfo, TemplateArgs);
+        /*FirstQualifierFoundInScope=*/nullptr, NameInfo, TemplateArgs);
   }
   return BuildDependentDeclRefExpr(SS, TemplateKWLoc, NameInfo, TemplateArgs);
 }
@@ -5849,10 +5855,14 @@
   return BuildTemplateIdExpr(SS, TemplateKWLoc, R, /*ADL=*/false, TemplateArgs);
 }
 
-TemplateNameKind Sema::ActOnTemplateName(
-    Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-    const UnqualifiedId &Name, ParsedType ObjectType, bool EnteringContext,
-    TemplateTy &Result, bool AllowInjectedClassName, bool MayBeNNS) {
+TemplateNameKind Sema::ActOnTemplateName(Scope *S,
+                                         CXXScopeSpec &SS,
+                                         SourceLocation TemplateKWLoc,
+                                         const UnqualifiedId &Name,
+                                         ParsedType ObjectType,
+                                         bool EnteringContext,
+                                         TemplateTy &Result,
+                                         bool AllowInjectedClassName) {
   if (TemplateKWLoc.isValid() && S && !S->getTemplateParamParent())
     Diag(TemplateKWLoc,
          getLangOpts().CPlusPlus11 ?
@@ -5887,10 +5897,9 @@
   // "template" keyword is now permitted). We follow the C++0x
   // rules, even in C++03 mode with a warning, retroactively applying the DR.
   bool MemberOfUnknownSpecialization;
-  TemplateNameKind TNK =
-      isTemplateName(S, SS, TemplateKWLoc.isValid(), Name, ObjectType,
-                     EnteringContext, Result, MemberOfUnknownSpecialization,
-                     /*Disambiguation=*/false, MayBeNNS);
+  TemplateNameKind TNK = isTemplateName(S, SS, TemplateKWLoc.isValid(), Name,
+                                        ObjectType, EnteringContext, Result,
+                                        MemberOfUnknownSpecialization);
   if (TNK != TNK_Non_template) {
     // We resolved this to a (non-dependent) template name. Return it.
     auto *LookupRD = dyn_cast_or_null<CXXRecordDecl>(LookupCtx);
@@ -5929,8 +5938,7 @@
                                    ? RequiredTemplateKind(TemplateKWLoc)
                                    : TemplateNameIsRequired;
     if (!LookupTemplateName(R, S, SS, ObjectType.get(), EnteringContext, RTK,
-                            /*ATK=*/nullptr, /*AllowTypoCorrection=*/false,
-                            MayBeNNS) &&
+                            /*ATK=*/nullptr, /*AllowTypoCorrection=*/false) &&
         !R.isAmbiguous()) {
       if (LookupCtx)
         Diag(Name.getBeginLoc(), diag::err_no_member)
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTemplateInstantiate.cpp b/clang/lib/Sema/SemaTemplateInstantiate.cpp
--- a/clang/lib/Sema/SemaTemplateInstantiate.cpp
+++ b/clang/lib/Sema/SemaTemplateInstantiate.cpp
@@ -1515,11 +1515,12 @@
                                    NestedNameSpecifierLoc QualifierLoc,
                                    QualType T);
 
-    TemplateName TransformTemplateName(CXXScopeSpec &SS, TemplateName Name,
-                                       SourceLocation NameLoc,
-                                       QualType ObjectType = QualType(),
-                                       bool AllowInjectedClassName = false,
-                                       bool MayBeNNS = false);
+    TemplateName
+    TransformTemplateName(CXXScopeSpec &SS, TemplateName Name,
+                          SourceLocation NameLoc,
+                          QualType ObjectType = QualType(),
+                          NamedDecl *FirstQualifierInScope = nullptr,
+                          bool AllowInjectedClassName = false);
 
     const CXXAssumeAttr *TransformCXXAssumeAttr(const CXXAssumeAttr *AA);
     const LoopHintAttr *TransformLoopHintAttr(const LoopHintAttr *LH);
@@ -1951,7 +1952,8 @@
 
 TemplateName TemplateInstantiator::TransformTemplateName(
     CXXScopeSpec &SS, TemplateName Name, SourceLocation NameLoc,
-    QualType ObjectType, bool AllowInjectedClassName, bool MayBeNNS) {
+    QualType ObjectType, NamedDecl *FirstQualifierInScope,
+    bool AllowInjectedClassName) {
   if (TemplateTemplateParmDecl *TTP
        = dyn_cast_or_null<TemplateTemplateParmDecl>(Name.getAsTemplateDecl())) {
     if (TTP->getDepth() < TemplateArgs.getNumLevels()) {
@@ -2023,7 +2025,8 @@
   }
 
   return inherited::TransformTemplateName(SS, Name, NameLoc, ObjectType,
-                                          AllowInjectedClassName, MayBeNNS);
+                                          FirstQualifierInScope,
+                                          AllowInjectedClassName);
 }
 
 ExprResult
diff -ruN --strip-trailing-cr a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/TreeTransform.h
--- a/clang/lib/Sema/TreeTransform.h
+++ b/clang/lib/Sema/TreeTransform.h
@@ -541,9 +541,10 @@
   /// By default, transforms all of the types and declarations within the
   /// nested-name-specifier. Subclasses may override this function to provide
   /// alternate behavior.
-  NestedNameSpecifierLoc TransformNestedNameSpecifierLoc(
-      NestedNameSpecifierLoc NNS, QualType ObjectType = QualType(),
-      ArrayRef<DeclAccessPair> UnqualifiedLookups = std::nullopt);
+  NestedNameSpecifierLoc
+  TransformNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS,
+                                  QualType ObjectType = QualType(),
+                                  NamedDecl *FirstQualifierInScope = nullptr);
 
   /// Transform the given declaration name.
   ///
@@ -584,11 +585,12 @@
   /// By default, transforms the template name by transforming the declarations
   /// and nested-name-specifiers that occur within the template name.
   /// Subclasses may override this function to provide alternate behavior.
-  TemplateName TransformTemplateName(CXXScopeSpec &SS, TemplateName Name,
-                                     SourceLocation NameLoc,
-                                     QualType ObjectType = QualType(),
-                                     bool AllowInjectedClassName = false,
-                                     bool MayBeNNS = false);
+  TemplateName
+  TransformTemplateName(CXXScopeSpec &SS, TemplateName Name,
+                        SourceLocation NameLoc,
+                        QualType ObjectType = QualType(),
+                        NamedDecl *FirstQualifierInScope = nullptr,
+                        bool AllowInjectedClassName = false);
 
   /// Transform the given template argument.
   ///
@@ -1138,8 +1140,8 @@
     CXXScopeSpec SS;
     SS.Adopt(QualifierLoc);
     TemplateName InstName = getDerived().RebuildTemplateName(
-        SS, TemplateKWLoc, *Name, NameLoc, QualType(), AllowInjectedClassName,
-        /*MayBeNNS=*/false);
+        SS, TemplateKWLoc, *Name, NameLoc, QualType(), nullptr,
+        AllowInjectedClassName);
 
     if (InstName.isNull())
       return QualType();
@@ -1310,7 +1312,8 @@
                                    SourceLocation TemplateKWLoc,
                                    const IdentifierInfo &Name,
                                    SourceLocation NameLoc, QualType ObjectType,
-                                   bool AllowInjectedClassName, bool MayBeNNS);
+                                   NamedDecl *FirstQualifierInScope,
+                                   bool AllowInjectedClassName);
 
   /// Build a new template name given a nested name specifier and the
   /// overloaded operator name that is referred to as a template.
@@ -2846,14 +2849,15 @@
   ///
   /// By default, performs semantic analysis to build the new expression.
   /// Subclasses may override this routine to provide different behavior.
-  ExprResult
-  RebuildMemberExpr(Expr *Base, SourceLocation OpLoc, bool isArrow,
-                    NestedNameSpecifierLoc QualifierLoc,
-                    SourceLocation TemplateKWLoc,
-                    const DeclarationNameInfo &MemberNameInfo,
-                    ValueDecl *Member, NamedDecl *FoundDecl,
-                    const TemplateArgumentListInfo *ExplicitTemplateArgs,
-                    ArrayRef<DeclAccessPair> UnqualifiedLookups) {
+  ExprResult RebuildMemberExpr(Expr *Base, SourceLocation OpLoc,
+                               bool isArrow,
+                               NestedNameSpecifierLoc QualifierLoc,
+                               SourceLocation TemplateKWLoc,
+                               const DeclarationNameInfo &MemberNameInfo,
+                               ValueDecl *Member,
+                               NamedDecl *FoundDecl,
+                        const TemplateArgumentListInfo *ExplicitTemplateArgs,
+                               NamedDecl *FirstQualifierInScope) {
     ExprResult BaseResult = getSema().PerformMemberExprBaseConversion(Base,
                                                                       isArrow);
     if (!Member->getDeclName()) {
@@ -2890,7 +2894,6 @@
 
     CXXScopeSpec SS;
     SS.Adopt(QualifierLoc);
-    SS.setUnqualifiedLookups(UnqualifiedLookups);
 
     Base = BaseResult.get();
     if (Base->containsErrors())
@@ -2923,9 +2926,10 @@
     }
 
     return getSema().BuildMemberReferenceExpr(Base, BaseType, OpLoc, isArrow,
-                                              SS, TemplateKWLoc, R,
-                                              ExplicitTemplateArgs,
-                                              /*S=*/nullptr);
+                                              SS, TemplateKWLoc,
+                                              FirstQualifierInScope,
+                                              R, ExplicitTemplateArgs,
+                                              /*S*/nullptr);
   }
 
   /// Build a new binary operator expression.
@@ -2998,9 +3002,10 @@
     CXXScopeSpec SS;
     DeclarationNameInfo NameInfo(&Accessor, AccessorLoc);
     return getSema().BuildMemberReferenceExpr(
-        Base, Base->getType(), OpLoc, IsArrow, SS,
-        /*TemplateKWLoc=*/SourceLocation(), NameInfo,
-        /*TemplateArgs=*/nullptr, /*S=*/nullptr);
+        Base, Base->getType(), OpLoc, IsArrow, SS, SourceLocation(),
+        /*FirstQualifierInScope*/ nullptr, NameInfo,
+        /* TemplateArgs */ nullptr,
+        /*S*/ nullptr);
   }
 
   /// Build a new initializer list expression.
@@ -3568,37 +3573,46 @@
   ///
   /// By default, performs semantic analysis to build the new expression.
   /// Subclasses may override this routine to provide different behavior.
-  ExprResult RebuildCXXDependentScopeMemberExpr(
-      Expr *BaseE, QualType BaseType, bool IsArrow, SourceLocation OperatorLoc,
-      NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,
-      ArrayRef<DeclAccessPair> UnqualifiedLookups,
-      const DeclarationNameInfo &MemberNameInfo,
-      const TemplateArgumentListInfo *TemplateArgs) {
+  ExprResult RebuildCXXDependentScopeMemberExpr(Expr *BaseE,
+                                                QualType BaseType,
+                                                bool IsArrow,
+                                                SourceLocation OperatorLoc,
+                                          NestedNameSpecifierLoc QualifierLoc,
+                                                SourceLocation TemplateKWLoc,
+                                            NamedDecl *FirstQualifierInScope,
+                                   const DeclarationNameInfo &MemberNameInfo,
+                              const TemplateArgumentListInfo *TemplateArgs) {
     CXXScopeSpec SS;
     SS.Adopt(QualifierLoc);
-    SS.setUnqualifiedLookups(UnqualifiedLookups);
 
-    return SemaRef.BuildMemberReferenceExpr(
-        BaseE, BaseType, OperatorLoc, IsArrow, SS, TemplateKWLoc,
-        MemberNameInfo, TemplateArgs, /*S=*/nullptr);
+    return SemaRef.BuildMemberReferenceExpr(BaseE, BaseType,
+                                            OperatorLoc, IsArrow,
+                                            SS, TemplateKWLoc,
+                                            FirstQualifierInScope,
+                                            MemberNameInfo,
+                                            TemplateArgs, /*S*/nullptr);
   }
 
   /// Build a new member reference expression.
   ///
   /// By default, performs semantic analysis to build the new expression.
   /// Subclasses may override this routine to provide different behavior.
-  ExprResult RebuildUnresolvedMemberExpr(
-      Expr *BaseE, QualType BaseType, SourceLocation OperatorLoc, bool IsArrow,
-      NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,
-      ArrayRef<DeclAccessPair> UnqualifiedLookups, LookupResult &R,
-      const TemplateArgumentListInfo *TemplateArgs) {
+  ExprResult RebuildUnresolvedMemberExpr(Expr *BaseE, QualType BaseType,
+                                         SourceLocation OperatorLoc,
+                                         bool IsArrow,
+                                         NestedNameSpecifierLoc QualifierLoc,
+                                         SourceLocation TemplateKWLoc,
+                                         NamedDecl *FirstQualifierInScope,
+                                         LookupResult &R,
+                                const TemplateArgumentListInfo *TemplateArgs) {
     CXXScopeSpec SS;
     SS.Adopt(QualifierLoc);
-    SS.setUnqualifiedLookups(UnqualifiedLookups);
 
-    return SemaRef.BuildMemberReferenceExpr(BaseE, BaseType, OperatorLoc,
-                                            IsArrow, SS, TemplateKWLoc, R,
-                                            TemplateArgs, /*S=*/nullptr);
+    return SemaRef.BuildMemberReferenceExpr(BaseE, BaseType,
+                                            OperatorLoc, IsArrow,
+                                            SS, TemplateKWLoc,
+                                            FirstQualifierInScope,
+                                            R, TemplateArgs, /*S*/nullptr);
   }
 
   /// Build a new noexcept expression.
@@ -3817,8 +3831,10 @@
     DeclarationNameInfo NameInfo(Ivar->getDeclName(), IvarLoc);
     ExprResult Result = getSema().BuildMemberReferenceExpr(
         BaseArg, BaseArg->getType(),
-        /*FIXME:*/ IvarLoc, IsArrow, SS, /*TemplateKWLoc=*/SourceLocation(),
-        NameInfo, /*TemplateArgs=*/nullptr, /*S=*/nullptr);
+        /*FIXME:*/ IvarLoc, IsArrow, SS, SourceLocation(),
+        /*FirstQualifierInScope=*/nullptr, NameInfo,
+        /*TemplateArgs=*/nullptr,
+        /*S=*/nullptr);
     if (IsFreeIvar && Result.isUsable())
       cast<ObjCIvarRefExpr>(Result.get())->setIsFreeIvar(IsFreeIvar);
     return Result;
@@ -3833,12 +3849,14 @@
                                         SourceLocation PropertyLoc) {
     CXXScopeSpec SS;
     DeclarationNameInfo NameInfo(Property->getDeclName(), PropertyLoc);
-    return getSema().BuildMemberReferenceExpr(
-        BaseArg, BaseArg->getType(),
-        /*FIXME:*/ PropertyLoc,
-        /*IsArrow=*/false, SS, /*TemplateKWLoc=*/SourceLocation(), NameInfo,
-        /*TemplateArgs=*/nullptr,
-        /*S=*/nullptr);
+    return getSema().BuildMemberReferenceExpr(BaseArg, BaseArg->getType(),
+                                              /*FIXME:*/PropertyLoc,
+                                              /*IsArrow=*/false,
+                                              SS, SourceLocation(),
+                                              /*FirstQualifierInScope=*/nullptr,
+                                              NameInfo,
+                                              /*TemplateArgs=*/nullptr,
+                                              /*S=*/nullptr);
   }
 
   /// Build a new Objective-C property reference expression.
@@ -3865,11 +3883,13 @@
                                 SourceLocation OpLoc, bool IsArrow) {
     CXXScopeSpec SS;
     DeclarationNameInfo NameInfo(&getSema().Context.Idents.get("isa"), IsaLoc);
-    return getSema().BuildMemberReferenceExpr(
-        BaseArg, BaseArg->getType(), OpLoc, IsArrow, SS,
-        /*TemplateKWLoc=*/SourceLocation(), NameInfo,
-        /*TemplateArgs=*/nullptr,
-        /*S=*/nullptr);
+    return getSema().BuildMemberReferenceExpr(BaseArg, BaseArg->getType(),
+                                              OpLoc, IsArrow,
+                                              SS, SourceLocation(),
+                                              /*FirstQualifierInScope=*/nullptr,
+                                              NameInfo,
+                                              /*TemplateArgs=*/nullptr,
+                                              /*S=*/nullptr);
   }
 
   /// Build a new shuffle vector expression.
@@ -4034,14 +4054,18 @@
   }
 
 private:
-  TypeLoc TransformTypeInObjectScope(TypeLoc TL, QualType ObjectType,
+  TypeLoc TransformTypeInObjectScope(TypeLoc TL,
+                                     QualType ObjectType,
+                                     NamedDecl *FirstQualifierInScope,
                                      CXXScopeSpec &SS);
 
   TypeSourceInfo *TransformTypeInObjectScope(TypeSourceInfo *TSInfo,
                                              QualType ObjectType,
+                                             NamedDecl *FirstQualifierInScope,
                                              CXXScopeSpec &SS);
 
   TypeSourceInfo *TransformTSIInObjectScope(TypeLoc TL, QualType ObjectType,
+                                            NamedDecl *FirstQualifierInScope,
                                             CXXScopeSpec &SS);
 
   QualType TransformDependentNameType(TypeLocBuilder &TLB,
@@ -4360,7 +4384,7 @@
 template <typename Derived>
 NestedNameSpecifierLoc TreeTransform<Derived>::TransformNestedNameSpecifierLoc(
     NestedNameSpecifierLoc NNS, QualType ObjectType,
-    ArrayRef<DeclAccessPair> UnqualifiedLookups) {
+    NamedDecl *FirstQualifierInScope) {
   SmallVector<NestedNameSpecifierLoc, 4> Qualifiers;
 
   auto insertNNS = [&Qualifiers](NestedNameSpecifierLoc NNS) {
@@ -4371,8 +4395,6 @@
   insertNNS(NNS);
 
   CXXScopeSpec SS;
-  SS.setUnqualifiedLookups(UnqualifiedLookups);
-
   while (!Qualifiers.empty()) {
     NestedNameSpecifierLoc Q = Qualifiers.pop_back_val();
     NestedNameSpecifier *QNNS = Q.getNestedNameSpecifier();
@@ -4382,9 +4404,8 @@
       Sema::NestedNameSpecInfo IdInfo(QNNS->getAsIdentifier(),
                                       Q.getLocalBeginLoc(), Q.getLocalEndLoc(),
                                       ObjectType);
-      if (SemaRef.BuildCXXNestedNameSpecifier(/*Scope=*/nullptr, IdInfo,
-                                              /*EnteringContext=*/false, SS,
-                                              /*ErrorRecoveryLookup=*/false))
+      if (SemaRef.BuildCXXNestedNameSpecifier(/*Scope=*/nullptr, IdInfo, false,
+                                              SS, FirstQualifierInScope, false))
         return NestedNameSpecifierLoc();
       break;
     }
@@ -4422,7 +4443,8 @@
 
     case NestedNameSpecifier::TypeSpecWithTemplate:
     case NestedNameSpecifier::TypeSpec: {
-      TypeLoc TL = TransformTypeInObjectScope(Q.getTypeLoc(), ObjectType, SS);
+      TypeLoc TL = TransformTypeInObjectScope(Q.getTypeLoc(), ObjectType,
+                                              FirstQualifierInScope, SS);
 
       if (!TL)
         return NestedNameSpecifierLoc();
@@ -4455,7 +4477,7 @@
     }
 
     // The qualifier-in-scope and object type only apply to the leftmost entity.
-    SS.setUnqualifiedLookups(std::nullopt);
+    FirstQualifierInScope = nullptr;
     ObjectType = QualType();
   }
 
@@ -4538,10 +4560,14 @@
   llvm_unreachable("Unknown name kind.");
 }
 
-template <typename Derived>
-TemplateName TreeTransform<Derived>::TransformTemplateName(
-    CXXScopeSpec &SS, TemplateName Name, SourceLocation NameLoc,
-    QualType ObjectType, bool AllowInjectedClassName, bool MayBeNNS) {
+template<typename Derived>
+TemplateName
+TreeTransform<Derived>::TransformTemplateName(CXXScopeSpec &SS,
+                                              TemplateName Name,
+                                              SourceLocation NameLoc,
+                                              QualType ObjectType,
+                                              NamedDecl *FirstQualifierInScope,
+                                              bool AllowInjectedClassName) {
   if (QualifiedTemplateName *QTN = Name.getAsQualifiedTemplateName()) {
     TemplateDecl *Template = QTN->getUnderlyingTemplate().getAsTemplateDecl();
     assert(Template && "qualified template name must refer to a template");
@@ -4565,7 +4591,7 @@
     if (SS.getScopeRep()) {
       // These apply to the scope specifier, not the template.
       ObjectType = QualType();
-      SS.setUnqualifiedLookups(std::nullopt);
+      FirstQualifierInScope = nullptr;
     }
 
     if (!getDerived().AlwaysRebuild() &&
@@ -4577,9 +4603,13 @@
     SourceLocation TemplateKWLoc = NameLoc;
 
     if (DTN->isIdentifier()) {
-      return getDerived().RebuildTemplateName(
-          SS, TemplateKWLoc, *DTN->getIdentifier(), NameLoc, ObjectType,
-          AllowInjectedClassName, MayBeNNS);
+      return getDerived().RebuildTemplateName(SS,
+                                              TemplateKWLoc,
+                                              *DTN->getIdentifier(),
+                                              NameLoc,
+                                              ObjectType,
+                                              FirstQualifierInScope,
+                                              AllowInjectedClassName);
     }
 
     return getDerived().RebuildTemplateName(SS, TemplateKWLoc,
@@ -5123,31 +5153,39 @@
   return SemaRef.BuildQualifiedType(T, Loc, Quals);
 }
 
-template <typename Derived>
-TypeLoc TreeTransform<Derived>::TransformTypeInObjectScope(TypeLoc TL,
-                                                           QualType ObjectType,
-                                                           CXXScopeSpec &SS) {
+template<typename Derived>
+TypeLoc
+TreeTransform<Derived>::TransformTypeInObjectScope(TypeLoc TL,
+                                                   QualType ObjectType,
+                                                   NamedDecl *UnqualLookup,
+                                                   CXXScopeSpec &SS) {
   if (getDerived().AlreadyTransformed(TL.getType()))
     return TL;
 
-  TypeSourceInfo *TSI = TransformTSIInObjectScope(TL, ObjectType, SS);
+  TypeSourceInfo *TSI =
+      TransformTSIInObjectScope(TL, ObjectType, UnqualLookup, SS);
   if (TSI)
     return TSI->getTypeLoc();
   return TypeLoc();
 }
 
-template <typename Derived>
-TypeSourceInfo *TreeTransform<Derived>::TransformTypeInObjectScope(
-    TypeSourceInfo *TSInfo, QualType ObjectType, CXXScopeSpec &SS) {
+template<typename Derived>
+TypeSourceInfo *
+TreeTransform<Derived>::TransformTypeInObjectScope(TypeSourceInfo *TSInfo,
+                                                   QualType ObjectType,
+                                                   NamedDecl *UnqualLookup,
+                                                   CXXScopeSpec &SS) {
   if (getDerived().AlreadyTransformed(TSInfo->getType()))
     return TSInfo;
 
-  return TransformTSIInObjectScope(TSInfo->getTypeLoc(), ObjectType, SS);
+  return TransformTSIInObjectScope(TSInfo->getTypeLoc(), ObjectType,
+                                   UnqualLookup, SS);
 }
 
 template <typename Derived>
 TypeSourceInfo *TreeTransform<Derived>::TransformTSIInObjectScope(
-    TypeLoc TL, QualType ObjectType, CXXScopeSpec &SS) {
+    TypeLoc TL, QualType ObjectType, NamedDecl *UnqualLookup,
+    CXXScopeSpec &SS) {
   QualType T = TL.getType();
   assert(!getDerived().AlreadyTransformed(T));
 
@@ -5160,7 +5198,7 @@
 
     TemplateName Template = getDerived().TransformTemplateName(
         SS, SpecTL.getTypePtr()->getTemplateName(), SpecTL.getTemplateNameLoc(),
-        ObjectType, /*AllowInjectedClassName=*/true, /*MayBeNNS=*/true);
+        ObjectType, UnqualLookup, /*AllowInjectedClassName*/true);
     if (Template.isNull())
       return nullptr;
 
@@ -5170,11 +5208,13 @@
     DependentTemplateSpecializationTypeLoc SpecTL =
         TL.castAs<DependentTemplateSpecializationTypeLoc>();
 
-    TemplateName Template = getDerived().RebuildTemplateName(
-        SS, SpecTL.getTemplateKeywordLoc(),
-        *SpecTL.getTypePtr()->getIdentifier(), SpecTL.getTemplateNameLoc(),
-        ObjectType,
-        /*AllowInjectedClassName=*/true, /*MayBeNNS=*/true);
+    TemplateName Template
+      = getDerived().RebuildTemplateName(SS,
+                                         SpecTL.getTemplateKeywordLoc(),
+                                         *SpecTL.getTypePtr()->getIdentifier(),
+                                         SpecTL.getTemplateNameLoc(),
+                                         ObjectType, UnqualLookup,
+                                         /*AllowInjectedClassName*/true);
     if (Template.isNull())
       return nullptr;
 
@@ -12318,8 +12358,7 @@
   // first-qualifier-in-scope here, just in case we had a dependent
   // base (and therefore couldn't do the check) and a
   // nested-name-qualifier (and therefore could do the lookup).
-  ArrayRef<DeclAccessPair> UnqualifiedLookups;
-
+  NamedDecl *FirstQualifierInScope = nullptr;
   DeclarationNameInfo MemberNameInfo = E->getMemberNameInfo();
   if (MemberNameInfo.getName()) {
     MemberNameInfo = getDerived().TransformDeclarationNameInfo(MemberNameInfo);
@@ -12327,11 +12366,16 @@
       return ExprError();
   }
 
-  return getDerived().RebuildMemberExpr(
-      Base.get(), FakeOperatorLoc, E->isArrow(), QualifierLoc, TemplateKWLoc,
-      MemberNameInfo, Member, FoundDecl,
-      (E->hasExplicitTemplateArgs() ? &TransArgs : nullptr),
-      UnqualifiedLookups);
+  return getDerived().RebuildMemberExpr(Base.get(), FakeOperatorLoc,
+                                        E->isArrow(),
+                                        QualifierLoc,
+                                        TemplateKWLoc,
+                                        MemberNameInfo,
+                                        Member,
+                                        FoundDecl,
+                                        (E->hasExplicitTemplateArgs()
+                                           ? &TransArgs : nullptr),
+                                        FirstQualifierInScope);
 }
 
 template<typename Derived>
@@ -13458,8 +13502,9 @@
 
   PseudoDestructorTypeStorage Destroyed;
   if (E->getDestroyedTypeInfo()) {
-    TypeSourceInfo *DestroyedTypeInfo = getDerived().TransformTypeInObjectScope(
-        E->getDestroyedTypeInfo(), ObjectType, SS);
+    TypeSourceInfo *DestroyedTypeInfo
+      = getDerived().TransformTypeInObjectScope(E->getDestroyedTypeInfo(),
+                                                ObjectType, nullptr, SS);
     if (!DestroyedTypeInfo)
       return ExprError();
     Destroyed = DestroyedTypeInfo;
@@ -13485,7 +13530,7 @@
   if (E->getScopeTypeInfo()) {
     CXXScopeSpec EmptySS;
     ScopeTypeInfo = getDerived().TransformTypeInObjectScope(
-        E->getScopeTypeInfo(), ObjectType, EmptySS);
+                      E->getScopeTypeInfo(), ObjectType, nullptr, EmptySS);
     if (!ScopeTypeInfo)
       return ExprError();
   }
@@ -14746,17 +14791,19 @@
     ObjectType = BaseType->castAs<PointerType>()->getPointeeType();
   }
 
-  UnresolvedSet<4> UnqualifiedLookups;
-  for (auto D : E->unqualified_lookups()) {
-    if (NamedDecl *InstD = getDerived().TransformFirstQualifierInScope(
-            D.getDecl(), E->getQualifierLoc().getBeginLoc()))
-      UnqualifiedLookups.addDecl(InstD);
-  }
+  // Transform the first part of the nested-name-specifier that qualifies
+  // the member name.
+  NamedDecl *FirstQualifierInScope
+    = getDerived().TransformFirstQualifierInScope(
+                                            E->getFirstQualifierFoundInScope(),
+                                            E->getQualifierLoc().getBeginLoc());
 
   NestedNameSpecifierLoc QualifierLoc;
   if (E->getQualifier()) {
-    QualifierLoc = getDerived().TransformNestedNameSpecifierLoc(
-        E->getQualifierLoc(), ObjectType, UnqualifiedLookups.pairs());
+    QualifierLoc
+      = getDerived().TransformNestedNameSpecifierLoc(E->getQualifierLoc(),
+                                                     ObjectType,
+                                                     FirstQualifierInScope);
     if (!QualifierLoc)
       return ExprError();
   }
@@ -14775,16 +14822,23 @@
   if (!E->hasExplicitTemplateArgs()) {
     // This is a reference to a member without an explicitly-specified
     // template argument list. Optimize for this common case.
-    if (!getDerived().AlwaysRebuild() && Base.get() == OldBase &&
-        BaseType == E->getBaseType() && QualifierLoc == E->getQualifierLoc() &&
+    if (!getDerived().AlwaysRebuild() &&
+        Base.get() == OldBase &&
+        BaseType == E->getBaseType() &&
+        QualifierLoc == E->getQualifierLoc() &&
         NameInfo.getName() == E->getMember() &&
-        UnqualifiedLookups.pairs() == E->unqualified_lookups())
+        FirstQualifierInScope == E->getFirstQualifierFoundInScope())
       return E;
 
-    return getDerived().RebuildCXXDependentScopeMemberExpr(
-        Base.get(), BaseType, E->isArrow(), E->getOperatorLoc(), QualifierLoc,
-        TemplateKWLoc, UnqualifiedLookups.pairs(), NameInfo,
-        /*TemplateArgs*/ nullptr);
+    return getDerived().RebuildCXXDependentScopeMemberExpr(Base.get(),
+                                                       BaseType,
+                                                       E->isArrow(),
+                                                       E->getOperatorLoc(),
+                                                       QualifierLoc,
+                                                       TemplateKWLoc,
+                                                       FirstQualifierInScope,
+                                                       NameInfo,
+                                                       /*TemplateArgs*/nullptr);
   }
 
   TemplateArgumentListInfo TransArgs(E->getLAngleLoc(), E->getRAngleLoc());
@@ -14793,9 +14847,15 @@
                                               TransArgs))
     return ExprError();
 
-  return getDerived().RebuildCXXDependentScopeMemberExpr(
-      Base.get(), BaseType, E->isArrow(), E->getOperatorLoc(), QualifierLoc,
-      TemplateKWLoc, UnqualifiedLookups.pairs(), NameInfo, &TransArgs);
+  return getDerived().RebuildCXXDependentScopeMemberExpr(Base.get(),
+                                                     BaseType,
+                                                     E->isArrow(),
+                                                     E->getOperatorLoc(),
+                                                     QualifierLoc,
+                                                     TemplateKWLoc,
+                                                     FirstQualifierInScope,
+                                                     NameInfo,
+                                                     &TransArgs);
 }
 
 template <typename Derived>
@@ -14856,11 +14916,11 @@
   // first-qualifier-in-scope here, just in case we had a dependent
   // base (and therefore couldn't do the check) and a
   // nested-name-qualifier (and therefore could do the lookup).
-  ArrayRef<DeclAccessPair> UnqualifiedLookups;
+  NamedDecl *FirstQualifierInScope = nullptr;
 
   return getDerived().RebuildUnresolvedMemberExpr(
       Base.get(), BaseType, Old->getOperatorLoc(), Old->isArrow(), QualifierLoc,
-      TemplateKWLoc, UnqualifiedLookups, R,
+      TemplateKWLoc, FirstQualifierInScope, R,
       (Old->hasExplicitTemplateArgs() ? &TransArgs : nullptr));
 }
 
@@ -16217,18 +16277,22 @@
                                                   TemplateName(Template));
 }
 
-template <typename Derived>
-TemplateName TreeTransform<Derived>::RebuildTemplateName(
-    CXXScopeSpec &SS, SourceLocation TemplateKWLoc, const IdentifierInfo &Name,
-    SourceLocation NameLoc, QualType ObjectType, bool AllowInjectedClassName,
-    bool MayBeNNS) {
+template<typename Derived>
+TemplateName
+TreeTransform<Derived>::RebuildTemplateName(CXXScopeSpec &SS,
+                                            SourceLocation TemplateKWLoc,
+                                            const IdentifierInfo &Name,
+                                            SourceLocation NameLoc,
+                                            QualType ObjectType,
+                                            NamedDecl *FirstQualifierInScope,
+                                            bool AllowInjectedClassName) {
   UnqualifiedId TemplateName;
   TemplateName.setIdentifier(&Name, NameLoc);
   Sema::TemplateTy Template;
   getSema().ActOnTemplateName(/*Scope=*/nullptr, SS, TemplateKWLoc,
                               TemplateName, ParsedType::make(ObjectType),
                               /*EnteringContext=*/false, Template,
-                              AllowInjectedClassName, MayBeNNS);
+                              AllowInjectedClassName);
   return Template.get();
 }
 
@@ -16376,10 +16440,13 @@
   }
 
   SourceLocation TemplateKWLoc; // FIXME: retrieve it from caller.
-  return getSema().BuildMemberReferenceExpr(
-      Base, BaseType, OperatorLoc, isArrow, SS, TemplateKWLoc, NameInfo,
-      /*TemplateArgs=*/nullptr,
-      /*S=*/nullptr);
+  return getSema().BuildMemberReferenceExpr(Base, BaseType,
+                                            OperatorLoc, isArrow,
+                                            SS, TemplateKWLoc,
+                                            /*FIXME: FirstQualifier*/ nullptr,
+                                            NameInfo,
+                                            /*TemplateArgs*/ nullptr,
+                                            /*S*/nullptr);
 }
 
 template<typename Derived>
diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReaderStmt.cpp b/clang/lib/Serialization/ASTReaderStmt.cpp
--- a/clang/lib/Serialization/ASTReaderStmt.cpp
+++ b/clang/lib/Serialization/ASTReaderStmt.cpp
@@ -1993,43 +1993,42 @@
     CXXDependentScopeMemberExpr *E) {
   VisitExpr(E);
 
-  CurrentUnpackingBits.emplace(Record.readInt());
-  bool HasQualifier = CurrentUnpackingBits->getNextBit();
-  bool HasTemplateInfo = CurrentUnpackingBits->getNextBit();
-  unsigned NumUnqualifiedLookups = Record.readInt();
   unsigned NumTemplateArgs = Record.readInt();
-  E->CXXDependentScopeMemberExprBits.HasQualifier = HasQualifier;
-  E->CXXDependentScopeMemberExprBits.NumUnqualifiedLookups =
-      NumUnqualifiedLookups;
-  E->CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo = HasTemplateInfo;
+  CurrentUnpackingBits.emplace(Record.readInt());
+  bool HasTemplateKWAndArgsInfo = CurrentUnpackingBits->getNextBit();
+  bool HasFirstQualifierFoundInScope = CurrentUnpackingBits->getNextBit();
+
+  assert((HasTemplateKWAndArgsInfo == E->hasTemplateKWAndArgsInfo()) &&
+         "Wrong HasTemplateKWAndArgsInfo!");
+  assert(
+      (HasFirstQualifierFoundInScope == E->hasFirstQualifierFoundInScope()) &&
+      "Wrong HasFirstQualifierFoundInScope!");
+
+  if (HasTemplateKWAndArgsInfo)
+    ReadTemplateKWAndArgsInfo(
+        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
+        E->getTrailingObjects<TemplateArgumentLoc>(), NumTemplateArgs);
+
+  assert((NumTemplateArgs == E->getNumTemplateArgs()) &&
+         "Wrong NumTemplateArgs!");
 
-  E->BaseType = Record.readType();
   E->CXXDependentScopeMemberExprBits.IsArrow =
       CurrentUnpackingBits->getNextBit();
 
+  E->BaseType = Record.readType();
+  E->QualifierLoc = Record.readNestedNameSpecifierLoc();
+  // not ImplicitAccess
   if (CurrentUnpackingBits->getNextBit())
     E->Base = Record.readSubExpr();
   else
     E->Base = nullptr;
 
-  E->OperatorLoc = Record.readSourceLocation();
-  E->MemberNameInfo = Record.readDeclarationNameInfo();
+  E->CXXDependentScopeMemberExprBits.OperatorLoc = readSourceLocation();
 
-  if (HasQualifier)
-    new (E->getTrailingObjects<NestedNameSpecifierLoc>())
-        NestedNameSpecifierLoc(Record.readNestedNameSpecifierLoc());
-
-  for (unsigned I = 0; I != NumUnqualifiedLookups; ++I) {
-    auto *FoundD = Record.readDeclAs<NamedDecl>();
-    auto AS = (AccessSpecifier)Record.readInt();
-    E->getTrailingObjects<DeclAccessPair>()[I] =
-        DeclAccessPair::make(FoundD, AS);
-  }
+  if (HasFirstQualifierFoundInScope)
+    *E->getTrailingObjects<NamedDecl *>() = readDeclAs<NamedDecl>();
 
-  if (HasTemplateInfo)
-    ReadTemplateKWAndArgsInfo(
-        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
-        E->getTrailingObjects<TemplateArgumentLoc>(), NumTemplateArgs);
+  E->MemberNameInfo = Record.readDeclarationNameInfo();
 }
 
 void
@@ -4076,16 +4075,16 @@
       break;
 
     case EXPR_CXX_DEPENDENT_SCOPE_MEMBER: {
+      unsigned NumTemplateArgs = Record[ASTStmtReader::NumExprFields];
       BitsUnpacker DependentScopeMemberBits(
-          Record[ASTStmtReader::NumExprFields]);
-      bool HasQualifier = DependentScopeMemberBits.getNextBit();
-      bool HasTemplateInfo = DependentScopeMemberBits.getNextBit();
-      unsigned NumUnqualifiedLookups = Record[ASTStmtReader::NumExprFields + 1];
-      unsigned NumTemplateArgs = Record[ASTStmtReader::NumExprFields + 2];
+          Record[ASTStmtReader::NumExprFields + 1]);
+      bool HasTemplateKWAndArgsInfo = DependentScopeMemberBits.getNextBit();
 
+      bool HasFirstQualifierFoundInScope =
+          DependentScopeMemberBits.getNextBit();
       S = CXXDependentScopeMemberExpr::CreateEmpty(
-          Context, HasQualifier, NumUnqualifiedLookups, HasTemplateInfo,
-          NumTemplateArgs);
+          Context, HasTemplateKWAndArgsInfo, NumTemplateArgs,
+          HasFirstQualifierFoundInScope);
       break;
     }
 
diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTWriterStmt.cpp b/clang/lib/Serialization/ASTWriterStmt.cpp
--- a/clang/lib/Serialization/ASTWriterStmt.cpp
+++ b/clang/lib/Serialization/ASTWriterStmt.cpp
@@ -1988,41 +1988,34 @@
     CXXDependentScopeMemberExpr *E) {
   VisitExpr(E);
 
-  bool HasQualifier = E->hasQualifier();
-  unsigned NumUnqualifiedLookups = E->getNumUnqualifiedLookups();
-  bool HasTemplateInfo = E->hasTemplateKWAndArgsInfo();
-  unsigned NumTemplateArgs = E->getNumTemplateArgs();
-
-  // Write these first for easy access when deserializing, as they affect the
-  // size of the CXXDependentScopeMemberExpr.
+  // Don't emit anything here (or if you do you will have to update
+  // the corresponding deserialization function).
+  Record.push_back(E->getNumTemplateArgs());
   CurrentPackingBits.updateBits();
-  CurrentPackingBits.addBit(HasQualifier);
-  CurrentPackingBits.addBit(HasTemplateInfo);
-  Record.push_back(NumUnqualifiedLookups);
-  Record.push_back(NumTemplateArgs);
+  CurrentPackingBits.addBit(E->hasTemplateKWAndArgsInfo());
+  CurrentPackingBits.addBit(E->hasFirstQualifierFoundInScope());
+
+  if (E->hasTemplateKWAndArgsInfo()) {
+    const ASTTemplateKWAndArgsInfo &ArgInfo =
+        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>();
+    AddTemplateKWAndArgsInfo(ArgInfo,
+                             E->getTrailingObjects<TemplateArgumentLoc>());
+  }
 
-  Record.AddTypeRef(E->getBaseType());
   CurrentPackingBits.addBit(E->isArrow());
+
+  Record.AddTypeRef(E->getBaseType());
+  Record.AddNestedNameSpecifierLoc(E->getQualifierLoc());
   CurrentPackingBits.addBit(!E->isImplicitAccess());
   if (!E->isImplicitAccess())
     Record.AddStmt(E->getBase());
 
   Record.AddSourceLocation(E->getOperatorLoc());
 
-  Record.AddDeclarationNameInfo(E->MemberNameInfo);
-
-  if (HasQualifier)
-    Record.AddNestedNameSpecifierLoc(E->getQualifierLoc());
-
-  for (DeclAccessPair D : E->unqualified_lookups()) {
-    Record.AddDeclRef(D.getDecl());
-    Record.push_back(D.getAccess());
-  }
-
-  if (HasTemplateInfo)
-    AddTemplateKWAndArgsInfo(*E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
-                             E->getTrailingObjects<TemplateArgumentLoc>());
+  if (E->hasFirstQualifierFoundInScope())
+    Record.AddDeclRef(E->getFirstQualifierFoundInScope());
 
+  Record.AddDeclarationNameInfo(E->MemberNameInfo);
   Code = serialization::EXPR_CXX_DEPENDENT_SCOPE_MEMBER;
 }
 
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/bitfield-access-pad.c b/clang/test/CodeGen/bitfield-access-pad.c
--- a/clang/test/CodeGen/bitfield-access-pad.c
+++ b/clang/test/CodeGen/bitfield-access-pad.c
@@ -16,6 +16,7 @@
 // Configs that have expensive unaligned access
 // Little Endian
 // RUN: %clang_cc1 -triple=hexagon-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT-T %s
+// RUN: %clang_cc1 -triple=le64-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT-T %s
 
 // Big endian
 // RUN: %clang_cc1 -triple=m68k-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT-T %s
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/bitfield-access-unit.c b/clang/test/CodeGen/bitfield-access-unit.c
--- a/clang/test/CodeGen/bitfield-access-unit.c
+++ b/clang/test/CodeGen/bitfield-access-unit.c
@@ -53,8 +53,8 @@
 // RUN: %clang_cc1 -triple=sparc-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT-STRICT %s
 // RUN: %clang_cc1 -triple=tce-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT-STRICT %s
 
-// m68-elf is a strict alignment ISA with 4-byte aligned 64-bit or 2-byte
-// aligned 32-bit integer types. This more compex to describe here.
+// Both le64-elf and m68-elf are strict alignment ISAs with 4-byte aligned
+// 64-bit or 2-byte aligned 32-bit integer types. This more compex to describe here.
 
 // If unaligned access is expensive don't stick these together.
 struct A {
diff -ruN --strip-trailing-cr a/clang/test/CodeGenCXX/bitfield-access-empty.cpp b/clang/test/CodeGenCXX/bitfield-access-empty.cpp
--- a/clang/test/CodeGenCXX/bitfield-access-empty.cpp
+++ b/clang/test/CodeGenCXX/bitfield-access-empty.cpp
@@ -26,6 +26,7 @@
 // RUN: %clang_cc1 -triple=bpf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT %s
 // RUN: %clang_cc1 -triple=csky %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT %s
 // RUN: %clang_cc1 -triple=hexagon-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT %s
+// RUN: %clang_cc1 -triple=le64-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT %s
 // RUN: %clang_cc1 -triple=loongarch32-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT %s
 // RUN: %clang_cc1 -triple=nvptx-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT %s
 // RUN: %clang_cc1 -triple=riscv32 %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT %s
diff -ruN --strip-trailing-cr a/clang/test/CodeGenCXX/bitfield-access-tail.cpp b/clang/test/CodeGenCXX/bitfield-access-tail.cpp
--- a/clang/test/CodeGenCXX/bitfield-access-tail.cpp
+++ b/clang/test/CodeGenCXX/bitfield-access-tail.cpp
@@ -26,6 +26,7 @@
 // RUN: %clang_cc1 -triple=bpf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT64 %s
 // RUN: %clang_cc1 -triple=csky %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT32 %s
 // RUN: %clang_cc1 -triple=hexagon-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT32 %s
+// RUN: %clang_cc1 -triple=le64-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT64 %s
 // RUN: %clang_cc1 -triple=loongarch32-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT32 %s
 // RUN: %clang_cc1 -triple=nvptx-elf %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT32 %s
 // RUN: %clang_cc1 -triple=riscv32 %s -emit-llvm -o /dev/null -fdump-record-layouts-simple | FileCheck --check-prefixes CHECK,LAYOUT,LAYOUT32 %s
diff -ruN --strip-trailing-cr a/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1.cpp
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1.cpp
@@ -86,19 +86,15 @@
 
   template<typename T> T *end(T*);
 
-  struct X { };
-  struct Y {
-    int end;
-  };
+  class X { };
   template <typename T>
   void Foo2() {
     T it1;
-    if (it1->end < it1->end) { }
+    if (it1->end < it1->end) {
+    }
 
     X *x;
-    if (x->end < 7) { } // expected-error{{no member named 'end' in 'PR11856::X'}}
-
-    Y *y;
-    if (y->end < 7) { }
+    if (x->end < 7) {  // expected-error{{no member named 'end' in 'PR11856::X'}}
+    }
   }
 }
diff -ruN --strip-trailing-cr a/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1-cxx11.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1-cxx11.cpp
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1-cxx11.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1-cxx11.cpp
@@ -55,19 +55,15 @@
 
   template<typename T> T *end(T*);
 
-  struct X { };
-  struct Y {
-    int end;
-  };
+  class X { };
   template <typename T>
   void Foo2() {
     T it1;
-    if (it1->end < it1->end) { }
+    if (it1->end < it1->end) {
+    }
 
     X *x;
-    if (x->end < 7) { } // expected-error{{no member named 'end' in 'PR11856::X'}}
-
-    Y *y;
-    if (y->end < 7) { }
+    if (x->end < 7) {  // expected-error{{no member named 'end' in 'PR11856::X'}}
+    }
   }
 }
diff -ruN --strip-trailing-cr a/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3.cpp
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3.cpp
@@ -1,98 +0,0 @@
-// RUN: %clang_cc1 -std=c++23 -Wno-unused %s -verify
-
-namespace Unambiguous {
-  struct A {
-    int x;
-
-    template<typename T>
-    using C = A;
-  };
-
-  using B = A;
-
-  template<typename T>
-  using D = A;
-
-  using E = void;
-
-  struct F : A {
-    void non_template() {
-      this->x;
-      this->A::x;
-      this->B::x;
-      this->C<int>::x;
-      this->D<int>::x;
-      this->E::x; // expected-error {{'Unambiguous::E' (aka 'void') is not a class, namespace, or enumeration}}
-    }
-  };
-
-  template<typename T>
-  void not_instantiated(T t) {
-    t.x;
-    t.A::x;
-    t.B::x;
-    t.C<int>::x; // expected-warning {{use 'template' keyword to treat 'C' as a dependent template name}}
-    t.template C<int>::x;
-    t.D<int>::x; // expected-warning {{use 'template' keyword to treat 'D' as a dependent template name}}
-    t.template D<int>::x;
-    t.E::x;
-  }
-
-  template<typename T>
-  void instantiated_valid(T t) {
-    t.x;
-    t.A::x;
-    t.B::x;
-    t.template C<int>::x;
-    t.template D<int>::x;
-    t.E::x;
-  }
-
-  template<typename T>
-  void instantiated_invalid(T t) {
-    t.x;
-    t.A::x;
-    t.B::x; // expected-error {{'Unambiguous::Invalid::B' (aka 'void') is not a class, namespace, or enumeration}}
-    t.template C<int>::x;
-    t.template D<int>::x; // expected-error {{'D' following the 'template' keyword does not refer to a template}}
-    t.E::x; // expected-error {{'Unambiguous::E' (aka 'void') is not a class, namespace, or enumeration}}
-  }
-
-  struct Valid : A {
-    using E = A;
-  };
-
-  template void instantiated_valid(Valid);
-
-  struct Invalid : A {
-    using B = void;
-    using D = A; // expected-note {{declared as a non-template here}}
-  };
-
-  template void instantiated_invalid(Invalid); // expected-note {{in instantiation of}}
-} // namespace Unambiguous
-
-namespace Ambiguous {
-  inline namespace N {
-    struct A { }; // expected-note {{candidate found by name lookup is 'Ambiguous::N::A'}}
-  }
-
-  struct A { }; // expected-note {{candidate found by name lookup is 'Ambiguous::A'}}
-
-  template<typename T>
-  void f(T t) {
-    t.A::x; // expected-error {{reference to 'A' is ambiguous}}
-  }
-
-  struct B {
-    using A = B;
-
-    int x;
-  };
-
-  struct C { };
-
-  template void f(B);
-  template void f(C); // expected-note {{in instantiation of}}
-
-} // namespace Ambiguous
diff -ruN --strip-trailing-cr a/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3-example3.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3-example3.cpp
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3-example3.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3-example3.cpp
@@ -1,27 +0,0 @@
-// RUN: %clang_cc1 -std=c++23 %s -verify
-
-int f();
-
-struct A {
-  int B, C; // expected-note {{declared as a non-template here}}
-  template<int> using D = void;
-  using T = void;
-  void f();
-};
-
-using B = A;
-template<int> using C = A;
-template<int> using D = A;
-template<int> using X = A;
-
-template<class T>
-void g(T *p) {
-  p->X<0>::f(); // expected-error {{no member named 'X' in 'A'}}
-  p->template X<0>::f();
-  p->B::f();
-  p->template C<0>::f(); // expected-error {{'C' following the 'template' keyword does not refer to a template}}
-  p->template D<0>::f(); // expected-error {{type 'template D<0>' (aka 'void') cannot be used prior to '::' because it has no members}}
-  p->T::f(); // expected-error {{'A::T' (aka 'void') is not a class, namespace, or enumeration}}
-}
-
-template void g(A*); // expected-note {{in instantiation of}}
diff -ruN --strip-trailing-cr a/clang/test/CXX/class.derived/class.member.lookup/p8.cpp b/clang/test/CXX/class.derived/class.member.lookup/p8.cpp
--- a/clang/test/CXX/class.derived/class.member.lookup/p8.cpp
+++ b/clang/test/CXX/class.derived/class.member.lookup/p8.cpp
@@ -47,8 +47,8 @@
 void DerivedT<T>::Inner() {
   Derived1T<T>::Foo();
   Derived2T<T>::Member = 42;
-  this->Derived1T<T>::Foo(); // expected-warning{{use 'template' keyword to treat 'Derived1T' as a dependent template name}}
-  this->Derived2T<T>::Member = 42; // expected-warning{{use 'template' keyword to treat 'Derived2T' as a dependent template name}}
+  this->Derived1T<T>::Foo();
+  this->Derived2T<T>::Member = 42;
   this->Foo(); // expected-error{{non-static member 'Foo' found in multiple base-class subobjects of type 'BaseT<int>'}}
 }
 
diff -ruN --strip-trailing-cr a/clang/test/CXX/drs/cwg1xx.cpp b/clang/test/CXX/drs/cwg1xx.cpp
--- a/clang/test/CXX/drs/cwg1xx.cpp
+++ b/clang/test/CXX/drs/cwg1xx.cpp
@@ -615,8 +615,10 @@
     //   cxx98-note@#cwg141-S {{lookup from the current scope refers here}}
     // expected-error@#cwg141-a {{no member named 'n' in 'cwg141::A::S<int>'; did you mean '::cwg141::S<int>::n'?}}
     //   expected-note@#cwg141-S {{'::cwg141::S<int>::n' declared here}}
+    // FIXME: we issue a useful diagnostic first, then some bogus ones.
     b.f<int>();
     // expected-error@-1 {{no member named 'f' in 'cwg141::B'}}
+    // expected-error@-2 +{{}}
     (void)b.S<int>::n;
   }
   template<typename T> struct C {
@@ -626,12 +628,10 @@
       // expected-error@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
     }
     void h() {
-      (void)t.S<int>::n;
-      // expected-error@-1 {{use 'template' keyword to treat 'S' as a dependent template name}}
+      (void)t.S<int>::n; // ok
     }
     void i() {
-      (void)t.S<int>();
-      // expected-error@-1 {{use 'template' keyword to treat 'S' as a dependent template name}}
+      (void)t.S<int>(); // ok!
     }
   };
   void h() { C<B>().h(); } // ok
diff -ruN --strip-trailing-cr a/clang/test/CXX/temp/temp.names/p3-23.cpp b/clang/test/CXX/temp/temp.names/p3-23.cpp
--- a/clang/test/CXX/temp/temp.names/p3-23.cpp
+++ b/clang/test/CXX/temp/temp.names/p3-23.cpp
@@ -1,237 +0,0 @@
-// RUN: %clang_cc1 -std=c++23 -Wno-unused %s -verify
-
-namespace FoundNothing {
-  template<typename T>
-  void f0(T &t) {
-    t.x<0;
-    t.x<0>; // expected-error {{expected expression}}
-    t.x<0>1;
-  }
-
-  template<typename T>
-  struct A {
-    void f1() {
-      this->x<0; // expected-error {{no member named 'x' in 'A<T>'}}
-      this->x<0>; // expected-error {{no member named 'x' in 'A<T>'}}
-                  // expected-error@-1 {{expected expression}}
-      this->x<0>1; // expected-error {{no member named 'x' in 'A<T>'}}
-    }
-  };
-} // namespace FoundNothing
-
-namespace FoundSingleNonTemplate {
-  void f0();
-
-  struct A0;
-
-  template<typename T>
-  void g0(T &t) {
-    t.f0<0;
-    t.f0<0>; // expected-error {{expected expression}}
-    t.f0<0>1;
-
-    t.A0<0;
-    t.A0<0>; // expected-error {{expected expression}}
-    t.A0<0>1;
-  }
-
-  template<typename T>
-  struct B {
-    void f1();
-
-    struct A1; // expected-note 3{{member 'A1' declared here}}
-
-    void g1() {
-      this->f0<0; // expected-error {{no member named 'f0' in 'B<T>'}}
-      this->f0<0>; // expected-error {{no member named 'f0' in 'B<T>'}}
-                   // expected-error@-1 {{expected expression}}
-      this->f0<0>1; // expected-error {{no member named 'f0' in 'B<T>'}}
-
-      this->A0<0; // expected-error {{no member named 'A0' in 'B<T>'}}
-      this->A0<0>; // expected-error {{no member named 'A0' in 'B<T>'}}
-                   // expected-error@-1 {{expected expression}}
-      this->A0<0>1; // expected-error {{no member named 'A0' in 'B<T>'}}
-
-      this->f1<0; // expected-error {{reference to non-static member function must be called}}
-      this->f1<0>; // expected-error {{reference to non-static member function must be called}}
-                   // expected-error@-1 {{expected expression}}
-      this->f1<0>1; // expected-error {{reference to non-static member function must be called}}
-
-      this->A1<0; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-      this->A1<0>; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-                   // expected-error@-1 {{expected expression}}
-      this->A1<0>1; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-    }
-  };
-} // namespace FoundSingleNonTemplate
-
-namespace FoundSingleTemplate {
-  template<int I>
-  void f0();
-
-  template<int I>
-  struct A0;
-
-  template<typename T>
-  void g0(T &t) {
-    t.f0<0;
-    t.f0<0>; // expected-error {{expected expression}}
-    t.f0<0>1;
-
-    t.A0<0;
-    t.A0<0>; // expected-error {{expected expression}}
-    t.A0<0>1;
-  }
-
-  template<typename T>
-  struct B {
-    template<int I>
-    void f1(); // expected-note 2{{possible target for call}}
-
-    template<int I>
-    struct A1; // expected-note 2{{member 'A1' declared here}}
-
-    void g1() {
-      this->f0<0; // expected-error {{no member named 'f0' in 'B<T>'}}
-      this->f0<0>; // expected-error {{no member named 'f0' in 'B<T>'}}
-      this->f0<0>1; // expected-error {{no member named 'f0' in 'B<T>'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-
-      this->A0<0; // expected-error {{no member named 'A0' in 'B<T>'}}
-      this->A0<0>; // expected-error {{no member named 'A0' in 'B<T>'}}
-      this->A0<0>1; // expected-error {{no member named 'A0' in 'B<T>'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-
-
-      this->f1<0; // expected-error {{expected '>'}}
-                  // expected-note@-1 {{to match this '<'}}
-      this->f1<0>; // expected-error {{reference to non-static member function must be called}}
-      this->f1<0>1; // expected-error {{reference to non-static member function must be called}}
-                    // expected-error@-1 {{expected ';' after expression}}
-
-      this->A1<0; // expected-error {{expected '>'}}
-                  // expected-note@-1 {{to match this '<'}}
-      this->A1<0>; // expected-error {{cannot refer to member 'A1' in 'B<T>' with '->'}}
-      this->A1<0>1; // expected-error {{cannot refer to member 'A1' in 'B<T>' with '->'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-    }
-  };
-} // namespace FoundSingleTemplate
-
-namespace FoundAmbiguousNonTemplate {
-  inline namespace N {
-    int f0;
-
-    struct A0;
-  } // namespace N
-
-  void f0();
-
-  struct A0;
-
-  template<typename T>
-  void g0(T &t) {
-    t.f0<0;
-    t.f0<0>; // expected-error {{expected expression}}
-    t.f0<0>1;
-
-    t.A0<0;
-    t.A0<0>; // expected-error {{expected expression}}
-    t.A0<0>1;
-  }
-
-  template<typename T>
-  struct B {
-    void f1();
-
-    struct A1; // expected-note 3{{member 'A1' declared here}}
-
-    void g1() {
-      this->f0<0; // expected-error {{no member named 'f0' in 'B<T>'}}
-      this->f0<0>; // expected-error {{no member named 'f0' in 'B<T>'}}
-                   // expected-error@-1 {{expected expression}}
-      this->f0<0>1; // expected-error {{no member named 'f0' in 'B<T>'}}
-
-      this->A0<0; // expected-error {{no member named 'A0' in 'B<T>'}}
-      this->A0<0>; // expected-error {{no member named 'A0' in 'B<T>'}}
-                   // expected-error@-1 {{expected expression}}
-      this->A0<0>1; // expected-error {{no member named 'A0' in 'B<T>'}}
-
-      this->f1<0; // expected-error {{reference to non-static member function must be called}}
-      this->f1<0>; // expected-error {{reference to non-static member function must be called}}
-                   // expected-error@-1 {{expected expression}}
-      this->f1<0>1; // expected-error {{reference to non-static member function must be called}}
-
-      this->A1<0; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-      this->A1<0>; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-                   // expected-error@-1 {{expected expression}}
-      this->A1<0>1; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-    }
-  };
-} // namespace FoundAmbiguousNonTemplates
-
-namespace FoundAmbiguousTemplate {
-  inline namespace N {
-    template<int I>
-    int f0; // expected-note 3{{candidate found by name lookup is 'FoundAmbiguousTemplate::N::f0'}}
-
-    template<int I>
-    struct A0; // expected-note 3{{candidate found by name lookup is 'FoundAmbiguousTemplate::N::A0'}}
-  } // namespace N
-
-  template<int I>
-  void f0(); // expected-note 3{{candidate found by name lookup is 'FoundAmbiguousTemplate::f0'}}
-
-  template<int I>
-  struct A0; // expected-note 3{{candidate found by name lookup is 'FoundAmbiguousTemplate::A0'}}
-
-  template<typename T>
-  void g0(T &t) {
-    t.f0<0;
-    t.f0<0>; // expected-error {{expected expression}}
-    t.f0<0>1;
-
-    t.A0<0;
-    t.A0<0>; // expected-error {{expected expression}}
-    t.A0<0>1;
-  }
-
-  template<typename T>
-  struct B {
-    template<int I>
-    void f1(); // expected-note 2{{possible target for call}}
-
-    template<int I>
-    struct A1; // expected-note 2{{member 'A1' declared here}}
-
-    void g1() {
-      this->f0<0; // expected-error {{no member named 'f0' in 'B<T>'}}
-                  // expected-error@-1 {{reference to 'f0' is ambiguous}}
-      this->f0<0>; // expected-error {{no member named 'f0' in 'B<T>'}}
-                   // expected-error@-1 {{reference to 'f0' is ambiguous}}
-      this->f0<0>1; // expected-error {{no member named 'f0' in 'B<T>'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-                    // expected-error@-2 {{reference to 'f0' is ambiguous}}
-
-      this->A0<0; // expected-error {{no member named 'A0' in 'B<T>'}}
-                  // expected-error@-1 {{reference to 'A0' is ambiguous}}
-      this->A0<0>; // expected-error {{no member named 'A0' in 'B<T>'}}
-                   // expected-error@-1 {{reference to 'A0' is ambiguous}}
-      this->A0<0>1; // expected-error {{no member named 'A0' in 'B<T>'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-                    // expected-error@-2 {{reference to 'A0' is ambiguous}}
-
-      this->f1<0; // expected-error {{expected '>'}}
-                  // expected-note@-1 {{to match this '<'}}
-      this->f1<0>; // expected-error {{reference to non-static member function must be called}}
-      this->f1<0>1; // expected-error {{reference to non-static member function must be called}}
-                    // expected-error@-1 {{expected ';' after expression}}
-
-      this->A1<0; // expected-error {{expected '>'}}
-                  // expected-note@-1 {{to match this '<'}}
-      this->A1<0>; // expected-error {{cannot refer to member 'A1' in 'B<T>' with '->'}}
-      this->A1<0>1; // expected-error {{cannot refer to member 'A1' in 'B<T>' with '->'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-    }
-  };
-} // namespace FoundAmbiguousTemplate
diff -ruN --strip-trailing-cr a/clang/test/CXX/temp/temp.res/p3.cpp b/clang/test/CXX/temp/temp.res/p3.cpp
--- a/clang/test/CXX/temp/temp.res/p3.cpp
+++ b/clang/test/CXX/temp/temp.res/p3.cpp
@@ -30,6 +30,6 @@
 template<typename T> template<typename U> struct A<T>::B {
   friend A<T>::C<T> f6(); // ok, same as 'friend T f6();'
 
-  friend A<U>::C<T> f7(); // expected-warning {{use 'template' keyword to treat 'C' as a dependent template name}} expected-warning {{missing 'typename'}}
+  friend A<U>::C<T> f7(); // expected-error {{use 'template' keyword to treat 'C' as a dependent template name}} expected-warning {{missing 'typename'}}
   friend A<U>::template C<T> f8(); // expected-warning {{missing 'typename'}}
 };
diff -ruN --strip-trailing-cr a/clang/test/FixIt/fixit.cpp b/clang/test/FixIt/fixit.cpp
--- a/clang/test/FixIt/fixit.cpp
+++ b/clang/test/FixIt/fixit.cpp
@@ -158,12 +158,12 @@
  
 template<class T>
 class F2  {
-  typename F1<T>:: /*template*/  Iterator<0> Mypos; // expected-warning {{use 'template' keyword to treat 'Iterator' as a dependent template name}}
+  typename F1<T>:: /*template*/  Iterator<0> Mypos; // expected-error {{use 'template' keyword to treat 'Iterator' as a dependent template name}}
 };
 
 template <class T>
 void f(){
-  typename F1<T>:: /*template*/ Iterator<0> Mypos; // expected-warning {{use 'template' keyword to treat 'Iterator' as a dependent template name}}
+  typename F1<T>:: /*template*/ Iterator<0> Mypos; // expected-error {{use 'template' keyword to treat 'Iterator' as a dependent template name}}
 }
 
 // Tests for &/* fixits
diff -ruN --strip-trailing-cr a/clang/test/Misc/warning-flags.c b/clang/test/Misc/warning-flags.c
--- a/clang/test/Misc/warning-flags.c
+++ b/clang/test/Misc/warning-flags.c
@@ -18,7 +18,7 @@
 
 The list of warnings below should NEVER grow.  It should gradually shrink to 0.
 
-CHECK: Warnings without flags (64):
+CHECK: Warnings without flags (65):
 
 CHECK-NEXT:   ext_expected_semi_decl_list
 CHECK-NEXT:   ext_missing_whitespace_after_macro_name
@@ -61,6 +61,7 @@
 CHECK-NEXT:   warn_maynot_respond
 CHECK-NEXT:   warn_method_param_redefinition
 CHECK-NEXT:   warn_missing_case_for_condition
+CHECK-NEXT:   warn_missing_dependent_template_keyword
 CHECK-NEXT:   warn_missing_whitespace_after_macro_name
 CHECK-NEXT:   warn_mt_message
 CHECK-NEXT:   warn_no_constructor_for_refconst
diff -ruN --strip-trailing-cr a/clang/test/Parser/cxx2a-concepts-requires-expr.cpp b/clang/test/Parser/cxx2a-concepts-requires-expr.cpp
--- a/clang/test/Parser/cxx2a-concepts-requires-expr.cpp
+++ b/clang/test/Parser/cxx2a-concepts-requires-expr.cpp
@@ -78,7 +78,7 @@
 
 template<typename T>
 bool r23 = requires { typename identity<T>::temp<T>; };
-// expected-warning@-1 {{use 'template' keyword to treat 'temp' as a dependent template name}}
+// expected-error@-1 {{use 'template' keyword to treat 'temp' as a dependent template name}}
 
 template<typename T>
 bool r24 = requires {
diff -ruN --strip-trailing-cr a/clang/test/Preprocessor/predefined-macros-no-warnings.c b/clang/test/Preprocessor/predefined-macros-no-warnings.c
--- a/clang/test/Preprocessor/predefined-macros-no-warnings.c
+++ b/clang/test/Preprocessor/predefined-macros-no-warnings.c
@@ -75,6 +75,8 @@
 // RUN: %clang_cc1 %s -Eonly -Wsystem-headers -Werror -triple m68k
 // RUN: %clang_cc1 %s -Eonly -Wsystem-headers -Werror -triple m68k-linux
 // RUN: %clang_cc1 %s -Eonly -Wsystem-headers -Werror -triple m68k-netbsd
+// RUN: %clang_cc1 %s -Eonly -Wsystem-headers -Werror -triple le32-nacl
+// RUN: %clang_cc1 %s -Eonly -Wsystem-headers -Werror -triple le64
 // RUN: %clang_cc1 %s -Eonly -Wsystem-headers -Werror -triple ppc
 // RUN: %clang_cc1 %s -Eonly -Wsystem-headers -Werror -triple ppc-freebsd
 // RUN: %clang_cc1 %s -Eonly -Wsystem-headers -Werror -triple ppc-netbsd
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx0x-noexcept-expression.cpp b/clang/test/SemaCXX/cxx0x-noexcept-expression.cpp
--- a/clang/test/SemaCXX/cxx0x-noexcept-expression.cpp
+++ b/clang/test/SemaCXX/cxx0x-noexcept-expression.cpp
@@ -127,7 +127,7 @@
   // `dependent` should be type-dependent because the noexcept-expression should be value-dependent
   // (it is true if T is int*, false if T is Polymorphic<false, false>* for example)
   dependent.f<void>();  // This should need to be `.template f` to parse as a template
-  // expected-warning@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
+  // expected-error@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
 }
 template<typename... T>
 void f2() {
@@ -135,14 +135,14 @@
   // X<true> when T...[0] is a type with some operator&& which returns int*
   // X<false> when sizeof...(T) == 0
   dependent.f<void>();
-  // expected-warning@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
+  // expected-error@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
 }
 template<typename T>
 void f3() {
   X<noexcept(typeid(*static_cast<T*>(nullptr)))> dependent;
   // X<true> when T is int, X<false> when T is Polymorphic<false, false>
   dependent.f<void>();
-  // expected-warning@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
+  // expected-error@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
 }
 template<typename T>
 void f4() {
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/pseudo-destructors.cpp b/clang/test/SemaCXX/pseudo-destructors.cpp
--- a/clang/test/SemaCXX/pseudo-destructors.cpp
+++ b/clang/test/SemaCXX/pseudo-destructors.cpp
@@ -22,21 +22,21 @@
 void f(A* a, Foo *f, int *i, double *d, int ii) {
   a->~A();
   a->A::~A();
-
+  
   a->~foo(); // expected-error{{undeclared identifier 'foo' in destructor name}}
-
+  
   a->~Bar(); // expected-error{{destructor type 'Bar' (aka 'Foo') in object destruction expression does not match the type 'A' of the object being destroyed}}
-
+  
   f->~Bar();
   f->~Foo();
   i->~Bar(); // expected-error{{does not match}}
-
+  
   g().~Bar(); // expected-error{{non-scalar}}
-
+  
   f->::~Bar(); // expected-error {{not a structure or union}}
   f->::Bar::~Bar();
   f->N::~Wibble(); // expected-error{{'N' does not refer to a type}} expected-error{{'Wibble' does not refer to a type}}
-
+  
   f->Bar::~Bar(17, 42); // expected-error{{cannot have any arguments}}
 
   i->~Integer();
@@ -148,12 +148,12 @@
   namespace Template {
     template<typename T> struct Y {};
     template<class U> using G = Y<U>;
-    template<typename T> void f(T *p) { p->~G<int>(); } // expected-error {{no member named 'G'}}
+    template<typename T> void f(T *p) { p->~G<int>(); } // expected-error {{no member named '~Y'}}
     void h1(Y<int> *p) { p->~G<int>(); }
-    void h2(Y<int> *p) { f(p); } // expected-note {{instantiation of}}
+    void h2(Y<int> *p) { f(p); }
     namespace N { template<typename T> struct G {}; }
     void h3(N::G<int> *p) { p->~G<int>(); }
-    void h4(N::G<int> *p) { f(p); }
+    void h4(N::G<int> *p) { f(p); } // expected-note {{instantiation of}}
   }
 
   namespace TemplateUndeclared {
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/static-assert-cxx17.cpp b/clang/test/SemaCXX/static-assert-cxx17.cpp
--- a/clang/test/SemaCXX/static-assert-cxx17.cpp
+++ b/clang/test/SemaCXX/static-assert-cxx17.cpp
@@ -96,7 +96,7 @@
   // expected-error@-1{{static assertion failed due to requirement 'static_cast<const X<int> *>(nullptr)'}}
   static_assert((const X<typename T::T>[]){} == nullptr);
   // expected-error@-1{{static assertion failed due to requirement '(const X<int>[0]){} == nullptr'}}
-  static_assert(sizeof(X<decltype(X<typename T::T>().template X<typename T::T>::~X())>) == 0);
+  static_assert(sizeof(X<decltype(X<typename T::T>().X<typename T::T>::~X())>) == 0);
   // expected-error@-1{{static assertion failed due to requirement 'sizeof(X<void>) == 0'}} \
   // expected-note@-1 {{evaluates to '8 == 0'}}
   static_assert(constexpr_return_false<typename T::T, typename T::U>());
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/dependent-base-classes.cpp b/clang/test/SemaTemplate/dependent-base-classes.cpp
--- a/clang/test/SemaTemplate/dependent-base-classes.cpp
+++ b/clang/test/SemaTemplate/dependent-base-classes.cpp
@@ -1,12 +1,12 @@
 // RUN: %clang_cc1 -fsyntax-only -verify %s
 
 template<typename T, typename U>
-struct X0 : T::template apply<U> {
+struct X0 : T::template apply<U> { 
   X0(U u) : T::template apply<U>(u) { }
 };
 
 template<typename T, typename U>
-struct X1 : T::apply<U> { }; // expected-warning{{use 'template' keyword to treat 'apply' as a dependent template name}}
+struct X1 : T::apply<U> { }; // expected-error{{use 'template' keyword to treat 'apply' as a dependent template name}}
 
 template<typename T>
 struct X2 : vector<T> { }; // expected-error{{no template named 'vector'}}
@@ -85,7 +85,7 @@
   struct A { };
 
   template<typename T>
-  class B : public A<T>
+  class B : public A<T> 
   {
   public:
     template< class X >
@@ -109,9 +109,9 @@
 
 namespace PR6413 {
   template <typename T> class Base_A { };
-
+  
   class Base_B { };
-
+  
   template <typename T>
   class Derived
     : public virtual Base_A<T>
@@ -120,12 +120,12 @@
 }
 
 namespace PR5812 {
-  template <class T> struct Base {
-    Base* p;
-  };
+  template <class T> struct Base { 
+    Base* p; 
+  }; 
 
-  template <class T> struct Derived: public Base<T> {
-    typename Derived::Base* p; // meaning Derived::Base<T>
+  template <class T> struct Derived: public Base<T> { 
+    typename Derived::Base* p; // meaning Derived::Base<T> 
   };
 
   Derived<int> di;
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/dependent-template-recover.cpp b/clang/test/SemaTemplate/dependent-template-recover.cpp
--- a/clang/test/SemaTemplate/dependent-template-recover.cpp
+++ b/clang/test/SemaTemplate/dependent-template-recover.cpp
@@ -2,15 +2,15 @@
 template<typename T, typename U, int N>
 struct X {
   void f(T* t) {
-    t->f0<U>(); // expected-warning{{use 'template' keyword to treat 'f0' as a dependent template name}}
-    t->f0<int>(); // expected-warning{{use 'template' keyword to treat 'f0' as a dependent template name}}
+    t->f0<U>(); // expected-error{{use 'template' keyword to treat 'f0' as a dependent template name}}
+    t->f0<int>(); // expected-error{{use 'template' keyword to treat 'f0' as a dependent template name}}
 
-    t->operator+<U const, 1>(1); // expected-warning{{use 'template' keyword to treat 'operator +' as a dependent template name}}
-    t->f1<int const, 2>(1); // expected-warning{{use 'template' keyword to treat 'f1' as a dependent template name}}
+    t->operator+<U const, 1>(1); // expected-error{{use 'template' keyword to treat 'operator +' as a dependent template name}}
+    t->f1<int const, 2>(1); // expected-error{{use 'template' keyword to treat 'f1' as a dependent template name}}
     t->f1<3, int const>(1); // expected-error{{missing 'template' keyword prior to dependent template name 'f1'}}
 
-    T::getAs<U>(); // expected-warning{{use 'template' keyword to treat 'getAs' as a dependent template name}}
-    t->T::getAs<U>(); // expected-warning{{use 'template' keyword to treat 'getAs' as a dependent template name}}
+    T::getAs<U>(); // expected-error{{use 'template' keyword to treat 'getAs' as a dependent template name}}
+    t->T::getAs<U>(); // expected-error{{use 'template' keyword to treat 'getAs' as a dependent template name}}
 
     (*t).f2<N>(); // expected-error{{missing 'template' keyword prior to dependent template name 'f2'}}
     (*t).f2<0>(); // expected-error{{missing 'template' keyword prior to dependent template name 'f2'}}
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/temp_arg_nontype_cxx20.cpp b/clang/test/SemaTemplate/temp_arg_nontype_cxx20.cpp
--- a/clang/test/SemaTemplate/temp_arg_nontype_cxx20.cpp
+++ b/clang/test/SemaTemplate/temp_arg_nontype_cxx20.cpp
@@ -115,7 +115,7 @@
   static_assert(f(X<A{}>()) == 0);
 
   template<A a> struct Y { void f(); };
-  template<A a> void g(Y<a> y) { y.template Y<a>::f(); }
+  template<A a> void g(Y<a> y) { y.Y<a>::f(); }
   void h() { constexpr A a; g<a>(Y<a>{}); }
 
   template<A a> struct Z {
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/template-id-expr.cpp b/clang/test/SemaTemplate/template-id-expr.cpp
--- a/clang/test/SemaTemplate/template-id-expr.cpp
+++ b/clang/test/SemaTemplate/template-id-expr.cpp
@@ -19,7 +19,7 @@
 struct X0 {
   template<typename U>
   void f1();
-
+  
   template<typename U>
   void f2(U) {
     f1<U>();
@@ -39,9 +39,9 @@
 template<int I>
 struct X {
   X(int, int);
-  void f() {
-    Y<X<I> >(X<I>(0, 0));
-    Y<X<I> >(::X<I>(0, 0));
+  void f() { 
+    Y<X<I> >(X<I>(0, 0)); 
+    Y<X<I> >(::X<I>(0, 0)); 
   }
 };
 
@@ -149,11 +149,11 @@
 
     int x;
     x = Y1::f4(0);
-    x = Y1::f4<int>(0); // expected-warning {{use 'template'}} expected-error {{assigning to 'int' from incompatible type 'void'}}
+    x = Y1::f4<int>(0); // expected-error {{use 'template'}} expected-error {{assigning to 'int' from incompatible type 'void'}}
     x = Y1::template f4(0); // expected-error {{assigning to 'int' from incompatible type 'void'}} expected-error {{a template argument list is expected after a name prefixed by the template keyword}}
 
     x = p->f4(0);
-    x = p->f4<int>(0); // expected-error {{assigning to 'int' from incompatible type 'void'}} expected-warning {{use 'template'}}
+    x = p->f4<int>(0); // expected-error {{assigning to 'int' from incompatible type 'void'}} expected-error {{use 'template'}}
     x = p->template f4(0); // expected-error {{assigning to 'int' from incompatible type 'void'}} expected-error {{a template argument list is expected after a name prefixed by the template keyword}}
   }
 };
@@ -184,7 +184,7 @@
 #if __cplusplus <= 199711L
 // expected-warning@+2 {{extension}}
 #endif
-template<typename T> using D = int; // expected-note {{declared here}}
+template<typename T> using D = int; // expected-note {{declared here}} 
 E<D> ed; // expected-note {{instantiation of}}
 
 namespace non_functions {
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/typename-specifier-3.cpp b/clang/test/SemaTemplate/typename-specifier-3.cpp
--- a/clang/test/SemaTemplate/typename-specifier-3.cpp
+++ b/clang/test/SemaTemplate/typename-specifier-3.cpp
@@ -46,7 +46,7 @@
       typedef int arg;
     };
     struct C {
-      typedef typename B::X<typename B::arg> x; // expected-warning {{use 'template'}} expected-error {{refers to non-type}}
+      typedef typename B::X<typename B::arg> x; // expected-error {{use 'template'}} expected-error {{refers to non-type}}
     };
   };
 
diff -ruN --strip-trailing-cr a/libc/src/__support/macros/config.h b/libc/src/__support/macros/config.h
--- a/libc/src/__support/macros/config.h
+++ b/libc/src/__support/macros/config.h
@@ -15,7 +15,6 @@
 
 // Workaround for compilers that do not support builtin detection.
 // FIXME: This is only required for the GPU portion which should be moved.
-#include "src/__support/macros/config.h"
 #ifndef __has_builtin
 #define __has_builtin(b) 0
 #endif
diff -ruN --strip-trailing-cr a/libcxx/include/regex b/libcxx/include/regex
--- a/libcxx/include/regex
+++ b/libcxx/include/regex
@@ -4214,7 +4214,7 @@
   _LIBCPP_HIDE_FROM_ABI int compare(const value_type* __s) const { return str().compare(__s); }
 
   _LIBCPP_HIDE_FROM_ABI void swap(sub_match& __s) _NOEXCEPT_(__is_nothrow_swappable_v<_BidirectionalIterator>) {
-    this->template pair<_BidirectionalIterator, _BidirectionalIterator>::swap(__s);
+    this->pair<_BidirectionalIterator, _BidirectionalIterator>::swap(__s);
     std::swap(matched, __s.matched);
   }
 };
diff -ruN --strip-trailing-cr a/llvm/include/llvm/ADT/ArrayRef.h b/llvm/include/llvm/ADT/ArrayRef.h
--- a/llvm/include/llvm/ADT/ArrayRef.h
+++ b/llvm/include/llvm/ADT/ArrayRef.h
@@ -460,11 +460,8 @@
 
     OwningArrayRef &operator=(OwningArrayRef &&Other) {
       delete[] this->data();
-      using Base = MutableArrayRef<T>;
-      // GCC versions prior to 11.1 incorrectly reject if the 'template' keyword
-      // is used prior to the nested-name-specifier here.
-      this->Base::operator=(Other);
-      Other.Base::operator=(Base());
+      this->MutableArrayRef<T>::operator=(Other);
+      Other.MutableArrayRef<T>::operator=(MutableArrayRef<T>());
       return *this;
     }
 
diff -ruN --strip-trailing-cr a/llvm/include/llvm/TargetParser/Triple.h b/llvm/include/llvm/TargetParser/Triple.h
--- a/llvm/include/llvm/TargetParser/Triple.h
+++ b/llvm/include/llvm/TargetParser/Triple.h
@@ -88,6 +88,8 @@
     xtensa,         // Tensilica: Xtensa
     nvptx,          // NVPTX: 32-bit
     nvptx64,        // NVPTX: 64-bit
+    le32,           // le32: generic little-endian 32-bit CPU (PNaCl)
+    le64,           // le64: generic little-endian 64-bit CPU (PNaCl)
     amdil,          // AMDIL
     amdil64,        // AMDIL with 64-bit pointers
     hsail,          // AMD HSAIL
diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/MachineSink.cpp b/llvm/lib/CodeGen/MachineSink.cpp
--- a/llvm/lib/CodeGen/MachineSink.cpp
+++ b/llvm/lib/CodeGen/MachineSink.cpp
@@ -961,7 +961,7 @@
                                                 MachineBasicBlock *ToBB,
                                                 bool BreakPHIEdge) {
   // Avoid breaking back edge. From == To means backedge for single BB cycle.
-  if (!SplitEdges || FromBB == ToBB)
+  if (!SplitEdges || FromBB == ToBB || !FromBB->isSuccessor(ToBB))
     return false;
 
   MachineCycle *FromCycle = CI->getCycle(FromBB);
diff -ruN --strip-trailing-cr a/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp b/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp
--- a/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp
+++ b/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp
@@ -128,7 +128,6 @@
   bool visitINSviGPR(MachineInstr &MI, unsigned Opc);
   bool visitINSvi64lane(MachineInstr &MI);
   bool visitFMOVDr(MachineInstr &MI);
-  bool visitCopy(MachineInstr &MI);
   bool runOnMachineFunction(MachineFunction &MF) override;
 
   StringRef getPassName() const override {
@@ -691,34 +690,6 @@
   return true;
 }
 
-// Across a basic-block we might have in i32 extract from a value that only
-// operates on upper bits (for example a sxtw). We can replace the COPY with a
-// new version skipping the sxtw.
-bool AArch64MIPeepholeOpt::visitCopy(MachineInstr &MI) {
-  Register InputReg = MI.getOperand(1).getReg();
-  if (MI.getOperand(1).getSubReg() != AArch64::sub_32 ||
-      !MRI->hasOneNonDBGUse(InputReg))
-    return false;
-
-  MachineInstr *SrcMI = MRI->getUniqueVRegDef(InputReg);
-  MachineInstr *CopyMI = SrcMI;
-  while (SrcMI && SrcMI->isFullCopy() &&
-         MRI->hasOneNonDBGUse(SrcMI->getOperand(1).getReg()))
-    SrcMI = MRI->getUniqueVRegDef(SrcMI->getOperand(1).getReg());
-
-  if (!SrcMI || SrcMI->getOpcode() != AArch64::SBFMXri ||
-      SrcMI->getOperand(2).getImm() != 0 || SrcMI->getOperand(3).getImm() != 31)
-    return false;
-
-  Register SrcReg = SrcMI->getOperand(1).getReg();
-  MRI->constrainRegClass(SrcReg, MRI->getRegClass(InputReg));
-  MI.getOperand(1).setReg(SrcReg);
-  if (CopyMI != SrcMI)
-    CopyMI->eraseFromParent();
-  SrcMI->eraseFromParent();
-  return true;
-}
-
 bool AArch64MIPeepholeOpt::runOnMachineFunction(MachineFunction &MF) {
   if (skipFunction(MF.getFunction()))
     return false;
@@ -800,9 +771,6 @@
       case AArch64::FMOVDr:
         Changed |= visitFMOVDr(MI);
         break;
-      case AArch64::COPY:
-        Changed |= visitCopy(MI);
-        break;
       }
     }
   }
diff -ruN --strip-trailing-cr a/llvm/lib/Target/AArch64/peephole-sxtw.mir b/llvm/lib/Target/AArch64/peephole-sxtw.mir
--- a/llvm/lib/Target/AArch64/peephole-sxtw.mir
+++ b/llvm/lib/Target/AArch64/peephole-sxtw.mir
@@ -1,46 +0,0 @@
-# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
-# RUN: llc -run-pass=aarch64-mi-peephole-opt -o - -mtriple=aarch64-unknown-linux -verify-machineinstrs %s | FileCheck %s
-
----
-name: removeSxtw
-tracksRegLiveness: true
-body: |
-  bb.0.entry:
-    liveins: $x0
-    ; CHECK-LABEL: name: removeSxtw
-    ; CHECK: liveins: $x0
-    ; CHECK-NEXT: {{  $}}
-    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gpr64 = COPY $x0
-    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:gpr32sp = COPY [[COPY]].sub_32
-    ; CHECK-NEXT: [[ADDWri:%[0-9]+]]:gpr32sp = ADDWri [[COPY1]], 1, 0
-    ; CHECK-NEXT: $w0 = COPY [[ADDWri]]
-    ; CHECK-NEXT: RET_ReallyLR implicit $w0
-    %0:gpr64 = COPY $x0
-    %1:gpr64 = SBFMXri %0:gpr64, 0, 31
-    %2:gpr32sp = COPY %1.sub_32:gpr64
-    %3:gpr32sp = ADDWri %2:gpr32sp, 1, 0
-    $w0 = COPY %3:gpr32sp
-    RET_ReallyLR implicit $w0
-...
----
-name: extraCopy
-tracksRegLiveness: true
-body: |
-  bb.0.entry:
-    liveins: $x0
-    ; CHECK-LABEL: name: extraCopy
-    ; CHECK: liveins: $x0
-    ; CHECK-NEXT: {{  $}}
-    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gpr64 = COPY $x0
-    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:gpr32sp = COPY [[COPY]].sub_32
-    ; CHECK-NEXT: [[ADDWri:%[0-9]+]]:gpr32sp = ADDWri [[COPY1]], 1, 0
-    ; CHECK-NEXT: $w0 = COPY [[ADDWri]]
-    ; CHECK-NEXT: RET_ReallyLR implicit $w0
-    %0:gpr64 = COPY $x0
-    %1:gpr64 = SBFMXri %0:gpr64, 0, 31
-    %2:gpr64all = COPY %1:gpr64
-    %3:gpr32sp = COPY %2.sub_32:gpr64all
-    %4:gpr32sp = ADDWri %3:gpr32sp, 1, 0
-    $w0 = COPY %4:gpr32sp
-    RET_ReallyLR implicit $w0
-...
diff -ruN --strip-trailing-cr a/llvm/lib/TargetParser/Triple.cpp b/llvm/lib/TargetParser/Triple.cpp
--- a/llvm/lib/TargetParser/Triple.cpp
+++ b/llvm/lib/TargetParser/Triple.cpp
@@ -44,6 +44,8 @@
   case hsail:          return "hsail";
   case kalimba:        return "kalimba";
   case lanai:          return "lanai";
+  case le32:           return "le32";
+  case le64:           return "le64";
   case loongarch32:    return "loongarch32";
   case loongarch64:    return "loongarch64";
   case m68k:           return "m68k";
@@ -197,6 +199,9 @@
   case nvptx:       return "nvvm";
   case nvptx64:     return "nvvm";
 
+  case le32:        return "le32";
+  case le64:        return "le64";
+
   case amdil:
   case amdil64:     return "amdil";
 
@@ -427,6 +432,8 @@
     .Case("xcore", xcore)
     .Case("nvptx", nvptx)
     .Case("nvptx64", nvptx64)
+    .Case("le32", le32)
+    .Case("le64", le64)
     .Case("amdil", amdil)
     .Case("amdil64", amdil64)
     .Case("hsail", hsail)
@@ -567,6 +574,8 @@
           .Case("xcore", Triple::xcore)
           .Case("nvptx", Triple::nvptx)
           .Case("nvptx64", Triple::nvptx64)
+          .Case("le32", Triple::le32)
+          .Case("le64", Triple::le64)
           .Case("amdil", Triple::amdil)
           .Case("amdil64", Triple::amdil64)
           .Case("hsail", Triple::hsail)
@@ -896,6 +905,8 @@
   case Triple::hsail:
   case Triple::kalimba:
   case Triple::lanai:
+  case Triple::le32:
+  case Triple::le64:
   case Triple::loongarch32:
   case Triple::loongarch64:
   case Triple::m68k:
@@ -1592,6 +1603,7 @@
   case llvm::Triple::hsail:
   case llvm::Triple::kalimba:
   case llvm::Triple::lanai:
+  case llvm::Triple::le32:
   case llvm::Triple::loongarch32:
   case llvm::Triple::m68k:
   case llvm::Triple::mips:
@@ -1624,6 +1636,7 @@
   case llvm::Triple::bpfeb:
   case llvm::Triple::bpfel:
   case llvm::Triple::hsail64:
+  case llvm::Triple::le64:
   case llvm::Triple::loongarch64:
   case llvm::Triple::mips64:
   case llvm::Triple::mips64el:
@@ -1682,6 +1695,7 @@
   case Triple::hsail:
   case Triple::kalimba:
   case Triple::lanai:
+  case Triple::le32:
   case Triple::loongarch32:
   case Triple::m68k:
   case Triple::mips:
@@ -1712,6 +1726,7 @@
   case Triple::aarch64_be:     T.setArch(Triple::armeb);   break;
   case Triple::amdil64:        T.setArch(Triple::amdil);   break;
   case Triple::hsail64:        T.setArch(Triple::hsail);   break;
+  case Triple::le64:           T.setArch(Triple::le32);    break;
   case Triple::loongarch64:    T.setArch(Triple::loongarch32); break;
   case Triple::mips64:
     T.setArch(Triple::mips, getSubArch());
@@ -1766,6 +1781,7 @@
   case Triple::bpfeb:
   case Triple::bpfel:
   case Triple::hsail64:
+  case Triple::le64:
   case Triple::loongarch64:
   case Triple::mips64:
   case Triple::mips64el:
@@ -1789,6 +1805,7 @@
   case Triple::arm:             T.setArch(Triple::aarch64);    break;
   case Triple::armeb:           T.setArch(Triple::aarch64_be); break;
   case Triple::hsail:           T.setArch(Triple::hsail64);    break;
+  case Triple::le32:            T.setArch(Triple::le64);       break;
   case Triple::loongarch32:     T.setArch(Triple::loongarch64);    break;
   case Triple::mips:
     T.setArch(Triple::mips64, getSubArch());
@@ -1831,6 +1848,8 @@
   case Triple::hsail64:
   case Triple::hsail:
   case Triple::kalimba:
+  case Triple::le32:
+  case Triple::le64:
   case Triple::loongarch32:
   case Triple::loongarch64:
   case Triple::msp430:
@@ -1934,6 +1953,8 @@
   case Triple::hsail64:
   case Triple::hsail:
   case Triple::kalimba:
+  case Triple::le32:
+  case Triple::le64:
   case Triple::loongarch32:
   case Triple::loongarch64:
   case Triple::mips64el:
diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
@@ -6995,7 +6995,7 @@
   // Ignore ephemeral values.
   CodeMetrics::collectEphemeralValues(TheLoop, AC, ValuesToIgnore);
 
-  SmallSetVector<Value *, 4> DeadInterleavePointerOps;
+  SmallVector<Value *, 4> DeadInterleavePointerOps;
   for (BasicBlock *BB : TheLoop->blocks())
     for (Instruction &I : *BB) {
       // Find all stores to invariant variables. Since they are going to sink
@@ -7013,7 +7013,7 @@
         if (Group->getInsertPos() == &I)
           continue;
         Value *PointerOp = getLoadStorePointerOperand(&I);
-        DeadInterleavePointerOps.insert(PointerOp);
+        DeadInterleavePointerOps.push_back(PointerOp);
       }
     }
 
@@ -7029,7 +7029,7 @@
         }))
       continue;
     VecValuesToIgnore.insert(Op);
-    DeadInterleavePointerOps.insert(Op->op_begin(), Op->op_end());
+    DeadInterleavePointerOps.append(Op->op_begin(), Op->op_end());
   }
 
   // Ignore type-promoting instructions we identified during reduction
diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/AArch64/aarch64-mull-masks.ll b/llvm/test/CodeGen/AArch64/aarch64-mull-masks.ll
--- a/llvm/test/CodeGen/AArch64/aarch64-mull-masks.ll
+++ b/llvm/test/CodeGen/AArch64/aarch64-mull-masks.ll
@@ -281,7 +281,8 @@
 ; CHECK-LABEL: smull_ldrsw_shift:
 ; CHECK:       // %bb.0: // %entry
 ; CHECK-NEXT:    ldrsw x8, [x0]
-; CHECK-NEXT:    smull x0, w8, w1
+; CHECK-NEXT:    sxtw x9, w1
+; CHECK-NEXT:    smull x0, w8, w9
 ; CHECK-NEXT:    ret
 entry:
   %ext64 = load i32, ptr %x0
@@ -489,7 +490,8 @@
 ; CHECK-LABEL: smaddl_ldrsw_shift:
 ; CHECK:       // %bb.0: // %entry
 ; CHECK-NEXT:    ldrsw x8, [x0]
-; CHECK-NEXT:    smaddl x0, w8, w1, x2
+; CHECK-NEXT:    sxtw x9, w1
+; CHECK-NEXT:    smaddl x0, w8, w9, x2
 ; CHECK-NEXT:    ret
 entry:
   %ext64 = load i32, ptr %x0
@@ -652,7 +654,8 @@
 ; CHECK-LABEL: smnegl_ldrsw_shift:
 ; CHECK:       // %bb.0: // %entry
 ; CHECK-NEXT:    ldrsw x8, [x0]
-; CHECK-NEXT:    smnegl x0, w8, w1
+; CHECK-NEXT:    sxtw x9, w1
+; CHECK-NEXT:    smnegl x0, w8, w9
 ; CHECK-NEXT:    ret
 entry:
   %ext64 = load i32, ptr %x0
@@ -815,7 +818,8 @@
 ; CHECK-LABEL: smsubl_ldrsw_shift:
 ; CHECK:       // %bb.0: // %entry
 ; CHECK-NEXT:    ldrsw x8, [x0]
-; CHECK-NEXT:    smsubl x0, w8, w1, x2
+; CHECK-NEXT:    sxtw x9, w1
+; CHECK-NEXT:    smsubl x0, w8, w9, x2
 ; CHECK-NEXT:    ret
 entry:
   %ext64 = load i32, ptr %x0
diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/MachineSink-Issue98477.ll b/llvm/test/CodeGen/X86/MachineSink-Issue98477.ll
--- a/llvm/test/CodeGen/X86/MachineSink-Issue98477.ll
+++ b/llvm/test/CodeGen/X86/MachineSink-Issue98477.ll
@@ -0,0 +1,76 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
+; RUN: llc < %s | FileCheck %s
+
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+define i32 @main(i1 %tobool.not, i32 %0) {
+; CHECK-LABEL: main:
+; CHECK:       # %bb.0: # %entry
+; CHECK-NEXT:    movl $1, %r8d
+; CHECK-NEXT:    testb $1, %dil
+; CHECK-NEXT:    jne .LBB0_8
+; CHECK-NEXT:  .LBB0_1: # %j.preheader
+; CHECK-NEXT:    xorl %r9d, %r9d
+; CHECK-NEXT:    jmp .LBB0_2
+; CHECK-NEXT:    .p2align 4, 0x90
+; CHECK-NEXT:  .LBB0_5: # %if.then4
+; CHECK-NEXT:    # in Loop: Header=BB0_2 Depth=1
+; CHECK-NEXT:    movl $1, %eax
+; CHECK-NEXT:    xorl %edx, %edx
+; CHECK-NEXT:    divl %r8d
+; CHECK-NEXT:    testb $1, %dil
+; CHECK-NEXT:    jne .LBB0_6
+; CHECK-NEXT:  .LBB0_2: # %j
+; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
+; CHECK-NEXT:    movl $1, %eax
+; CHECK-NEXT:    xorl %edx, %edx
+; CHECK-NEXT:    idivl %esi
+; CHECK-NEXT:    movl %edx, %ecx
+; CHECK-NEXT:    testb %r9b, %r9b
+; CHECK-NEXT:    jne .LBB0_5
+; CHECK-NEXT:  # %bb.3: # %j
+; CHECK-NEXT:    # in Loop: Header=BB0_2 Depth=1
+; CHECK-NEXT:    testl %r9d, %r9d
+; CHECK-NEXT:    js .LBB0_5
+; CHECK-NEXT:  # %bb.4:
+; CHECK-NEXT:    movl %r9d, %edx
+; CHECK-NEXT:  .LBB0_6: # %if.end9
+; CHECK-NEXT:    testl %edx, %edx
+; CHECK-NEXT:    jne .LBB0_7
+; CHECK-NEXT:  .LBB0_8: # %if.end13
+; CHECK-NEXT:    xorl %r8d, %r8d
+; CHECK-NEXT:    jmp .LBB0_1
+; CHECK-NEXT:  .LBB0_7: # %while.body.lr.ph
+; CHECK-NEXT:    movl %ecx, %eax
+; CHECK-NEXT:    retq
+entry:
+  br i1 %tobool.not, label %if.end13, label %j.preheader
+
+  j.preheader:       ; preds = %if.end13, %entry
+  %h.0.ph = phi i32 [ 1, %entry ], [ 0, %if.end13 ]
+  br label %j
+
+  j:                 ; preds = %if.then4, %j.preheader
+  %1 = phi i32 [ %div2, %if.then4 ], [ 0, %j.preheader ]
+  %rem1 = srem i32 1, %0
+  %cmp = icmp slt i32 %1, 0
+  %or.cond = select i1 false, i1 true, i1 %cmp
+  br i1 %or.cond, label %if.then4, label %if.end9
+
+  if.then4:          ; preds = %j
+  %div2 = sdiv i32 1, 0
+  %rem5 = srem i32 1, %h.0.ph
+  br i1 %tobool.not, label %if.end9, label %j
+
+  if.end9:           ; preds = %if.then4, %j
+  %2 = phi i32 [ 0, %j ], [ %rem5, %if.then4 ]
+  %tobool10.not = icmp eq i32 %2, 0
+  br i1 %tobool10.not, label %if.end13, label %while.body.lr.ph
+
+  while.body.lr.ph:  ; preds = %if.end9
+  ret i32 %rem1
+
+  if.end13:          ; preds = %if.end9, %entry
+  br label %j.preheader
+}
diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/X86/interleave-cost.ll b/llvm/test/Transforms/LoopVectorize/X86/interleave-cost.ll
--- a/llvm/test/Transforms/LoopVectorize/X86/interleave-cost.ll
+++ b/llvm/test/Transforms/LoopVectorize/X86/interleave-cost.ll
@@ -182,9 +182,432 @@
 exit:
   ret void
 }
+
+define void @geps_feeding_interleave_groups_with_reuse(ptr %arg, i64 %arg1, ptr %arg2) #0 {
+; CHECK-LABEL: define void @geps_feeding_interleave_groups_with_reuse(
+; CHECK-SAME: ptr [[ARG:%.*]], i64 [[ARG1:%.*]], ptr [[ARG2:%.*]]) #[[ATTR0:[0-9]+]] {
+; CHECK-NEXT:  [[ENTRY:.*]]:
+; CHECK-NEXT:    [[TMP0:%.*]] = add i64 [[ARG1]], 1
+; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[TMP0]], 30
+; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_SCEVCHECK:.*]]
+; CHECK:       [[VECTOR_SCEVCHECK]]:
+; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[ARG2]], i64 8
+; CHECK-NEXT:    [[MUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 16, i64 [[ARG1]])
+; CHECK-NEXT:    [[MUL_RESULT:%.*]] = extractvalue { i64, i1 } [[MUL]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW:%.*]] = extractvalue { i64, i1 } [[MUL]], 1
+; CHECK-NEXT:    [[TMP1:%.*]] = sub i64 0, [[MUL_RESULT]]
+; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[SCEVGEP]], i64 [[MUL_RESULT]]
+; CHECK-NEXT:    [[TMP3:%.*]] = icmp ult ptr [[TMP2]], [[SCEVGEP]]
+; CHECK-NEXT:    [[TMP4:%.*]] = or i1 [[TMP3]], [[MUL_OVERFLOW]]
+; CHECK-NEXT:    [[SCEVGEP1:%.*]] = getelementptr i8, ptr [[ARG2]], i64 12
+; CHECK-NEXT:    [[MUL2:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 16, i64 [[ARG1]])
+; CHECK-NEXT:    [[MUL_RESULT3:%.*]] = extractvalue { i64, i1 } [[MUL2]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW4:%.*]] = extractvalue { i64, i1 } [[MUL2]], 1
+; CHECK-NEXT:    [[TMP5:%.*]] = sub i64 0, [[MUL_RESULT3]]
+; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[SCEVGEP1]], i64 [[MUL_RESULT3]]
+; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult ptr [[TMP6]], [[SCEVGEP1]]
+; CHECK-NEXT:    [[TMP8:%.*]] = or i1 [[TMP7]], [[MUL_OVERFLOW4]]
+; CHECK-NEXT:    [[SCEVGEP5:%.*]] = getelementptr i8, ptr [[ARG2]], i64 4
+; CHECK-NEXT:    [[MUL6:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 16, i64 [[ARG1]])
+; CHECK-NEXT:    [[MUL_RESULT7:%.*]] = extractvalue { i64, i1 } [[MUL6]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW8:%.*]] = extractvalue { i64, i1 } [[MUL6]], 1
+; CHECK-NEXT:    [[TMP9:%.*]] = sub i64 0, [[MUL_RESULT7]]
+; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[SCEVGEP5]], i64 [[MUL_RESULT7]]
+; CHECK-NEXT:    [[TMP11:%.*]] = icmp ult ptr [[TMP10]], [[SCEVGEP5]]
+; CHECK-NEXT:    [[TMP12:%.*]] = or i1 [[TMP11]], [[MUL_OVERFLOW8]]
+; CHECK-NEXT:    [[MUL9:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 16, i64 [[ARG1]])
+; CHECK-NEXT:    [[MUL_RESULT10:%.*]] = extractvalue { i64, i1 } [[MUL9]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW11:%.*]] = extractvalue { i64, i1 } [[MUL9]], 1
+; CHECK-NEXT:    [[TMP13:%.*]] = sub i64 0, [[MUL_RESULT10]]
+; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i8, ptr [[ARG2]], i64 [[MUL_RESULT10]]
+; CHECK-NEXT:    [[TMP15:%.*]] = icmp ult ptr [[TMP14]], [[ARG2]]
+; CHECK-NEXT:    [[TMP16:%.*]] = or i1 [[TMP15]], [[MUL_OVERFLOW11]]
+; CHECK-NEXT:    [[TMP17:%.*]] = or i1 [[TMP4]], [[TMP8]]
+; CHECK-NEXT:    [[TMP18:%.*]] = or i1 [[TMP17]], [[TMP12]]
+; CHECK-NEXT:    [[TMP19:%.*]] = or i1 [[TMP18]], [[TMP16]]
+; CHECK-NEXT:    br i1 [[TMP19]], label %[[SCALAR_PH]], label %[[VECTOR_MEMCHECK:.*]]
+; CHECK:       [[VECTOR_MEMCHECK]]:
+; CHECK-NEXT:    [[TMP20:%.*]] = shl i64 [[ARG1]], 4
+; CHECK-NEXT:    [[TMP21:%.*]] = add i64 [[TMP20]], 16
+; CHECK-NEXT:    [[SCEVGEP12:%.*]] = getelementptr i8, ptr [[ARG2]], i64 [[TMP21]]
+; CHECK-NEXT:    [[TMP22:%.*]] = shl i64 [[ARG1]], 5
+; CHECK-NEXT:    [[TMP23:%.*]] = add i64 [[TMP22]], 32
+; CHECK-NEXT:    [[SCEVGEP13:%.*]] = getelementptr i8, ptr [[ARG]], i64 [[TMP23]]
+; CHECK-NEXT:    [[BOUND0:%.*]] = icmp ult ptr [[ARG2]], [[SCEVGEP13]]
+; CHECK-NEXT:    [[BOUND1:%.*]] = icmp ult ptr [[ARG]], [[SCEVGEP12]]
+; CHECK-NEXT:    [[FOUND_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]]
+; CHECK-NEXT:    br i1 [[FOUND_CONFLICT]], label %[[SCALAR_PH]], label %[[VECTOR_PH:.*]]
+; CHECK:       [[VECTOR_PH]]:
+; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[TMP0]], 2
+; CHECK-NEXT:    [[N_VEC:%.*]] = sub i64 [[TMP0]], [[N_MOD_VF]]
+; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
+; CHECK:       [[VECTOR_BODY]]:
+; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
+; CHECK-NEXT:    [[TMP24:%.*]] = add i64 [[INDEX]], 0
+; CHECK-NEXT:    [[TMP25:%.*]] = shl i64 [[TMP24]], 5
+; CHECK-NEXT:    [[TMP26:%.*]] = getelementptr i8, ptr [[ARG]], i64 [[TMP25]]
+; CHECK-NEXT:    [[TMP27:%.*]] = shl i64 [[TMP24]], 4
+; CHECK-NEXT:    [[TMP28:%.*]] = getelementptr i8, ptr [[ARG2]], i64 [[TMP27]]
+; CHECK-NEXT:    [[TMP29:%.*]] = getelementptr float, ptr [[TMP26]], i32 0
+; CHECK-NEXT:    [[WIDE_VEC:%.*]] = load <16 x float>, ptr [[TMP29]], align 4
+; CHECK-NEXT:    [[STRIDED_VEC:%.*]] = shufflevector <16 x float> [[WIDE_VEC]], <16 x float> poison, <2 x i32> <i32 0, i32 8>
+; CHECK-NEXT:    [[STRIDED_VEC14:%.*]] = shufflevector <16 x float> [[WIDE_VEC]], <16 x float> poison, <2 x i32> <i32 1, i32 9>
+; CHECK-NEXT:    [[STRIDED_VEC15:%.*]] = shufflevector <16 x float> [[WIDE_VEC]], <16 x float> poison, <2 x i32> <i32 2, i32 10>
+; CHECK-NEXT:    [[STRIDED_VEC16:%.*]] = shufflevector <16 x float> [[WIDE_VEC]], <16 x float> poison, <2 x i32> <i32 3, i32 11>
+; CHECK-NEXT:    [[STRIDED_VEC17:%.*]] = shufflevector <16 x float> [[WIDE_VEC]], <16 x float> poison, <2 x i32> <i32 4, i32 12>
+; CHECK-NEXT:    [[STRIDED_VEC18:%.*]] = shufflevector <16 x float> [[WIDE_VEC]], <16 x float> poison, <2 x i32> <i32 5, i32 13>
+; CHECK-NEXT:    [[STRIDED_VEC19:%.*]] = shufflevector <16 x float> [[WIDE_VEC]], <16 x float> poison, <2 x i32> <i32 6, i32 14>
+; CHECK-NEXT:    [[STRIDED_VEC20:%.*]] = shufflevector <16 x float> [[WIDE_VEC]], <16 x float> poison, <2 x i32> <i32 7, i32 15>
+; CHECK-NEXT:    [[TMP30:%.*]] = fadd <2 x float> [[STRIDED_VEC]], [[STRIDED_VEC17]]
+; CHECK-NEXT:    [[TMP31:%.*]] = fmul <2 x float> [[TMP30]], zeroinitializer
+; CHECK-NEXT:    [[TMP32:%.*]] = fadd <2 x float> [[STRIDED_VEC14]], [[STRIDED_VEC18]]
+; CHECK-NEXT:    [[TMP33:%.*]] = fmul <2 x float> [[TMP32]], zeroinitializer
+; CHECK-NEXT:    [[TMP34:%.*]] = fadd <2 x float> [[STRIDED_VEC15]], [[STRIDED_VEC19]]
+; CHECK-NEXT:    [[TMP35:%.*]] = fmul <2 x float> [[TMP34]], zeroinitializer
+; CHECK-NEXT:    [[TMP36:%.*]] = fadd <2 x float> [[STRIDED_VEC16]], [[STRIDED_VEC20]]
+; CHECK-NEXT:    [[TMP37:%.*]] = fmul <2 x float> [[TMP36]], zeroinitializer
+; CHECK-NEXT:    [[TMP38:%.*]] = getelementptr i8, ptr [[TMP28]], i64 12
+; CHECK-NEXT:    [[TMP39:%.*]] = getelementptr float, ptr [[TMP38]], i32 -3
+; CHECK-NEXT:    [[TMP40:%.*]] = shufflevector <2 x float> [[TMP31]], <2 x float> [[TMP33]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
+; CHECK-NEXT:    [[TMP41:%.*]] = shufflevector <2 x float> [[TMP35]], <2 x float> [[TMP37]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
+; CHECK-NEXT:    [[TMP42:%.*]] = shufflevector <4 x float> [[TMP40]], <4 x float> [[TMP41]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
+; CHECK-NEXT:    [[INTERLEAVED_VEC:%.*]] = shufflevector <8 x float> [[TMP42]], <8 x float> poison, <8 x i32> <i32 0, i32 2, i32 4, i32 6, i32 1, i32 3, i32 5, i32 7>
+; CHECK-NEXT:    store <8 x float> [[INTERLEAVED_VEC]], ptr [[TMP39]], align 4
+; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2
+; CHECK-NEXT:    [[TMP43:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
+; CHECK-NEXT:    br i1 [[TMP43]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
+; CHECK:       [[MIDDLE_BLOCK]]:
+; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[TMP0]], [[N_VEC]]
+; CHECK-NEXT:    br i1 [[CMP_N]], label %[[EXIT:.*]], label %[[SCALAR_PH]]
+; CHECK:       [[SCALAR_PH]]:
+; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], %[[MIDDLE_BLOCK]] ], [ 0, %[[ENTRY]] ], [ 0, %[[VECTOR_SCEVCHECK]] ], [ 0, %[[VECTOR_MEMCHECK]] ]
+; CHECK-NEXT:    br label %[[LOOP:.*]]
+; CHECK:       [[LOOP]]:
+; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
+; CHECK-NEXT:    [[SHL_IV_5:%.*]] = shl i64 [[IV]], 5
+; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr i8, ptr [[ARG]], i64 [[SHL_IV_5]]
+; CHECK-NEXT:    [[ADD_5:%.*]] = or disjoint i64 [[SHL_IV_5]], 16
+; CHECK-NEXT:    [[GEP_2:%.*]] = getelementptr i8, ptr [[ARG]], i64 [[ADD_5]]
+; CHECK-NEXT:    [[SHL_IV_4:%.*]] = shl i64 [[IV]], 4
+; CHECK-NEXT:    [[GEP_3:%.*]] = getelementptr i8, ptr [[ARG2]], i64 [[SHL_IV_4]]
+; CHECK-NEXT:    [[L_1:%.*]] = load float, ptr [[GEP_1]], align 4
+; CHECK-NEXT:    [[L_2:%.*]] = load float, ptr [[GEP_2]], align 4
+; CHECK-NEXT:    [[ADD_1:%.*]] = fadd float [[L_1]], [[L_2]]
+; CHECK-NEXT:    [[MUL_1:%.*]] = fmul float [[ADD_1]], 0.000000e+00
+; CHECK-NEXT:    store float [[MUL_1]], ptr [[GEP_3]], align 4
+; CHECK-NEXT:    [[GEP_4:%.*]] = getelementptr i8, ptr [[GEP_1]], i64 4
+; CHECK-NEXT:    [[L_3:%.*]] = load float, ptr [[GEP_4]], align 4
+; CHECK-NEXT:    [[GEP_5:%.*]] = getelementptr i8, ptr [[GEP_2]], i64 4
+; CHECK-NEXT:    [[L_4:%.*]] = load float, ptr [[GEP_5]], align 4
+; CHECK-NEXT:    [[ADD_2:%.*]] = fadd float [[L_3]], [[L_4]]
+; CHECK-NEXT:    [[MUL_2:%.*]] = fmul float [[ADD_2]], 0.000000e+00
+; CHECK-NEXT:    [[GEP_6:%.*]] = getelementptr i8, ptr [[GEP_3]], i64 4
+; CHECK-NEXT:    store float [[MUL_2]], ptr [[GEP_6]], align 4
+; CHECK-NEXT:    [[GEP_7:%.*]] = getelementptr i8, ptr [[GEP_1]], i64 8
+; CHECK-NEXT:    [[L_5:%.*]] = load float, ptr [[GEP_7]], align 4
+; CHECK-NEXT:    [[GEP_8:%.*]] = getelementptr i8, ptr [[GEP_2]], i64 8
+; CHECK-NEXT:    [[L_6:%.*]] = load float, ptr [[GEP_8]], align 4
+; CHECK-NEXT:    [[ADD_3:%.*]] = fadd float [[L_5]], [[L_6]]
+; CHECK-NEXT:    [[MUL_3:%.*]] = fmul float [[ADD_3]], 0.000000e+00
+; CHECK-NEXT:    [[GEP_9:%.*]] = getelementptr i8, ptr [[GEP_3]], i64 8
+; CHECK-NEXT:    store float [[MUL_3]], ptr [[GEP_9]], align 4
+; CHECK-NEXT:    [[I27:%.*]] = getelementptr i8, ptr [[GEP_1]], i64 12
+; CHECK-NEXT:    [[L_7:%.*]] = load float, ptr [[I27]], align 4
+; CHECK-NEXT:    [[GEP_10:%.*]] = getelementptr i8, ptr [[GEP_2]], i64 12
+; CHECK-NEXT:    [[L_8:%.*]] = load float, ptr [[GEP_10]], align 4
+; CHECK-NEXT:    [[ADD_4:%.*]] = fadd float [[L_7]], [[L_8]]
+; CHECK-NEXT:    [[MUL_4:%.*]] = fmul float [[ADD_4]], 0.000000e+00
+; CHECK-NEXT:    [[GEP_11:%.*]] = getelementptr i8, ptr [[GEP_3]], i64 12
+; CHECK-NEXT:    store float [[MUL_4]], ptr [[GEP_11]], align 4
+; CHECK-NEXT:    [[IV_NEXT]] = add i64 [[IV]], 1
+; CHECK-NEXT:    [[EC:%.*]] = icmp eq i64 [[IV]], [[ARG1]]
+; CHECK-NEXT:    br i1 [[EC]], label %[[EXIT]], label %[[LOOP]], !llvm.loop [[LOOP5:![0-9]+]]
+; CHECK:       [[EXIT]]:
+; CHECK-NEXT:    ret void
+;
+entry:
+  br label %loop
+
+loop:
+  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
+  %shl.iv.5 = shl i64 %iv, 5
+  %gep.1 = getelementptr i8, ptr %arg, i64 %shl.iv.5
+  %add.5 = or disjoint i64 %shl.iv.5, 16
+  %gep.2 = getelementptr i8, ptr %arg, i64 %add.5
+  %shl.iv.4 = shl i64 %iv, 4
+  %gep.3 = getelementptr i8, ptr %arg2, i64 %shl.iv.4
+  %l.1 = load float, ptr %gep.1, align 4
+  %l.2 = load float, ptr %gep.2, align 4
+  %add.1 = fadd float %l.1, %l.2
+  %mul.1 = fmul float %add.1, 0.000000e+00
+  store float %mul.1, ptr %gep.3, align 4
+  %gep.4 = getelementptr i8, ptr %gep.1, i64 4
+  %l.3 = load float, ptr %gep.4, align 4
+  %gep.5 = getelementptr i8, ptr %gep.2, i64 4
+  %l.4 = load float, ptr %gep.5, align 4
+  %add.2 = fadd float %l.3, %l.4
+  %mul.2 = fmul float %add.2, 0.000000e+00
+  %gep.6 = getelementptr i8, ptr %gep.3, i64 4
+  store float %mul.2, ptr %gep.6, align 4
+  %gep.7 = getelementptr i8, ptr %gep.1, i64 8
+  %l.5 = load float, ptr %gep.7, align 4
+  %gep.8 = getelementptr i8, ptr %gep.2, i64 8
+  %l.6 = load float, ptr %gep.8, align 4
+  %add.3 = fadd float %l.5, %l.6
+  %mul.3 = fmul float %add.3, 0.000000e+00
+  %gep.9 = getelementptr i8, ptr %gep.3, i64 8
+  store float %mul.3, ptr %gep.9, align 4
+  %i27 = getelementptr i8, ptr %gep.1, i64 12
+  %l.7 = load float, ptr %i27, align 4
+  %gep.10 = getelementptr i8, ptr %gep.2, i64 12
+  %l.8 = load float, ptr %gep.10, align 4
+  %add.4 = fadd float %l.7, %l.8
+  %mul.4 = fmul float %add.4, 0.000000e+00
+  %gep.11 = getelementptr i8, ptr %gep.3, i64 12
+  store float %mul.4, ptr %gep.11, align 4
+  %iv.next = add i64 %iv, 1
+  %ec = icmp eq i64 %iv, %arg1
+  br i1 %ec, label %exit, label %loop
+
+exit:
+  ret void
+}
+
+define void @geps_feeding_interleave_groups_with_reuse2(ptr %A, ptr %B, i64 %N) #1 {
+; CHECK-LABEL: define void @geps_feeding_interleave_groups_with_reuse2(
+; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i64 [[N:%.*]]) #[[ATTR1:[0-9]+]] {
+; CHECK-NEXT:  [[ENTRY:.*]]:
+; CHECK-NEXT:    [[TMP0:%.*]] = lshr i64 [[N]], 3
+; CHECK-NEXT:    [[TMP1:%.*]] = add nuw nsw i64 [[TMP0]], 1
+; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ule i64 [[TMP1]], 28
+; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_SCEVCHECK:.*]]
+; CHECK:       [[VECTOR_SCEVCHECK]]:
+; CHECK-NEXT:    [[TMP2:%.*]] = lshr i64 [[N]], 3
+; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[A]], i64 24
+; CHECK-NEXT:    [[MUL:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 32, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT:%.*]] = extractvalue { i64, i1 } [[MUL]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW:%.*]] = extractvalue { i64, i1 } [[MUL]], 1
+; CHECK-NEXT:    [[TMP3:%.*]] = sub i64 0, [[MUL_RESULT]]
+; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[SCEVGEP]], i64 [[MUL_RESULT]]
+; CHECK-NEXT:    [[TMP5:%.*]] = icmp ult ptr [[TMP4]], [[SCEVGEP]]
+; CHECK-NEXT:    [[TMP6:%.*]] = or i1 [[TMP5]], [[MUL_OVERFLOW]]
+; CHECK-NEXT:    [[SCEVGEP1:%.*]] = getelementptr i8, ptr [[A]], i64 28
+; CHECK-NEXT:    [[MUL2:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 32, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT3:%.*]] = extractvalue { i64, i1 } [[MUL2]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW4:%.*]] = extractvalue { i64, i1 } [[MUL2]], 1
+; CHECK-NEXT:    [[TMP7:%.*]] = sub i64 0, [[MUL_RESULT3]]
+; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[SCEVGEP1]], i64 [[MUL_RESULT3]]
+; CHECK-NEXT:    [[TMP9:%.*]] = icmp ult ptr [[TMP8]], [[SCEVGEP1]]
+; CHECK-NEXT:    [[TMP10:%.*]] = or i1 [[TMP9]], [[MUL_OVERFLOW4]]
+; CHECK-NEXT:    [[SCEVGEP5:%.*]] = getelementptr i8, ptr [[A]], i64 20
+; CHECK-NEXT:    [[MUL6:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 32, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT7:%.*]] = extractvalue { i64, i1 } [[MUL6]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW8:%.*]] = extractvalue { i64, i1 } [[MUL6]], 1
+; CHECK-NEXT:    [[TMP11:%.*]] = sub i64 0, [[MUL_RESULT7]]
+; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr [[SCEVGEP5]], i64 [[MUL_RESULT7]]
+; CHECK-NEXT:    [[TMP13:%.*]] = icmp ult ptr [[TMP12]], [[SCEVGEP5]]
+; CHECK-NEXT:    [[TMP14:%.*]] = or i1 [[TMP13]], [[MUL_OVERFLOW8]]
+; CHECK-NEXT:    [[SCEVGEP9:%.*]] = getelementptr i8, ptr [[A]], i64 16
+; CHECK-NEXT:    [[MUL10:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 32, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT11:%.*]] = extractvalue { i64, i1 } [[MUL10]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW12:%.*]] = extractvalue { i64, i1 } [[MUL10]], 1
+; CHECK-NEXT:    [[TMP15:%.*]] = sub i64 0, [[MUL_RESULT11]]
+; CHECK-NEXT:    [[TMP16:%.*]] = getelementptr i8, ptr [[SCEVGEP9]], i64 [[MUL_RESULT11]]
+; CHECK-NEXT:    [[TMP17:%.*]] = icmp ult ptr [[TMP16]], [[SCEVGEP9]]
+; CHECK-NEXT:    [[TMP18:%.*]] = or i1 [[TMP17]], [[MUL_OVERFLOW12]]
+; CHECK-NEXT:    [[SCEVGEP13:%.*]] = getelementptr i8, ptr [[A]], i64 12
+; CHECK-NEXT:    [[MUL14:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 32, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT15:%.*]] = extractvalue { i64, i1 } [[MUL14]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW16:%.*]] = extractvalue { i64, i1 } [[MUL14]], 1
+; CHECK-NEXT:    [[TMP19:%.*]] = sub i64 0, [[MUL_RESULT15]]
+; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr i8, ptr [[SCEVGEP13]], i64 [[MUL_RESULT15]]
+; CHECK-NEXT:    [[TMP21:%.*]] = icmp ult ptr [[TMP20]], [[SCEVGEP13]]
+; CHECK-NEXT:    [[TMP22:%.*]] = or i1 [[TMP21]], [[MUL_OVERFLOW16]]
+; CHECK-NEXT:    [[SCEVGEP17:%.*]] = getelementptr i8, ptr [[A]], i64 8
+; CHECK-NEXT:    [[MUL18:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 32, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT19:%.*]] = extractvalue { i64, i1 } [[MUL18]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW20:%.*]] = extractvalue { i64, i1 } [[MUL18]], 1
+; CHECK-NEXT:    [[TMP23:%.*]] = sub i64 0, [[MUL_RESULT19]]
+; CHECK-NEXT:    [[TMP24:%.*]] = getelementptr i8, ptr [[SCEVGEP17]], i64 [[MUL_RESULT19]]
+; CHECK-NEXT:    [[TMP25:%.*]] = icmp ult ptr [[TMP24]], [[SCEVGEP17]]
+; CHECK-NEXT:    [[TMP26:%.*]] = or i1 [[TMP25]], [[MUL_OVERFLOW20]]
+; CHECK-NEXT:    [[SCEVGEP21:%.*]] = getelementptr i8, ptr [[A]], i64 4
+; CHECK-NEXT:    [[MUL22:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 32, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT23:%.*]] = extractvalue { i64, i1 } [[MUL22]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW24:%.*]] = extractvalue { i64, i1 } [[MUL22]], 1
+; CHECK-NEXT:    [[TMP27:%.*]] = sub i64 0, [[MUL_RESULT23]]
+; CHECK-NEXT:    [[TMP28:%.*]] = getelementptr i8, ptr [[SCEVGEP21]], i64 [[MUL_RESULT23]]
+; CHECK-NEXT:    [[TMP29:%.*]] = icmp ult ptr [[TMP28]], [[SCEVGEP21]]
+; CHECK-NEXT:    [[TMP30:%.*]] = or i1 [[TMP29]], [[MUL_OVERFLOW24]]
+; CHECK-NEXT:    [[MUL25:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 32, i64 [[TMP2]])
+; CHECK-NEXT:    [[MUL_RESULT26:%.*]] = extractvalue { i64, i1 } [[MUL25]], 0
+; CHECK-NEXT:    [[MUL_OVERFLOW27:%.*]] = extractvalue { i64, i1 } [[MUL25]], 1
+; CHECK-NEXT:    [[TMP31:%.*]] = sub i64 0, [[MUL_RESULT26]]
+; CHECK-NEXT:    [[TMP32:%.*]] = getelementptr i8, ptr [[A]], i64 [[MUL_RESULT26]]
+; CHECK-NEXT:    [[TMP33:%.*]] = icmp ult ptr [[TMP32]], [[A]]
+; CHECK-NEXT:    [[TMP34:%.*]] = or i1 [[TMP33]], [[MUL_OVERFLOW27]]
+; CHECK-NEXT:    [[TMP35:%.*]] = or i1 [[TMP6]], [[TMP10]]
+; CHECK-NEXT:    [[TMP36:%.*]] = or i1 [[TMP35]], [[TMP14]]
+; CHECK-NEXT:    [[TMP37:%.*]] = or i1 [[TMP36]], [[TMP18]]
+; CHECK-NEXT:    [[TMP38:%.*]] = or i1 [[TMP37]], [[TMP22]]
+; CHECK-NEXT:    [[TMP39:%.*]] = or i1 [[TMP38]], [[TMP26]]
+; CHECK-NEXT:    [[TMP40:%.*]] = or i1 [[TMP39]], [[TMP30]]
+; CHECK-NEXT:    [[TMP41:%.*]] = or i1 [[TMP40]], [[TMP34]]
+; CHECK-NEXT:    br i1 [[TMP41]], label %[[SCALAR_PH]], label %[[VECTOR_MEMCHECK:.*]]
+; CHECK:       [[VECTOR_MEMCHECK]]:
+; CHECK-NEXT:    [[TMP42:%.*]] = lshr i64 [[N]], 3
+; CHECK-NEXT:    [[TMP43:%.*]] = shl i64 [[TMP42]], 5
+; CHECK-NEXT:    [[TMP44:%.*]] = add i64 [[TMP43]], 32
+; CHECK-NEXT:    [[SCEVGEP28:%.*]] = getelementptr i8, ptr [[A]], i64 [[TMP44]]
+; CHECK-NEXT:    [[TMP45:%.*]] = add nuw nsw i64 [[TMP43]], 4
+; CHECK-NEXT:    [[SCEVGEP29:%.*]] = getelementptr i8, ptr [[B]], i64 [[TMP45]]
+; CHECK-NEXT:    [[TMP46:%.*]] = shl i64 [[TMP42]], 4
+; CHECK-NEXT:    [[TMP47:%.*]] = add nuw nsw i64 [[TMP46]], 8
+; CHECK-NEXT:    [[SCEVGEP30:%.*]] = getelementptr i8, ptr [[B]], i64 [[TMP47]]
+; CHECK-NEXT:    [[BOUND0:%.*]] = icmp ult ptr [[A]], [[SCEVGEP29]]
+; CHECK-NEXT:    [[BOUND1:%.*]] = icmp ult ptr [[B]], [[SCEVGEP28]]
+; CHECK-NEXT:    [[FOUND_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]]
+; CHECK-NEXT:    [[BOUND031:%.*]] = icmp ult ptr [[A]], [[SCEVGEP30]]
+; CHECK-NEXT:    [[BOUND132:%.*]] = icmp ult ptr [[B]], [[SCEVGEP28]]
+; CHECK-NEXT:    [[FOUND_CONFLICT33:%.*]] = and i1 [[BOUND031]], [[BOUND132]]
+; CHECK-NEXT:    [[CONFLICT_RDX:%.*]] = or i1 [[FOUND_CONFLICT]], [[FOUND_CONFLICT33]]
+; CHECK-NEXT:    br i1 [[CONFLICT_RDX]], label %[[SCALAR_PH]], label %[[VECTOR_PH:.*]]
+; CHECK:       [[VECTOR_PH]]:
+; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[TMP1]], 4
+; CHECK-NEXT:    [[TMP48:%.*]] = icmp eq i64 [[N_MOD_VF]], 0
+; CHECK-NEXT:    [[TMP49:%.*]] = select i1 [[TMP48]], i64 4, i64 [[N_MOD_VF]]
+; CHECK-NEXT:    [[N_VEC:%.*]] = sub i64 [[TMP1]], [[TMP49]]
+; CHECK-NEXT:    [[IND_END:%.*]] = mul i64 [[N_VEC]], 8
+; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
+; CHECK:       [[VECTOR_BODY]]:
+; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
+; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <4 x i64> [ <i64 0, i64 8, i64 16, i64 24>, %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[VECTOR_BODY]] ]
+; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i64 [[INDEX]], 8
+; CHECK-NEXT:    [[TMP50:%.*]] = add i64 [[OFFSET_IDX]], 0
+; CHECK-NEXT:    [[TMP51:%.*]] = lshr exact i64 [[TMP50]], 1
+; CHECK-NEXT:    [[TMP52:%.*]] = getelementptr i32, ptr [[B]], i64 [[TMP51]]
+; CHECK-NEXT:    [[TMP53:%.*]] = getelementptr i32, ptr [[TMP52]], i32 0
+; CHECK-NEXT:    [[WIDE_VEC:%.*]] = load <16 x i32>, ptr [[TMP53]], align 4
+; CHECK-NEXT:    [[STRIDED_VEC:%.*]] = shufflevector <16 x i32> [[WIDE_VEC]], <16 x i32> poison, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
+; CHECK-NEXT:    [[STRIDED_VEC34:%.*]] = shufflevector <16 x i32> [[WIDE_VEC]], <16 x i32> poison, <4 x i32> <i32 1, i32 5, i32 9, i32 13>
+; CHECK-NEXT:    [[TMP54:%.*]] = getelementptr i32, ptr [[B]], <4 x i64> [[VEC_IND]]
+; CHECK-NEXT:    [[WIDE_MASKED_GATHER:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP54]], i32 4, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> poison), !alias.scope [[META6:![0-9]+]]
+; CHECK-NEXT:    [[TMP55:%.*]] = or disjoint i64 [[TMP50]], 7
+; CHECK-NEXT:    [[TMP56:%.*]] = getelementptr i32, ptr [[A]], i64 [[TMP55]]
+; CHECK-NEXT:    [[TMP57:%.*]] = getelementptr i32, ptr [[TMP56]], i32 -7
+; CHECK-NEXT:    [[TMP58:%.*]] = shufflevector <4 x i32> [[STRIDED_VEC]], <4 x i32> zeroinitializer, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
+; CHECK-NEXT:    [[TMP59:%.*]] = shufflevector <4 x i32> [[STRIDED_VEC34]], <4 x i32> zeroinitializer, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
+; CHECK-NEXT:    [[TMP60:%.*]] = shufflevector <4 x i32> [[WIDE_MASKED_GATHER]], <4 x i32> zeroinitializer, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
+; CHECK-NEXT:    [[TMP61:%.*]] = shufflevector <8 x i32> [[TMP58]], <8 x i32> [[TMP59]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
+; CHECK-NEXT:    [[TMP62:%.*]] = shufflevector <8 x i32> [[TMP60]], <8 x i32> zeroinitializer, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
+; CHECK-NEXT:    [[TMP63:%.*]] = shufflevector <16 x i32> [[TMP61]], <16 x i32> [[TMP62]], <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>
+; CHECK-NEXT:    [[INTERLEAVED_VEC:%.*]] = shufflevector <32 x i32> [[TMP63]], <32 x i32> poison, <32 x i32> <i32 0, i32 4, i32 8, i32 12, i32 16, i32 20, i32 24, i32 28, i32 1, i32 5, i32 9, i32 13, i32 17, i32 21, i32 25, i32 29, i32 2, i32 6, i32 10, i32 14, i32 18, i32 22, i32 26, i32 30, i32 3, i32 7, i32 11, i32 15, i32 19, i32 23, i32 27, i32 31>
+; CHECK-NEXT:    store <32 x i32> [[INTERLEAVED_VEC]], ptr [[TMP57]], align 4
+; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4
+; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <4 x i64> [[VEC_IND]], <i64 32, i64 32, i64 32, i64 32>
+; CHECK-NEXT:    [[TMP64:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
+; CHECK-NEXT:    br i1 [[TMP64]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP9:![0-9]+]]
+; CHECK:       [[MIDDLE_BLOCK]]:
+; CHECK-NEXT:    br label %[[SCALAR_PH]]
+; CHECK:       [[SCALAR_PH]]:
+; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[IND_END]], %[[MIDDLE_BLOCK]] ], [ 0, %[[ENTRY]] ], [ 0, %[[VECTOR_SCEVCHECK]] ], [ 0, %[[VECTOR_MEMCHECK]] ]
+; CHECK-NEXT:    br label %[[LOOP:.*]]
+; CHECK:       [[LOOP]]:
+; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ], [ [[IV_NEXT_7:%.*]], %[[LOOP]] ]
+; CHECK-NEXT:    [[SHR_1:%.*]] = lshr exact i64 [[IV]], 1
+; CHECK-NEXT:    [[GEP_B:%.*]] = getelementptr nusw i32, ptr [[B]], i64 [[SHR_1]]
+; CHECK-NEXT:    [[L:%.*]] = load i32, ptr [[GEP_B]], align 4
+; CHECK-NEXT:    [[GEP_A:%.*]] = getelementptr i32, ptr [[A]], i64 [[IV]]
+; CHECK-NEXT:    store i32 [[L]], ptr [[GEP_A]], align 4
+; CHECK-NEXT:    [[IV_NEXT:%.*]] = or disjoint i64 [[IV]], 1
+; CHECK-NEXT:    [[GEP_A_1:%.*]] = getelementptr i32, ptr [[A]], i64 [[IV_NEXT]]
+; CHECK-NEXT:    store i32 0, ptr [[GEP_A_1]], align 4
+; CHECK-NEXT:    [[IV_NEXT_1:%.*]] = or disjoint i64 [[IV]], 2
+; CHECK-NEXT:    [[SHR_2:%.*]] = lshr exact i64 [[IV_NEXT_1]], 1
+; CHECK-NEXT:    [[GEP_B_2:%.*]] = getelementptr i32, ptr [[B]], i64 [[SHR_2]]
+; CHECK-NEXT:    [[TMP65:%.*]] = load i32, ptr [[GEP_B_2]], align 4
+; CHECK-NEXT:    [[GEP_A_2:%.*]] = getelementptr i32, ptr [[A]], i64 [[IV_NEXT_1]]
+; CHECK-NEXT:    store i32 [[TMP65]], ptr [[GEP_A_2]], align 4
+; CHECK-NEXT:    [[IV_NEXT_2:%.*]] = or disjoint i64 [[IV]], 3
+; CHECK-NEXT:    [[GEP_A_3:%.*]] = getelementptr i32, ptr [[A]], i64 [[IV_NEXT_2]]
+; CHECK-NEXT:    store i32 0, ptr [[GEP_A_3]], align 4
+; CHECK-NEXT:    [[IV_NEXT_3:%.*]] = or disjoint i64 [[IV]], 4
+; CHECK-NEXT:    [[GEP_B_4:%.*]] = getelementptr i32, ptr [[B]], i64 [[IV]]
+; CHECK-NEXT:    [[TMP66:%.*]] = load i32, ptr [[GEP_B_4]], align 4
+; CHECK-NEXT:    [[GEP_A_4:%.*]] = getelementptr i32, ptr [[A]], i64 [[IV_NEXT_3]]
+; CHECK-NEXT:    store i32 [[TMP66]], ptr [[GEP_A_4]], align 4
+; CHECK-NEXT:    [[IV_NEXT_4:%.*]] = or disjoint i64 [[IV]], 5
+; CHECK-NEXT:    [[GEP_A_5:%.*]] = getelementptr i32, ptr [[A]], i64 [[IV_NEXT_4]]
+; CHECK-NEXT:    store i32 0, ptr [[GEP_A_5]], align 4
+; CHECK-NEXT:    [[IV_NEXT_5:%.*]] = or disjoint i64 [[IV]], 6
+; CHECK-NEXT:    [[GEP_A_6:%.*]] = getelementptr i32, ptr [[A]], i64 [[IV_NEXT_5]]
+; CHECK-NEXT:    store i32 0, ptr [[GEP_A_6]], align 4
+; CHECK-NEXT:    [[IV_NEXT_6:%.*]] = or disjoint i64 [[IV]], 7
+; CHECK-NEXT:    [[GEP_A_7:%.*]] = getelementptr i32, ptr [[A]], i64 [[IV_NEXT_6]]
+; CHECK-NEXT:    store i32 0, ptr [[GEP_A_7]], align 4
+; CHECK-NEXT:    [[IV_NEXT_7]] = add nuw nsw i64 [[IV]], 8
+; CHECK-NEXT:    [[EC:%.*]] = icmp eq i64 [[IV]], [[N]]
+; CHECK-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP]], !llvm.loop [[LOOP10:![0-9]+]]
+; CHECK:       [[EXIT]]:
+; CHECK-NEXT:    ret void
+;
+entry:
+  br label %loop
+
+loop:
+  %iv = phi i64 [ 0, %entry ], [ %iv.next.7, %loop ]
+  %shr.1 = lshr exact i64 %iv, 1
+  %gep.B = getelementptr nusw i32, ptr %B, i64 %shr.1
+  %l = load i32, ptr %gep.B, align 4
+  %gep.A = getelementptr i32, ptr %A, i64 %iv
+  store i32 %l, ptr %gep.A, align 4
+  %iv.next = or disjoint i64 %iv, 1
+  %gep.A.1 = getelementptr i32, ptr %A, i64 %iv.next
+  store i32 0, ptr %gep.A.1, align 4
+  %iv.next.1 = or disjoint i64 %iv, 2
+  %shr.2 = lshr exact i64 %iv.next.1, 1
+  %gep.B.2 = getelementptr i32, ptr %B, i64 %shr.2
+  %1 = load i32, ptr %gep.B.2, align 4
+  %gep.A.2 = getelementptr i32, ptr %A, i64 %iv.next.1
+  store i32 %1, ptr %gep.A.2, align 4
+  %iv.next.2 = or disjoint i64 %iv, 3
+  %gep.A.3 = getelementptr i32, ptr %A, i64 %iv.next.2
+  store i32 0, ptr %gep.A.3, align 4
+  %iv.next.3 = or disjoint i64 %iv, 4
+  %gep.B.4 = getelementptr i32, ptr %B, i64 %iv
+  %2 = load i32, ptr %gep.B.4, align 4
+  %gep.A.4 = getelementptr i32, ptr %A, i64 %iv.next.3
+  store i32 %2, ptr %gep.A.4, align 4
+  %iv.next.4 = or disjoint i64 %iv, 5
+  %gep.A.5 = getelementptr i32, ptr %A, i64 %iv.next.4
+  store i32 0, ptr %gep.A.5, align 4
+  %iv.next.5 = or disjoint i64 %iv, 6
+  %gep.A.6 = getelementptr i32, ptr %A, i64 %iv.next.5
+  store i32 0, ptr %gep.A.6, align 4
+  %iv.next.6 = or disjoint i64 %iv, 7
+  %gep.A.7 = getelementptr i32, ptr %A, i64 %iv.next.6
+  store i32 0, ptr %gep.A.7, align 4
+  %iv.next.7 = add nuw nsw i64 %iv, 8
+  %ec = icmp eq i64 %iv, %N
+  br i1 %ec, label %exit, label %loop
+
+exit:
+  ret void
+}
+
+attributes #0 = { "target-features"="+sse4.2" }
+attributes #1 = { "min-legal-vector-width"="0" "target-cpu"="cascadelake" }
+
 ;.
 ; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
 ; CHECK: [[META1]] = !{!"llvm.loop.isvectorized", i32 1}
 ; CHECK: [[META2]] = !{!"llvm.loop.unroll.runtime.disable"}
 ; CHECK: [[LOOP3]] = distinct !{[[LOOP3]], [[META1]]}
+; CHECK: [[LOOP4]] = distinct !{[[LOOP4]], [[META1]], [[META2]]}
+; CHECK: [[LOOP5]] = distinct !{[[LOOP5]], [[META1]]}
+; CHECK: [[META6]] = !{[[META7:![0-9]+]]}
+; CHECK: [[META7]] = distinct !{[[META7]], [[META8:![0-9]+]]}
+; CHECK: [[META8]] = distinct !{[[META8]], !"LVerDomain"}
+; CHECK: [[LOOP9]] = distinct !{[[LOOP9]], [[META1]], [[META2]]}
+; CHECK: [[LOOP10]] = distinct !{[[LOOP10]], [[META1]]}
 ;.
diff -ruN --strip-trailing-cr a/llvm/utils/gn/secondary/clang/lib/Basic/BUILD.gn b/llvm/utils/gn/secondary/clang/lib/Basic/BUILD.gn
--- a/llvm/utils/gn/secondary/clang/lib/Basic/BUILD.gn
+++ b/llvm/utils/gn/secondary/clang/lib/Basic/BUILD.gn
@@ -108,6 +108,7 @@
     "Targets/DirectX.cpp",
     "Targets/Hexagon.cpp",
     "Targets/Lanai.cpp",
+    "Targets/Le64.cpp",
     "Targets/LoongArch.cpp",
     "Targets/M68k.cpp",
     "Targets/MSP430.cpp",
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
@@ -254,6 +254,7 @@
     hdrs = ["src/__support/macros/optimization.h"],
     deps = [
         ":__support_macros_attributes",
+        ":__support_macros_config",
         ":__support_macros_properties_compiler",
     ],
 )
@@ -261,6 +262,9 @@
 libc_support_library(
     name = "__support_macros_sanitizer",
     hdrs = ["src/__support/macros/sanitizer.h"],
+    deps = [
+        ":__support_macros_config",
+    ],
 )
 
 libc_support_library(
@@ -271,6 +275,7 @@
     ],
     deps = [
         ":__support_macros_attributes",
+        ":__support_macros_config",
         ":__support_macros_properties_architectures",
     ],
 )
@@ -280,6 +285,7 @@
     hdrs = ["src/__support/CPP/algorithm.h"],
     deps = [
         ":__support_macros_attributes",
+        ":__support_macros_config",
     ],
 )
 
@@ -317,6 +323,7 @@
     hdrs = ["src/__support/CPP/bitset.h"],
     deps = [
         ":__support_macros_attributes",
+        ":__support_macros_config",
     ],
 )
 
@@ -334,6 +341,7 @@
     hdrs = ["src/__support/CPP/expected.h"],
     deps = [
         ":__support_macros_attributes",
+        ":__support_macros_config",
     ],
 )
 
@@ -424,6 +432,7 @@
     ],
     deps = [
         ":__support_macros_attributes",
+        ":__support_macros_config",
         ":__support_macros_properties_types",
         ":llvm_libc_macros_stdfix_macros",
     ],
@@ -573,7 +582,10 @@
 libc_support_library(
     name = "__support_str_to_num_result",
     hdrs = ["src/__support/str_to_num_result.h"],
-    deps = [":__support_macros_attributes"],
+    deps = [
+        ":__support_macros_attributes",
+        ":__support_macros_config",
+    ],
 )
 
 libc_support_library(
@@ -612,7 +624,10 @@
 libc_support_library(
     name = "__support_ctype_utils",
     hdrs = ["src/__support/ctype_utils.h"],
-    deps = [":__support_macros_attributes"],
+    deps = [
+        ":__support_macros_attributes",
+        ":__support_macros_config",
+    ],
 )
 
 libc_support_library(
@@ -785,6 +800,7 @@
     hdrs = ["src/__support/FPUtil/rounding_mode.h"],
     deps = [
         ":__support_macros_attributes",
+        ":__support_macros_config",
         ":hdr_fenv_macros",
     ],
 )
@@ -1126,6 +1142,7 @@
     hdrs = ["src/__support/threads/sleep.h"],
     deps = [
         ":__support_macros_attributes",
+        ":__support_macros_config",
     ],
 )
 
@@ -3408,9 +3425,9 @@
         ":__support_arg_list",
         ":__support_file_file",
         ":__support_macros_attributes",
-        ":types_FILE",
         ":printf_main",
         ":printf_writer",
+        ":types_FILE",
     ],
 )
 
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/libc_build_rules.bzl b/utils/bazel/llvm-project-overlay/libc/libc_build_rules.bzl
--- a/utils/bazel/llvm-project-overlay/libc/libc_build_rules.bzl
+++ b/utils/bazel/llvm-project-overlay/libc/libc_build_rules.bzl
@@ -43,7 +43,7 @@
         name = name,
         copts = copts + libc_common_copts(),
         local_defines = local_defines + LIBC_CONFIGURE_OPTIONS,
-        deps = deps + ["//libc:__support_macros_config"],
+        deps = deps,
         linkstatic = 1,
         **kwargs
     )
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/test/src/math/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/test/src/math/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/test/src/math/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/test/src/math/BUILD.bazel
@@ -298,8 +298,8 @@
         "//libc:__support_fputil_fp_bits",
         "//libc:__support_fputil_manipulation_functions",
         "//libc:hdr_math_macros",
-        "//libc/test/UnitTest:fp_test_helpers",
         "//libc/test/UnitTest:LibcUnitTest",
+        "//libc/test/UnitTest:fp_test_helpers",
     ],
 )
 
@@ -559,7 +559,10 @@
 libc_support_library(
     name = "sdcomp26094",
     hdrs = ["sdcomp26094.h"],
-    deps = ["//libc:__support_cpp_array"],
+    deps = [
+        "//libc:__support_cpp_array",
+        "//libc:__support_macros_config",
+    ],
 )
 
 math_test(
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/test/src/string/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/test/src/string/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/test/src/string/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/test/src/string/BUILD.bazel
@@ -121,6 +121,7 @@
     deps = [
         "//libc:__support_cpp_span",
         "//libc:__support_libc_assert",
+        "//libc:__support_macros_config",
         "//libc:__support_macros_sanitizer",
         "//libc:string_memory_utils",
     ],
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/test/UnitTest/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/test/UnitTest/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/test/UnitTest/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/test/UnitTest/BUILD.bazel
@@ -18,6 +18,7 @@
         "//libc:__support_big_int",
         "//libc:__support_cpp_string",
         "//libc:__support_cpp_string_view",
+        "//libc:__support_macros_config",
         "//libc:__support_macros_properties_types",
         "//libc:__support_osutil_io",
         "//libc:__support_uint128",
@@ -52,6 +53,7 @@
         "//libc:__support_fputil_fp_bits",
         "//libc:__support_fputil_fpbits_str",
         "//libc:__support_fputil_rounding_mode",
+        "//libc:__support_macros_config",
         "//libc:__support_macros_properties_architectures",
         "//libc:__support_macros_properties_types",
         "//libc:__support_stringutil",
@@ -89,10 +91,11 @@
         "//libc:__support_fputil_fp_bits",
         "//libc:__support_fputil_fpbits_str",
         "//libc:__support_fputil_rounding_mode",
+        "//libc:__support_macros_config",
         "//libc:__support_macros_properties_architectures",
+        "//libc:hdr_fenv_macros",
         "//libc:hdr_math_macros",
-	    "//libc:hdr_fenv_macros",
-	    "//libc:types_fenv_t",
+        "//libc:types_fenv_t",
     ],
 )
 
@@ -110,6 +113,7 @@
         "//libc:__support_cpp_bitset",
         "//libc:__support_cpp_span",
         "//libc:__support_cpp_type_traits",
+        "//libc:__support_macros_config",
     ],
 )
 
@@ -125,6 +129,7 @@
         ":LibcUnitTest",
         ":string_utils",
         "//libc:__support_fputil_fp_bits",
+        "//libc:__support_macros_config",
         "//libc:printf_core_structs",
     ],
 )
@@ -138,5 +143,6 @@
         "//libc:__support_big_int",
         "//libc:__support_cpp_string",
         "//libc:__support_cpp_type_traits",
+        "//libc:__support_macros_config",
     ],
 )
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/utils/MPFRWrapper/BUILD.bazel
@@ -48,6 +48,7 @@
         "//libc:__support_cpp_type_traits",
         "//libc:__support_fputil_fp_bits",
         "//libc:__support_fputil_fpbits_str",
+        "//libc:__support_macros_config",
         "//libc:__support_macros_properties_types",
         "//libc:hdr_math_macros",
         "//libc/test/UnitTest:LibcUnitTest",
