Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaExpr.cpp b/clang/lib/Sema/SemaExpr.cpp
--- a/clang/lib/Sema/SemaExpr.cpp
+++ b/clang/lib/Sema/SemaExpr.cpp
@@ -9966,8 +9966,13 @@
       // If there is a conversion of some kind, check to see what kind of
       // pointer conversion happened so we can diagnose a C++ compatibility
       // diagnostic if the conversion is invalid. This only matters if the RHS
-      // is some kind of void pointer.
-      if (Kind != CK_NoOp && !getLangOpts().CPlusPlus) {
+      // is some kind of void pointer. We have a carve-out when the RHS is from
+      // a macro expansion because the use of a macro may indicate different
+      // code between C and C++. Consider: char *s = NULL; where NULL is
+      // defined as (void *)0 in C (which would be invalid in C++), but 0 in
+      // C++, which is valid in C++.
+      if (Kind != CK_NoOp && !getLangOpts().CPlusPlus &&
+          !RHS.get()->getBeginLoc().isMacroID()) {
         QualType CanRHS =
             RHS.get()->getType().getCanonicalType().getUnqualifiedType();
         QualType CanLHS = LHSType.getCanonicalType().getUnqualifiedType();
diff -ruN --strip-trailing-cr a/clang/test/Sema/implicit-void-ptr-cast.c b/clang/test/Sema/implicit-void-ptr-cast.c
--- a/clang/test/Sema/implicit-void-ptr-cast.c
+++ b/clang/test/Sema/implicit-void-ptr-cast.c
@@ -59,4 +59,26 @@
   b3 = (char *)0;
   b3 = nullptr;
   b3 = 0;
+
+  // Note that we explicitly silence the diagnostic if the RHS is from a macro
+  // expansion. This allows for things like NULL expanding to different token
+  // sequences depending on language mode, but applies to any macro that
+  // expands to a valid null pointer constant.
+#if defined(__cplusplus)
+  #define NULL 0
+#else
+  #define NULL ((void *)0)
+#endif
+  #define SOMETHING_NOT_SPELLED_NULL nullptr
+  #define SOMETHING_THAT_IS_NOT_NULL (void *)12
+
+  char *ptr1 = NULL; // Ok
+  char *ptr2 = SOMETHING_NOT_SPELLED_NULL; // Ok
+  char *ptr3 = SOMETHING_THAT_IS_NOT_NULL; // c-warning {{implicit conversion when initializing 'char *' with an expression of type 'void *' is not permitted in C++}} \
+                                              cxx-error {{cannot initialize a variable of type 'char *' with an rvalue of type 'void *'}}
+
+  ptr1 = NULL; // Ok
+  ptr2 = SOMETHING_NOT_SPELLED_NULL; // Ok
+  ptr3 = SOMETHING_THAT_IS_NOT_NULL; // c-warning {{implicit conversion when assigning to 'char *' from type 'void *' is not permitted in C++}} \
+                                        cxx-error {{assigning to 'char *' from incompatible type 'void *'}}
 }
