Auto generated patch. Do not edit or delete it, even if empty.
<<<<<<< HEAD
diff -ruN --strip-trailing-cr a/lld/ELF/Config.h b/lld/ELF/Config.h
--- a/lld/ELF/Config.h
+++ b/lld/ELF/Config.h
@@ -619,7 +619,6 @@
   };
   ElfSym sym{};
   std::unique_ptr<SymbolTable> symtab;
-  SmallVector<Symbol *, 0> synthesizedSymbols;
 
   SmallVector<std::unique_ptr<MemoryBuffer>> memoryBuffers;
   SmallVector<ELFFileBase *, 0> objectFiles;
diff -ruN --strip-trailing-cr a/lld/ELF/Writer.cpp b/lld/ELF/Writer.cpp
--- a/lld/ELF/Writer.cpp
+++ b/lld/ELF/Writer.cpp
@@ -149,7 +149,6 @@
   if (!s || s->isDefined() || s->isCommon())
     return nullptr;
 
-  ctx.synthesizedSymbols.push_back(s);
   s->resolve(ctx, Defined{ctx, ctx.internalFile, StringRef(), STB_GLOBAL,
                           stOther, STT_NOTYPE, val,
                           /*size=*/0, sec});
@@ -283,7 +282,6 @@
 static void demoteSymbolsAndComputeIsPreemptible(Ctx &ctx) {
   llvm::TimeTraceScope timeScope("Demote symbols");
   DenseMap<InputFile *, DenseMap<SectionBase *, size_t>> sectionIndexMap;
-  bool hasDynSymTab = ctx.arg.hasDynSymTab;
   for (Symbol *sym : ctx.symtab->getSymbols()) {
     if (auto *d = dyn_cast<Defined>(sym)) {
       if (d->section && !d->section->isLive())
@@ -296,12 +294,11 @@
                   sym->type)
             .overwrite(*sym);
         sym->versionId = VER_NDX_GLOBAL;
-        if (sym->includeInDynsym(ctx))
-          sym->isExported = true;
       }
     }
 
-    if (hasDynSymTab)
+    sym->isExported = sym->includeInDynsym(ctx);
+    if (ctx.arg.hasDynSymTab)
       sym->isPreemptible = sym->isExported && computeIsPreemptible(ctx, *sym);
   }
 }
@@ -1839,11 +1836,6 @@
     }
   }
 
-  // If the previous code block defines any non-hidden symbols (e.g.
-  // __global_pointer$), they may be exported.
-  for (Symbol *sym : ctx.synthesizedSymbols)
-    sym->isExported = sym->includeInDynsym(ctx);
-
   demoteSymbolsAndComputeIsPreemptible(ctx);
 
   if (ctx.arg.copyRelocs && ctx.arg.discard != DiscardPolicy::None)
=======
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/BuiltinsX86.td b/clang/include/clang/Basic/BuiltinsX86.td
--- a/clang/include/clang/Basic/BuiltinsX86.td
+++ b/clang/include/clang/Basic/BuiltinsX86.td
@@ -130,10 +130,6 @@
   }
 }
 
-let Features = "sse", Header = "xmmintrin.h", Attributes = [NoThrow, Const] in {
-  def _mm_prefetch : X86LibBuiltin<"void(void const *, int)">;
-}
-
 // AVX
 let Attributes = [Const, NoThrow, RequiredVectorWidth<256>], Features = "avx" in {
   foreach Op = ["addsub", "hadd", "hsub", "max", "min"] in {
@@ -142,12 +138,6 @@
   }
 }
 
-// PRFCHW
-let Features = "prfchw", Header = "intrin.h", Attributes = [NoThrow, Const] in {
-  def _m_prefetch : X86LibBuiltin<"void(void *)">;
-  def _m_prefetchw : X86LibBuiltin<"void(void volatile const *)">;
-}
-
 
 // Mechanically ported builtins from the original `.def` file.
 //
@@ -156,6 +146,10 @@
 // current formulation is based on what was easiest to recognize from the
 // pre-TableGen version.
 
+let Features = "mmx", Attributes = [NoThrow, Const] in {
+  def _mm_prefetch : X86NoPrefixBuiltin<"void(char const *, int)">;
+}
+
 let Features = "sse", Attributes = [NoThrow] in {
   def ldmxcsr : X86Builtin<"void(unsigned int)">;
 }
diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CGBuiltin.cpp b/clang/lib/CodeGen/CGBuiltin.cpp
--- a/clang/lib/CodeGen/CGBuiltin.cpp
+++ b/clang/lib/CodeGen/CGBuiltin.cpp
@@ -15374,17 +15374,6 @@
     Function *F = CGM.getIntrinsic(Intrinsic::prefetch, Address->getType());
     return Builder.CreateCall(F, {Address, RW, Locality, Data});
   }
-  case X86::BI_m_prefetch:
-  case X86::BI_m_prefetchw: {
-    Value *Address = Ops[0];
-    // The 'w' suffix implies write.
-    Value *RW =
-        ConstantInt::get(Int32Ty, BuiltinID == X86::BI_m_prefetchw ? 1 : 0);
-    Value *Locality = ConstantInt::get(Int32Ty, 0x3);
-    Value *Data = ConstantInt::get(Int32Ty, 1);
-    Function *F = CGM.getIntrinsic(Intrinsic::prefetch, Address->getType());
-    return Builder.CreateCall(F, {Address, RW, Locality, Data});
-  }
   case X86::BI_mm_clflush: {
     return Builder.CreateCall(CGM.getIntrinsic(Intrinsic::x86_sse2_clflush),
                               Ops[0]);
diff -ruN --strip-trailing-cr a/clang/lib/Headers/prfchwintrin.h b/clang/lib/Headers/prfchwintrin.h
--- a/clang/lib/Headers/prfchwintrin.h
+++ b/clang/lib/Headers/prfchwintrin.h
@@ -14,10 +14,6 @@
 #ifndef __PRFCHWINTRIN_H
 #define __PRFCHWINTRIN_H
 
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
 /// Loads a memory sequence containing the specified memory address into
 ///    all data cache levels.
 ///
@@ -30,7 +26,11 @@
 ///
 /// \param __P
 ///    A pointer specifying the memory address to be prefetched.
-void _m_prefetch(void *__P);
+static __inline__ void __attribute__((__always_inline__, __nodebug__))
+_m_prefetch(void *__P)
+{
+  __builtin_prefetch (__P, 0, 3 /* _MM_HINT_T0 */);
+}
 
 /// Loads a memory sequence containing the specified memory address into
 ///    the L1 data cache and sets the cache-coherency state to modified.
@@ -48,10 +48,13 @@
 ///
 /// \param __P
 ///    A pointer specifying the memory address to be prefetched.
-void _m_prefetchw(volatile const void *__P);
-
-#if defined(__cplusplus)
-} // extern "C"
-#endif
+static __inline__ void __attribute__((__always_inline__, __nodebug__))
+_m_prefetchw(volatile const void *__P)
+{
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wcast-qual"
+  __builtin_prefetch ((const void*)__P, 1, 3 /* _MM_HINT_T0 */);
+#pragma clang diagnostic pop
+}
 
 #endif /* __PRFCHWINTRIN_H */
diff -ruN --strip-trailing-cr a/clang/lib/Headers/xmmintrin.h b/clang/lib/Headers/xmmintrin.h
--- a/clang/lib/Headers/xmmintrin.h
+++ b/clang/lib/Headers/xmmintrin.h
@@ -2197,7 +2197,10 @@
 #define _MM_HINT_T2  1
 #define _MM_HINT_NTA 0
 
-#if 0
+#ifndef _MSC_VER
+/* FIXME: We have to #define this because "sel" must be a constant integer, and
+   Sema doesn't do any form of constant propagation yet. */
+
 /// Loads one cache line of data from the specified address to a location
 ///    closer to the processor.
 ///
@@ -2222,10 +2225,6 @@
 ///    be generated. \n
 ///    _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will
 ///    be generated.
-///
-/// _mm_prefetch is implemented as a "library builtin" directly in Clang,
-/// similar to how it is done in MSVC. Clang will warn if the user doesn't
-/// include xmmintrin.h or immintrin.h.
 #define _mm_prefetch(a, sel) (__builtin_prefetch((const void *)(a), \
                                                  ((sel) >> 2) & 1, (sel) & 0x3))
 #endif
>>>>>>> upstream/r2.19
