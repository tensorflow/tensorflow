#!/usr/bin/env bash

DO_NOT_SUBMIT_WARNING="Unofficial setting. DO NOT SUBMIT!!!"

## Verify that the submodule google/protobuf is available
# TODO(cais): Remove this check once protobuf is no longer depended upon
if [[ ! -f "google/protobuf/protobuf.bzl" ]]; then
  echo "ERROR: It appears that the required submodule google/protobuf is not "\
"available in this TensorFlow git clone."
  echo "Please be sure to use the --recurse-submodules flag when performing "\
"git clone of TensorFlow."

  exit 1
fi

## Set up python-related environment settings
while true; do
  fromuser=""
  if [ -z "$PYTHON_BIN_PATH" ]; then
    default_python_bin_path=$(which python)
    read -p "Please specify the location of python. [Default is $default_python_bin_path]: " PYTHON_BIN_PATH
    fromuser="1"
    if [ -z "$PYTHON_BIN_PATH" ]; then
      PYTHON_BIN_PATH=$default_python_bin_path
    fi
  fi
  if [ -e "$PYTHON_BIN_PATH" ]; then
    break
  fi
  echo "Invalid python path. ${PYTHON_BIN_PATH} cannot be found" 1>&2
  if [ -z "$fromuser" ]; then
    exit 1
  fi
  PYTHON_BIN_PATH=""
  # Retry
done

while [ "$TF_NEED_GCP" == "" ]; do
  read -p "Do you wish to build TensorFlow with "\
"Google Cloud Platform support? [y/N] " INPUT
  case $INPUT in
    [Yy]* ) echo "Google Cloud Platform support will be enabled for "\
"TensorFlow"; TF_NEED_GCP=1;;
    [Nn]* ) echo "No Google Cloud Platform support will be enabled for "\
"TensorFlow"; TF_NEED_GCP=0;;
    "" ) echo "No Google Cloud Platform support will be enabled for "\
"TensorFlow"; TF_NEED_GCP=0;;
    * ) echo "Invalid selection: " $INPUT;;
  esac
done

if [ "$TF_NEED_GCP" == "1" ]; then

  ## Verify that libcurl header files are available.
  # Only check Linux, since on MacOS the header files are installed with XCode.
  if [[ $(uname -a) =~ Linux ]] && [[ ! -f "/usr/include/curl/curl.h" ]]; then
    echo "ERROR: It appears that the development version of libcurl is not "\
"available. Please install the libcurl3-dev package."
    exit 1
  fi

  # Update Bazel build configuration.
  perl -pi -e "s,WITH_GCP_SUPPORT = (False|True),WITH_GCP_SUPPORT = True,s" tensorflow/core/platform/default/build_config.bzl
else
  # Update Bazel build configuration.
  perl -pi -e "s,WITH_GCP_SUPPORT = (False|True),WITH_GCP_SUPPORT = False,s" tensorflow/core/platform/default/build_config.bzl
fi

## Find swig path
if [ -z "$SWIG_PATH" ]; then
  SWIG_PATH=`type -p swig 2> /dev/null`
fi
if [[ ! -e "$SWIG_PATH" ]]; then
  echo "Can't find swig.  Ensure swig is in \$PATH or set \$SWIG_PATH."
  exit 1
fi
echo "$SWIG_PATH" > tensorflow/tools/swig/swig_path

# Invoke python_config and set up symlinks to python includes
(./util/python/python_config.sh --setup "$PYTHON_BIN_PATH";) || exit -1

## Set up Cuda-related environment settings

while [ "$TF_NEED_CUDA" == "" ]; do
  read -p "Do you wish to build TensorFlow with GPU support? [y/N] " INPUT
  case $INPUT in
    [Yy]* ) echo "GPU support will be enabled for TensorFlow"; TF_NEED_CUDA=1;;
    [Nn]* ) echo "No GPU support will be enabled for TensorFlow"; TF_NEED_CUDA=0;;
    "" ) echo "No GPU support will be enabled for TensorFlow"; TF_NEED_CUDA=0;;
    * ) echo "Invalid selection: " $INPUT;;
  esac
done

if [ "$TF_NEED_CUDA" == "0" ]; then
  echo "Configuration finished"
  exit
fi

# Set up which gcc nvcc should use as the host compiler
while true; do
  fromuser=""
  if [ -z "$GCC_HOST_COMPILER_PATH" ]; then
    default_gcc_host_compiler_path=$(which gcc)
    read -p "Please specify which gcc nvcc should use as the host compiler. [Default is $default_gcc_host_compiler_path]: " GCC_HOST_COMPILER_PATH
    fromuser="1"
    if [ -z "$GCC_HOST_COMPILER_PATH" ]; then
      GCC_HOST_COMPILER_PATH=$default_gcc_host_compiler_path
    fi
  fi
  if [ -e "$GCC_HOST_COMPILER_PATH" ]; then
    break
  fi
  echo "Invalid gcc path. ${GCC_HOST_COMPILER_PATH} cannot be found" 1>&2
  if [ -z "$fromuser" ]; then
    exit 1
  fi
  GCC_HOST_COMPILER_PATH=""
  # Retry
done


# Find out where the CUDA toolkit is installed
OSNAME=`uname -s`

while true; do
  # Configure the Cuda SDK version to use.
  if [ -z "$TF_CUDA_VERSION" ]; then
    read -p "Please specify the Cuda SDK version you want to use, e.g. 7.0. [Leave empty to use system default]: " TF_CUDA_VERSION
  fi

  fromuser=""
  if [ -z "$CUDA_TOOLKIT_PATH" ]; then
    default_cuda_path=/usr/local/cuda
    read -p "Please specify the location where CUDA $TF_CUDA_VERSION toolkit is installed. Refer to README.md for more details. [Default is $default_cuda_path]: " CUDA_TOOLKIT_PATH
    fromuser="1"
    if [ -z "$CUDA_TOOLKIT_PATH" ]; then
      CUDA_TOOLKIT_PATH=$default_cuda_path
    fi
  fi

  if [[ -z "$TF_CUDA_VERSION" ]]; then
    TF_CUDA_EXT=""
  else
    TF_CUDA_EXT=".$TF_CUDA_VERSION"
  fi

  if [ "$OSNAME" == "Linux" ]; then
    CUDA_RT_LIB_PATH="lib64/libcudart.so${TF_CUDA_EXT}"
  elif [ "$OSNAME" == "Darwin" ]; then
    CUDA_RT_LIB_PATH="lib/libcudart${TF_CUDA_EXT}.dylib"
  fi

  if [ -e "${CUDA_TOOLKIT_PATH}/${CUDA_RT_LIB_PATH}" ]; then
    break
  fi
  echo "Invalid path to CUDA $TF_CUDA_VERSION toolkit. ${CUDA_TOOLKIT_PATH}/${CUDA_RT_LIB_PATH} cannot be found"

  if [ -z "$fromuser" ]; then
    exit 1
  fi
  # Retry
  TF_CUDA_VERSION=""
  CUDA_TOOLKIT_PATH=""
done

# Find out where the cuDNN library is installed
while true; do
  # Configure the Cudnn version to use.
  if [ -z "$TF_CUDNN_VERSION" ]; then
    read -p "Please specify the Cudnn version you want to use. [Leave empty to use system default]: " TF_CUDNN_VERSION
  fi

  fromuser=""
  if [ -z "$CUDNN_INSTALL_PATH" ]; then
    default_cudnn_path=${CUDA_TOOLKIT_PATH}
    read -p "Please specify the location where cuDNN $TF_CUDNN_VERSION library is installed. Refer to README.md for more details. [Default is $default_cudnn_path]: " CUDNN_INSTALL_PATH
    fromuser="1"
    if [ -z "$CUDNN_INSTALL_PATH" ]; then
      CUDNN_INSTALL_PATH=$default_cudnn_path
    fi
    # Result returned from "read" will be used unexpanded. That make "~" unuseable.
    # Going through one more level of expansion to handle that.
    CUDNN_INSTALL_PATH=`${PYTHON_BIN_PATH} -c "import os; print(os.path.realpath(os.path.expanduser('${CUDNN_INSTALL_PATH}')))"`
  fi

  if [[ -z "$TF_CUDNN_VERSION" ]]; then
    TF_CUDNN_EXT=""
  else
    TF_CUDNN_EXT=".$TF_CUDNN_VERSION"
  fi

  if [ "$OSNAME" == "Linux" ]; then
    CUDA_DNN_LIB_PATH="lib64/libcudnn.so${TF_CUDNN_EXT}"
    CUDA_DNN_LIB_ALT_PATH="libcudnn.so${TF_CUDNN_EXT}"
  elif [ "$OSNAME" == "Darwin" ]; then
    CUDA_DNN_LIB_PATH="lib/libcudnn${TF_CUDNN_EXT}.dylib"
    CUDA_DNN_LIB_ALT_PATH="libcudnn${TF_CUDNN_EXT}.dylib"
  fi

  if [ -e "$CUDNN_INSTALL_PATH/${CUDA_DNN_LIB_ALT_PATH}" -o -e "$CUDNN_INSTALL_PATH/${CUDA_DNN_LIB_PATH}" ]; then
    break
  fi

  if [ "$OSNAME" == "Linux" ]; then
    CUDNN_PATH_FROM_LDCONFIG="$(ldconfig -p | sed -n 's/.*libcudnn.so .* => \(.*\)/\1/p')"
    if [ -e "${CUDNN_PATH_FROM_LDCONFIG}${TF_CUDNN_EXT}" ]; then
      CUDNN_INSTALL_PATH="$(dirname ${CUDNN_PATH_FROM_LDCONFIG})"
      break
    fi
  fi
  echo "Invalid path to cuDNN ${CUDNN_VERSION} toolkit. Neither of the following two files can be found:"
  echo "${CUDNN_INSTALL_PATH}/${CUDA_DNN_LIB_PATH}"
  echo "${CUDNN_INSTALL_PATH}/${CUDA_DNN_LIB_ALT_PATH}"
  if [ "$OSNAME" == "Linux" ]; then
    echo "${CUDNN_PATH_FROM_LDCONFIG}${TF_CUDNN_EXT}"
  fi

  if [ -z "$fromuser" ]; then
    exit 1
  fi
  # Retry
  TF_CUDNN_VERSION=""
  CUDNN_INSTALL_PATH=""
done

cat > third_party/gpus/cuda/cuda.config <<EOF
# CUDA_TOOLKIT_PATH refers to the CUDA toolkit.
CUDA_TOOLKIT_PATH="$CUDA_TOOLKIT_PATH"
# CUDNN_INSTALL_PATH refers to the cuDNN toolkit. The cuDNN header and library
# files can be either in this directory, or under include/ and lib64/
# directories separately.
CUDNN_INSTALL_PATH="$CUDNN_INSTALL_PATH"

# The Cuda SDK version that should be used in this build (empty to use libcudart.so symlink)
TF_CUDA_VERSION=$TF_CUDA_VERSION

# The Cudnn version that should be used in this build
TF_CUDNN_VERSION=$TF_CUDNN_VERSION
EOF

# Configure the gcc host compiler to use
export WARNING=$DO_NOT_SUBMIT_WARNING
perl -pi -e "s,CPU_COMPILER = \('.*'\),# \$ENV{WARNING}\nCPU_COMPILER = ('$GCC_HOST_COMPILER_PATH'),s" third_party/gpus/crosstool/clang/bin/crosstool_wrapper_driver_is_not_gcc
perl -pi -e "s,GCC_HOST_COMPILER_PATH = \('.*'\),# \$ENV{WARNING}\nGCC_HOST_COMPILER_PATH = ('$GCC_HOST_COMPILER_PATH'),s" third_party/gpus/crosstool/clang/bin/crosstool_wrapper_driver_is_not_gcc

# Configure the platform name.
perl -pi -e "s,PLATFORM = \".*\",PLATFORM = \"$OSNAME\",s" third_party/gpus/cuda/platform.bzl

# Configure the Cuda toolkit version to work with.
perl -pi -e "s,(GetCudaVersion.*return )\"[0-9\.]*\",\1\"$TF_CUDA_VERSION\",s" tensorflow/stream_executor/dso_loader.cc
perl -pi -e "s,CUDA_VERSION = \"[0-9\.]*\",CUDA_VERSION = \"$TF_CUDA_VERSION\",s" third_party/gpus/cuda/platform.bzl

# Configure the Cudnn version to work with.
perl -pi -e "s,(GetCudnnVersion.*return )\"[0-9\.]*\",\1\"$TF_CUDNN_VERSION\",s" tensorflow/stream_executor/dso_loader.cc
perl -pi -e "s,CUDNN_VERSION = \"[0-9\.]*\",CUDNN_VERSION = \"$TF_CUDNN_VERSION\",s" third_party/gpus/cuda/platform.bzl


# Configure the compute capabilities that TensorFlow builds for.
# Since Cuda toolkit is not backward-compatible, this is not guaranteed to work.
while true; do
  fromuser=""
  if [ -z "$TF_CUDA_COMPUTE_CAPABILITIES" ]; then
cat << EOF
Please specify a list of comma-separated Cuda compute capabilities you want to build with.
You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.
Please note that each additional compute capability significantly increases your build time and binary size.
EOF
    read -p "[Default is: \"3.5,5.2\"]: " TF_CUDA_COMPUTE_CAPABILITIES
    fromuser=1
  fi
  # Check whether all capabilities from the input is valid
  COMPUTE_CAPABILITIES=${TF_CUDA_COMPUTE_CAPABILITIES//,/ }
  ALL_VALID=1
  for CAPABILITY in $COMPUTE_CAPABILITIES; do
    if [[ ! "$CAPABILITY" =~ [0-9]+.[0-9]+ ]]; then
      echo "Invalid compute capability: " $CAPABILITY
      ALL_VALID=0
      break
    fi
  done
  if [ "$ALL_VALID" == "0" ]; then
    if [ -z "$fromuser" ]; then
      exit 1
    fi
  else
    break
  fi
  TF_CUDA_COMPUTE_CAPABILITIES=""
done

if [ ! -z "$TF_CUDA_COMPUTE_CAPABILITIES" ]; then
  export WARNING=$DO_NOT_SUBMIT_WARNING
  function CudaGenCodeOpts() {
    OUTPUT=""
    for CAPABILITY in $@; do
      OUTPUT=${OUTPUT}"   \"${CAPABILITY}\",     "
    done
    echo $OUTPUT
  }
  export CUDA_GEN_CODES_OPTS=$(CudaGenCodeOpts ${TF_CUDA_COMPUTE_CAPABILITIES//,/ })
  perl -pi -0 -e 's,\n( *)([^\n]*supported_cuda_compute_capabilities\s*=\s*\[).*?(\]),\n\1# $ENV{WARNING}\n\1\2$ENV{CUDA_GEN_CODES_OPTS}\3,s' third_party/gpus/crosstool/clang/bin/crosstool_wrapper_driver_is_not_gcc
  function CudaVersionOpts() {
    OUTPUT=""
    for CAPABILITY in $@; do
      OUTPUT=$OUTPUT"CudaVersion(\"${CAPABILITY}\"), "
    done
    echo $OUTPUT
  }
  export CUDA_VERSION_OPTS=$(CudaVersionOpts ${TF_CUDA_COMPUTE_CAPABILITIES//,/ })
  perl -pi -0 -e 's,\n( *)([^\n]*supported_cuda_compute_capabilities\s*=\s*\{).*?(\}),\n\1// $ENV{WARNING}\n\1\2$ENV{CUDA_VERSION_OPTS}\3,s' tensorflow/core/common_runtime/gpu/gpu_device.cc
fi

# Invoke the cuda_config.sh and set up the TensorFlow's canonical view of the Cuda libraries
(cd third_party/gpus/cuda; ./cuda_config.sh;) || exit -1

echo "Configuration finished"
