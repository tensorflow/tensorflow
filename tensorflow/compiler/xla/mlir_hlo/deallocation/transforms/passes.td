/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

include "mlir/Pass/PassBase.td"

def SplitAllocTensorsPass :
    Pass<"hlo-split-alloc-tensors", "mlir::func::FuncOp"> {
  let summary = "Split bufferization.alloc_tensor ops.";
  let description = [{
    `bufferization.alloc_tensor` ops that are reused for non-conflicting ops
    prevent buffer reuse. This pass replaces each use of an alloc tensor with a
    fresh alloc.
  }];
  let constructor = "::mlir::deallocation::createSplitAllocTensorsPass()";
  let dependentDialects = ["::mlir::bufferization::BufferizationDialect"];
}

def DeallocatePass : Pass<"hlo-deallocate", "mlir::ModuleOp"> {
  let summary = "Deallocate buffers by inserting `deallocation.retain` ops.";
  let description = [{
    Inserts deallocations (in the form of `deallocation.retain`) ops. Most
    deallocations are typically converted to `memref.dealloc` by
    canonicalization.
  }];
  let constructor = "::mlir::deallocation::createDeallocatePass()";
  let dependentDialects = ["::mlir::deallocation::DeallocationDialect"];
}

def DeallocationSimplificationPass : Pass<"hlo-deallocation-simplification",
    "mlir::func::FuncOp"> {
  let summary = "Simplifies deallocation.retain ops.";
  let constructor = "::mlir::deallocation::createDeallocationSimplificationPass()";
  let dependentDialects = ["::mlir::deallocation::DeallocationDialect"];
}

def XlaBufferArgRewritePass :
    Pass<"hlo-xla-buffer-arg-rewrite", "mlir::func::FuncOp"> {
  let summary = "Rewrites XLA framework buffer arguments with alias information";
  let description = [{
    In the presence of variables, some results of the main function will alias
    other parameters. This pass rewrites the main function to annotate results
    for which this isn't the case with the `deallocation.restrict` attribute,
    indicating that they do not alias with any other buffer and allowing the
    buffer-reuse pass to optimize them.

    The pass uses attributes present in XLA programs
    (`xla_framework.input_mapping`, `xla_framework.result_mapping` and
    `xla_framework.result_inner_mapping`, specifically).
  }];
  let constructor = "::mlir::deallocation::createXlaBufferArgRewritePass()";
}

def BufferReusePass : Pass<"hlo-buffer-reuse", "mlir::func::FuncOp"> {
  let summary = "Reuse buffers.";
  let description = [{
    A collection of transforms to eliminate allocations, in particular from
    loops:

    - Reuse of buffers (dealloc, alloc pairs)
    - Hoisting of allocations out of loops
    - Promotion of buffers to the stack
    - Double buffering

    For this pass to work properly, the following conditions must be met:

    - The input IR must have been generated by hlo-deallocate. This pass assumes
      invariants guaranteed by hlo-deallocate.
    - The IR must have been canonicalized at least once after hlo-deallocate.
  }];
  let constructor = "::mlir::deallocation::createBufferReusePass()";
  let dependentDialects = ["::mlir::memref::MemRefDialect"];
}

def ConvertDeallocationOpsToLLVMPass
    : Pass<"hlo-convert-deallocation-ops-to-llvm", "mlir::func::FuncOp"> {
  let summary = "Convert `deallocation` ops to LLVM";
  let constructor = "::mlir::deallocation::createConvertDeallocationOpsToLLVM()";
  let dependentDialects = ["mlir::LLVM::LLVMDialect"];
}

def DeallocationToScfPass : Pass<"hlo-deallocation-to-scf",
                                 "mlir::func::FuncOp"> {
  let summary = "Lowers retain to scf.";
  let constructor = "::mlir::deallocation::createDeallocationToScfPass()";
  let dependentDialects = [
    "::mlir::arith::ArithDialect",
    "::mlir::scf::SCFDialect",
    "::mlir::memref::MemRefDialect",
  ];
}
