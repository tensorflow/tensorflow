// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = call i32 @llvm.amdgcn.workgroup.id.x(), !range !1
// CHECK:         %[[VAL_1:.*]] = call i32 @llvm.amdgcn.workitem.id.x(), !range !1
// CHECK:         %[[VAL_2:.*]] = mul nuw nsw i32 %[[VAL_0]], 1
// CHECK:         %[[VAL_3:.*]] = add nuw nsw i32 %[[VAL_2]], %[[VAL_1]]
// CHECK:         %[[VAL_4:.*]] = icmp ult i32 %[[VAL_3]], 1
// CHECK:         call void @llvm.assume(i1 %[[VAL_4]])
// CHECK:         %[[VAL_5:.*]] = icmp ult i32 %[[VAL_3]], 1
// CHECK:         br i1 %[[VAL_5]], label %[[VAL_6:.*]], label %[[VAL_7:.*]]
// CHECK:       fusion.in_bounds-after:                           ; preds = %[[VAL_6]], %[[VAL_8:.*]]
// CHECK:         ret void
// CHECK:       fusion.in_bounds-true:                            ; preds = %[[VAL_8]]
// CHECK:         %[[VAL_9:.*]] = load i8, ptr %[[VAL_10:.*]], align 1, !invariant.load !2
// CHECK:         %[[VAL_11:.*]] = load i8, ptr %[[VAL_12:.*]], align 1, !invariant.load !2
// CHECK:         %[[VAL_13:.*]] = or i8 %[[VAL_9]], %[[VAL_11]]
// CHECK:         %[[VAL_14:.*]] = trunc i8 %[[VAL_13]] to i1
// CHECK:         %[[VAL_15:.*]] = xor i1 %[[VAL_14]], true
// CHECK:         %[[VAL_16:.*]] = zext i1 %[[VAL_15]] to i8
// CHECK:         store i8 %[[VAL_16]], ptr %[[VAL_17:.*]], align 1
// CHECK:         br label %[[VAL_7]]

HloModule xla_computation_f.8

// Since the conversion to MLIR goes through completely different code paths
// depending on whether an op is fused or not, this separately tests pred
// "addition" in fused context.

%fused_computation (param_0.1: pred[], param_1: pred[]) -> pred[] {
  %param_0.1 = pred[] parameter(0)
  %param_1 = pred[] parameter(1)
  %add.1 = pred[] add(pred[] %param_0.1, pred[] %param_1)
  ROOT %not.1 = pred[] not(pred[] %add.1)
}

ENTRY %xla_computation_f.8 (parameter.0: pred[], parameter.1: pred[]) -> (pred[]) {
  %parameter.0 = pred[] parameter(0)
  %parameter.1 = pred[] parameter(1)
  %fusion = pred[] fusion(pred[] %parameter.0, pred[] %parameter.1), kind=kLoop, calls=%fused_computation
  ROOT %tuple.7 = (pred[]) tuple(pred[] %fusion)
}