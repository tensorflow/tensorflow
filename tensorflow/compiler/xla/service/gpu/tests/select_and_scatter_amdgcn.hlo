// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i8, align 1
// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_2:.*]] = alloca i1, align 1
// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_4:.*]] = alloca float, align 4
// CHECK:         %[[VAL_5:.*]] = call i32 @llvm.amdgcn.workgroup.id.x(), !range !1
// CHECK:         %[[VAL_6:.*]] = call i32 @llvm.amdgcn.workitem.id.x(), !range !2
// CHECK:         %[[VAL_7:.*]] = mul nuw nsw i32 %[[VAL_5]], 2
// CHECK:         %[[VAL_8:.*]] = add nuw nsw i32 %[[VAL_7]], %[[VAL_6]]
// CHECK:         %[[VAL_9:.*]] = icmp ult i32 %[[VAL_8]], 2
// CHECK:         call void @llvm.assume(i1 %[[VAL_9]])
// CHECK:         %[[VAL_10:.*]] = udiv i32 %[[VAL_8]], 1
// CHECK:         %[[VAL_11:.*]] = icmp ult i32 %[[VAL_8]], 2
// CHECK:         br i1 %[[VAL_11]], label %[[VAL_12:.*]], label %[[VAL_13:.*]]
// CHECK:       select_and_scatter_12.in_bounds-after:            ; preds = %[[VAL_14:.*]], %[[VAL_15:.*]]
// CHECK:         ret void
// CHECK:       select_and_scatter_12.in_bounds-true:             ; preds = %[[VAL_15]]
// CHECK:         store i1 false, ptr addrspace(5) %[[VAL_2]], align 1
// CHECK:         store i32 0, ptr addrspace(5) %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_16:.*]]
// CHECK:       select_and_scatter_12inner.loop_header.window.0:  ; preds = %[[VAL_17:.*]], %[[VAL_12]]
// CHECK:         %[[VAL_18:.*]] = load i32, ptr addrspace(5) %[[VAL_1]], align 4
// CHECK:         %[[VAL_19:.*]] = icmp uge i32 %[[VAL_18]], 3
// CHECK:         br i1 %[[VAL_19]], label %[[VAL_20:.*]], label %[[VAL_21:.*]]
// CHECK:       select_and_scatter_12inner.loop_body.window.0:    ; preds = %[[VAL_16]]
// CHECK:         %[[VAL_22:.*]] = mul nsw i32 %[[VAL_10]], 3
// CHECK:         %[[VAL_23:.*]] = add nsw i32 %[[VAL_22]], %[[VAL_18]]
// CHECK:         %[[VAL_24:.*]] = sub nsw i32 %[[VAL_23]], 0
// CHECK:         %[[VAL_25:.*]] = icmp ult i32 %[[VAL_24]], 6
// CHECK:         %[[VAL_26:.*]] = and i1 true, %[[VAL_25]]
// CHECK:         br i1 %[[VAL_26]], label %[[VAL_27:.*]], label %[[VAL_28:.*]]
// CHECK:       in-bounds-after:                                  ; preds = %[[VAL_28]], %[[VAL_29:.*]]
// CHECK:         %[[VAL_30:.*]] = add nuw nsw i32 %[[VAL_18]], 1
// CHECK:         store i32 %[[VAL_30]], ptr addrspace(5) %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_16]]
// CHECK:       select_and_scatter_12inner.loop_exit.window.0:    ; preds = %[[VAL_16]]
// CHECK:         %[[VAL_31:.*]] = load i1, ptr addrspace(5) %[[VAL_2]], align 1
// CHECK:         br i1 %[[VAL_31]], label %[[VAL_32:.*]], label %[[VAL_14]]
// CHECK:       should-store-after:                               ; preds = %[[VAL_32]], %[[VAL_20]]
// CHECK:         br label %[[VAL_13]]
// CHECK:       in-bounds-true:                                   ; preds = %[[VAL_21]]
// CHECK:         %[[VAL_33:.*]] = load i1, ptr addrspace(5) %[[VAL_2]], align 1
// CHECK:         br i1 %[[VAL_33]], label %[[VAL_34:.*]], label %[[VAL_35:.*]]
// CHECK:       initialized-after:                                ; preds = %[[VAL_35]], %[[VAL_36:.*]]
// CHECK:         br label %[[VAL_17]]
// CHECK:       in-bounds-false:                                  ; preds = %[[VAL_21]]
// CHECK:         br label %[[VAL_17]]
// CHECK:       initialized-true:                                 ; preds = %[[VAL_27]]
// CHECK:         %[[VAL_37:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_38:.*]], i32 0, i32 %[[VAL_24]]
// CHECK:         %[[VAL_99:.*]] = addrspacecast ptr addrspace(5) %[[VAL_4]] to ptr
// CHECK:         %[[VAL_98:.*]] = addrspacecast ptr addrspace(5) %[[VAL_0]] to ptr
// CHECK:         call void @region_0_4(ptr %[[VAL_99]], ptr %[[VAL_37]], ptr %[[VAL_98]])
// CHECK:         %[[VAL_39:.*]] = load i8, ptr addrspace(5) %[[VAL_0]], align 1
// CHECK:         %[[VAL_40:.*]] = icmp ne i8 %[[VAL_39]], 0
// CHECK:         br i1 %[[VAL_40]], label %[[VAL_41:.*]], label %[[VAL_42:.*]]
// CHECK:       if-select-lhs-after:                              ; preds = %[[VAL_42]], %[[VAL_41]]
// CHECK:         br label %[[VAL_29]]
// CHECK:       initialized-false:                                ; preds = %[[VAL_27]]
// CHECK:         %[[VAL_43:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_38]], i32 0, i32 %[[VAL_24]]
// CHECK:         %[[VAL_44:.*]] = load float, ptr %[[VAL_43]], align 4, !invariant.load !3
// CHECK:         store float %[[VAL_44]], ptr addrspace(5) %[[VAL_4]], align 4
// CHECK:         %[[VAL_45:.*]] = getelementptr inbounds i32, ptr addrspace(5) %[[VAL_3]], i32 0
// CHECK:         store i32 %[[VAL_24]], ptr addrspace(5) %[[VAL_45]], align 4
// CHECK:         store i1 true, ptr addrspace(5) %[[VAL_2]], align 1
// CHECK:         br label %[[VAL_29]]
// CHECK:       if-select-lhs-true:                               ; preds = %[[VAL_34]]
// CHECK:         br label %[[VAL_36]]
// CHECK:       if-select-lhs-false:                              ; preds = %[[VAL_34]]
// CHECK:         %[[VAL_46:.*]] = load float, ptr %[[VAL_37]], align 4
// CHECK:         store float %[[VAL_46]], ptr addrspace(5) %[[VAL_4]], align 4
// CHECK:         %[[VAL_47:.*]] = getelementptr inbounds i32, ptr addrspace(5) %[[VAL_3]], i32 0
// CHECK:         store i32 %[[VAL_24]], ptr addrspace(5) %[[VAL_47]], align 4
// CHECK:         br label %[[VAL_36]]
// CHECK:       should-store-true:                                ; preds = %[[VAL_20]]
// CHECK:         %[[VAL_48:.*]] = getelementptr inbounds i32, ptr addrspace(5) %[[VAL_3]], i32 0
// CHECK:         %[[VAL_49:.*]] = load i32, ptr addrspace(5) %[[VAL_48]], align 4
// CHECK:         %[[VAL_50:.*]] = getelementptr inbounds float, ptr %[[VAL_51:.*]], i32 %[[VAL_8]]
// CHECK:         %[[VAL_52:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_53:.*]], i32 0, i32 %[[VAL_49]]
// CHECK:         %[[VAL_54:.*]] = load float, ptr %[[VAL_50]], align 4
// CHECK:         %[[VAL_97:.*]] = addrspacecast ptr %[[VAL_52]] to ptr addrspace(1)
// CHECK:         %[[VAL_55:.*]] = atomicrmw fadd ptr addrspace(1) %[[VAL_97]], float %[[VAL_54]] syncscope("agent") seq_cst, align 4
// CHECK:         br label %[[VAL_14]]
// CHECK:       entry:
// CHECK:         %[[VAL_56:.*]] = alloca i8, align 1, addrspace(5)
// CHECK:         %[[VAL_96:.*]] = addrspacecast ptr addrspace(5) %[[VAL_56:.*]] to ptr
// CHECK:         %[[VAL_57:.*]] = load float, ptr %[[VAL_58:.*]], align 4
// CHECK:         %[[VAL_59:.*]] = load float, ptr %[[VAL_60:.*]], align 4
// CHECK:         %[[VAL_61:.*]] = fcmp oge float %[[VAL_57]], %[[VAL_59]]
// CHECK:         %[[VAL_62:.*]] = zext i1 %[[VAL_61]] to i8
// CHECK:         store i8 %[[VAL_62]], ptr %[[VAL_96]], align 1
// CHECK:         %[[VAL_63:.*]] = load i8, ptr %[[VAL_96]], align 1
// CHECK:         store i8 %[[VAL_63]], ptr %[[VAL_64:.*]], align 1
// CHECK:         ret void

HloModule SelectAndScatter

%ge_F32 (lhs.5: f32[], rhs.6: f32[]) -> pred[] {
  %lhs.5 = f32[] parameter(0)
  %rhs.6 = f32[] parameter(1)
  ROOT %compare.7 = pred[] compare(f32[] %lhs.5, f32[] %rhs.6), direction=GE
}

%add_F32 (lhs.9: f32[], rhs.10: f32[]) -> f32[] {
  %lhs.9 = f32[] parameter(0)
  %rhs.10 = f32[] parameter(1)
  ROOT %add.11 = f32[] add(f32[] %lhs.9, f32[] %rhs.10)
}

ENTRY main () -> f32[6] {
  %operand = f32[6]{0} parameter(0)
  %source = f32[2]{0} parameter(1)
  %init = f32[] constant(0)
  ROOT %select_and_scatter_12 = f32[6]{0} select-and-scatter(f32[6]{0} %operand, f32[2]{0} %source, f32[] %init), window={size=3 stride=3}, select=%ge_F32, scatter=%add_F32
}
