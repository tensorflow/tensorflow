// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = getelementptr inbounds i8, ptr %[[VAL_1:.*]], i64 0
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_3:.*]], i64 0
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_5:.*]], i64 0
// CHECK:         %[[VAL_6:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !2
// CHECK:         %[[VAL_7:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !2
// CHECK:         %[[VAL_8:.*]] = mul nuw nsw i32 %[[VAL_6]], 1
// CHECK:         %[[VAL_9:.*]] = add nuw nsw i32 %[[VAL_8]], %[[VAL_7]]
// CHECK:         %[[VAL_10:.*]] = icmp ult i32 %[[VAL_9]], 1
// CHECK:         call void @llvm.assume(i1 %[[VAL_10]])
// CHECK:         %[[VAL_11:.*]] = icmp ult i32 %[[VAL_9]], 1
// CHECK:         br i1 %[[VAL_11]], label %[[VAL_12:.*]], label %[[VAL_13:.*]]
// CHECK:       fusion.in_bounds-after:                           ; preds = %[[VAL_12]], %[[VAL_14:.*]]
// CHECK:         ret void
// CHECK:       fusion.in_bounds-true:                            ; preds = %[[VAL_14]]
// CHECK:         %[[VAL_15:.*]] = load i8, ptr %[[VAL_0]], align 1, !invariant.load !3
// CHECK:         %[[VAL_16:.*]] = load i8, ptr %[[VAL_2]], align 1, !invariant.load !3
// CHECK:         %[[VAL_17:.*]] = or i8 %[[VAL_15]], %[[VAL_16]]
// CHECK:         %[[VAL_18:.*]] = trunc i8 %[[VAL_17]] to i1
// CHECK:         %[[VAL_19:.*]] = xor i1 %[[VAL_18]], true
// CHECK:         %[[VAL_20:.*]] = zext i1 %[[VAL_19]] to i8
// CHECK:         store i8 %[[VAL_20]], ptr %[[VAL_4]], align 1
// CHECK:         br label %[[VAL_13]]

HloModule xla_computation_f.8

// Since the conversion to MLIR goes through completely different code paths
// depending on whether an op is fused or not, this separately tests pred
// "addition" in fused context.

%fused_computation (param_0.1: pred[], param_1: pred[]) -> pred[] {
  %param_0.1 = pred[] parameter(0)
  %param_1 = pred[] parameter(1)
  %add.1 = pred[] add(pred[] %param_0.1, pred[] %param_1)
  ROOT %not.1 = pred[] not(pred[] %add.1)
}

ENTRY %xla_computation_f.8 (parameter.0: pred[], parameter.1: pred[]) -> (pred[]) {
  %parameter.0 = pred[] parameter(0)
  %parameter.1 = pred[] parameter(1)
  %fusion = pred[] fusion(pred[] %parameter.0, pred[] %parameter.1), kind=kLoop, calls=%fused_computation
  ROOT %tuple.7 = (pred[]) tuple(pred[] %fusion)
}
