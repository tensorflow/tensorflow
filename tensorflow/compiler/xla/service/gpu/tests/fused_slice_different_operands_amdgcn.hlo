// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.


// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = call i32 @llvm.amdgcn.workgroup.id.x(), !range !1
// CHECK:         %[[VAL_1:.*]] = call i32 @llvm.amdgcn.workitem.id.x(), !range !2
// CHECK:         %[[VAL_2:.*]] = mul nuw nsw i32 %[[VAL_0]], 1024
// CHECK:         %[[VAL_3:.*]] = add nuw nsw i32 %[[VAL_2]], %[[VAL_1]]
// CHECK:         %[[VAL_4:.*]] = icmp ult i32 %[[VAL_3]], 1024
// CHECK:         call void @llvm.assume(i1 %[[VAL_4]])
// CHECK:         %[[VAL_5:.*]] = udiv i32 %[[VAL_3]], 1
// CHECK:         %[[VAL_6:.*]] = icmp ult i32 %[[VAL_3]], 1024
// CHECK:         br i1 %[[VAL_6]], label %[[VAL_7:.*]], label %[[VAL_8:.*]]
// CHECK:       fusion.in_bounds-after:                           ; preds = %[[VAL_9:.*]], %[[VAL_10:.*]]
// CHECK:         ret void
// CHECK:       fusion.in_bounds-true:                            ; preds = %[[VAL_10]]
// CHECK:         %[[VAL_11:.*]] = add i32 %[[VAL_5]], 0
// CHECK:         br label %[[VAL_12:.*]]
// CHECK:       concat_index_from_operand_id0:                    ; preds = %[[VAL_13:.*]]
// CHECK:         %[[VAL_14:.*]] = phi i32 [ 0, %[[VAL_13]] ]
// CHECK:         %[[VAL_15:.*]] = sub nsw i32 %[[VAL_11]], %[[VAL_14]]
// CHECK:         %[[VAL_16:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_17:.*]], i32 0, i32 %[[VAL_15]]
// CHECK:         %[[VAL_18:.*]] = load half, ptr %[[VAL_16]], align 2, !invariant.load !3
// CHECK:         %[[VAL_19:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_20:.*]], i32 0, i32 %[[VAL_15]]
// CHECK:         %[[VAL_21:.*]] = load half, ptr %[[VAL_19]], align 2, !invariant.load !3
// CHECK:         %[[VAL_22:.*]] = fmul half %[[VAL_18]], %[[VAL_21]]
// CHECK:         br label %[[VAL_9]]
// CHECK:       concat_index_from_operand_id1:                    ; preds = %[[VAL_23:.*]]
// CHECK:         %[[VAL_24:.*]] = phi i32 [ 1024, %[[VAL_23]] ]
// CHECK:         %[[VAL_25:.*]] = sub nsw i32 %[[VAL_11]], %[[VAL_24]]
// CHECK:         %[[VAL_26:.*]] = getelementptr inbounds [1023 x half], ptr %[[VAL_27:.*]], i32 0, i32 %[[VAL_25]]
// CHECK:         %[[VAL_28:.*]] = load half, ptr %[[VAL_26]], align 2, !invariant.load !3
// CHECK:         %[[VAL_29:.*]] = getelementptr inbounds [1023 x half], ptr %[[VAL_30:.*]], i32 0, i32 %[[VAL_25]]
// CHECK:         %[[VAL_31:.*]] = load half, ptr %[[VAL_29]], align 2, !invariant.load !3
// CHECK:         %[[VAL_32:.*]] = fadd half %[[VAL_28]], %[[VAL_31]]
// CHECK:         br label %[[VAL_9]]
// CHECK:       concatenate.pivot.1024.:                          ; preds = %[[VAL_7]]
// CHECK:         %[[VAL_33:.*]] = icmp ult i32 %[[VAL_11]], 1024
// CHECK:         br i1 %[[VAL_33]], label %[[VAL_13]], label %[[VAL_23]]
// CHECK:       concatenate.pivot.0.:                             ; preds = %[[VAL_12]]
// CHECK:         br label %[[VAL_34:.*]]
// CHECK:       concatenate.pivot.1024.1:                         ; preds = %[[VAL_12]]
// CHECK:         br label %[[VAL_35:.*]]
// CHECK:       concatenate.7.merge:                              ; preds = %[[VAL_35]], %[[VAL_34]]
// CHECK:         %[[VAL_36:.*]] = phi half [ %[[VAL_22]], %[[VAL_34]] ], [ %[[VAL_32]], %[[VAL_35]] ]
// CHECK:         %[[VAL_37:.*]] = insertvalue { half, half } undef, half %[[VAL_36]], 0
// CHECK:         %[[VAL_38:.*]] = add i32 %[[VAL_5]], 0
// CHECK:         %[[VAL_39:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_17]], i32 0, i32 %[[VAL_38]]
// CHECK:         %[[VAL_40:.*]] = load half, ptr %[[VAL_39]], align 2, !invariant.load !3
// CHECK:         %[[VAL_41:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_20]], i32 0, i32 %[[VAL_38]]
// CHECK:         %[[VAL_42:.*]] = load half, ptr %[[VAL_41]], align 2, !invariant.load !3
// CHECK:         %[[VAL_43:.*]] = fmul half %[[VAL_40]], %[[VAL_42]]
// CHECK:         %[[VAL_44:.*]] = insertvalue { half, half } %[[VAL_37]], half %[[VAL_43]], 1
// CHECK:         %[[VAL_45:.*]] = extractvalue { half, half } %[[VAL_44]], 0
// CHECK:         %[[VAL_46:.*]] = getelementptr inbounds half, ptr %[[VAL_47:.*]], i32 %[[VAL_3]]
// CHECK:         store half %[[VAL_45]], ptr %[[VAL_46]], align 2
// CHECK:         %[[VAL_48:.*]] = extractvalue { half, half } %[[VAL_44]], 1
// CHECK:         %[[VAL_49:.*]] = getelementptr inbounds half, ptr %[[VAL_50:.*]], i32 %[[VAL_3]]
// CHECK:         store half %[[VAL_48]], ptr %[[VAL_49]], align 2
// CHECK:         br label %[[VAL_8]]

HloModule input_fusion_with_a_tuple_of_slices

fused_computation {
  arg.1 = f16[1024]{0} parameter(0)
  arg.2 = f16[1024]{0} parameter(1)
  arg.3 = f16[1023]{0} parameter(2)
  arg.4 = f16[1023]{0} parameter(3)
  mul.1 = f16[1024]{0} multiply(arg.1, arg.2)
  add.1 = f16[1023]{0} add(arg.3, arg.4)
  concat.1 = f16[2047]{0} concatenate(mul.1, add.1), dimensions={0}
  slice.1 = f16[1024]{0} slice(concat.1), slice={[0:1024]}
  slice.2 = f16[1024]{0} slice(mul.1), slice={[0:1024]}
  ROOT tuple.1 = (f16[1024]{0}, f16[1024]{0}) tuple(slice.1, slice.2)
}

ENTRY kernel_entry {
  arg.1 = f16[1024]{0} parameter(0)
  arg.2 = f16[1024]{0} parameter(1)
  arg.3 = f16[1023]{0} parameter(2)
  arg.4 = f16[1023]{0} parameter(3)
  ROOT fusion = (f16[1024]{0}, f16[1024]{0})
      fusion(arg.1, arg.2, arg.3, arg.4), kind=kLoop, calls=fused_computation
}

