op {
  name: "Abs"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the absolute value of a tensor."
  description: "Given a tensor `x`, this operation returns a tensor containing the absolute\nvalue of each element in `x`. For example, if x is an input element and y is\nan output element, this operation computes \\\\(y = |x|\\\\)."
}
op {
  name: "Add"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
      }
    }
  }
  summary: "Returns x + y element-wise."
  description: "*NOTE*: Add supports broadcasting. AddN does not."
  is_commutative: true
}
op {
  name: "AddN"
  input_arg {
    name: "inputs"
    description: "Must all be the same size and shape."
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "sum"
    type_attr: "T"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Add all input tensors element wise."
  is_aggregate: true
  is_commutative: true
}
op {
  name: "AdjustContrast"
  input_arg {
    name: "images"
    type_attr: "T"
  }
  input_arg {
    name: "contrast_factor"
    description: "A float multiplier for adjusting contrast."
    type: DT_FLOAT
  }
  input_arg {
    name: "min_value"
    description: "Minimum value for clipping the adjusted pixels."
    type: DT_FLOAT
  }
  input_arg {
    name: "max_value"
    description: "Maximum value for clipping the adjusted pixels."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "The constrast-adjusted image or images."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Adjust the contrast of one or more images."
  description: "`images` is a tensor of at least 3 dimensions.  The last 3 dimensions are\ninterpreted as `[height, width, channels]`.  The other dimensions only\nrepresent a collection of images, such as `[batch, height, width, channels].`\n\nContrast is adjusted independently for each channel of each image.\n\nFor each channel, the Op first computes the mean of the image pixels in the\nchannel and then adjusts each component of each pixel to\n`(x - mean) * contrast_factor + mean`.\n\nThese adjusted values are then clipped to fit in the `[min_value, max_value]`\ninterval.\n\n`images: Images to adjust.  At least 3-D."
}
op {
  name: "All"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type: DT_BOOL
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type: DT_BOOL
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  summary: "Computes the \"logical and\" of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "AllCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate represting the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to produce per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a learned unigram distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Any"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type: DT_BOOL
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type: DT_BOOL
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  summary: "Computes the \"logical or\" of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "ApplyAdagrad"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'*var\' according to the adagrad scheme."
  description: "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))"
}
op {
  name: "ApplyAdam"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "m"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "v"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "beta1_power"
    description: "Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "beta2_power"
    description: "Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "beta1"
    description: "Momentum factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "beta2"
    description: "Momentum factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "epsilon"
    description: "Ridge term. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, updating of the var, m, and v tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'*var\' according to the Adam algorithm."
  description: "lr_t <- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)\nm_t <- beta1 * m_{t-1} + (1 - beta1) * g_t\nv_t <- beta2 * v_{t-1} + (1 - beta2) * g_t * g_t\nvariable <- variable - lr_t * m_t / (sqrt(v_t) + epsilon)"
}
op {
  name: "ApplyGradientDescent"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "alpha"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "delta"
    description: "The change."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'*var\' by subtracting \'alpha\' * \'delta\' from it."
}
op {
  name: "ApplyMomentum"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  input_arg {
    name: "momentum"
    description: "Momentum. Must be a scalar."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'*var\' according to the momentum scheme."
  description: "accum = accum * momentum + grad\nvar -= lr * accum"
}
op {
  name: "ApplyRMSProp"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "ms"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "mom"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "rho"
    description: "Decay rate. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "momentum"
    type_attr: "T"
  }
  input_arg {
    name: "epsilon"
    description: "Ridge term. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, updating of the var, m, and v tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'*var\' according to the RMSProp algorithm."
  description: "mean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom"
}
op {
  name: "ArgMax"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "dimension"
    description: "int32, 0 <= dimension < rank(input).  Describes which dimension\nof the input Tensor to reduce across. For vectors, use dimension = 0."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type: DT_INT64
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Returns the index with the largest value across dimensions of a tensor."
}
op {
  name: "ArgMin"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "dimension"
    description: "int32, 0 <= dimension < rank(input).  Describes which dimension\nof the input Tensor to reduce across. For vectors, use dimension = 0."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type: DT_INT64
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Returns the index with the smallest value across dimensions of a tensor."
}
op {
  name: "Assert"
  input_arg {
    name: "condition"
    description: "The condition to evaluate."
    type: DT_BOOL
  }
  input_arg {
    name: "data"
    description: "The tensors to print out when condition is false."
    type_list_attr: "T"
  }
  attr {
    name: "T"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "summarize"
    type: "int"
    default_value {
      i: 3
    }
    description: "Print this many entries of each tensor."
  }
  summary: "Asserts that the given condition is true."
  description: "If `condition` evaluates to false, print the list of tensors in `data`.\n`summarize` determines how many entries of the tensors to print."
}
op {
  name: "Assign"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node. May be uninitialized."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "value"
    description: "The value to be assigned to the variable."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been reset."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "validate_shape"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true, the operation will validate that the shape\nof \'value\' matches the shape of the Tensor being assigned to.  If false,\n\'ref\' will take on the shape of \'value\'."
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: true
    }
    description: "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'ref\' by assigning \'value\' to it."
  description: "This operation outputs \"ref\" after the assignment is done.\nThis makes it easier to chain operations that need to use the reset value."
  allows_uninitialized_input: true
}
op {
  name: "AssignAdd"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "value"
    description: "The value to be added to the variable."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'ref\' by adding \'value\' to it."
  description: "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value."
}
op {
  name: "AssignSub"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "value"
    description: "The value to be subtracted to the variable."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'ref\' by subtracting \'value\' from it."
  description: "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value."
}
op {
  name: "AvgPool"
  input_arg {
    name: "value"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The average pooled output tensor."
    type_attr: "T"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the sliding window for each dimension of `value`."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of `value`."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Performs average pooling on the input."
  description: "Each entry in `output` is the mean of the corresponding size `ksize`\nwindow in `value`."
}
op {
  name: "AvgPoolGrad"
  input_arg {
    name: "orig_input_shape"
    description: "1-D.  Shape of the original input to `avg_pool`."
    type: DT_INT32
  }
  input_arg {
    name: "grad"
    description: "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t.\nthe output of `avg_pool`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D.  Gradients w.r.t. the input of `avg_pool`."
    type_attr: "T"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the sliding window for each dimension of the input."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the input."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes gradients of the average pooling function."
}
op {
  name: "BatchCholesky"
  input_arg {
    name: "input"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    description: "The type of values in the input and output."
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the Cholesky decomposition of a batch of square matrices."
  description: "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices, with the same constraints as the single matrix Cholesky\ndecomposition above. The output is a tensor of the same shape as the input\ncontaining the Cholesky decompositions for all input submatrices `[..., :, :]`."
}
op {
  name: "BatchMatMul"
  input_arg {
    name: "x"
    description: "3-D or higher with shape `[..., r_x, c_x]`."
    type_attr: "T"
  }
  input_arg {
    name: "y"
    description: "3-D or higher with shape `[..., r_y, c_y]`."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "3-D or higher with shape `[..., r_o, c_o]`"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
      }
    }
  }
  attr {
    name: "adj_x"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, adjoint the slices of `x`. Defaults to `False`."
  }
  attr {
    name: "adj_y"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, adjoint the slices of `y`. Defaults to `False`."
  }
  summary: "Multiplies slices of two tensors in batches."
  description: "Multiplies all slices of `Tensor` `x` and `y` (each slice can be\nviewed as an element of a batch), and arranges the individual results\nin a single output tensor of the same batch size. Each of the\nindividual slices can optionally be adjointed (to adjoint a matrix\nmeans to transpose and conjugate it) before multiplication by setting\nthe `adj_x` or `adj_y` flag to `True`, which are by default `False`.\n\nThe input tensors `x` and `y` are 3-D or higher with shape `[..., r_x, c_x]`\nand `[..., r_y, c_y]`.\n\nThe output tensor is 3-D or higher with shape `[..., r_o, c_o]`, where:\n\n    r_o = c_x if adj_x else r_x\n    c_o = r_y if adj_y else c_y\n\nIt is computed as:\n\n    out[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])"
}
op {
  name: "BatchMatrixDeterminant"
  input_arg {
    name: "input"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[...]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    description: "The type of values in the input and output."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Calculates the determinants for a batch of square matrices."
  description: "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a 1-D tensor containing the determinants\nfor all input submatrices `[..., :, :]`."
}
op {
  name: "BatchMatrixInverse"
  input_arg {
    name: "input"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    description: "The type of values in the input and output."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Calculates the inverse of square invertible matrices."
  description: "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the inverse for all input submatrices `[..., :, :]`.\n\nThe op uses the Cholesky decomposition if the matrices are symmetric positive\ndefinite and LU decomposition with partial pivoting otherwise.\n\nIf a matrix is not invertible there is no guarantee what the op does. It\nmay detect the condition and raise an exception or it may simply return a\ngarbage result."
}
op {
  name: "BatchNormWithGlobalNormalization"
  input_arg {
    name: "t"
    description: "A 4D input Tensor."
    type_attr: "T"
  }
  input_arg {
    name: "m"
    description: "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof."
    type_attr: "T"
  }
  input_arg {
    name: "v"
    description: "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof."
    type_attr: "T"
  }
  input_arg {
    name: "beta"
    description: "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor."
    type_attr: "T"
  }
  input_arg {
    name: "gamma"
    description: "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor."
    type_attr: "T"
  }
  output_arg {
    name: "result"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "variance_epsilon"
    type: "float"
    description: "A small float number to avoid dividing by 0."
  }
  attr {
    name: "scale_after_normalization"
    type: "bool"
    description: "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."
  }
  summary: "Batch normalization."
}
op {
  name: "BatchNormWithGlobalNormalizationGrad"
  input_arg {
    name: "t"
    description: "A 4D input Tensor."
    type_attr: "T"
  }
  input_arg {
    name: "m"
    description: "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof."
    type_attr: "T"
  }
  input_arg {
    name: "v"
    description: "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof."
    type_attr: "T"
  }
  input_arg {
    name: "gamma"
    description: "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this Tensor will be multiplied\nwith the normalized Tensor."
    type_attr: "T"
  }
  input_arg {
    name: "backprop"
    description: "4D backprop Tensor."
    type_attr: "T"
  }
  output_arg {
    name: "dx"
    description: "4D backprop tensor for input."
    type_attr: "T"
  }
  output_arg {
    name: "dm"
    description: "1D backprop tensor for mean."
    type_attr: "T"
  }
  output_arg {
    name: "dv"
    description: "1D backprop tensor for variance."
    type_attr: "T"
  }
  output_arg {
    name: "db"
    description: "1D backprop tensor for beta."
    type_attr: "T"
  }
  output_arg {
    name: "dg"
    description: "1D backprop tensor for gamma."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "variance_epsilon"
    type: "float"
    description: "A small float number to avoid dividing by 0."
  }
  attr {
    name: "scale_after_normalization"
    type: "bool"
    description: "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."
  }
  summary: "Gradients for batch normalization."
}
op {
  name: "BatchSelfAdjointEig"
  input_arg {
    name: "input"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., M+1, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    description: "The type of values in the input and output."
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the Eigen Decomposition of a batch of square self-adjoint matrices."
  description: "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices, with the same constraints as the single matrix\nSelfAdjointEig.\n\nThe result is a \'[..., M+1, M] matrix with [..., 0,:] containing the\neigenvalues, and subsequent [...,1:, :] containing the eigenvectors."
}
op {
  name: "BiasAdd"
  input_arg {
    name: "value"
    description: "Any number of dimensions."
    type_attr: "T"
  }
  input_arg {
    name: "bias"
    description: "1-D with size the last dimension of `value`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Broadcasted sum of `value` and `bias`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Adds `bias` to `value`."
  description: "This is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions."
}
op {
  name: "BroadcastGradientArgs"
  input_arg {
    name: "s0"
    type: DT_INT32
  }
  input_arg {
    name: "s1"
    type: DT_INT32
  }
  output_arg {
    name: "r0"
    type: DT_INT32
  }
  output_arg {
    name: "r1"
    type: DT_INT32
  }
  summary: "Return the reduction indices for computing gradients of s0 op s1 with broadcast."
  description: "This is typically used by gradient computations for a broadcasting operation."
}
op {
  name: "Cast"
  input_arg {
    name: "x"
    type_attr: "SrcT"
  }
  output_arg {
    name: "y"
    type_attr: "DstT"
  }
  attr {
    name: "SrcT"
    type: "type"
  }
  attr {
    name: "DstT"
    type: "type"
  }
  summary: "Cast x of type SrcT to y of DstT."
}
op {
  name: "Ceil"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns element-wise smallest integer in not less than x."
}
op {
  name: "CheckNumerics"
  input_arg {
    name: "tensor"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "message"
    type: "string"
    description: "Prefix of the error message."
  }
  summary: "Checks a tensor for NaN and Inf values."
  description: "When run, reports an `InvalidArgument` error if `tensor` has any values\nthat are not a number (NaN) or infinity (Inf). Otherwise, passes `tensor` as-is."
}
op {
  name: "Cholesky"
  input_arg {
    name: "input"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    description: "The type of values in the input and output."
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the Cholesky decomposition of a square matrix."
  description: "The input has to be symmetric and positive definite. Only the lower-triangular\npart of the input will be used for this operation. The upper-triangular part\nwill not be read.\n\nThe result is the lower-triangular matrix of the Cholesky decomposition of the\ninput."
}
op {
  name: "Complex"
  input_arg {
    name: "real"
    type: DT_FLOAT
  }
  input_arg {
    name: "imag"
    type: DT_FLOAT
  }
  output_arg {
    name: "out"
    type: DT_COMPLEX64
  }
  summary: "Converts two real numbers to a complex number."
  description: "Given a tensor `real` representing the real part of a complex number, and a\ntensor `imag` representing the imaginary part of a complex number, this\noperation returns complex numbers elementwise of the form \\\\(a + bj\\\\), where\n*a* represents the `real` part and *b* represents the `imag` part.\n\nThe input tensors `real` and `imag` must have the same shape.\n\nFor example:\n\n```\n# tensor \'real\' is [2.25, 3.25]\n# tensor `imag` is [4.75, 5.75]\ntf.complex(real, imag) ==> [[2.25 + 4.75j], [3.25 + 5.75j]]\n```"
}
op {
  name: "ComplexAbs"
  input_arg {
    name: "x"
    type: DT_COMPLEX64
  }
  output_arg {
    name: "y"
    type: DT_FLOAT
  }
  summary: "Computes the complex absolute value of a tensor."
  description: "Given a tensor `x` of complex numbers, this operation returns a tensor of type\n`float` that is the absolute value of each element in `x`. All elements in `x`\nmust be complex numbers of the form \\\\(a + bj\\\\). The absolute value is\ncomputed as \\\\( \\sqrt{a^2 + b^2}\\\\).\n\nFor example:\n\n```\n# tensor \'x\' is [[-2.25 + 4.75j], [-3.25 + 5.75j]]\ntf.complex_abs(x) ==> [5.25594902, 6.60492229]\n```"
}
op {
  name: "ComputeAccidentalHits"
  input_arg {
    name: "true_classes"
    description: "The true_classes output of UnpackSparseLabels."
    type: DT_INT64
  }
  input_arg {
    name: "sampled_candidates"
    description: "The sampled_candidates output of CandidateSampler."
    type: DT_INT64
  }
  output_arg {
    name: "indices"
    description: "A vector of indices corresponding to rows of true_candidates."
    type: DT_INT32
  }
  output_arg {
    name: "ids"
    description: "A vector of IDs of positions in sampled_candidates that match a true_label\nfor the row with the corresponding index in indices."
    type: DT_INT64
  }
  output_arg {
    name: "weights"
    description: "A vector of the same length as indices and ids, in which each element\nis -FLOAT_MAX."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Computes the ids of the positions in sampled_candidates that match true_labels."
  description: "When doing log-odds NCE, the result of this op should be passed through a\nSparseToDense op, then added to the logits of the sampled candidates. This has\nthe effect of \'removing\' the sampled labels that match the true labels by\nmaking the classifier sure that they are sampled labels."
}
op {
  name: "Concat"
  input_arg {
    name: "concat_dim"
    description: "0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values))."
    type: DT_INT32
  }
  input_arg {
    name: "values"
    description: "The `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`."
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "output"
    description: "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor\'s shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes."
    type_attr: "T"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 2
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Concatenates tensors along one dimension."
}
op {
  name: "Conj"
  input_arg {
    name: "in"
    type: DT_COMPLEX64
  }
  output_arg {
    name: "out"
    type: DT_COMPLEX64
  }
  summary: "Returns the complex conjugate of a complex number."
  description: "Given a tensor `in` of complex numbers, this operation returns a tensor of\ncomplex numbers that are the complex conjugate of each element in `in`. The\ncomplex numbers in `in` must be of the form \\\\(a + bj\\\\), where *a* is the real\npart and *b* is the imaginary part.\n\nThe complex conjugate returned by this operation is of the form \\\\(a - bj\\\\).\n\nFor example:\n\n```\n# tensor \'in\' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.conj(in) ==> [-2.25 - 4.75j, 3.25 - 5.75j]\n```"
}
op {
  name: "Const"
  output_arg {
    name: "output"
    type_attr: "dtype"
  }
  attr {
    name: "value"
    type: "tensor"
    description: "Attr `value` is the tensor to return."
  }
  attr {
    name: "dtype"
    type: "type"
  }
  summary: "Returns a constant tensor."
}
op {
  name: "ControlTrigger"
  summary: "Does nothing. Serves as a control trigger for scheduling. Only useful as a"
  description: "placeholder for control edges."
}
op {
  name: "Conv2D"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "filter"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`."
  }
  attr {
    name: "use_cudnn_on_gpu"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes a 2-D convolution given 4-D `input` and `filter` tensors."
  description: "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, out_channels]`, this op\nperforms the following:\n\n1. Flattens the filter to a 2-D matrix with shape\n   `[filter_height * filter_width * in_channels, output_channels]`.\n2. Extracts image patches from the the input tensor to form a *virtual*\n   tensor of shape `[batch, out_height, out_width,\n   filter_height * filter_width * in_channels]`.\n3. For each patch, right-multiplies the filter matrix and the image patch\n   vector.\n\nIn detail,\n\n    output[b, i, j, k] =\n        sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *\n                        filter[di, dj, q, k]\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`."
}
op {
  name: "Conv2DBackpropFilter"
  input_arg {
    name: "input"
    description: "4-D with shape `[batch, in_height, in_width, in_channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "filter_sizes"
    description: "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, out_channels]` tensor."
    type: DT_INT32
  }
  input_arg {
    name: "out_backprop"
    description: "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the input\nof the convolution."
  }
  attr {
    name: "use_cudnn_on_gpu"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes the gradients of convolution with respect to the filter."
}
op {
  name: "Conv2DBackpropInput"
  input_arg {
    name: "input_sizes"
    description: "An integer vector representing the shape of `input`,\nwhere `input` is a 4-D `[batch, height, width, channels]` tensor."
    type: DT_INT32
  }
  input_arg {
    name: "filter"
    description: "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "out_backprop"
    description: "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient\nw.r.t. the input of the convolution."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the input\nof the convolution."
  }
  attr {
    name: "use_cudnn_on_gpu"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes the gradients of convolution with respect to the input."
}
op {
  name: "Cos"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes cos of x element-wise."
}
op {
  name: "CountUpTo"
  input_arg {
    name: "ref"
    description: "Should be from a scalar `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "A copy of the input before increment. If nothing else modifies the\ninput, the values produced will all be distinct."
    type_attr: "T"
  }
  attr {
    name: "limit"
    type: "int"
    description: "If incrementing ref would bring it above limit, instead generates an\n\'OutOfRange\' error."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Increments \'ref\' until it reaches \'limit\'."
  description: "This operation outputs \"ref\" after the update is done.  This makes it\neasier to chain operations that need to use the updated value."
}
op {
  name: "DecodeCSV"
  input_arg {
    name: "records"
    description: "Each string is a record/row in the csv and all records should have\nthe same format."
    type: DT_STRING
  }
  input_arg {
    name: "record_defaults"
    description: "One tensor per column of the input record, with either a\nscalar default value for that column or empty if the column is required."
    type_list_attr: "OUT_TYPE"
  }
  output_arg {
    name: "output"
    description: "Each tensor will have the same shape as records."
    type_list_attr: "OUT_TYPE"
  }
  attr {
    name: "OUT_TYPE"
    type: "list(type)"
    has_minimum: true
    minimum: 1
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT32
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "field_delim"
    type: "string"
    default_value {
      s: ","
    }
    description: "delimiter to separate fields in a record."
  }
  summary: "Convert CSV records to tensors. Each column maps to one tensor."
  description: "RFC 4180 format is expected for the CSV records.\n(https://tools.ietf.org/html/rfc4180)\nNote that we allow leading and trailing spaces with int or float field."
}
op {
  name: "DecodeJpeg"
  input_arg {
    name: "contents"
    description: "0-D.  The JPEG-encoded image."
    type: DT_STRING
  }
  output_arg {
    name: "image"
    description: "3-D with shape `[height, width, channels]`.."
    type: DT_UINT8
  }
  attr {
    name: "channels"
    type: "int"
    default_value {
      i: 0
    }
    description: "Number of color channels for the decoded image."
  }
  attr {
    name: "ratio"
    type: "int"
    default_value {
      i: 1
    }
    description: "Downscaling ratio."
  }
  attr {
    name: "fancy_upscaling"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only)."
  }
  attr {
    name: "try_recover_truncated"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true try to recover an image from truncated input."
  }
  attr {
    name: "acceptable_fraction"
    type: "float"
    default_value {
      f: 1
    }
    description: "The minimum required fraction of lines before a truncated\ninput is accepted."
  }
  summary: "Decode a JPEG-encoded image to a uint8 tensor."
  description: "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the JPEG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n\nIf needed, the JPEG-encoded image is transformed to match the requested number\nof color channels.\n\nThe attr `ratio` allows downscaling the image by an integer factor during\ndecoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\ndownscaling the image later."
}
op {
  name: "DecodePng"
  input_arg {
    name: "contents"
    description: "0-D.  The PNG-encoded image."
    type: DT_STRING
  }
  output_arg {
    name: "image"
    description: "3-D with shape `[height, width, channels]`."
    type: DT_UINT8
  }
  attr {
    name: "channels"
    type: "int"
    default_value {
      i: 0
    }
    description: "Number of color channels for the decoded image."
  }
  summary: "Decode a PNG-encoded image to a uint8 tensor."
  description: "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the PNG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n*   4: output an RGBA image.\n\nIf needed, the PNG-encoded image is transformed to match the requested number\nof color channels."
}
op {
  name: "DecodeRaw"
  input_arg {
    name: "bytes"
    description: "All the elements must have the same length."
    type: DT_STRING
  }
  output_arg {
    name: "output"
    description: "A Tensor with one more dimension than the input `bytes`.  The\nadded dimension will have size equal to the length of the elements\nof `bytes` divided by the number of bytes to represent `out_type`."
    type_attr: "out_type"
  }
  attr {
    name: "out_type"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_INT64
      }
    }
  }
  attr {
    name: "little_endian"
    type: "bool"
    default_value {
      b: true
    }
    description: "Whether the input `bytes` are in little-endian order.\nIgnored for `out_type` values that are stored in a single byte like\n`uint8`."
  }
  summary: "Reinterpret the bytes of a string as a vector of numbers."
}
op {
  name: "DeserializeManySparse"
  input_arg {
    name: "serialized_sparse"
    description: "2-D, The `N` serialized `SparseTensor` objects.\nMust have 3 columns."
    type: DT_STRING
  }
  output_arg {
    name: "sparse_indices"
    type: DT_INT64
  }
  output_arg {
    name: "sparse_values"
    type_attr: "dtype"
  }
  output_arg {
    name: "sparse_shape"
    type: DT_INT64
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The `dtype` of the serialized `SparseTensor` objects."
  }
  summary: "Deserialize and concatenate `SparseTensors` from a serialized minibatch."
  description: "The input `serialized_sparse` must be a string matrix of shape `[N x 3]` where\n`N` is the minibatch size and the rows correspond to packed outputs of\n`SerializeSparse`.  The ranks of the original `SparseTensor` objects\nmust all match.  When the final `SparseTensor` is created, it has rank one\nhigher than the ranks of the incoming `SparseTensor` objects\n(they have been concatenated along a new row dimension).\n\nThe output `SparseTensor` object\'s shape values for all dimensions but the\nfirst are the max across the input `SparseTensor` objects\' shape values\nfor the corresponding dimensions.  Its first shape value is `N`, the minibatch\nsize.\n\nThe input `SparseTensor` objects\' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the serialized input is a `[2 x 3]` matrix representing two\noriginal `SparseTensor` objects:\n\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n\nand\n\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n\nthen the final deserialized `SparseTensor` will be:\n\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]"
}
op {
  name: "DestroyTemporaryVariable"
  input_arg {
    name: "ref"
    description: "A reference to the temporary variable tensor."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "value"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "var_name"
    type: "string"
    description: "Name of the temporary variable, usually the name of the matching\n\'TemporaryVariable\' op."
  }
  summary: "Destroys the temporary variable and returns its final value."
  description: "Sets output to the value of the Tensor pointed to by \'ref\', then destroys\nthe temporary variable called \'var_name\'.\nAll other uses of \'ref\' *must* have executed before this op.\nThis is typically achieved by chaining the ref through each assign op, or by\nusing control dependencies.\n\nOutputs the final value of the tensor pointed to by \'ref\'."
}
op {
  name: "Diag"
  input_arg {
    name: "diagonal"
    description: "Rank k tensor where k is at most 3."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns a diagonal tensor with a given diagonal values."
  description: "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has dimensions [D1,..., Dk], then the output is a tensor of\nrank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:\n\n`output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]` and 0 everywhere else.\n\nFor example:\n\n```prettyprint\n# \'diagonal\' is [1, 2, 3, 4]\ntf.diag(diagonal) ==> [[1, 0, 0, 0]\n                       [0, 2, 0, 0]\n                       [0, 0, 3, 0]\n                       [0, 0, 0, 4]]\n```"
}
op {
  name: "Div"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
      }
    }
  }
  summary: "Returns x / y element-wise."
}
op {
  name: "DynamicPartition"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "partitions"
    description: "Any shape.  Indices in the range `[0, num_partitions)`."
    type: DT_INT32
  }
  output_arg {
    name: "outputs"
    type_attr: "T"
    number_attr: "num_partitions"
  }
  attr {
    name: "num_partitions"
    type: "int"
    description: "The number of partitions to output."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Partitions `data` into `num_partitions` tensors using indices from `partitions`."
  description: "For each index tuple `js` of size `partitions.ndim`, the slice `data[js, ...]`\nbecomes part of `outputs[partitions[js]]`.  The slices with `partitions[js] = i`\nare placed in `outputs[i]` in lexicographic order of `js`, and the first\ndimension of `outputs[i]` is the number of entries in `partitions` equal to `i`.\nIn detail,\n\n    outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]\n\n    outputs[i] = pack([data[js, ...] for js if partitions[js] == i])\n\n`data.shape` must start with `partitions.shape`.\n\nFor example:\n\n    # Scalar partitions\n    partitions = 1\n    num_partitions = 2\n    data = [10, 20]\n    outputs[0] = []  # Empty with shape [0, 2]\n    outputs[1] = [[10, 20]]\n\n    # Vector partitions\n    partitions = [0, 0, 1, 1, 0]\n    num_partitions = 2\n    data = [10, 20, 30, 40, 50]\n    outputs[0] = [10, 20, 50]\n    outputs[1] = [30, 40]\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/DynamicPartition.png\" alt>\n</div>"
}
op {
  name: "DynamicStitch"
  input_arg {
    name: "indices"
    type: DT_INT32
    number_attr: "N"
  }
  input_arg {
    name: "data"
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "merged"
    type_attr: "T"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 2
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Interleave the values from the `data` tensors into a single tensor."
  description: "Builds a merged tensor such that\n\n    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n\nFor example, if each `indices[m]` is scalar or vector, we have\n\n    # Scalar indices\n    merged[indices[m], ...] = data[m][...]\n\n    # Vector indices\n    merged[indices[m][i], ...] = data[m][i, ...]\n\nEach `data[i].shape` must start with the corresponding `indices[i].shape`,\nand the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we\nmust have `data[i].shape = indices[i].shape + constant`.  In terms of this\n`constant`, the output shape is\n\n    merged.shape = [max(indices)] + constant\n\nValues are merged in order, so if an index appears in both `indices[m][i]` and\n`indices[n][j]` for `(m,i) < (n,j)` the slice `data[n][j]` will appear in the\nmerged result.\n\nFor example:\n\n    indices[0] = 6\n    indices[1] = [4, 1]\n    indices[2] = [[5, 2], [0, 3]]\n    data[0] = [61, 62]\n    data[1] = [[41, 42], [11, 12]]\n    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/DynamicStitch.png\" alt>\n</div>"
}
op {
  name: "EditDistance"
  input_arg {
    name: "hypothesis_indices"
    description: "The indices of the hypothesis list SparseTensor.\nThis is an N x R int64 matrix."
    type: DT_INT64
  }
  input_arg {
    name: "hypothesis_values"
    description: "The values of the hypothesis list SparseTensor.\nThis is an N-length vector."
    type_attr: "T"
  }
  input_arg {
    name: "hypothesis_shape"
    description: "The shape of the hypothesis list SparseTensor.\nThis is an R-length vector."
    type: DT_INT64
  }
  input_arg {
    name: "truth_indices"
    description: "The indices of the truth list SparseTensor.\nThis is an M x R int64 matrix."
    type: DT_INT64
  }
  input_arg {
    name: "truth_values"
    description: "The values of the truth list SparseTensor.\nThis is an M-length vector."
    type_attr: "T"
  }
  input_arg {
    name: "truth_shape"
    description: "truth indices, vector."
    type: DT_INT64
  }
  output_arg {
    name: "output"
    description: "A dense float tensor with rank R - 1.\n\nFor the example input:\n\n    // hypothesis represents a 2x1 matrix with variable-length values:\n    //   (0,0) = [\"a\"]\n    //   (1,0) = [\"b\"]\n    hypothesis_indices = [[0, 0, 0],\n                          [1, 0, 0]]\n    hypothesis_values = [\"a\", \"b\"]\n    hypothesis_shape = [2, 1, 1]\n\n    // truth represents a 2x2 matrix with variable-length values:\n    //   (0,0) = []\n    //   (0,1) = [\"a\"]\n    //   (1,0) = [\"b\", \"c\"]\n    //   (1,1) = [\"a\"]\n    truth_indices = [[0, 1, 0],\n                     [1, 0, 0],\n                     [1, 0, 1],\n                     [1, 1, 0]]\n    truth_values = [\"a\", \"b\", \"c\", \"a\"]\n    truth_shape = [2, 2, 2]\n    normalize = true\n\nThe output will be:\n\n    // output is a 2x2 matrix with edit distances normalized by truth lengths.\n    output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis\n              [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis"
    type: DT_FLOAT
  }
  attr {
    name: "normalize"
    type: "bool"
    default_value {
      b: true
    }
    description: "boolean (if true, edit distances are normalized by length of truth).\n\nThe output is:"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Computes the (possibly normalized) Levenshtein Edit Distance."
  description: "The inputs are variable-length sequences provided by SparseTensors\n  (hypothesis_indices, hypothesis_values, hypothesis_shape)\nand\n  (truth_indices, truth_values, truth_shape).\n\nThe inputs are:"
}
op {
  name: "Elu"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes exponential linear: `exp(features) - 1` if < 0, `features` otherwise."
  description: "See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)\n](http://arxiv.org/abs/1511.07289)"
}
op {
  name: "EluGrad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding Elu operation."
    type_attr: "T"
  }
  input_arg {
    name: "outputs"
    description: "The outputs of the corresponding Elu operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients: `gradients * (outputs + 1)` if outputs < 0,\n`gradients` otherwise."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes gradients for the exponential linear (Elu) operation."
}
op {
  name: "EncodeJpeg"
  input_arg {
    name: "image"
    description: "3-D with shape `[height, width, channels]`."
    type: DT_UINT8
  }
  output_arg {
    name: "contents"
    description: "0-D. JPEG-encoded image."
    type: DT_STRING
  }
  attr {
    name: "format"
    type: "string"
    default_value {
      s: ""
    }
    description: "Per pixel image format."
    allowed_values {
      list {
        s: ""
        s: "grayscale"
        s: "rgb"
      }
    }
  }
  attr {
    name: "quality"
    type: "int"
    default_value {
      i: 95
    }
    description: "Quality of the compression from 0 to 100 (higher is better and slower)."
  }
  attr {
    name: "progressive"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, create a JPEG that loads progressively (coarse to fine)."
  }
  attr {
    name: "optimize_size"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, spend CPU/RAM to reduce size with no quality change."
  }
  attr {
    name: "chroma_downsampling"
    type: "bool"
    default_value {
      b: true
    }
    description: "See http://en.wikipedia.org/wiki/Chroma_subsampling."
  }
  attr {
    name: "density_unit"
    type: "string"
    default_value {
      s: "in"
    }
    description: "Unit used to specify `x_density` and `y_density`:\npixels per inch (`\'in\'`) or centimeter (`\'cm\'`)."
    allowed_values {
      list {
        s: "in"
        s: "cm"
      }
    }
  }
  attr {
    name: "x_density"
    type: "int"
    default_value {
      i: 300
    }
    description: "Horizontal pixels per density unit."
  }
  attr {
    name: "y_density"
    type: "int"
    default_value {
      i: 300
    }
    description: "Vertical pixels per density unit."
  }
  attr {
    name: "xmp_metadata"
    type: "string"
    default_value {
      s: ""
    }
    description: "If not empty, embed this XMP metadata in the image header."
  }
  summary: "JPEG-encode an image."
  description: "`image` is a 3-D uint8 Tensor of shape `[height, width, channels]`.\n\nThe attr `format` can be used to override the color format of the encoded\noutput.  Values can be:\n\n*   `\'\'`: Use a default format based on the number of channels in the image.\n*   `grayscale`: Output a grayscale JPEG image.  The `channels` dimension\n    of `image` must be 1.\n*   `rgb`: Output an RGB JPEG image. The `channels` dimension\n    of `image` must be 3.\n\nIf `format` is not specified or is the empty string, a default format is picked\nin function of the number of channels in `image`:\n\n*   1: Output a grayscale image.\n*   3: Output an RGB image."
}
op {
  name: "EncodePng"
  input_arg {
    name: "image"
    description: "3-D with shape `[height, width, channels]`."
    type: DT_UINT8
  }
  output_arg {
    name: "contents"
    description: "0-D. PNG-encoded image."
    type: DT_STRING
  }
  attr {
    name: "compression"
    type: "int"
    default_value {
      i: -1
    }
    description: "Compression level."
  }
  summary: "PNG-encode an image."
  description: "`image` is a 3-D uint8 Tensor of shape `[height, width, channels]` where\n`channels` is:\n\n*   1: for grayscale.\n*   3: for RGB.\n*   4: for RGBA.\n\nThe ZLIB compression level, `compression`, can be -1 for the PNG-encoder\ndefault or a value from 0 to 9.  9 is the highest compression level, generating\nthe smallest output, but is slower."
}
op {
  name: "Enter"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the child frame."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "frame_name"
    type: "string"
    description: "The name of the child frame."
  }
  attr {
    name: "is_constant"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, the output is constant within the child frame."
  }
  attr {
    name: "parallel_iterations"
    type: "int"
    default_value {
      i: 10
    }
    description: "The number of iterations allowed to run in parallel."
  }
  summary: "Creates or finds a child frame, and makes `data` available to the child frame."
  description: "This op is used together with `Exit` to create loops in the graph.\nThe unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame."
}
op {
  name: "Equal"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
        type: DT_QUINT8
        type: DT_QINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Returns the truth value of (x == y) element-wise."
  is_commutative: true
}
op {
  name: "Exit"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the parent frame."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Exits the current frame to its parent frame."
  description: "Exit makes its input `data` available to the parent frame."
}
op {
  name: "Exp"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes exponential of x element-wise.  \\\\(y = e^x\\\\)."
}
op {
  name: "ExpandDims"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "dim"
    description: "0-D (scalar). Specifies the dimension index at which to\nexpand the shape of `input`."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Contains the same data as `input`, but its shape has an additional\ndimension of size 1 added."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Inserts a dimension of 1 into a tensor\'s shape."
  description: "Given a tensor `input`, this operation inserts a dimension of 1 at the\ndimension index `dim` of `input`\'s shape. The dimension index `dim` starts at\nzero; if you specify a negative number for `dim` it is counted backward from\nthe end.\n\nThis operation is useful if you want to add a batch dimension to a single\nelement. For example, if you have a single image of shape `[height, width,\nchannels]`, you can make it a batch of 1 image with `expand_dims(image, 0)`,\nwhich will make the shape `[1, height, width, channels]`.\n\nOther examples:\n\n```prettyprint\n# \'t\' is a tensor of shape [2]\nshape(expand_dims(t, 0)) ==> [1, 2]\nshape(expand_dims(t, 1)) ==> [2, 1]\nshape(expand_dims(t, -1)) ==> [2, 1]\n\n# \'t2\' is a tensor of shape [2, 3, 5]\nshape(expand_dims(t2, 0)) ==> [1, 2, 3, 5]\nshape(expand_dims(t2, 2)) ==> [2, 3, 1, 5]\nshape(expand_dims(t2, 3)) ==> [2, 3, 5, 1]\n```\n\nThis operation requires that:\n\n`-1-input.dims() <= dim <= input.dims()`\n\nThis operation is related to `squeeze()`, which removes dimensions of\nsize 1."
}
op {
  name: "ExtractGlimpse"
  input_arg {
    name: "input"
    description: "A 4-D float tensor of shape `[batch_size, height, width, channels]`."
    type: DT_FLOAT
  }
  input_arg {
    name: "size"
    description: "A 1-D tensor of 2 elements containing the size of the glimpses to extract.\nThe glimpse height must be specified first, following by the glimpse width."
    type: DT_INT32
  }
  input_arg {
    name: "offsets"
    description: "A 2-D integer tensor of shape `[batch_size, 2]` containing the x, y\nlocations of the center of each window."
    type: DT_FLOAT
  }
  output_arg {
    name: "glimpse"
    description: "A tensor representing the glimpses `[batch_size, glimpse_height,\nglimpse_width, channels]`."
    type: DT_FLOAT
  }
  attr {
    name: "centered"
    type: "bool"
    default_value {
      b: true
    }
    description: "indicates if the offset coordinates are centered relative to\nthe image, in which case the (0, 0) offset is relative to the center of the\ninput images. If false, the (0,0) offset corresponds to the upper left corner\nof the input images."
  }
  attr {
    name: "normalized"
    type: "bool"
    default_value {
      b: true
    }
    description: "indicates if the offset coordinates are normalized."
  }
  attr {
    name: "uniform_noise"
    type: "bool"
    default_value {
      b: true
    }
    description: "indicates if the noise should be generated using a\nuniform distribution or a gaussian distribution."
  }
  summary: "Extracts a glimpse from the input tensor."
  description: "Returns a set of windows called glimpses extracted at location `offsets`\nfrom the input tensor. If the windows only partially overlaps the inputs, the\nnon overlapping areas will be filled with random noise.\n\nThe result is a 4-D tensor of shape `[batch_size, glimpse_height,\nglimpse_width, channels]`. The channels and batch dimensions are the same as that\nof the input tensor. The height and width of the output windows are\nspecified in the `size` parameter.\n\nThe argument `normalized` and `centered` controls how the windows are built:\n* If the coordinates are normalized but not centered, 0.0 and 1.0\n  correspond to the minimum and maximum of each height and width dimension.\n* If the coordinates are both normalized and centered, they range from -1.0 to\n  1.0. The coordinates (-1.0, -1.0) correspond to the upper left corner, the\n  lower right corner is located at  (1.0, 1.0) and the center is at (0, 0).\n* If the coordinates are not normalized they are interpreted as numbers of pixels."
}
op {
  name: "FIFOQueue"
  output_arg {
    name: "handle"
    description: "The handle to the queue."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a value."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "shapes"
    type: "list(shape)"
    default_value {
      list {
      }
    }
    description: "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time."
    has_minimum: true
  }
  attr {
    name: "capacity"
    type: "int"
    default_value {
      i: -1
    }
    description: "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue will be shared under the given name\nacross multiple sessions."
  }
  summary: "A queue that produces elements in first-in first-out order."
  is_stateful: true
}
op {
  name: "Fact"
  output_arg {
    name: "fact"
    type: DT_STRING
  }
  summary: "Output a fact about factorials."
}
op {
  name: "Fill"
  input_arg {
    name: "dims"
    description: "1-D. Represents the shape of the output tensor."
    type: DT_INT32
  }
  input_arg {
    name: "value"
    description: "0-D (scalar). Value to fill the returned tensor."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Creates a tensor filled with a scalar value."
  description: "This operation creates a tensor of shape `dims` and fills it with `value`.\n\nFor example:\n\n```prettyprint\n# output tensor shape needs to be [2, 3]\n# so \'dims\' is [2, 3]\nfill(dims, 9) ==> [[9, 9, 9]\n                   [9, 9, 9]]\n```"
}
op {
  name: "FixedLengthRecordReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "header_bytes"
    type: "int"
    default_value {
      i: 0
    }
  }
  attr {
    name: "record_bytes"
    type: "int"
  }
  attr {
    name: "footer_bytes"
    type: "int"
    default_value {
      i: 0
    }
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs fixed-length records from a file."
  is_stateful: true
}
op {
  name: "FixedUnigramCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate represting the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "vocab_file"
    type: "string"
    default_value {
      s: ""
    }
    description: "Each valid line in this file (which should have a CSV-like format)\ncorresponds to a valid word ID. IDs are in sequential order, starting from\nnum_reserved_ids. The last entry in each line is expected to be a value\ncorresponding to the count or relative probability. Exactly one of vocab_file\nand unigrams needs to be passed to this op."
  }
  attr {
    name: "distortion"
    type: "float"
    default_value {
      f: 1
    }
    description: "The distortion is used to skew the unigram probability distribution.\nEach weight is first raised to the distortion\'s power before adding to the\ninternal unigram distribution. As a result, distortion = 1.0 gives regular\nunigram sampling (as defined by the vocab file), and distortion = 0.0 gives\na uniform distribution."
  }
  attr {
    name: "num_reserved_ids"
    type: "int"
    default_value {
      i: 0
    }
    description: "Optionally some reserved IDs can be added in the range [0,\n..., num_reserved_ids) by the users. One use case is that a special unknown\nword token is used as ID 0. These IDs will have a sampling probability of 0."
  }
  attr {
    name: "num_shards"
    type: "int"
    default_value {
      i: 1
    }
    description: "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with \'shard\') indicates the number of partitions that are being\nused in the overall computation."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "shard"
    type: "int"
    default_value {
      i: 0
    }
    description: "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with \'num_shards\') indicates the particular partition number of a\nsampler op, when partitioning is being used."
    has_minimum: true
  }
  attr {
    name: "unigrams"
    type: "list(float)"
    default_value {
      list {
      }
    }
    description: "A list of unigram counts or probabilities, one per ID in sequential\norder. Exactly one of vocab_file and unigrams should be passed to this op."
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a learned unigram distribution."
  description: "A unigram sampler could use a fixed unigram distribution read from a\nfile or passed in as an in-memory array instead of building up the distribution\nfrom data on the fly. There is also an option to skew the distribution by\napplying a distortion power to the weights.\n\nThe vocabulary file should be in CSV-like format, with the last field\nbeing the weight associated with the word.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Floor"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns element-wise largest integer not greater than x."
}
op {
  name: "Gather"
  input_arg {
    name: "params"
    type_attr: "Tparams"
  }
  input_arg {
    name: "indices"
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    type_attr: "Tparams"
  }
  attr {
    name: "Tparams"
    type: "type"
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Gather slices from `params` according to `indices`."
  description: "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `indices.shape + params.shape[1:]` where:\n\n    # Scalar indices\n    output[:, ..., :] = params[indices, :, ... :]\n\n    # Vector indices\n    output[i, :, ..., :] = params[indices[i], :, ... :]\n\n    # Higher rank indices\n    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n\nIf `indices` is a permutation and `len(indices) == params.shape[0]` then\nthis operation will permute `params` accordingly.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/Gather.png\" alt>\n</div>"
}
op {
  name: "Greater"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the truth value of (x > y) element-wise."
}
op {
  name: "GreaterEqual"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the truth value of (x >= y) element-wise."
}
op {
  name: "HSVToRGB"
  input_arg {
    name: "images"
    description: "1-D or higher rank. HSV data to convert. Last dimension must be size 3."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "`images` converted to RGB."
    type: DT_FLOAT
  }
  summary: "Convert one or more images from HSV to RGB."
  description: "Outputs a tensor of the same shape as the `images` tensor, containing the RGB\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\nSee `rgb_to_hsv` for a description of the HSV encoding."
}
op {
  name: "HashTable"
  output_arg {
    name: "table_handle"
    description: "Handle to a table."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this table is shared under the given name across\nmultiple sessions."
  }
  attr {
    name: "key_dtype"
    type: "type"
    description: "Type of the table keys."
  }
  attr {
    name: "value_dtype"
    type: "type"
    description: "Type of the table values."
  }
  summary: "Creates a non-initialized hash table."
  description: "This op creates a hash table, specifying the type of its keys and values.\nBefore using the table you will have to initialize it.  After initialization the\ntable will be immutable."
}
op {
  name: "HistogramSummary"
  input_arg {
    name: "tag"
    description: "Scalar.  Tag to use for the `Summary.Value`."
    type: DT_STRING
  }
  input_arg {
    name: "values"
    description: "Any shape. Values to use to build the histogram."
    type_attr: "T"
  }
  output_arg {
    name: "summary"
    description: "Scalar. Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
    default_value {
      type: DT_FLOAT
    }
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Outputs a `Summary` protocol buffer with a histogram."
  description: "The generated\n[`Summary`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/summary.proto)\nhas one summary value containing a histogram for `values`.\n\nThis op reports an `OutOfRange` error if any value is not finite."
}
op {
  name: "Identity"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Return a tensor with the same shape and contents as the input tensor or value."
}
op {
  name: "IdentityReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs the queued work as both the key and value."
  description: "To use, enqueue strings in a Queue.  ReaderRead will take the front\nwork string and output (work, work)."
  is_stateful: true
}
op {
  name: "Imag"
  input_arg {
    name: "in"
    type: DT_COMPLEX64
  }
  output_arg {
    name: "out"
    type: DT_FLOAT
  }
  summary: "Returns the imaginary part of a complex number."
  description: "Given a tensor `in` of complex numbers, this operation returns a tensor of type\n`float` that is the imaginary part of each element in `in`. All elements in `in`\nmust be complex numbers of the form \\\\(a + bj\\\\), where *a* is the real part\nand *b* is the imaginary part returned by this operation.\n\nFor example:\n\n```\n# tensor \'in\' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.imag(in) ==> [4.75, 5.75]\n```"
}
op {
  name: "ImageSummary"
  input_arg {
    name: "tag"
    description: "Scalar. Used to build the `tag` attribute of the summary values."
    type: DT_STRING
  }
  input_arg {
    name: "tensor"
    description: "4-D of shape `[batch_size, height, width, channels]` where\n`channels` is 1, 3, or 4."
    type_attr: "T"
  }
  output_arg {
    name: "summary"
    description: "Scalar. Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "max_images"
    type: "int"
    default_value {
      i: 3
    }
    description: "Max number of batch elements to generate images for."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
    default_value {
      type: DT_FLOAT
    }
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_FLOAT
      }
    }
  }
  attr {
    name: "bad_color"
    type: "tensor"
    default_value {
      tensor {
        dtype: DT_UINT8
        tensor_shape {
          dim {
            size: 4
          }
        }
        int_val: 255
        int_val: 0
        int_val: 0
        int_val: 255
      }
    }
    description: "Color to use for pixels with non-finite values."
  }
  summary: "Outputs a `Summary` protocol buffer with images."
  description: "The summary has up to `max_images` summary values containing images. The\nimages are built from `tensor` which must be 4-D with shape `[batch_size,\nheight, width, channels]` and where `channels` can be:\n\n*  1: `tensor` is interpreted as Grayscale.\n*  3: `tensor` is interpreted as RGB.\n*  4: `tensor` is interpreted as RGBA.\n\nThe images have the same number of channels as the input tensor. For float\ninput, the values are normalized one image at a time to fit in the range\n`[0, 255]`.  `uint8` values are unchanged.  The op uses two different\nnormalization algorithms:\n\n*  If the input values are all positive, they are rescaled so the largest one\n   is 255.\n\n*  If any input value is negative, the values are shifted so input value 0.0\n   is at 127.  They are then rescaled so that either the smallest value is 0,\n   or the largest one is 255.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_images` is 1, the summary value tag is \'*tag*/image\'.\n*  If `max_images` is greater than 1, the summary value tags are\n   generated sequentially as \'*tag*/image/0\', \'*tag*/image/1\', etc.\n\nThe `bad_color` argument is the color to use in the generated images for\nnon-finite input values.  It is a `unit8` 1-D tensor of length `channels`.\nEach element must be in the range `[0, 255]` (It represents the value of a\npixel in the output image).  Non-finite values in the input tensor are\nreplaced by this tensor in the output image.  The default value is the color\nred."
}
op {
  name: "InTopK"
  input_arg {
    name: "predictions"
    description: "A `batch_size` x `classes` tensor."
    type: DT_FLOAT
  }
  input_arg {
    name: "targets"
    description: "A `batch_size` vector of class ids."
    type_attr: "T"
  }
  output_arg {
    name: "precision"
    description: "Computed Precision at `k` as a `bool Tensor`."
    type: DT_BOOL
  }
  attr {
    name: "k"
    type: "int"
    description: "Number of top elements to look at for computing precision."
  }
  attr {
    name: "T"
    type: "type"
    default_value {
      type: DT_INT32
    }
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Says whether the targets are in the top `K` predictions."
  description: "This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the\nprediction for the target class is among the top `k` predictions among\nall predictions for example `i`. Note that the behavior of `InTopK` differs\nfrom the `TopK` op in its handling of ties; if multiple classes have the\nsame prediction value and straddle the top-`k` boundary, all of those\nclasses are considered to be in the top `k`.\n\nMore formally, let\n\n  \\\\(predictions_i\\\\) be the predictions for all classes for example `i`,\n  \\\\(targets_i\\\\) be the target class for example `i`,\n  \\\\(out_i\\\\) be the output for example `i`,\n\n$$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$"
}
op {
  name: "InitializeTable"
  input_arg {
    name: "table_handle"
    description: "Handle to a table which will be initialized."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "keys"
    description: "Keys of type Tkey."
    type_attr: "Tkey"
  }
  input_arg {
    name: "values"
    description: "Values of type Tval. Same shape as `keys`."
    type_attr: "Tval"
  }
  attr {
    name: "Tkey"
    type: "type"
  }
  attr {
    name: "Tval"
    type: "type"
  }
  summary: "Table initializer that takes two tensors for keys and values respectively."
}
op {
  name: "Inv"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes the reciprocal of x element-wise."
  description: "I.e., \\\\(y = 1 / x\\\\)."
}
op {
  name: "InvertPermutation"
  input_arg {
    name: "x"
    description: "1-D."
    type: DT_INT32
  }
  output_arg {
    name: "y"
    description: "1-D."
    type: DT_INT32
  }
  summary: "Computes the inverse permutation of a tensor."
  description: "This operation computes the inverse of an index permutation. It takes a 1-D\ninteger tensor `x`, which represents the indices of a zero-based array, and\nswaps each value with its index position. In other words, for an ouput tensor\n`y` and an input tensor `x`, this operation computes the following:\n\n`y[x[i]] = i for i in [0, 1, ..., len(x) - 1]`\n\nThe values must include 0. There can be no duplicate values or negative values.\n\nFor example:\n\n```prettyprint\n# tensor `x` is [3, 4, 0, 2, 1]\ninvert_permutation(x) ==> [2, 4, 3, 0, 1]\n```"
}
op {
  name: "IsFinite"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns which elements of x are finite."
}
op {
  name: "IsInf"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns which elements of x are Inf."
}
op {
  name: "IsNan"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns which elements of x are NaN."
}
op {
  name: "L2Loss"
  input_arg {
    name: "t"
    description: "Typically 2-D, but may have any dimensions."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "0-D."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "L2 Loss."
  description: "Computes half the L2 norm of a tensor without the `sqrt`:\n\n    output = sum(t ** 2) / 2"
}
op {
  name: "LRN"
  input_arg {
    name: "input"
    description: "4-D."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    type: DT_FLOAT
  }
  attr {
    name: "depth_radius"
    type: "int"
    default_value {
      i: 5
    }
    description: "0-D.  Half-width of the 1-D normalization window."
  }
  attr {
    name: "bias"
    type: "float"
    default_value {
      f: 1
    }
    description: "An offset (usually positive to avoid dividing by 0)."
  }
  attr {
    name: "alpha"
    type: "float"
    default_value {
      f: 1
    }
    description: "A scale factor, usually positive."
  }
  attr {
    name: "beta"
    type: "float"
    default_value {
      f: 0.5
    }
    description: "An exponent."
  }
  summary: "Local Response Normalization."
  description: "The 4-D `input` tensor is treated as a 3-D array of 1-D vectors (along the last\ndimension), and each vector is normalized independently.  Within a given vector,\neach component is divided by the weighted, squared sum of inputs within\n`depth_radius`.  In detail,\n\n    sqr_sum[a, b, c, d] =\n        sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)\n    output = input / (bias + alpha * sqr_sum ** beta)\n\nFor details, see [Krizhevsky et al., ImageNet classification with deep\nconvolutional neural networks (NIPS 2012)]\n(http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks)."
}
op {
  name: "LRNGrad"
  input_arg {
    name: "input_grads"
    description: "4-D with shape `[batch, height, width, channels]`."
    type: DT_FLOAT
  }
  input_arg {
    name: "input_image"
    description: "4-D with shape `[batch, height, width, channels]`."
    type: DT_FLOAT
  }
  input_arg {
    name: "output_image"
    description: "4-D with shape `[batch, height, width, channels]`."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "The gradients for LRN."
    type: DT_FLOAT
  }
  attr {
    name: "depth_radius"
    type: "int"
    default_value {
      i: 5
    }
    description: "A depth radius."
  }
  attr {
    name: "bias"
    type: "float"
    default_value {
      f: 1
    }
    description: "An offset (usually > 0 to avoid dividing by 0)."
  }
  attr {
    name: "alpha"
    type: "float"
    default_value {
      f: 1
    }
    description: "A scale factor, usually positive."
  }
  attr {
    name: "beta"
    type: "float"
    default_value {
      f: 0.5
    }
    description: "An exponent."
  }
  summary: "Gradients for Local Response Normalization."
}
op {
  name: "LearnedUnigramCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate represting the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a learned unigram distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Less"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the truth value of (x < y) element-wise."
}
op {
  name: "LessEqual"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the truth value of (x <= y) element-wise."
}
op {
  name: "LinSpace"
  input_arg {
    name: "start"
    description: "First entry in the range."
    type_attr: "T"
  }
  input_arg {
    name: "stop"
    description: "Last entry in the range."
    type_attr: "T"
  }
  input_arg {
    name: "num"
    description: "Number of values to generate."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "1-D. The generated values."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Generates values in an interval."
  description: "A sequence of `num` evenly-spaced values are generated beginning at `start`.\nIf `num > 1`, the values in the sequence increase by `stop - start / num - 1`,\nso that the last one is exactly `stop`.\n\nFor example:\n\n```\ntf.linspace(10.0, 12.0, 3, name=\"linspace\") => [ 10.0  11.0  12.0]\n```"
}
op {
  name: "ListDiff"
  input_arg {
    name: "x"
    description: "1-D. Values to keep."
    type_attr: "T"
  }
  input_arg {
    name: "y"
    description: "1-D. Values to remove."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "1-D. Values present in `x` but not in `y`."
    type_attr: "T"
  }
  output_arg {
    name: "idx"
    description: "1-D. Positions of `x` values preserved in `out`."
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Computes the difference between two lists of numbers or strings."
  description: "Given a list `x` and a list `y`, this operation returns a list `out` that\nrepresents all values that are in `x` but not in `y`. The returned list `out`\nis sorted in the same order that the numbers appear in `x` (duplicates are\npreserved). This operation also returns a list `idx` that represents the\nposition of each `out` element in `x`. In other words:\n\n`out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]`\n\nFor example, given this input:\n\n```prettyprint\nx = [1, 2, 3, 4, 5, 6]\ny = [1, 3, 5]\n```\n\nThis operation would return:\n\n```prettyprint\nout ==> [2, 4, 6]\nidx ==> [1, 3, 5]\n```"
}
op {
  name: "Log"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes natural logrithm of x element-wise."
  description: "I.e., \\\\(y = \\log_e x\\\\)."
}
op {
  name: "LogUniformCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate represting the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a log-uniform distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "LogicalAnd"
  input_arg {
    name: "x"
    type: DT_BOOL
  }
  input_arg {
    name: "y"
    type: DT_BOOL
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  summary: "Returns the truth value of x AND y element-wise."
  is_commutative: true
}
op {
  name: "LogicalNot"
  input_arg {
    name: "x"
    type: DT_BOOL
  }
  output_arg {
    name: "y"
    type: DT_BOOL
  }
  summary: "Returns the truth value of NOT x element-wise."
}
op {
  name: "LogicalOr"
  input_arg {
    name: "x"
    type: DT_BOOL
  }
  input_arg {
    name: "y"
    type: DT_BOOL
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  summary: "Returns the truth value of x OR y element-wise."
  is_commutative: true
}
op {
  name: "LookupTableFind"
  input_arg {
    name: "table_handle"
    description: "Handle to the table."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "keys"
    description: "Any shape.  Keys to look up."
    type_attr: "Tin"
  }
  input_arg {
    name: "default_value"
    type_attr: "Tout"
  }
  output_arg {
    name: "values"
    description: "Same shape as `keys`.  Values found in the table, or `default_values`\nfor missing keys."
    type_attr: "Tout"
  }
  attr {
    name: "Tin"
    type: "type"
  }
  attr {
    name: "Tout"
    type: "type"
  }
  summary: "Looks up keys in a table, outputs the corresponding values."
  description: "The tensor `keys` must of the same type as the keys of the table.\nThe output `values` is of the type of the table values.\n\nThe scalar `default_value` is the value output for keys not present in the\ntable. It must also be of the same type as the table values."
}
op {
  name: "LookupTableSize"
  input_arg {
    name: "table_handle"
    description: "Handle to the table."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "size"
    description: "Scalar that contains number of elements in the table."
    type: DT_INT64
  }
  summary: "Computes the number of elements in the given table."
}
op {
  name: "LoopCond"
  input_arg {
    name: "input"
    description: "= A boolean scalar, representing the branch predicate of the Switch op."
    type: DT_BOOL
  }
  output_arg {
    name: "output"
    description: "The same tensor as `input`."
    type: DT_BOOL
  }
  summary: "Forwards the input to the output."
  description: "This operator represents the loop termination condition used by the\n\"pivot\" switches of a loop."
}
op {
  name: "MatMul"
  input_arg {
    name: "a"
    type_attr: "T"
  }
  input_arg {
    name: "b"
    type_attr: "T"
  }
  output_arg {
    name: "product"
    type_attr: "T"
  }
  attr {
    name: "transpose_a"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, \"a\" is transposed before multiplication."
  }
  attr {
    name: "transpose_b"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, \"b\" is transposed before multiplication."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
      }
    }
  }
  summary: "Multiply the matrix \"a\" by the matrix \"b\"."
  description: "The inputs must be two-dimensional matrices and the inner dimension of\n\"a\" (after being transposed if transpose_a is true) must match the\nouter dimension of \"b\" (after being transposed if transposed_b is\ntrue).\n\n*Note*: The default kernel implementation for MatMul on GPUs uses\ncublas."
}
op {
  name: "MatchingFiles"
  input_arg {
    name: "pattern"
    description: "A (scalar) shell wildcard pattern."
    type: DT_STRING
  }
  output_arg {
    name: "filenames"
    description: "A vector of matching filenames."
    type: DT_STRING
  }
  summary: "Returns the set of files matching a pattern."
  description: "Note that this routine only supports wildcard characters in the\nbasename portion of the pattern, not in the directory portion."
}
op {
  name: "MatrixDeterminant"
  input_arg {
    name: "input"
    description: "A tensor of shape `[M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A scalar, equal to the determinant of the input."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    description: "The type of values in the input and output."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Calculates the determinant of a square matrix."
}
op {
  name: "MatrixInverse"
  input_arg {
    name: "input"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[M, M]` containing the matrix inverse of the input."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    description: "The type of values in the input and output."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Calculates the inverse of a square invertible matrix."
  description: "The op uses the Cholesky decomposition if the matrix is symmetric positive\ndefinite and LU decomposition with partial pivoting otherwise.\n\nIf the matrix is not invertible there is no guarantee what the op does. It\nmay detect the condition and raise an exception or it may simply return a\ngarbage result."
}
op {
  name: "Max"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Computes the maximum of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "MaxPool"
  input_arg {
    name: "input"
    description: "4-D input to pool over."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "The max pooled output tensor."
    type: DT_FLOAT
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the window for each dimension of the input tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the\ninput tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Performs max pooling on the input."
}
op {
  name: "MaxPoolGrad"
  input_arg {
    name: "orig_input"
    description: "The original input tensor."
    type: DT_FLOAT
  }
  input_arg {
    name: "orig_output"
    description: "The original output tensor."
    type: DT_FLOAT
  }
  input_arg {
    name: "grad"
    description: "4-D.  Gradients w.r.t. the output of `max_pool`."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "Gradients w.r.t. the input to `max_pool`."
    type: DT_FLOAT
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the window for each dimension of the input tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the\ninput tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes gradients of the maxpooling function."
}
op {
  name: "MaxPoolGradWithArgmax"
  input_arg {
    name: "input"
    description: "The original input."
    type: DT_FLOAT
  }
  input_arg {
    name: "grad"
    description: "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the\noutput of `max_pool`."
    type: DT_FLOAT
  }
  input_arg {
    name: "argmax"
    description: "The indices of the maximum values chosen for each output of `max_pool`."
    type_attr: "Targmax"
  }
  output_arg {
    name: "output"
    description: "Gradients w.r.t. the input of `max_pool`."
    type: DT_FLOAT
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the window for each dimension of the input tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the\ninput tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "Targmax"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes gradients of the maxpooling function."
}
op {
  name: "MaxPoolWithArgmax"
  input_arg {
    name: "input"
    description: "4-D with shape `[batch, height, width, channels]`.  Input to pool over."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "The max pooled output tensor."
    type: DT_FLOAT
  }
  output_arg {
    name: "argmax"
    description: "4-D.  The flattened indices of the max values chosen for each output."
    type_attr: "Targmax"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the window for each dimension of the input tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the\ninput tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "Targmax"
    type: "type"
    default_value {
      type: DT_INT64
    }
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Performs max pooling on the input and outputs both max values and indices."
  description: "The indices in `argmax` are flattened, so that a maximum value at position\n`[b, y, x, c]` becomes flattened index\n`((b * height + y) * width + x) * channels + c`."
}
op {
  name: "Maximum"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the max of x and y (i.e. x > y ? x : y) element-wise, broadcasts."
  is_commutative: true
}
op {
  name: "Mean"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Computes the mean of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "Merge"
  input_arg {
    name: "inputs"
    description: "The input tensors, exactly one of which will become available."
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "output"
    description: "Will be set to the available input tensor."
    type_attr: "T"
  }
  output_arg {
    name: "value_index"
    description: "The index of the chosen input tensor in `inputs`."
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  summary: "Forwards the value of an available tensor from `inputs` to `output`."
  description: "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor for become available to `output`, and sets\n`value_index` to its index in `inputs`.\n\nIt is an error if more than one tensor in `inputs` is available."
}
op {
  name: "MergeSummary"
  input_arg {
    name: "inputs"
    description: "Can be of any shape.  Each must contain serialized `Summary` protocol\nbuffers."
    type: DT_STRING
    number_attr: "N"
  }
  output_arg {
    name: "summary"
    description: "Scalar. Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  summary: "Merges summaries."
  description: "This op creates a\n[`Summary`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/summary.proto)\nprotocol buffer that contains the union of all the values in the input\nsummaries.\n\nWhen the Op is run, it reports an `InvalidArgument` error if multiple values\nin the summaries to merge use the same tag."
}
op {
  name: "Min"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Computes the minimum of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "Minimum"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the min of x and y (i.e. x < y ? x : y) element-wise, broadcasts."
  is_commutative: true
}
op {
  name: "Mod"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns element-wise remainder of division."
}
op {
  name: "Mul"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
      }
    }
  }
  summary: "Returns x * y element-wise."
  is_commutative: true
}
op {
  name: "Neg"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes numerical negative value element-wise."
  description: "I.e., \\\\(y = -x\\\\)."
}
op {
  name: "NegTrain"
  input_arg {
    name: "w_in"
    description: "input word embedding."
    type: DT_FLOAT
    is_ref: true
  }
  input_arg {
    name: "w_out"
    description: "output word embedding."
    type: DT_FLOAT
    is_ref: true
  }
  input_arg {
    name: "examples"
    description: "A vector of word ids."
    type: DT_INT32
  }
  input_arg {
    name: "labels"
    description: "A vector of word ids."
    type: DT_INT32
  }
  input_arg {
    name: "lr"
    type: DT_FLOAT
  }
  attr {
    name: "vocab_count"
    type: "list(int)"
    description: "Count of words in the vocabulary."
  }
  attr {
    name: "num_negative_samples"
    type: "int"
    description: "Number of negative samples per exaple."
  }
  summary: "Training via negative sampling."
}
op {
  name: "NextIteration"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the next iteration."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Makes its input available to the next iteration."
}
op {
  name: "NoOp"
  summary: "Does nothing. Only useful as a placeholder for control edges."
}
op {
  name: "NotEqual"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
        type: DT_QUINT8
        type: DT_QINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Returns the truth value of (x != y) element-wise."
  is_commutative: true
}
op {
  name: "Pack"
  input_arg {
    name: "values"
    description: "Must be of same shape and type."
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "output"
    description: "The packed tensor."
    type_attr: "T"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor."
  description: "Packs the `N` tensors in `values` into a tensor with rank one higher than each\ntensor in `values` and shape `[N] + values[0].shape`. The output satisfies\n`output[i, ...] = values[i][...]`.\n\nThis is the opposite of `unpack`."
}
op {
  name: "Pad"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "paddings"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Pads a tensor with zeros."
  description: "This operation pads a `input` with zeros according to the `paddings` you\nspecify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the\nrank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many zeros to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many zeros to add after the contents of `input`\nin that dimension.\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```prettyprint\n# \'t\' is [[1, 1], [2, 2]]\n# \'paddings\' is [[1, 1]], [2, 2]]\n# rank of \'t\' is 2\npad(t, paddings) ==> [[0, 0, 0, 0, 0]\n                      [0, 0, 0, 0, 0]\n                      [0, 1, 1, 0, 0]\n                     [[0, 2, 2, 0, 0]\n                      [0, 0, 0, 0, 0]]\n```"
}
op {
  name: "ParseExample"
  input_arg {
    name: "serialized"
    description: "A vector containing a batch of binary serialized Example protos."
    type: DT_STRING
  }
  input_arg {
    name: "names"
    description: "A vector containing the names of the serialized protos.\nMay contain, for example, table key (descriptive) names for the\ncorresponding serialized protos.  These are purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no names are available.\nIf non-empty, this vector must be the same length as \"serialized\"."
    type: DT_STRING
  }
  input_arg {
    name: "sparse_keys"
    description: "A list of Nsparse string Tensors (scalars).\nThe keys expected in the Examples\' features associated with sparse values."
    type: DT_STRING
    number_attr: "Nsparse"
  }
  input_arg {
    name: "dense_keys"
    description: "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples\' features associated with dense values."
    type: DT_STRING
    number_attr: "Ndense"
  }
  input_arg {
    name: "dense_defaults"
    description: "A list of Ndense Tensors (some may be empty).\ndense_defaults[j] provides default values\nwhen the example\'s feature_map lacks dense_key[j].  If an empty Tensor is\nprovided for dense_defaults[j], then the Feature dense_keys[j] is required.\nThe input type is inferred from dense_defaults[j], even when it\'s empty.\nIf dense_defaults[j] is not empty, its shape must match dense_shapes[j]."
    type_list_attr: "Tdense"
  }
  output_arg {
    name: "sparse_indices"
    type: DT_INT64
    number_attr: "Nsparse"
  }
  output_arg {
    name: "sparse_values"
    type_list_attr: "sparse_types"
  }
  output_arg {
    name: "sparse_shapes"
    type: DT_INT64
    number_attr: "Nsparse"
  }
  output_arg {
    name: "dense_values"
    type_list_attr: "Tdense"
  }
  attr {
    name: "Nsparse"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "Ndense"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "sparse_types"
    type: "list(type)"
    description: "A list of Nsparse types; the data types of data in each Feature\ngiven in sparse_keys.\nCurrently the ParseExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList)."
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "Tdense"
    type: "list(type)"
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "dense_shapes"
    type: "list(shape)"
    description: "A list of Ndense shapes; the shapes of data in each Feature\ngiven in dense_keys.\nThe number of elements in the Feature corresponding to dense_key[j]\nmust always equal dense_shapes[j].NumEntries().\nIf dense_shapes[j] == (D0, D1, ..., DN) then the the shape of output\nTensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):\nThe dense outputs are just the inputs row-stacked by batch."
    has_minimum: true
  }
  summary: "Transforms a vector of brain.Example protos (as strings) into typed tensors."
}
op {
  name: "ParseSingleSequenceExample"
  input_arg {
    name: "serialized"
    description: "A scalar containing a binary serialized SequenceExample proto."
    type: DT_STRING
  }
  input_arg {
    name: "feature_list_dense_missing_assumed_empty"
    description: "A vector listing the\nFeatureList keys which may be missing from the SequenceExample.  If the\nassociated FeatureList is missing, it is treated as empty.  By default,\nany FeatureList not listed in this vector must exist in the SequenceExample."
    type: DT_STRING
  }
  input_arg {
    name: "context_sparse_keys"
    description: "A list of Ncontext_sparse string Tensors (scalars).\nThe keys expected in the Examples\' features associated with context_sparse\nvalues."
    type: DT_STRING
    number_attr: "Ncontext_sparse"
  }
  input_arg {
    name: "context_dense_keys"
    description: "A list of Ncontext_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples\' context features associated with\ndense values."
    type: DT_STRING
    number_attr: "Ncontext_dense"
  }
  input_arg {
    name: "feature_list_dense_keys"
    description: "A list of Nfeature_list_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples\' feature_lists associated\nwith lists of dense values."
    type: DT_STRING
    number_attr: "Nfeature_list_dense"
  }
  input_arg {
    name: "context_dense_defaults"
    description: "A list of Ncontext_dense Tensors (some may be empty).\ncontext_dense_defaults[j] provides default values\nwhen the SequenceExample\'s context map lacks context_dense_key[j].\nIf an empty Tensor is provided for context_dense_defaults[j],\nthen the Feature context_dense_keys[j] is required.\nThe input type is inferred from context_dense_defaults[j], even when it\'s\nempty.  If context_dense_defaults[j] is not empty, its shape must match\ncontext_dense_shapes[j]."
    type_list_attr: "Tcontext_dense"
  }
  input_arg {
    name: "debug_name"
    description: "A scalar containing the name of the serialized proto.\nMay contain, for example, table key (descriptive) name for the\ncorresponding serialized proto.  This is purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty scalar if no name is available."
    type: DT_STRING
  }
  output_arg {
    name: "context_sparse_indices"
    type: DT_INT64
    number_attr: "Ncontext_sparse"
  }
  output_arg {
    name: "context_sparse_values"
    type_list_attr: "context_sparse_types"
  }
  output_arg {
    name: "context_sparse_shapes"
    type: DT_INT64
    number_attr: "Ncontext_sparse"
  }
  output_arg {
    name: "context_dense_values"
    type_list_attr: "Tcontext_dense"
  }
  output_arg {
    name: "feature_list_dense_values"
    type_list_attr: "feature_list_dense_types"
  }
  attr {
    name: "Ncontext_sparse"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "Ncontext_dense"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "Nfeature_list_dense"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "context_sparse_types"
    type: "list(type)"
    description: "A list of Ncontext_sparse types; the data types of data in\neach context Feature given in context_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList)."
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "Tcontext_dense"
    type: "list(type)"
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "feature_list_dense_types"
    type: "list(type)"
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "context_dense_shapes"
    type: "list(shape)"
    description: "A list of Ncontext_dense shapes; the shapes of data in\neach context Feature given in context_dense_keys.\nThe number of elements in the Feature corresponding to context_dense_key[j]\nmust always equal context_dense_shapes[j].NumEntries().\nThe shape of context_dense_values[j] will match context_dense_shapes[j]."
    has_minimum: true
  }
  attr {
    name: "feature_list_dense_shapes"
    type: "list(shape)"
    description: "A list of Nfeature_list_dense shapes; the shapes of\ndata in each FeatureList given in feature_list_dense_keys.\nThe shape of each Feature in the FeatureList corresponding to\nfeature_list_dense_key[j] must always equal\nfeature_list_dense_shapes[j].NumEntries()."
    has_minimum: true
  }
  summary: "Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors."
}
op {
  name: "Placeholder"
  output_arg {
    name: "output"
    description: "A placeholder tensor that must be replaced using the feed mechanism."
    type_attr: "dtype"
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of elements in the tensor."
  }
  attr {
    name: "shape"
    type: "shape"
    description: "(Optional) The shape of the tensor. If the shape has 0 dimensions, the\nshape is unconstrained."
  }
  summary: "A placeholder op for a value that will be fed into the computation."
  description: "N.B. This operation will fail with an error if it is executed. It is\nintended as a way to represent a value that will always be fed, and to\nprovide attrs that enable the fed value to be checked at runtime."
}
op {
  name: "Pow"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes the power of one value to another."
  description: "Given a tensor `x` and a tensor `y`, this operation computes \\\\(x^y\\\\) for\ncorresponding elements in `x` and `y`. For example:\n\n```\n# tensor \'x\' is [[2, 2]], [3, 3]]\n# tensor \'y\' is [[8, 16], [2, 3]]\ntf.pow(x, y) ==> [[256, 65536], [9, 27]]\n```"
}
op {
  name: "Print"
  input_arg {
    name: "input"
    description: "The tensor passed to `output`"
    type_attr: "T"
  }
  input_arg {
    name: "data"
    description: "A list of tensors to print out when op is evaluated."
    type_list_attr: "U"
  }
  output_arg {
    name: "output"
    description: "= The unmodified `input` tensor"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "U"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "message"
    type: "string"
    default_value {
      s: ""
    }
    description: "A string, prefix of the error message."
  }
  attr {
    name: "first_n"
    type: "int"
    default_value {
      i: -1
    }
    description: "Only log `first_n` number of times. -1 disables logging."
  }
  attr {
    name: "summarize"
    type: "int"
    default_value {
      i: 3
    }
    description: "Only print this many entries of each tensor."
  }
  summary: "Prints a list of tensors."
  description: "Passes `input` through to `output` and prints `data` when evaluating."
}
op {
  name: "Prod"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Computes the product of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "QueueClose"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "cancel_pending_enqueues"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, all pending enqueue requests that are\nblocked on the given queue will be cancelled."
  }
  summary: "Closes the given queue."
  description: "This operation signals that no more elements will be enqueued in the\ngiven queue. Subsequent Enqueue(Many) operations will fail.\nSubsequent Dequeue(Many) operations will continue to succeed if\nsufficient elements remain in the queue. Subsequent Dequeue(Many)\noperations that would block will fail immediately."
}
op {
  name: "QueueDequeue"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "components"
    description: "One or more tensors that were dequeued as a tuple."
    type_list_attr: "component_types"
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a tuple."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Dequeues a tuple of one or more tensors from the given queue."
  description: "This operation has k outputs, where k is the number of components\nin the tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until an element\nhas been dequeued (or \'timeout_ms\' elapses, if specified)."
}
op {
  name: "QueueDequeueMany"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "n"
    description: "The number of tuples to dequeue."
    type: DT_INT32
  }
  output_arg {
    name: "components"
    description: "One or more tensors that were dequeued as a tuple."
    type_list_attr: "component_types"
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a tuple."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Dequeues n tuples of one or more tensors from the given queue."
  description: "This operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size n in the 0th dimension.\n\nThis operation has k outputs, where k is the number of components in\nthe tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until n elements\nhave been dequeued (or \'timeout_ms\' elapses, if specified)."
}
op {
  name: "QueueEnqueue"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "components"
    description: "One or more tensors from which the enqueued tensors should be taken."
    type_list_attr: "Tcomponents"
  }
  attr {
    name: "Tcomponents"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue is full, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Enqueues a tuple of one or more tensors in the given queue."
  description: "The components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelement has been enqueued (or \'timeout_ms\' elapses, if specified)."
}
op {
  name: "QueueEnqueueMany"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "components"
    description: "One or more tensors from which the enqueued tensors should\nbe taken."
    type_list_attr: "Tcomponents"
  }
  attr {
    name: "Tcomponents"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue is too full, this operation will block for up\nto timeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Enqueues zero or more tuples of one or more tensors in the given queue."
  description: "This operation slices each component tensor along the 0th dimension to\nmake multiple queue elements. All of the tuple components must have the\nsame size in the 0th dimension.\n\nThe components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelements have been enqueued (or \'timeout_ms\' elapses, if specified)."
}
op {
  name: "QueueSize"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "size"
    description: "The number of elements in the given queue."
    type: DT_INT32
  }
  summary: "Computes the number of elements in the given queue."
}
op {
  name: "RGBToHSV"
  input_arg {
    name: "images"
    description: "1-D or higher rank. RGB data to convert. Last dimension must be size 3."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "`images` converted to HSV."
    type: DT_FLOAT
  }
  summary: "Converts one or more images from RGB to HSV."
  description: "Outputs a tensor of the same shape as the `images` tensor, containing the HSV\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\n`output[..., 0]` contains hue, `output[..., 1]` contains saturation, and\n`output[..., 2]` contains value. All HSV values are in `[0,1]`. A hue of 0\ncorresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue."
}
op {
  name: "RandomCrop"
  input_arg {
    name: "image"
    description: "3-D of shape `[height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "1-D of length 2 containing: `crop_height`, `crop_width`.."
    type: DT_INT64
  }
  output_arg {
    name: "output"
    description: "3-D of shape `[crop_height, crop_width, channels].`"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Randomly crop `image`."
  description: "`size` is a 1-D int64 tensor with 2 elements representing the crop height and\nwidth.  The values must be non negative.\n\nThis Op picks a random location in `image` and crops a `height` by `width`\nrectangle from that location.  The random location is picked so the cropped\narea will fit inside the original image."
  is_stateful: true
}
op {
  name: "RandomShuffle"
  input_arg {
    name: "value"
    description: "The tensor to be shuffled."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A tensor of same shape and type as `value`, shuffled along its first\ndimension."
    type_attr: "T"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Randomly shuffles a tensor along its first dimension."
  description: "  The tensor is shuffled along dimension 0, such that each `value[j]` is mapped\n  to one and only one `output[i]`. For example, a mapping that might occur for a\n  3x2 tensor is:\n\n```prettyprint\n[[1, 2],       [[5, 6],\n [3, 4],  ==>   [1, 2],\n [5, 6]]        [3, 4]]\n```"
  is_stateful: true
}
op {
  name: "RandomShuffleQueue"
  output_arg {
    name: "handle"
    description: "The handle to the queue."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a value."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "shapes"
    type: "list(shape)"
    default_value {
      list {
      }
    }
    description: "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time."
    has_minimum: true
  }
  attr {
    name: "capacity"
    type: "int"
    default_value {
      i: -1
    }
    description: "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit."
  }
  attr {
    name: "min_after_dequeue"
    type: "int"
    default_value {
      i: 0
    }
    description: "Dequeue will block unless there would be this\nmany elements after the dequeue or the queue is closed. This\nensures a minimum level of mixing of elements."
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 is set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue will be shared under the given name\nacross multiple sessions."
  }
  summary: "A queue that randomizes the order of elements."
  is_stateful: true
}
op {
  name: "RandomStandardNormal"
  input_arg {
    name: "shape"
    description: "The shape of the output tensor."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A tensor of the specified shape filled with random normal values."
    type_attr: "dtype"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the output."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Outputs random values from a normal distribution."
  description: "The generated values will have mean 0 and standard deviation 1."
  is_stateful: true
}
op {
  name: "RandomUniform"
  input_arg {
    name: "shape"
    description: "The shape of the output tensor."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A tensor of the specified shape filled with uniform random values."
    type_attr: "dtype"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the output."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Outputs random values from a uniform distribution."
  description: "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded."
  is_stateful: true
}
op {
  name: "RandomUniformInt"
  input_arg {
    name: "shape"
    description: "The shape of the output tensor."
    type_attr: "T"
  }
  input_arg {
    name: "minval"
    description: "0-D.  Inclusive lower bound on the generated integers."
    type_attr: "Tout"
  }
  input_arg {
    name: "maxval"
    description: "0-D.  Exclusive upper bound on the generated integers."
    type_attr: "Tout"
  }
  output_arg {
    name: "output"
    description: "A tensor of the specified shape filled with uniform random integers."
    type_attr: "Tout"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "Tout"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Outputs random integers from a uniform distribution."
  description: "The generated values are uniform integers in the range `[minval, maxval)`.\nThe lower bound `minval` is included in the range, while the upper bound\n`maxval` is excluded.\n\nThe random integers are slightly biased unless `maxval - minval` is an exact\npower of two.  The bias is small for values of `maxval - minval` significantly\nsmaller than the range of the output (either `2^32` or `2^64`)."
  is_stateful: true
}
op {
  name: "Range"
  input_arg {
    name: "start"
    description: "0-D (scalar). First entry in the sequence."
    type: DT_INT32
  }
  input_arg {
    name: "limit"
    description: "0-D (scalar). Upper limit of sequence, exclusive."
    type: DT_INT32
  }
  input_arg {
    name: "delta"
    description: "0-D (scalar). Optional. Default is 1. Number that increments `start`."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "1-D."
    type: DT_INT32
  }
  summary: "Creates a sequence of integers."
  description: "This operation creates a sequence of integers that begins at `start` and\nextends by increments of `delta` up to but not including `limit`.\n\nFor example:\n\n```\n# \'start\' is 3\n# \'limit\' is 18\n# \'delta\' is 3\ntf.range(start, limit, delta) ==> [3, 6, 9, 12, 15]\n```"
}
op {
  name: "Rank"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the rank of a tensor."
  description: "This operation returns an integer representing the rank of `input`.\n\nFor example:\n\n```prettyprint\n# \'t\' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\n# shape of tensor \'t\' is [2, 2, 3]\nrank(t) ==> 3\n```\n\n**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank\nof a tensor is the number of indices required to uniquely select each element\nof the tensor. Rank is also known as \"order\", \"degree\", or \"ndims.\""
}
op {
  name: "ReadFile"
  input_arg {
    name: "filename"
    type: DT_STRING
  }
  output_arg {
    name: "contents"
    type: DT_STRING
  }
  summary: "Reads and outputs the entire contents of the input filename."
}
op {
  name: "ReaderNumRecordsProduced"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "records_produced"
    type: DT_INT64
  }
  summary: "Returns the number of records this Reader has produced."
  description: "This is the same as the number of ReaderRead executions that have\nsucceeded."
}
op {
  name: "ReaderNumWorkUnitsCompleted"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "units_completed"
    type: DT_INT64
  }
  summary: "Returns the number of work units this Reader has finished processing."
}
op {
  name: "ReaderRead"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "queue_handle"
    description: "Handle to a Queue, with string work items."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "key"
    description: "A scalar."
    type: DT_STRING
  }
  output_arg {
    name: "value"
    description: "A scalar."
    type: DT_STRING
  }
  summary: "Returns the next record (key, value pair) produced by a Reader."
  description: "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file)."
}
op {
  name: "ReaderReset"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  summary: "Restore a Reader to its initial clean state."
}
op {
  name: "ReaderRestoreState"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "state"
    description: "Result of a ReaderSerializeState of a Reader with type\nmatching reader_handle."
    type: DT_STRING
  }
  summary: "Restore a reader to a previously saved state."
  description: "Not all Readers support being restored, so this can produce an\nUnimplemented error."
}
op {
  name: "ReaderSerializeState"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "state"
    type: DT_STRING
  }
  summary: "Produce a string tensor that encodes the state of a Reader."
  description: "Not all Readers support being serialized, so this can produce an\nUnimplemented error."
}
op {
  name: "Real"
  input_arg {
    name: "in"
    type: DT_COMPLEX64
  }
  output_arg {
    name: "out"
    type: DT_FLOAT
  }
  summary: "Returns the real part of a complex number."
  description: "Given a tensor `in` of complex numbers, this operation returns a tensor of type\n`float` that is the real part of each element in `in`. All elements in `in`\nmust be complex numbers of the form \\\\(a + bj\\\\), where *a* is the real part\nreturned by this operation and *b* is the imaginary part.\n\nFor example:\n\n```\n# tensor \'in\' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.real(in) ==> [-2.25, 3.25]\n```"
}
op {
  name: "RefEnter"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the child frame."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "frame_name"
    type: "string"
    description: "The name of the child frame."
  }
  attr {
    name: "is_constant"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, the output is constant within the child frame."
  }
  attr {
    name: "parallel_iterations"
    type: "int"
    default_value {
      i: 10
    }
    description: "The number of iterations allowed to run in parallel."
  }
  summary: "Creates or finds a child frame, and makes `data` available to the child frame."
  description: "The unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame."
}
op {
  name: "RefIdentity"
  input_arg {
    name: "input"
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output"
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Return the same ref tensor as the input ref tensor."
}
op {
  name: "RefSelect"
  input_arg {
    name: "index"
    description: "A scalar that determines the input that gets selected."
    type: DT_INT32
  }
  input_arg {
    name: "inputs"
    description: "A list of ref tensors, one of which will be forwarded to `output`."
    type_attr: "T"
    number_attr: "N"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "The forwarded tensor."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  summary: "Forwards the `index`th element of `inputs` to `output`."
}
op {
  name: "RefSwitch"
  input_arg {
    name: "data"
    description: "The ref tensor to be forwarded to the appropriate output."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "pred"
    description: "A scalar that specifies which output port will receive data."
    type: DT_BOOL
  }
  output_arg {
    name: "output_false"
    description: "If `pred` is false, data will be forwarded to this output."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output_true"
    description: "If `pred` is true, data will be forwarded to this output."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Forwards the ref tensor `data` to the output port determined by `pred`."
  description: "If `pred` is true, the `data` input is forwared to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `Switch` and `Merge`."
}
op {
  name: "Relu"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes rectified linear: `max(features, 0)`."
}
op {
  name: "Relu6"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes rectified linear 6: `min(max(features, 0), 6)`."
}
op {
  name: "Relu6Grad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding Relu6 operation."
    type_attr: "T"
  }
  input_arg {
    name: "features"
    description: "The features passed as input to the corresponding Relu6 operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients:\n`gradients * features * (features > 0) * (features < 6)`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes rectified linear 6 gradients for a Relu6 operation."
}
op {
  name: "ReluGrad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding Relu operation."
    type_attr: "T"
  }
  input_arg {
    name: "features"
    description: "The features passed as input to the corresponding Relu operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients: `gradients * features * (features > 0)`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes rectified linear gradients for a Relu operation."
}
op {
  name: "Reshape"
  input_arg {
    name: "tensor"
    type_attr: "T"
  }
  input_arg {
    name: "shape"
    description: "Defines the shape of the output tensor."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Reshapes a tensor."
  description: "Given `tensor`, this operation returns a tensor that has the same values\nas `tensor` with shape `shape`.\n\nIf one component of `shape` is the special value -1, the size of that dimension\nis computed so that the total size remains constant.  In particular, a `shape`\nof `[-1]` flattens into 1-D.  At most one component of `shape` can be -1.\n\nIf `shape` is 1-D or higher, then the operation returns a tensor with shape\n`shape` filled with the values of `tensor`. In this case, the number of elements\nimplied by `shape` must be the same as the number of elements in `tensor`.\n\nFor example:\n\n```prettyprint\n# tensor \'t\' is [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# tensor \'t\' has shape [9]\nreshape(t, [3, 3]) ==> [[1, 2, 3]\n                        [4, 5, 6]\n                        [7, 8, 9]]\n\n# tensor \'t\' is [[[1, 1], [2, 2]]\n#                [[3, 3], [4, 4]]]\n# tensor \'t\' has shape [2, 2, 2]\nreshape(t, [2, 4]) ==> [[1, 1, 2, 2]\n                        [3, 3, 4, 4]]\n\n# tensor \'t\' is [[[1, 1, 1],\n#                 [2, 2, 2]],\n#                [[3, 3, 3],\n#                 [4, 4, 4]],\n#                [[5, 5, 5],\n#                 [6, 6, 6]]]\n# tensor \'t\' has shape [3, 2, 3]\n# pass \'[-1]\' to flatten \'t\'\nreshape(t, [-1]) ==> [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]\n# -1 can also be used with higher dimensional shapes\nreshape(t, [2, -1]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n\n# tensor \'t\' is [7]\n# shape `[]` reshapes to a scalar\nreshape(t, []) ==> 7\n```"
}
op {
  name: "ResizeArea"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images."
    type: DT_INT32
  }
  output_arg {
    name: "resized_images"
    description: "4-D with shape\n`[batch, new_height, new_width, channels]`."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT32
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Resize `images` to `size` using area interpolation."
  description: "Input images can be of different types but output images are always float."
}
op {
  name: "ResizeBicubic"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images."
    type: DT_INT32
  }
  output_arg {
    name: "resized_images"
    description: "4-D with shape\n`[batch, new_height, new_width, channels]`."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT32
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Resize `images` to `size` using bicubic interpolation."
  description: "Input images can be of different types but output images are always float."
}
op {
  name: "ResizeBilinear"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images."
    type: DT_INT32
  }
  output_arg {
    name: "resized_images"
    description: "4-D with shape\n`[batch, new_height, new_width, channels]`."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT32
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Resize `images` to `size` using bilinear interpolation."
  description: "Input images can be of different types but output images are always float."
}
op {
  name: "ResizeBilinearGrad"
  input_arg {
    name: "grads"
    description: "4-D with shape `[batch, height, width, channels]`."
    type: DT_FLOAT
  }
  input_arg {
    name: "original_image"
    description: "4-D with shape `[batch, orig_height, orig_width, channels]`,\nThe image tensor that was resized."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D with shape `[batch, orig_height, orig_width, channels]`.\nGradients with respect to the input image. Input image must have been\nfloat or double."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes the gradient of bilinear interpolation."
}
op {
  name: "ResizeNearestNeighbor"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images."
    type: DT_INT32
  }
  output_arg {
    name: "resized_images"
    description: "4-D with shape\n`[batch, new_height, new_width, channels]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT32
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Resize `images` to `size` using nearest neighbor interpolation."
}
op {
  name: "ResizeNearestNeighborGrad"
  input_arg {
    name: "grads"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `orig_height, orig_width`. The\noriginal input size."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "4-D with shape `[batch, orig_height, orig_width, channels]`. Gradients\nwith respect to the input image."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT32
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes the gradient of nearest neighbor interpolation."
}
op {
  name: "Restore"
  input_arg {
    name: "file_pattern"
    description: "Must have a single element. The pattern of the files from\nwhich we read the tensor."
    type: DT_STRING
  }
  input_arg {
    name: "tensor_name"
    description: "Must have a single element. The name of the tensor to be\nrestored."
    type: DT_STRING
  }
  output_arg {
    name: "tensor"
    description: "The restored tensor."
    type_attr: "dt"
  }
  attr {
    name: "dt"
    type: "type"
    description: "The type of the tensor to be restored."
  }
  attr {
    name: "preferred_shard"
    type: "int"
    default_value {
      i: -1
    }
    description: "Index of file to open first if multiple files match\n`file_pattern`."
  }
  summary: "Restores a tensor from checkpoint files."
  description: "Reads a tensor stored in one or several files. If there are several files (for\ninstance because a tensor was saved as slices), `file_pattern` may contain\nwildcard symbols (`*` and `?`) in the filename portion only, not in the\ndirectory portion.\n\nIf a `file_pattern` matches several files, `preferred_shard` can be used to hint\nin which file the requested tensor is likely to be found. This op will first\nopen the file at index `preferred_shard` in the list of matching files and try\nto restore tensors from that file.  Only if some tensors or tensor slices are\nnot found in that first file, then the Op opens all the files. Setting\n`preferred_shard` to match the value passed as the `shard` input\nof a matching `Save` Op may speed up Restore.  This attribute only affects\nperformance, not correctness.  The default value -1 means files are processed in\norder.\n\nSee also `RestoreSlice`."
}
op {
  name: "RestoreSlice"
  input_arg {
    name: "file_pattern"
    description: "Must have a single element. The pattern of the files from\nwhich we read the tensor."
    type: DT_STRING
  }
  input_arg {
    name: "tensor_name"
    description: "Must have a single element. The name of the tensor to be\nrestored."
    type: DT_STRING
  }
  input_arg {
    name: "shape_and_slice"
    description: "Scalar. The shapes and slice specifications to use when\nrestoring a tensors."
    type: DT_STRING
  }
  output_arg {
    name: "tensor"
    description: "The restored tensor."
    type_attr: "dt"
  }
  attr {
    name: "dt"
    type: "type"
    description: "The type of the tensor to be restored."
  }
  attr {
    name: "preferred_shard"
    type: "int"
    default_value {
      i: -1
    }
    description: "Index of file to open first if multiple files match\n`file_pattern`. See the documentation for `Restore`."
  }
  summary: "Restores a tensor from checkpoint files."
  description: "This is like `Restore` except that restored tensor can be listed as filling\nonly a slice of a larger tensor.  `shape_and_slice` specifies the shape of the\nlarger tensor and the slice that the restored tensor covers.\n\nThe `shape_and_slice` input has the same format as the\nelements of the `shapes_and_slices` input of the `SaveSlices` op."
}
op {
  name: "Reverse"
  input_arg {
    name: "tensor"
    description: "Up to 8-D."
    type_attr: "T"
  }
  input_arg {
    name: "dims"
    description: "1-D. The dimensions to reverse."
    type: DT_BOOL
  }
  output_arg {
    name: "output"
    description: "The same shape as `tensor`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT32
        type: DT_BOOL
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Reverses specific dimensions of a tensor."
  description: "Given a `tensor`, and a `bool` tensor `dims` representing the dimensions\nof `tensor`, this operation reverses each dimension i of `tensor` where\n`dims[i]` is `True`.\n\n`tensor` can have up to 8 dimensions. The number of dimensions\nof `tensor` must equal the number of elements in `dims`. In other words:\n\n`rank(tensor) = size(dims)`\n\nFor example:\n\n```prettyprint\n# tensor \'t\' is [[[[ 0,  1,  2,  3],\n#                  [ 4,  5,  6,  7],\n#                  [ 8,  9, 10, 11]],\n#                 [[12, 13, 14, 15],\n#                  [16, 17, 18, 19],\n#                  [20, 21, 22, 23]]]]\n# tensor \'t\' shape is [1, 2, 3, 4]\n\n# \'dims\' is [False, False, False, True]\nreverse(t, dims) ==> [[[[ 3,  2,  1,  0],\n                        [ 7,  6,  5,  4],\n                        [ 11, 10, 9, 8]],\n                       [[15, 14, 13, 12],\n                        [19, 18, 17, 16],\n                        [23, 22, 21, 20]]]]\n\n# \'dims\' is [False, True, False, False]\nreverse(t, dims) ==> [[[[12, 13, 14, 15],\n                        [16, 17, 18, 19],\n                        [20, 21, 22, 23]\n                       [[ 0,  1,  2,  3],\n                        [ 4,  5,  6,  7],\n                        [ 8,  9, 10, 11]]]]\n\n# \'dims\' is [False, False, True, False]\nreverse(t, dims) ==> [[[[8, 9, 10, 11],\n                        [4, 5, 6, 7],\n                        [0, 1, 2, 3]]\n                       [[20, 21, 22, 23],\n                        [16, 17, 18, 19],\n                        [12, 13, 14, 15]]]]\n```"
}
op {
  name: "ReverseSequence"
  input_arg {
    name: "input"
    description: "The input to reverse."
    type_attr: "T"
  }
  input_arg {
    name: "seq_lengths"
    description: "1-D with length `input.dims(0)` and\n`max(seq_lengths) < input.dims(seq_dim)`"
    type: DT_INT64
  }
  output_arg {
    name: "output"
    description: "The partially reversed input. It has the same shape as `input`."
    type_attr: "T"
  }
  attr {
    name: "seq_dim"
    type: "int"
    description: "The dimension which is partially reversed."
  }
  attr {
    name: "batch_dim"
    type: "int"
    default_value {
      i: 0
    }
    description: "The dimension along which reversal is performed."
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Reverses variable length slices."
  description: "This op first slices `input` along the dimension `batch_dim`, and for each\nslice `i`, reverses the first `seq_lengths[i]` elements along\nthe dimension `seq_dim`.\n\nThe elements of `seq_lengths` must obey `seq_lengths[i] < input.dims[seq_dim]`,\nand `seq_lengths` must be a vector of length `input.dims[batch_dim]`.\n\nThe output slice `i` along dimension `batch_dim` is then given by input\nslice `i`, with the first `seq_lengths[i]` slices along dimension\n`seq_dim` reversed.\n\nFor example:\n\n```prettyprint\n# Given this:\nbatch_dim = 0\nseq_dim = 1\ninput.dims = (4, 8, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]\noutput[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]\noutput[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]\noutput[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[0, 7:, :, ...] = input[0, 7:, :, ...]\noutput[1, 2:, :, ...] = input[1, 2:, :, ...]\noutput[2, 3:, :, ...] = input[2, 3:, :, ...]\noutput[3, 2:, :, ...] = input[3, 2:, :, ...]\n```\n\nIn contrast, if:\n```prettyprint\n# Given this:\nbatch_dim = 2\nseq_dim = 0\ninput.dims = (8, ?, 4, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]\noutput[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]\noutput[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]\noutput[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]\noutput[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]\noutput[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]\noutput[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]\n```"
}
op {
  name: "Rsqrt"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes reciprocal of square root of x element-wise."
  description: "I.e., \\\\(y = 1 / \\sqrt{x}\\\\)."
}
op {
  name: "Save"
  input_arg {
    name: "filename"
    description: "Must have a single element. The name of the file to which we write\nthe tensor."
    type: DT_STRING
  }
  input_arg {
    name: "tensor_names"
    description: "Shape `[N]`. The names of the tensors to be saved."
    type: DT_STRING
  }
  input_arg {
    name: "data"
    description: "`N` tensors to save."
    type_list_attr: "T"
  }
  attr {
    name: "T"
    type: "list(type)"
    has_minimum: true
    minimum: 1
    allowed_values {
      list {
        type: DT_BOOL
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_QUINT8
        type: DT_QINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Saves the input tensors to disk."
  description: "The size of `tensor_names` must match the number of tensors in `data`. `data[i]`\nis written to `filename` with name `tensor_names[i]`.\n\nSee also `SaveSlices`."
}
op {
  name: "SaveSlices"
  input_arg {
    name: "filename"
    description: "Must have a single element. The name of the file to which we write the\ntensor."
    type: DT_STRING
  }
  input_arg {
    name: "tensor_names"
    description: "Shape `[N]`. The names of the tensors to be saved."
    type: DT_STRING
  }
  input_arg {
    name: "shapes_and_slices"
    description: "Shape `[N]`.  The shapes and slice specifications to use when\nsaving the tensors."
    type: DT_STRING
  }
  input_arg {
    name: "data"
    description: "`N` tensors to save."
    type_list_attr: "T"
  }
  attr {
    name: "T"
    type: "list(type)"
    has_minimum: true
    minimum: 1
    allowed_values {
      list {
        type: DT_BOOL
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_QUINT8
        type: DT_QINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Saves input tensors slices to disk."
  description: "This is like `Save` except that tensors can be listed in the saved file as being\na slice of a larger tensor.  `shapes_and_slices` specifies the shape of the\nlarger tensor and the slice that this tensor covers. `shapes_and_slices` must\nhave as many elements as `tensor_names`.\n\nElements of the `shapes_and_slices` input must either be:\n\n*  The empty string, in which case the corresponding tensor is\n   saved normally.\n*  A string of the form `dim0 dim1 ... dimN-1 slice-spec` where the\n   `dimI` are the dimensions of the larger tensor and `slice-spec`\n   specifies what part is covered by the tensor to save.\n\n`slice-spec` itself is a `:`-separated list: `slice0:slice1:...:sliceN-1`\nwhere each `sliceI` is either:\n\n*  The string `-` meaning that the slice covers all indices of this dimension\n*  `start,length` where `start` and `length` are integers.  In that\n   case the slice covers `length` indices starting at `start`.\n\nSee also `Save`."
}
op {
  name: "ScalarSummary"
  input_arg {
    name: "tags"
    description: "1-D. Tags for the summary."
    type: DT_STRING
  }
  input_arg {
    name: "values"
    description: "1-D, same size as `tags.  Values for the summary."
    type_attr: "T"
  }
  output_arg {
    name: "summary"
    description: "Scalar.  Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Outputs a `Summary` protocol buffer with scalar values."
  description: "The input `tags` and `values` must have the same shape.  The generated summary\nhas a summary value for each tag-value pair in `tags` and `values`."
}
op {
  name: "ScatterAdd"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "indices"
    description: "A tensor of indices into the first dimension of `ref`."
    type_attr: "Tindices"
  }
  input_arg {
    name: "updates"
    description: "A tensor of updated values to add to `ref`."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Adds sparse updates to a variable reference."
  description: "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] += updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] += updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/ScatterAdd.png\" alt>\n</div>"
}
op {
  name: "ScatterSub"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "indices"
    description: "A tensor of indices into the first dimension of `ref`."
    type_attr: "Tindices"
  }
  input_arg {
    name: "updates"
    description: "A tensor of updated values to subtract from `ref`."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Subtracts sparse updates to a variable reference."
  description: "    # Scalar indices\n    ref[indices, ...] -= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] -= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their (negated) contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/ScatterSub.png\" alt>\n</div>"
}
op {
  name: "ScatterUpdate"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "indices"
    description: "A tensor of indices into the first dimension of `ref`."
    type_attr: "Tindices"
  }
  input_arg {
    name: "updates"
    description: "A tensor of updated values to store in `ref`."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: true
    }
    description: "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Applies sparse updates to a variable reference."
  description: "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nIf `indices` contains duplicate entries, lexicographically later entries\noverride earlier entries.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/ScatterUpdate.png\" alt>\n</div>"
}
op {
  name: "SegmentMax"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the maximum along segments of a tensor."
  description: "Read [the section on Segmentation](../../api_docs/python/math_ops.md#segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\max_j(data_j)\\\\) where `max` is over `j` such\nthat `segment_ids[j] == i`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentMax.png\" alt>\n</div>"
}
op {
  name: "SegmentMean"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the mean along segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nComputes a tensor such that\n\\\\(output_i = \\frac{\\sum_j data_j}{N}\\\\) where `mean` is\nover `j` such that `segment_ids[j] == i` and `N` is the total number of\nvalues summed.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentMean.png\" alt>\n</div>"
}
op {
  name: "SegmentMin"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the minimum along segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nComputes a tensor such that\n\\\\(output_i = \\min_j(data_j)\\\\) where `min` is over `j` such\nthat `segment_ids[j] == i`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentMin.png\" alt>\n</div>"
}
op {
  name: "SegmentProd"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the product along segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nComputes a tensor such that\n\\\\(output_i = \\prod_j data_j\\\\) where the product is over `j` such\nthat `segment_ids[j] == i`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentProd.png\" alt>\n</div>"
}
op {
  name: "SegmentSum"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the sum along segments of a tensor."
  description: "Read [the section on Segmentation](../../api_docs/python/math_ops.md#segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\sum_j data_j\\\\) where sum is over `j` such\nthat `segment_ids[j] == i`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentSum.png\" alt>\n</div>"
}
op {
  name: "Select"
  input_arg {
    name: "condition"
    type: DT_BOOL
  }
  input_arg {
    name: "t"
    description: "= A `Tensor` with the same shape as `condition`."
    type_attr: "T"
  }
  input_arg {
    name: "e"
    description: "= A `Tensor` with the same type and shape as `t`."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "= A `Tensor` with the same type and shape as `t` and `e`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Selects elements from `t` or `e`, depending on `condition`."
  description: "The `condition`, `t`, and `e` tensors must all have the same shape,\nand the output will also have that shape. The `condition` tensor acts\nas an element-wise mask that chooses, based on the value at each\nelement, whether the corresponding element in the output should be\ntaken from `t` (if true) or `e` (if false). For example:\n\nFor example:\n\n```prettyprint\n# \'condition\' tensor is [[True, False]\n#                        [True, False]]\n# \'t\' is [[1, 1],\n#         [1, 1]]\n# \'e\' is [[2, 2],\n#         [2, 2]]\nselect(condition, t, e) ==> [[1, 2],\n                             [1, 2]]\n```"
}
op {
  name: "SelfAdjointEig"
  input_arg {
    name: "input"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[M+1, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    description: "The type of values in the input and output."
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the Eigen Decomposition of a square Self-Adjoint matrix."
  description: "Only the lower-triangular part of the input will be used in this case. The\nupper-triangular part will not be read.\n\nThe result is a M+1 x M matrix whose first row is the eigenvalues, and\nsubsequent rows are eigenvectors."
}
op {
  name: "SerializeManySparse"
  input_arg {
    name: "sparse_indices"
    description: "2-D.  The `indices` of the minibatch `SparseTensor`."
    type: DT_INT64
  }
  input_arg {
    name: "sparse_values"
    description: "1-D.  The `values` of the minibatch `SparseTensor`."
    type_attr: "T"
  }
  input_arg {
    name: "sparse_shape"
    description: "1-D.  The `shape` of the minibatch `SparseTensor`."
    type: DT_INT64
  }
  output_arg {
    name: "serialized_sparse"
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` string `Tensor`."
  description: "The `SparseTensor` must have rank `R` greater than 1, and the first dimension\nis treated as the minibatch dimension.  Elements of the `SparseTensor`\nmust be sorted in increasing order of this first dimension.  The serialized\n`SparseTensor` objects going into each row of `serialized_sparse` will have\nrank `R-1`.\n\nThe minibatch size `N` is extracted from `sparse_shape[0]`."
}
op {
  name: "SerializeSparse"
  input_arg {
    name: "sparse_indices"
    description: "2-D.  The `indices` of the `SparseTensor`."
    type: DT_INT64
  }
  input_arg {
    name: "sparse_values"
    description: "1-D.  The `values` of the `SparseTensor`."
    type_attr: "T"
  }
  input_arg {
    name: "sparse_shape"
    description: "1-D.  The `shape` of the `SparseTensor`."
    type: DT_INT64
  }
  output_arg {
    name: "serialized_sparse"
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Serialize a `SparseTensor` into a string 3-vector (1-D `Tensor`) object."
}
op {
  name: "Shape"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the shape of a tensor."
  description: "This operation returns a 1-D integer tensor representing the shape of `input`.\n\nFor example:\n\n```prettyprint\n# \'t\' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\nshape(t) ==> [2, 2, 3]\n```"
}
op {
  name: "ShardedFilename"
  input_arg {
    name: "basename"
    type: DT_STRING
  }
  input_arg {
    name: "shard"
    type: DT_INT32
  }
  input_arg {
    name: "num_shards"
    type: DT_INT32
  }
  output_arg {
    name: "filename"
    type: DT_STRING
  }
  summary: "Generate a sharded filename. The filename is printf formated as"
  description: "   %s-%05d-of-%05d, basename, shard, num_shards."
}
op {
  name: "ShardedFilespec"
  input_arg {
    name: "basename"
    type: DT_STRING
  }
  input_arg {
    name: "num_shards"
    type: DT_INT32
  }
  output_arg {
    name: "filename"
    type: DT_STRING
  }
  summary: "Generate a glob pattern matching all sharded file names."
}
op {
  name: "Sigmoid"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes sigmoid of `x` element-wise."
  description: "Specifically, `y = 1 / (1 + exp(-x))`."
}
op {
  name: "Sign"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns an element-wise indication of the sign of a number."
  description: "y = sign(x) = -1 if x < 0; 0 if x == 0; 1 if x > 0."
}
op {
  name: "Sin"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes sin of x element-wise."
}
op {
  name: "Size"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the size of a tensor."
  description: "This operation returns an integer representing the number of elements in\n`input`.\n\nFor example:\n\n```prettyprint\n# \'t\' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]\nsize(t) ==> 12\n```"
}
op {
  name: "Skipgram"
  output_arg {
    name: "vocab_word"
    description: "A vector of words in the corpus."
    type: DT_STRING
  }
  output_arg {
    name: "vocab_freq"
    description: "Frequencies of words. Sorted in the non-ascending order."
    type: DT_INT32
  }
  output_arg {
    name: "words_per_epoch"
    description: "Number of words per epoch in the data file."
    type: DT_INT64
  }
  output_arg {
    name: "current_epoch"
    description: "The current epoch number."
    type: DT_INT32
  }
  output_arg {
    name: "total_words_processed"
    description: "The total number of words processed so far."
    type: DT_INT64
  }
  output_arg {
    name: "examples"
    description: "A vector of word ids."
    type: DT_INT32
  }
  output_arg {
    name: "labels"
    description: "A vector of word ids."
    type: DT_INT32
  }
  attr {
    name: "filename"
    type: "string"
    description: "The corpus\'s text file name."
  }
  attr {
    name: "batch_size"
    type: "int"
    description: "The size of produced batch."
  }
  attr {
    name: "window_size"
    type: "int"
    default_value {
      i: 5
    }
    description: "The number of words to predict to the left and right of the target."
  }
  attr {
    name: "min_count"
    type: "int"
    default_value {
      i: 5
    }
    description: "The minimum number of word occurrences for it to be included in the\nvocabulary."
  }
  attr {
    name: "subsample"
    type: "float"
    default_value {
      f: 0.001
    }
    description: "Threshold for word occurrence. Words that appear with higher\nfrequency will be randomly down-sampled. Set to 0 to disable."
  }
  summary: "Parses a text file and creates a batch of examples."
}
op {
  name: "Slice"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "begin"
    description: "begin[i] specifies the offset into the \'i\'th dimension of\n\'input\' to slice from."
    type_attr: "Index"
  }
  input_arg {
    name: "size"
    description: "size[i] specifies the number of elements of the \'i\'th dimension\nof \'input\' to slice. If size[i] is -1, all remaining elements in dimension\ni are included in the slice (i.e. this is equivalent to setting\nsize[i] = input.dim_size(i) - begin[i])."
    type_attr: "Index"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "Index"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Return a slice from \'input\'."
  description: "The output tensor is a tensor with dimensions described by \'size\'\nwhose values are extracted from \'input\' starting at the offsets in\n\'begin\'.\n\n*Requirements*:\n  0 <= begin[i] <= begin[i] + size[i] <= Di  for i in [0, n)"
}
op {
  name: "Softmax"
  input_arg {
    name: "logits"
    description: "2-D with shape `[batch_size, num_classes]`."
    type_attr: "T"
  }
  output_arg {
    name: "softmax"
    description: "Same shape as `logits`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes softmax activations."
  description: "For each batch `i` and class `j` we have\n\n    softmax[i, j] = exp(logits[i, j]) / sum(exp(logits[i]))"
}
op {
  name: "SoftmaxCrossEntropyWithLogits"
  input_arg {
    name: "features"
    description: "batch_size x num_classes matrix"
    type_attr: "T"
  }
  input_arg {
    name: "labels"
    description: "batch_size x num_classes matrix\nThe caller must ensure that each batch of labels represents a valid\nprobability distribution."
    type_attr: "T"
  }
  output_arg {
    name: "loss"
    description: "Per example loss (batch_size vector)."
    type_attr: "T"
  }
  output_arg {
    name: "backprop"
    description: "backpropagated gradients (batch_size x num_classes matrix)."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes softmax cross entropy cost and gradients to backpropagate."
  description: "Inputs are the logits, not probabilities."
}
op {
  name: "Softplus"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes softplus: `log(exp(features) + 1)`."
}
op {
  name: "SoftplusGrad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding softplus operation."
    type_attr: "T"
  }
  input_arg {
    name: "features"
    description: "The features passed as input to the corresponding softplus operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients: `gradients / (1 + exp(-features))`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes softplus gradients for a softplus operation."
}
op {
  name: "Softsign"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes softsign: `features / (abs(features) + 1)`."
}
op {
  name: "SoftsignGrad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding softsign operation."
    type_attr: "T"
  }
  input_arg {
    name: "features"
    description: "The features passed as input to the corresponding softsign operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients: `gradients / (1 + abs(-features)) ** 2`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes softsign gradients for a softsign operation."
}
op {
  name: "SparseApplyAdagrad"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Learning rate. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A vector of indices into the first dimension of var and accum."
    type_attr: "Tindices"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update relevant entries in \'*var\' and \'*accum\' according to the adagrad scheme."
  description: "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))"
}
op {
  name: "SparseApplyMomentum"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Learning rate. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A vector of indices into the first dimension of var and accum."
    type_attr: "Tindices"
  }
  input_arg {
    name: "momentum"
    description: "Momentum. Must be a scalar."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update relevant entries in \'*var\' and \'*accum\' according to the momentum scheme."
  description: "That is for rows we have grad for, we update var and accum as follows:\n\naccum = accum * momentum + grad\nvar -= lr * accum"
}
op {
  name: "SparseConcat"
  input_arg {
    name: "indices"
    description: "2-D.  Indices of each input `SparseTensor`."
    type: DT_INT64
    number_attr: "N"
  }
  input_arg {
    name: "values"
    description: "1-D.  Non-empty values of each `SparseTensor`."
    type_attr: "T"
    number_attr: "N"
  }
  input_arg {
    name: "shapes"
    description: "1-D.  Shapes of each `SparseTensor`."
    type: DT_INT64
    number_attr: "N"
  }
  output_arg {
    name: "output_indices"
    description: "2-D.  Indices of the concatenated `SparseTensor`."
    type: DT_INT64
  }
  output_arg {
    name: "output_values"
    description: "1-D.  Non-empty values of the concatenated `SparseTensor`."
    type_attr: "T"
  }
  output_arg {
    name: "output_shape"
    description: "1-D.  Shape of the concatenated `SparseTensor`."
    type: DT_INT64
  }
  attr {
    name: "concat_dim"
    type: "int"
    description: "Dimension to concatenate along."
    has_minimum: true
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 2
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Concatenates a list of `SparseTensor` along the specified dimension."
  description: "Concatenation is with respect to the dense versions of these sparse tensors.\nIt is assumed that each input is a `SparseTensor` whose elements are ordered\nalong increasing dimension number.\n\nAll inputs\' shapes must match, except for the concat dimension.  The\n`indices`, `values`, and `shapes` lists must have the same length.\n\nThe output shape is identical to the inputs\', except along the concat\ndimension, where it is the sum of the inputs\' sizes along that dimension.\n\nThe output elements will be resorted to preserve the sort order along\nincreasing dimension number.\n\nThis op runs in `O(M log M)` time, where `M` is the total number of non-empty\nvalues across all inputs. This is due to the need for an internal sort in\norder to concatenate efficiently across an arbitrary dimension.\n\nFor example, if `concat_dim = 1` and the inputs are\n\n    sp_inputs[0]: shape = [2, 3]\n    [0, 2]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    sp_inputs[1]: shape = [2, 4]\n    [0, 1]: \"d\"\n    [0, 2]: \"e\"\n\nthen the output will be\n\n    shape = [2, 7]\n    [0, 2]: \"a\"\n    [0, 4]: \"d\"\n    [0, 5]: \"e\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\nGraphically this is equivalent to doing\n\n    [    a] concat [  d e  ] = [    a   d e  ]\n    [b c  ]        [       ]   [b c          ]"
}
op {
  name: "SparseMatMul"
  input_arg {
    name: "a"
    type: DT_FLOAT
  }
  input_arg {
    name: "b"
    type: DT_FLOAT
  }
  output_arg {
    name: "product"
    type: DT_FLOAT
  }
  attr {
    name: "transpose_a"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "transpose_b"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "a_is_sparse"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "b_is_sparse"
    type: "bool"
    default_value {
      b: false
    }
  }
  summary: "Multiply matrix \"a\" by matrix \"b\"."
  description: "The inputs must be two-dimensional matrices and the inner dimension of \"a\" must\nmatch the outer dimension of \"b\". This op is optimized for the case where at\nleast one of \"a\" or \"b\" is sparse. The breakeven for using this versus a dense\nmatrix multiply on one platform was 30% zero values in the sparse matrix."
}
op {
  name: "SparseReorder"
  input_arg {
    name: "input_indices"
    description: "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering."
    type: DT_INT64
  }
  input_arg {
    name: "input_values"
    description: "1-D.  `N` non-empty values corresponding to `input_indices`."
    type_attr: "T"
  }
  input_arg {
    name: "input_shape"
    description: "1-D.  Shape of the input SparseTensor."
    type: DT_INT64
  }
  output_arg {
    name: "output_indices"
    description: "2-D.  `N x R` matrix with the same indices as input_indices, but\nin canonical row-major ordering."
    type: DT_INT64
  }
  output_arg {
    name: "output_values"
    description: "1-D.  `N` non-empty values corresponding to `output_indices`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Reorders a SparseTensor into the canonical, row-major ordering."
  description: "Note that by convention, all sparse ops preserve the canonical ordering along\nincreasing dimension number. The only time ordering can be violated is during\nmanual manipulation of the indices and values vectors to add entries.\n\nReordering does not affect the shape of the SparseTensor.\n\nIf the tensor has rank `R` and `N` non-empty values, `input_indices` has\nshape `[N, R]`, input_values has length `N`, and input_shape has length `R`."
}
op {
  name: "SparseSegmentMean"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A 1-D tensor. Has same rank as `segment_ids`."
    type: DT_INT32
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor. Values should be sorted and can be repeated."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes the mean along sparse segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nLike `SegmentMean`, but `segment_ids` can have rank less than `data`\'s first\ndimension, selecting a subset of dimension 0, specified by `indices`."
}
op {
  name: "SparseSegmentMeanGrad"
  input_arg {
    name: "grad"
    description: "gradient propagated to the SparseSegmentMean op."
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "indices passed to the corresponding SparseSegmentMean op."
    type: DT_INT32
  }
  input_arg {
    name: "segment_ids"
    description: "segment_ids passed to the corresponding SparseSegmentMean op."
    type: DT_INT32
  }
  input_arg {
    name: "output_dim0"
    description: "dimension 0 of \"data\" passed to SparseSegmentMean op."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes gradients for SparseSegmentMean."
  description: "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0."
}
op {
  name: "SparseSegmentSum"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A 1-D tensor. Has same rank as `segment_ids`."
    type: DT_INT32
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor. Values should be sorted and can be repeated."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Computes the sum along sparse segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nLike `SegmentSum`, but `segment_ids` can have rank less than `data`\'s first\ndimension, selecting a subset of dimension 0, specified by `indices`.\n\nFor example:\n\n```prettyprint\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n\n# Select two rows, one segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))\n  ==> [[0 0 0 0]]\n\n# Select two rows, two segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))\n  ==> [[ 1  2  3  4]\n       [-1 -2 -3 -4]]\n\n# Select all rows, two segments.\ntf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))\n  ==> [[0 0 0 0]\n       [5 6 7 8]]\n\n# Which is equivalent to:\ntf.segment_sum(c, tf.constant([0, 0, 1]))\n```"
}
op {
  name: "SparseToDense"
  input_arg {
    name: "sparse_indices"
    description: "0-D, 1-D, or 2-D.  `sparse_indices[i]` contains the complete\nindex where `sparse_values[i]` will be placed."
    type_attr: "Tindices"
  }
  input_arg {
    name: "output_shape"
    description: "1-D.  Shape of the dense output tensor."
    type_attr: "Tindices"
  }
  input_arg {
    name: "sparse_values"
    description: "1-D.  Values corresponding to each row of `sparse_indices`,\nor a scalar value to be used for all sparse indices."
    type_attr: "T"
  }
  input_arg {
    name: "default_value"
    description: "Scalar value to set for indices not specified in\n`sparse_indices`."
    type_attr: "T"
  }
  output_arg {
    name: "dense"
    description: "Dense output tensor of shape `output_shape`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Converts a sparse representation into a dense tensor."
  description: "Builds an array `dense` with shape `output_shape` such that\n\n```prettyprint\n# If sparse_indices is scalar\ndense[i] = (i == sparse_indices ? sparse_values : default_value)\n\n# If sparse_indices is a vector, then for each i\ndense[sparse_indices[i]] = sparse_values[i]\n\n# If sparse_indices is an n by d matrix, then for each i in [0, n)\ndense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]\n```\n\nAll other values in `dense` are set to `default_value`.  If `sparse_values` is a\nscalar, all sparse indices are set to this single value."
}
op {
  name: "Split"
  input_arg {
    name: "split_dim"
    description: "0-D.  The dimension along which to split.  Must be in the range\n`[0, rank(value))`."
    type: DT_INT32
  }
  input_arg {
    name: "value"
    description: "The tensor to split."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "They are identically shaped tensors, whose shape matches that of `value`\nexcept along `split_dim`, where their sizes are\n`values.shape[split_dim] / num_split`."
    type_attr: "T"
    number_attr: "num_split"
  }
  attr {
    name: "num_split"
    type: "int"
    description: "The number of ways to split.  Must evenly divide\n`value.shape[split_dim]`."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Splits a tensor into `num_split` tensors along one dimension."
}
op {
  name: "Sqrt"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes square root of x element-wise."
  description: "I.e., \\\\(y = \\sqrt{x} = x^{1/2}\\\\)."
}
op {
  name: "Square"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes square of x element-wise."
  description: "I.e., \\\\(y = x * x = x^2\\\\)."
}
op {
  name: "Squeeze"
  input_arg {
    name: "input"
    description: "The `input` to squeeze."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Contains the same data as `input`, but has one or more dimensions of\nsize 1 removed."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "squeeze_dims"
    type: "list(int)"
    default_value {
      list {
      }
    }
    description: "If specified, only squeezes the dimensions listed. The dimension\nindex starts at 0. It is an error to squeeze a dimension that is not 1."
    has_minimum: true
  }
  summary: "Removes dimensions of size 1 from the shape of a tensor."
  description: "Given a tensor `input`, this operation returns a tensor of the same type with\nall dimensions of size 1 removed. If you don\'t want to remove all size 1\ndimensions, you can remove specific size 1 dimensions by specifying\n`squeeze_dims`.\n\nFor example:\n\n```prettyprint\n# \'t\' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t)) ==> [2, 3]\n```\n\nOr, to remove specific size 1 dimensions:\n\n```prettyprint\n# \'t\' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t, [2, 4])) ==> [1, 2, 3, 1]\n```"
}
op {
  name: "Stack"
  output_arg {
    name: "handle"
    description: "The handle to the stack."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "elem_type"
    type: "type"
    description: "The type of the elements on the stack."
  }
  attr {
    name: "stack_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "Overrides the name used for the temporary stack resource. Default\nvalue is the name of the \'Stack\' op (which is guaranteed unique)."
  }
  summary: "A stack that produces elements in first-in last-out order."
  is_stateful: true
}
op {
  name: "StackClose"
  input_arg {
    name: "handle"
    description: "The handle to a stack."
    type: DT_STRING
    is_ref: true
  }
  summary: "Delete the stack from its resource container."
}
op {
  name: "StackPop"
  input_arg {
    name: "handle"
    description: "The handle to a stack."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "elem"
    description: "The tensor that is popped from the top of the stack."
    type_attr: "elem_type"
  }
  attr {
    name: "elem_type"
    type: "type"
    description: "The type of the elem that is popped."
  }
  summary: "Pop the element at the top of the stack."
}
op {
  name: "StackPush"
  input_arg {
    name: "handle"
    description: "The handle to a stack."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "elem"
    description: "The tensor to be pushed onto the stack."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The same tensor as the input \'elem\'."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Push an element onto the stack."
}
op {
  name: "StopGradient"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Stops gradient computation."
  description: "When executed in a graph, this op outputs its input tensor as-is.\n\nWhen building ops to compute gradients, this op prevents the contribution of\nits inputs to be taken into account.  Normally, the gradient generator adds ops\nto a graph to compute the derivatives of a specified \'loss\' by recursively\nfinding out inputs that contributed to its computation.  If you insert this op\nin the graph it inputs are masked from the gradient generator.  They are not\ntaken into account for computing gradients.\n\nThis is useful any time you want to compute a value with TensorFlow but need\nto pretend that the value was a constant. Some examples include:\n\n*  The *EM* algorithm where the *M-step* should not involve backpropagation\n   through the output of the *E-step*.\n*  Contrastive divergence training of Boltzmann machines where, when\n   differentiating the energy function, the training must not backpropagate\n   through the graph that generated the samples from the model.\n*  Adversarial training, where no backprop should happen through the adversarial\n   example generation process."
}
op {
  name: "StringToHashBucket"
  input_arg {
    name: "string_tensor"
    type: DT_STRING
  }
  output_arg {
    name: "output"
    description: "A Tensor of the same shape as the input `string_tensor`."
    type: DT_INT64
  }
  attr {
    name: "num_buckets"
    type: "int"
    description: "The number of buckets."
    has_minimum: true
    minimum: 1
  }
  summary: "Converts each string in the input Tensor to its hash mod by a number of buckets."
  description: "The hash function is deterministic on the content of the string within the\nprocess.\n\nNote that the hash function may change from time to time."
}
op {
  name: "StringToNumber"
  input_arg {
    name: "string_tensor"
    type: DT_STRING
  }
  output_arg {
    name: "output"
    description: "A Tensor of the same shape as the input `string_tensor`."
    type_attr: "out_type"
  }
  attr {
    name: "out_type"
    type: "type"
    default_value {
      type: DT_FLOAT
    }
    description: "The numeric type to interpret each string in string_tensor as."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT32
      }
    }
  }
  summary: "Converts each string in the input Tensor to the specified numeric type."
  description: "(Note that int32 overflow results in an error while float overflow\nresults in a rounded value.)"
}
op {
  name: "Sub"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Returns x - y element-wise."
}
op {
  name: "Sum"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
      }
    }
  }
  summary: "Computes the sum of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "Switch"
  input_arg {
    name: "data"
    description: "The tensor to be forwarded to the appropriate output."
    type_attr: "T"
  }
  input_arg {
    name: "pred"
    description: "A scalar that specifies which output port will receive data."
    type: DT_BOOL
  }
  output_arg {
    name: "output_false"
    description: "If `pred` is false, data will be forwarded to this output."
    type_attr: "T"
  }
  output_arg {
    name: "output_true"
    description: "If `pred` is true, data will be forwarded to this output."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Forwards `data` to the output port determined by `pred`."
  description: "If `pred` is true, the `data` input is forwared to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `RefSwitch` and `Merge`."
}
op {
  name: "TFRecordReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs the records from a TensorFlow Records file."
  is_stateful: true
}
op {
  name: "Tanh"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes hyperbolic tangent of `x` element-wise."
}
op {
  name: "TemporaryVariable"
  output_arg {
    name: "ref"
    description: "A reference to the variable tensor."
    type_attr: "dtype"
    is_ref: true
  }
  attr {
    name: "shape"
    type: "shape"
    description: "The shape of the variable tensor."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of elements in the variable tensor."
  }
  attr {
    name: "var_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "Overrides the name used for the temporary variable resource. Default\nvalue is the name of the \'TemporaryVariable\' op (which is guaranteed unique)."
  }
  summary: "Returns a tensor that may be mutated, but only persists within a single step."
  description: "This is an experimental op for internal use only and it is possible to use this\nop in unsafe ways.  DO NOT USE unless you fully understand the risks.\n\nIt is the caller\'s responsibility to ensure that \'ref\' is eventually passed to a\nmatching \'DestroyTemporaryVariable\' op after all other uses have completed.\n\nOutputs a ref to the tensor state so it may be read or modified.\n\n  E.g.\n      var = state_ops._temporary_variable([1, 2], types.float_)\n      var_name = var.op.name\n      var = state_ops.assign(var, [[4.0, 5.0]])\n      var = state_ops.assign_add(var, [[6.0, 7.0]])\n      final = state_ops._destroy_temporary_variable(var, var_name=var_name)"
  is_stateful: true
}
op {
  name: "TextLineReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "skip_header_lines"
    type: "int"
    default_value {
      i: 0
    }
    description: "Number of lines to skip from the beginning of every file."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs the lines of a file delimited by \'\\n\'."
  is_stateful: true
}
op {
  name: "ThreadUnsafeUnigramCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate represting the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a learned unigram distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Tile"
  input_arg {
    name: "input"
    description: "1-D or higher."
    type_attr: "T"
  }
  input_arg {
    name: "multiples"
    description: "1-D. Length must be the same as the number of dimensions in `input`"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Constructs a tensor by tiling a given tensor."
  description: "This operation creates a new tensor by replicating `input` `multiples` times.\nThe output tensor\'s i\'th dimension has `input.dims(i) * multiples[i]` elements,\nand the values of `input` are replicated `multiples[i]` times along the \'i\'th\ndimension. For example, tiling `[a b c d]` by `[2]` produces\n`[a b c d a b c d]`."
}
op {
  name: "TileGrad"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "multiples"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the gradient of `Tile`."
  description: "Since `Tile` takes an input and repeats the input `multiples` times\nalong each dimension, `TileGrad` takes in `multiples` and aggregates\neach repeated tile of `input` into `output`."
}
op {
  name: "TopK"
  input_arg {
    name: "input"
    description: "A `batch_size` x `classes` tensor."
    type_attr: "T"
  }
  output_arg {
    name: "values"
    description: "A `batch_size` x `k` tensor with the `k` largest elements for\neach row, sorted in descending order."
    type_attr: "T"
  }
  output_arg {
    name: "indices"
    description: "A `batch_size` x `k` tensor with the index of each value within\neach row."
    type: DT_INT32
  }
  attr {
    name: "k"
    type: "int"
    description: "Number of top elements to look for within each row."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  summary: "Returns the values and indices of the `k` largest elements for each row."
  description: "\\\\(values_{i, j}\\\\) represents the j-th largest element in \\\\(input_i\\\\).\n\n\\\\(indices_{i, j}\\\\) gives the column index of the corresponding element,\nsuch that \\\\(input_{i, indices_{i, j}} = values_{i, j}\\\\). If two\nelements are equal, the lower-index element appears first."
}
op {
  name: "Transpose"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "perm"
    type: DT_INT32
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Shuffle dimensions of x according to a permutation."
  description: "The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:\n  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`"
}
op {
  name: "TruncatedNormal"
  input_arg {
    name: "shape"
    description: "The shape of the output tensor."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A tensor of the specified shape filled with random truncated normal\nvalues."
    type_attr: "dtype"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the output."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Outputs random values from a truncated normal distribution."
  description: "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked."
  is_stateful: true
}
op {
  name: "UniformCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate represting the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a uniform distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Unique"
  input_arg {
    name: "x"
    description: "1-D."
    type_attr: "T"
  }
  output_arg {
    name: "y"
    description: "1-D."
    type_attr: "T"
  }
  output_arg {
    name: "idx"
    description: "1-D."
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Finds unique elements in a 1-D tensor."
  description: "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`. This operation also returns a\ntensor `idx` the same size as `x` that contains the index of each value of `x`\nin the unique output `y`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```prettyprint\n# tensor \'x\' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx = unique(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\n```"
}
op {
  name: "Unpack"
  input_arg {
    name: "value"
    description: "1-D or higher, with first dimension `num`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The list of tensors unpacked from `value`."
    type_attr: "T"
    number_attr: "num"
  }
  attr {
    name: "num"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Unpacks the outer dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors."
  description: "Unpacks `num` tensors from `value` by chipping it along the first dimension.\nThe i\'th tensor in `output` is the slice `value[i, ...]`. Each tensor in\n`output` has shape `value.shape[1:]`.\n\nThis is the opposite of `pack`."
}
op {
  name: "UnsortedSegmentSum"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension."
    type_attr: "Tindices"
  }
  input_arg {
    name: "num_segments"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `num_segments`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the sum along segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nComputes a tensor such that\n\\\\(output_i = \\sum_j data_j\\\\) where sum is over `j` such\nthat `segment_ids[j] == i`. Unlike `SegmentSum`, `segment_ids`\nneed not be sorted and need not cover all values in the full\n  range of valid values.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\n\n`num_segments` should equal the number of distinct segment IDs.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/UnsortedSegmentSum.png\" alt>\n</div>"
}
op {
  name: "Variable"
  output_arg {
    name: "ref"
    description: "A reference to the variable tensor."
    type_attr: "dtype"
    is_ref: true
  }
  attr {
    name: "shape"
    type: "shape"
    description: "The shape of the variable tensor."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of elements in the variable tensor."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this variable is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this variable is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "Holds state in the form of a tensor that persists across steps."
  description: "Outputs a ref to the tensor state so it may be read or modified.\nTODO(zhifengc/mrry): Adds a pointer to a more detail document\nabout sharing states in tensorflow."
  is_stateful: true
}
op {
  name: "Where"
  input_arg {
    name: "input"
    type: DT_BOOL
  }
  output_arg {
    name: "index"
    type: DT_INT64
  }
  summary: "Returns locations of true values in a boolean tensor."
  description: "This operation returns the coordinates of true elements in `input`. The\ncoordinates are returned in a 2-D tensor where the first dimension (rows)\nrepresents the number of true elements, and the second dimension (columns)\nrepresents the coordinates of the true elements. Keep in mind, the shape of\nthe output tensor can vary depending on how many true values there are in\n`input`. Indices are output in row-major order.\n\nFor example:\n\n```prettyprint\n# \'input\' tensor is [[True, False]\n#                    [True, False]]\n# \'input\' has two true values, so output has two coordinates.\n# \'input\' has rank of 2, so coordinates have two indices.\nwhere(input) ==> [[0, 0],\n                  [1, 0]]\n\n# `input` tensor is [[[True, False]\n#                     [True, False]]\n#                    [[False, True]\n#                     [False, True]]\n#                    [[False, False]\n#                     [False, True]]]\n# \'input\' has 5 true values, so output has 5 coordinates.\n# \'input\' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n```"
}
op {
  name: "WholeFileReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs the entire contents of a file as a value."
  description: "To use, enqueue filenames in a Queue.  The output of ReaderRead will\nbe a filename (key) and the contents of that file (value)."
  is_stateful: true
}
op {
  name: "ZerosLike"
  input_arg {
    name: "x"
    description: "a tensor of type T."
    type_attr: "T"
  }
  output_arg {
    name: "y"
    description: "a tensor of the same shape and type as x but filled with zeros."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns a tensor of zeros with the same shape and type as x."
}
