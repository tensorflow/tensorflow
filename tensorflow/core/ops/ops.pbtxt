op {
  name: "Abort"
  attr {
    name: "error_msg"
    type: "string"
    default_value {
      s: ""
    }
    description: "A string which is the message associated with the exception."
  }
  summary: "Raise a exception to abort the process when called."
  description: "Returns nothing but an exception."
}
op {
  name: "Abs"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the absolute value of a tensor."
  description: "Given a tensor `x`, this operation returns a tensor containing the absolute\nvalue of each element in `x`. For example, if x is an input element and y is\nan output element, this operation computes \\\\(y = |x|\\\\)."
}
op {
  name: "Add"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
        type: DT_STRING
      }
    }
  }
  summary: "Returns x + y element-wise."
  description: "*NOTE*: Add supports broadcasting. AddN does not."
}
op {
  name: "AddN"
  input_arg {
    name: "inputs"
    description: "Must all be the same size and shape."
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "sum"
    type_attr: "T"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Add all input tensors element wise."
  is_aggregate: true
  is_commutative: true
}
op {
  name: "AdjustContrast"
  input_arg {
    name: "images"
    type_attr: "T"
  }
  input_arg {
    name: "contrast_factor"
    type: DT_FLOAT
  }
  input_arg {
    name: "min_value"
    type: DT_FLOAT
  }
  input_arg {
    name: "max_value"
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Deprecated. Disallowed in GraphDef version >= 2."
  deprecation {
    version: 2
    explanation: "Use AdjustContrastv2 instead"
  }
}
op {
  name: "AdjustContrastv2"
  input_arg {
    name: "images"
    description: "Images to adjust.  At least 3-D."
    type: DT_FLOAT
  }
  input_arg {
    name: "contrast_factor"
    description: "A float multiplier for adjusting contrast."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "The contrast-adjusted image or images."
    type: DT_FLOAT
  }
  summary: "Adjust the contrast of one or more images."
  description: "`images` is a tensor of at least 3 dimensions.  The last 3 dimensions are\ninterpreted as `[height, width, channels]`.  The other dimensions only\nrepresent a collection of images, such as `[batch, height, width, channels].`\n\nContrast is adjusted independently for each channel of each image.\n\nFor each channel, the Op first computes the mean of the image pixels in the\nchannel and then adjusts each component of each pixel to\n`(x - mean) * contrast_factor + mean`."
}
op {
  name: "All"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type: DT_BOOL
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type: DT_BOOL
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  summary: "Computes the \"logical and\" of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "AllCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to produce per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a learned unigram distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Any"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type: DT_BOOL
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type: DT_BOOL
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  summary: "Computes the \"logical or\" of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "ApplyAdadelta"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum_update"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "rho"
    description: "Decay factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "epsilon"
    description: "Constant factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, updating of the var, accum and update_accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'*var\' according to the adadelta scheme."
  description: "accum = rho() * accum + (1 - rho()) * grad.square();\nupdate = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;\nupdate_accum = rho() * update_accum + (1 - rho()) * update.square();\nvar -= update;"
}
op {
  name: "ApplyAdagrad"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention."
  }
  summary: "Update \'*var\' according to the adagrad scheme."
  description: "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))"
}
op {
  name: "ApplyAdam"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "m"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "v"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "beta1_power"
    description: "Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "beta2_power"
    description: "Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "beta1"
    description: "Momentum factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "beta2"
    description: "Momentum factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "epsilon"
    description: "Ridge term. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention."
  }
  summary: "Update \'*var\' according to the Adam algorithm."
  description: "lr_t <- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)\nm_t <- beta1 * m_{t-1} + (1 - beta1) * g_t\nv_t <- beta2 * v_{t-1} + (1 - beta2) * g_t * g_t\nvariable <- variable - lr_t * m_t / (sqrt(v_t) + epsilon)"
}
op {
  name: "ApplyFtrl"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "linear"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "l1"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "l2"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "lr_power"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention."
  }
  summary: "Update \'*var\' according to the Ftrl-proximal scheme."
  description: "accum_new = accum + grad * grad\nlinear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new"
}
op {
  name: "ApplyGradientDescent"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "alpha"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "delta"
    description: "The change."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'*var\' by subtracting \'alpha\' * \'delta\' from it."
}
op {
  name: "ApplyMomentum"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  input_arg {
    name: "momentum"
    description: "Momentum. Must be a scalar."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention."
  }
  summary: "Update \'*var\' according to the momentum scheme."
  description: "accum = accum * momentum + grad\nvar -= lr * accum"
}
op {
  name: "ApplyRMSProp"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "ms"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "mom"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "rho"
    description: "Decay rate. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "momentum"
    type_attr: "T"
  }
  input_arg {
    name: "epsilon"
    description: "Ridge term. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention."
  }
  summary: "Update \'*var\' according to the RMSProp algorithm."
  description: "mean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom"
}
op {
  name: "ArgMax"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "dimension"
    description: "int32, 0 <= dimension < rank(input).  Describes which dimension\nof the input Tensor to reduce across. For vectors, use dimension = 0."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type: DT_INT64
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Returns the index with the largest value across dimensions of a tensor."
}
op {
  name: "ArgMin"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "dimension"
    description: "int32, 0 <= dimension < rank(input).  Describes which dimension\nof the input Tensor to reduce across. For vectors, use dimension = 0."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type: DT_INT64
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Returns the index with the smallest value across dimensions of a tensor."
}
op {
  name: "Assert"
  input_arg {
    name: "condition"
    description: "The condition to evaluate."
    type: DT_BOOL
  }
  input_arg {
    name: "data"
    description: "The tensors to print out when condition is false."
    type_list_attr: "T"
  }
  attr {
    name: "T"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "summarize"
    type: "int"
    default_value {
      i: 3
    }
    description: "Print this many entries of each tensor."
  }
  summary: "Asserts that the given condition is true."
  description: "If `condition` evaluates to false, print the list of tensors in `data`.\n`summarize` determines how many entries of the tensors to print."
  is_stateful: true
}
op {
  name: "Assign"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node. May be uninitialized."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "value"
    description: "The value to be assigned to the variable."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been reset."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "validate_shape"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true, the operation will validate that the shape\nof \'value\' matches the shape of the Tensor being assigned to.  If false,\n\'ref\' will take on the shape of \'value\'."
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: true
    }
    description: "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'ref\' by assigning \'value\' to it."
  description: "This operation outputs \"ref\" after the assignment is done.\nThis makes it easier to chain operations that need to use the reset value."
  allows_uninitialized_input: true
}
op {
  name: "AssignAdd"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "value"
    description: "The value to be added to the variable."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'ref\' by adding \'value\' to it."
  description: "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value."
}
op {
  name: "AssignSub"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "value"
    description: "The value to be subtracted to the variable."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Update \'ref\' by subtracting \'value\' from it."
  description: "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value."
}
op {
  name: "AudioSummary"
  input_arg {
    name: "tag"
    description: "Scalar. Used to build the `tag` attribute of the summary values."
    type: DT_STRING
  }
  input_arg {
    name: "tensor"
    description: "2-D of shape `[batch_size, frames]`."
    type: DT_FLOAT
  }
  output_arg {
    name: "summary"
    description: "Scalar. Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "sample_rate"
    type: "float"
    description: "The sample rate of the signal in hertz."
  }
  attr {
    name: "max_outputs"
    type: "int"
    default_value {
      i: 3
    }
    description: "Max number of batch elements to generate audio for."
    has_minimum: true
    minimum: 1
  }
  summary: "Outputs a `Summary` protocol buffer with audio."
  description: "The summary has up to `max_outputs` summary values containing audio. The\naudio is built from `tensor` which must be 3-D with shape `[batch_size,\nframes, channels]` or 2-D with shape `[batch_size, frames]`. The values are\nassumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_outputs` is 1, the summary value tag is \'*tag*/audio\'.\n*  If `max_outputs` is greater than 1, the summary value tags are\n   generated sequentially as \'*tag*/audio/0\', \'*tag*/audio/1\', etc."
}
op {
  name: "AvgPool"
  input_arg {
    name: "value"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The average pooled output tensor."
    type_attr: "T"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the sliding window for each dimension of `value`."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of `value`."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Performs average pooling on the input."
  description: "Each entry in `output` is the mean of the corresponding size `ksize`\nwindow in `value`."
}
op {
  name: "AvgPool3D"
  input_arg {
    name: "input"
    description: "Shape `[batch, depth, rows, cols, channels]` tensor to pool over."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The average pooled output tensor."
    type_attr: "T"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[1] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Performs 3D average pooling on the input."
}
op {
  name: "AvgPool3DGrad"
  input_arg {
    name: "orig_input_shape"
    description: "The original input dimensions."
    type: DT_INT32
  }
  input_arg {
    name: "grad"
    description: "Output backprop of shape `[batch, depth, rows, cols, channels]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The backprop for input."
    type_attr: "T"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[1] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Computes gradients of average pooling function."
}
op {
  name: "AvgPoolGrad"
  input_arg {
    name: "orig_input_shape"
    description: "1-D.  Shape of the original input to `avg_pool`."
    type: DT_INT32
  }
  input_arg {
    name: "grad"
    description: "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t.\nthe output of `avg_pool`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D.  Gradients w.r.t. the input of `avg_pool`."
    type_attr: "T"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the sliding window for each dimension of the input."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the input."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes gradients of the average pooling function."
}
op {
  name: "BatchCholesky"
  input_arg {
    name: "input"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the Cholesky decomposition of a batch of square matrices."
  description: "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices, with the same constraints as the single matrix Cholesky\ndecomposition above. The output is a tensor of the same shape as the input\ncontaining the Cholesky decompositions for all input submatrices `[..., :, :]`."
}
op {
  name: "BatchFFT"
  input_arg {
    name: "input"
    description: "A complex64 tensor."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "A complex64 tensor of the same shape as `input`. The inner-most\ndimension of `input` is replaced with its 1D Fourier Transform."
    type: DT_COMPLEX64
  }
  summary: "Compute the 1-dimensional discrete Fourier Transform over the inner-most"
  description: "dimension of `input`."
}
op {
  name: "BatchFFT2D"
  input_arg {
    name: "input"
    description: "A complex64 tensor."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "A complex64 tensor of the same shape as `input`. The inner-most 2\ndimensions of `input` are replaced with their 2D Fourier Transform."
    type: DT_COMPLEX64
  }
  summary: "Compute the 2-dimensional discrete Fourier Transform over the inner-most"
  description: "2 dimensions of `input`."
}
op {
  name: "BatchFFT3D"
  input_arg {
    name: "input"
    description: "A complex64 tensor."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "A complex64 tensor of the same shape as `input`. The inner-most 3\ndimensions of `input` are replaced with their 3D Fourier Transform."
    type: DT_COMPLEX64
  }
  summary: "Compute the 3-dimensional discrete Fourier Transform over the inner-most 3"
  description: "dimensions of `input`."
}
op {
  name: "BatchIFFT"
  input_arg {
    name: "input"
    description: "A complex64 tensor."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "A complex64 tensor of the same shape as `input`. The inner-most\ndimension of `input` is replaced with its inverse 1D Fourier Transform."
    type: DT_COMPLEX64
  }
  summary: "Compute the inverse 1-dimensional discrete Fourier Transform over the inner-most"
  description: "dimension of `input`."
}
op {
  name: "BatchIFFT2D"
  input_arg {
    name: "input"
    description: "A complex64 tensor."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "A complex64 tensor of the same shape as `input`. The inner-most 2\ndimensions of `input` are replaced with their inverse 2D Fourier Transform."
    type: DT_COMPLEX64
  }
  summary: "Compute the inverse 2-dimensional discrete Fourier Transform over the inner-most"
  description: "2 dimensions of `input`."
}
op {
  name: "BatchIFFT3D"
  input_arg {
    name: "input"
    description: "A complex64 tensor."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "A complex64 tensor of the same shape as `input`. The inner-most 3\ndimensions of `input` are replaced with their inverse 3D Fourier Transform."
    type: DT_COMPLEX64
  }
  summary: "Compute the inverse 3-dimensional discrete Fourier Transform over the inner-most"
  description: "3 dimensions of `input`."
}
op {
  name: "BatchMatMul"
  input_arg {
    name: "x"
    description: "3-D or higher with shape `[..., r_x, c_x]`."
    type_attr: "T"
  }
  input_arg {
    name: "y"
    description: "3-D or higher with shape `[..., r_y, c_y]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "3-D or higher with shape `[..., r_o, c_o]`"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
      }
    }
  }
  attr {
    name: "adj_x"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, adjoint the slices of `x`. Defaults to `False`."
  }
  attr {
    name: "adj_y"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, adjoint the slices of `y`. Defaults to `False`."
  }
  summary: "Multiplies slices of two tensors in batches."
  description: "Multiplies all slices of `Tensor` `x` and `y` (each slice can be\nviewed as an element of a batch), and arranges the individual results\nin a single output tensor of the same batch size. Each of the\nindividual slices can optionally be adjointed (to adjoint a matrix\nmeans to transpose and conjugate it) before multiplication by setting\nthe `adj_x` or `adj_y` flag to `True`, which are by default `False`.\n\nThe input tensors `x` and `y` are 3-D or higher with shape `[..., r_x, c_x]`\nand `[..., r_y, c_y]`.\n\nThe output tensor is 3-D or higher with shape `[..., r_o, c_o]`, where:\n\n    r_o = c_x if adj_x else r_x\n    c_o = r_y if adj_y else c_y\n\nIt is computed as:\n\n    output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])"
}
op {
  name: "BatchMatrixBandPart"
  input_arg {
    name: "input"
    description: "Rank `k` tensor."
    type_attr: "T"
  }
  input_arg {
    name: "num_lower"
    description: "0-D tensor. Number of subdiagonals to keep. If negative, keep entire\nlower triangle."
    type: DT_INT64
  }
  input_arg {
    name: "num_upper"
    description: "0-D tensor. Number of superdiagonals to keep. If negative, keep\nentire upper triangle."
    type: DT_INT64
  }
  output_arg {
    name: "band"
    description: "Rank `k` tensor of the same shape as input. The extracted banded tensor."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Copy a tensor setting everything outside a central band in each innermost matrix"
  description: "to zero.\n\nThe `band` part is computed as follows:\nAssume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a\ntensor with the same shape where\n\n`band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.\n\nThe indicator function \'in_band(m, n)` is one if\n`(num_lower < 0 || (m-n) <= num_lower)) &&\n(num_upper < 0 || (n-m) <= num_upper)`, and zero otherwise.\n\nFor example:\n\n```prettyprint\n# if \'input\' is [[ 0,  1,  2, 3]\n                 [-1,  0,  1, 2]\n                 [-2, -1,  0, 1]\n                 [-3, -2, -1, 0]],\n\ntf.batch_matrix_band_part(input, 1, -1) ==> [[ 0,  1,  2, 3]\n                                             [-1,  0,  1, 2]\n                                             [ 0, -1,  0, 1]\n                                             [ 0,  0, -1, 0]],\n\ntf.batch_matrix_band_part(input, 2, 1) ==> [[ 0,  1,  0, 0]\n                                            [-1,  0,  1, 0]\n                                            [-2, -1,  0, 1]\n                                            [ 0, -2, -1, 0]]\n```\n\nUseful special cases:\n\n```prettyprint\n tf.batch_matrix_band_part(input, 0, -1) ==> Upper triangular part.\n tf.batch_matrix_band_part(input, -1, 0) ==> Lower triangular part.\n tf.batch_matrix_band_part(input, 0, 0) ==> Diagonal.\n```"
}
op {
  name: "BatchMatrixDeterminant"
  input_arg {
    name: "input"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[...]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Calculates the determinants for a batch of square matrices."
  description: "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a 1-D tensor containing the determinants\nfor all input submatrices `[..., :, :]`."
}
op {
  name: "BatchMatrixDiag"
  input_arg {
    name: "diagonal"
    description: "Rank `k`, where `k >= 1`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Rank `k+1`, with `output.shape = diagonal.shape + [diagonal.shape[-1]]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns a batched diagonal tensor with a given batched diagonal values."
  description: "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has `k` dimensions `[I, J, K, ..., N]`, then the output is a\ntensor of rank `k+1` with dimensions [I, J, K, ..., N, N]` where:\n\n`output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]`.\n\nFor example:\n\n```prettyprint\n# \'diagonal\' is [[1, 2, 3, 4], [5, 6, 7, 8]]\n\nand diagonal.shape = (2, 4)\n\ntf.batch_matrix_diag(diagonal) ==> [[[1, 0, 0, 0]\n                                     [0, 2, 0, 0]\n                                     [0, 0, 3, 0]\n                                     [0, 0, 0, 4]],\n                                    [[5, 0, 0, 0]\n                                     [0, 6, 0, 0]\n                                     [0, 0, 7, 0]\n                                     [0, 0, 0, 8]]]\n\nwhich has shape (2, 4, 4)\n```"
}
op {
  name: "BatchMatrixDiagPart"
  input_arg {
    name: "input"
    description: "Rank `k` tensor where `k >= 2` and the last two dimensions are equal."
    type_attr: "T"
  }
  output_arg {
    name: "diagonal"
    description: "The extracted diagonal(s) having shape\n`diagonal.shape = input.shape[:-1]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the batched diagonal part of a batched tensor."
  description: "This operation returns a tensor with the `diagonal` part\nof the batched `input`. The `diagonal` part is computed as follows:\n\nAssume `input` has `k` dimensions `[I, J, K, ..., N, N]`, then the output is a\ntensor of rank `k - 1` with dimensions `[I, J, K, ..., N]` where:\n\n`diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]`.\n\nThe input must be at least a matrix.\n\nFor example:\n\n```prettyprint\n# \'input\' is [[[1, 0, 0, 0]\n               [0, 2, 0, 0]\n               [0, 0, 3, 0]\n               [0, 0, 0, 4]],\n              [[5, 0, 0, 0]\n               [0, 6, 0, 0]\n               [0, 0, 7, 0]\n               [0, 0, 0, 8]]]\n\nand input.shape = (2, 4, 4)\n\ntf.batch_matrix_diag_part(input) ==> [[1, 2, 3, 4], [5, 6, 7, 8]]\n\nwhich has shape (2, 4)\n```"
}
op {
  name: "BatchMatrixInverse"
  input_arg {
    name: "input"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  attr {
    name: "adjoint"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the inverse of square invertible matrices or their adjoints"
  description: "(conjugate transposes).\n\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the inverse for all input submatrices `[..., :, :]`.\n\nThe op uses LU decomposition with partial pivoting to compute the inverses.\n\nIf a matrix is not invertible there is no guarantee what the op does. It\nmay detect the condition and raise an exception or it may simply return a\ngarbage result."
}
op {
  name: "BatchMatrixSolve"
  input_arg {
    name: "matrix"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  input_arg {
    name: "rhs"
    description: "Shape is `[..., M, K]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., M, K]`."
    type_attr: "T"
  }
  attr {
    name: "adjoint"
    type: "bool"
    default_value {
      b: false
    }
    description: "Boolean indicating whether to solve with `matrix` or its (block-wise)\nadjoint."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Solves systems of linear equations. Checks for invertibility."
  description: "Matrix is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. Rhs is a tensor of shape\n`[..., M, K]`. The output is a tensor shape `[..., M, K]`.  If `adjoint` is `False` then each output\nmatrix satisfies `matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.\nIf `adjoint` is `True` then each output\nmatrix satisfies `adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]`."
}
op {
  name: "BatchMatrixSolveLs"
  input_arg {
    name: "matrix"
    description: "Shape is `[..., M, N]`."
    type_attr: "T"
  }
  input_arg {
    name: "rhs"
    description: "Shape is `[..., M, K]`."
    type_attr: "T"
  }
  input_arg {
    name: "l2_regularizer"
    type: DT_DOUBLE
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., N, K]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  attr {
    name: "fast"
    type: "bool"
    default_value {
      b: true
    }
  }
  summary: "Solves multiple linear least-squares problems."
  description: "`matrix` is a tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform square matrices. Rhs is a tensor of shape `[..., M, K]`. The output\nis a tensor shape `[..., N, K]` where each output matrix solves each of\nthe equations matrix[..., :, :] * output[..., :, :] = rhs[..., :, :] in the\nleast squares sense.\n\nBelow we will use the following notation for each pair of\nmatrix and right-hand sides in the batch:\n\n`matrix`=\\\\(A \\in \\Re^{m \\times n}\\\\),\n`rhs`=\\\\(B  \\in \\Re^{m \\times k}\\\\),\n`output`=\\\\(X  \\in \\Re^{n \\times k}\\\\),\n`l2_regularizer`=\\\\(\\lambda\\\\).\n\nIf `fast` is `True`, then the solution is computed by solving the normal\nequations using Cholesky decomposition. Specifically, if \\\\(m \\ge n\\\\) then\n\\\\(X = (A^T A + \\lambda I)^{-1} A^T B\\\\), which solves the least-squares\nproblem \\\\(X = \\mathrm{argmin}_{Z \\in \\Re^{n \\times k}} ||A Z - B||_F^2 +\n\\lambda ||Z||_F^2\\\\). If \\\\(m \\lt n\\\\) then `output` is computed as\n\\\\(X = A^T (A A^T + \\lambda I)^{-1} B\\\\), which (for \\\\(\\lambda = 0\\\\)) is the\nminimum-norm solution to the under-determined linear system, i.e.\n\\\\(X = \\mathrm{argmin}_{Z \\in \\Re^{n \\times k}} ||Z||_F^2 \\\\), subject to\n\\\\(A Z = B\\\\). Notice that the fast path is only numerically stable when\n\\\\(A\\\\) is numerically full rank and has a condition number\n\\\\(\\mathrm{cond}(A) \\lt \\frac{1}{\\sqrt{\\epsilon_{mach}}}\\\\) or\\\\(\\lambda\\\\) is\nsufficiently large.\n\nIf `fast` is `False` an algorithm based on the numerically robust complete\northogonal decomposition is used. This computes the minimum-norm\nleast-squares solution, even when \\\\(A\\\\) is rank deficient. This path is\ntypically 6-7 times slower than the fast path. If `fast` is `False` then\n`l2_regularizer` is ignored."
}
op {
  name: "BatchMatrixTriangularSolve"
  input_arg {
    name: "matrix"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  input_arg {
    name: "rhs"
    description: "Shape is `[..., M, K]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., M, K]`."
    type_attr: "T"
  }
  attr {
    name: "lower"
    type: "bool"
    default_value {
      b: true
    }
    description: "Boolean indicating whether the innermost matrices in `matrix` are\nlower or upper triangular."
  }
  attr {
    name: "adjoint"
    type: "bool"
    default_value {
      b: false
    }
    description: "Boolean indicating whether to solve with `matrix` or its (block-wise)\nadjoint."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Solves systems of linear equations with upper or lower triangular matrices by"
  description: "backsubstitution.\n\n`matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions form\nsquare matrices. If `lower` is `True` then the strictly upper triangular part\nof each inner-most matrix is assumed to be zero and not accessed.\nIf `lower` is False then the strictly lower triangular part of each inner-most\nmatrix is assumed to be zero and not accessed.\n`rhs` is a tensor of shape [..., M, K]`.\n\nThe output is a tensor of shape `[..., M, K]`. If `adjoint` is `True` then the\ninnermost matrices in output` satisfy matrix equations\n`matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.\nIf `adjoint` is `False` then the strictly then the  innermost matrices in\n`output` satisfy matrix equations\n`adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`."
}
op {
  name: "BatchNormWithGlobalNormalization"
  input_arg {
    name: "t"
    description: "A 4D input Tensor."
    type_attr: "T"
  }
  input_arg {
    name: "m"
    description: "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof."
    type_attr: "T"
  }
  input_arg {
    name: "v"
    description: "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof."
    type_attr: "T"
  }
  input_arg {
    name: "beta"
    description: "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor."
    type_attr: "T"
  }
  input_arg {
    name: "gamma"
    description: "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor."
    type_attr: "T"
  }
  output_arg {
    name: "result"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "variance_epsilon"
    type: "float"
    description: "A small float number to avoid dividing by 0."
  }
  attr {
    name: "scale_after_normalization"
    type: "bool"
    description: "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."
  }
  summary: "Batch normalization."
  description: "This op is deprecated. Prefer `tf.nn.batch_normalization`."
  deprecation {
    version: 9
    explanation: "Use tf.nn.batch_normalization()"
  }
}
op {
  name: "BatchNormWithGlobalNormalizationGrad"
  input_arg {
    name: "t"
    description: "A 4D input Tensor."
    type_attr: "T"
  }
  input_arg {
    name: "m"
    description: "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof."
    type_attr: "T"
  }
  input_arg {
    name: "v"
    description: "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof."
    type_attr: "T"
  }
  input_arg {
    name: "gamma"
    description: "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this Tensor will be multiplied\nwith the normalized Tensor."
    type_attr: "T"
  }
  input_arg {
    name: "backprop"
    description: "4D backprop Tensor."
    type_attr: "T"
  }
  output_arg {
    name: "dx"
    description: "4D backprop tensor for input."
    type_attr: "T"
  }
  output_arg {
    name: "dm"
    description: "1D backprop tensor for mean."
    type_attr: "T"
  }
  output_arg {
    name: "dv"
    description: "1D backprop tensor for variance."
    type_attr: "T"
  }
  output_arg {
    name: "db"
    description: "1D backprop tensor for beta."
    type_attr: "T"
  }
  output_arg {
    name: "dg"
    description: "1D backprop tensor for gamma."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "variance_epsilon"
    type: "float"
    description: "A small float number to avoid dividing by 0."
  }
  attr {
    name: "scale_after_normalization"
    type: "bool"
    description: "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."
  }
  summary: "Gradients for batch normalization."
  description: "This op is deprecated. See `tf.nn.batch_normalization`."
  deprecation {
    version: 9
    explanation: "Use tf.nn.batch_normalization()"
  }
}
op {
  name: "BatchSelfAdjointEig"
  input_arg {
    name: "input"
    description: "Shape is `[..., M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[..., M+1, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the Eigen Decomposition of a batch of square self-adjoint matrices."
  description: "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices, with the same constraints as the single matrix\nSelfAdjointEig.\n\nThe result is a \'[..., M+1, M] matrix with [..., 0,:] containing the\neigenvalues, and subsequent [...,1:, :] containing the eigenvectors."
}
op {
  name: "BatchToSpace"
  input_arg {
    name: "input"
    description: "4-D tensor with shape\n`[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n  depth]`. Note that the batch size of the input tensor must be divisible by\n`block_size * block_size`."
    type_attr: "T"
  }
  input_arg {
    name: "crops"
    description: "2-D tensor of non-negative integers with shape `[2, 2]`. It specifies\nhow many elements to crop from the intermediate result across the spatial\ndimensions as follows:\n\n    crops = [[crop_top, crop_bottom], [crop_left, crop_right]]"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "4-D with shape `[batch, height, width, depth]`, where:\n\n      height = height_pad - crop_top - crop_bottom\n      width = width_pad - crop_left - crop_right\n\nThe attr `block_size` must be greater than one. It indicates the block size."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "block_size"
    type: "int"
  }
  summary: "BatchToSpace for 4-D tensors of type T."
  description: "Rearranges (permutes) data from batch into blocks of spatial data, followed by\ncropping. This is the reverse transformation of SpaceToBatch. More specifically,\nthis op outputs a copy of the input tensor where values from the `batch`\ndimension are moved in spatial blocks to the `height` and `width` dimensions,\nfollowed by cropping along the `height` and `width` dimensions."
}
op {
  name: "BiasAdd"
  input_arg {
    name: "value"
    description: "Any number of dimensions."
    type_attr: "T"
  }
  input_arg {
    name: "bias"
    description: "1-D with size the last dimension of `value`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Broadcasted sum of `value` and `bias`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the bias tensor will be added to the last dimension\nof the value tensor.\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].\nThe tensor will be added to \"in_channels\", the third-to-the-last\n    dimension."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  summary: "Adds `bias` to `value`."
  description: "This is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions."
}
op {
  name: "BiasAddGrad"
  input_arg {
    name: "out_backprop"
    description: "Any number of dimensions."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "1-D with size the feature dimension of `out_backprop`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the bias tensor will be added to the last dimension\nof the value tensor.\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].\nThe tensor will be added to \"in_channels\", the third-to-the-last\n    dimension."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  summary: "The backward operation for \"BiasAdd\" on the \"bias\" tensor."
  description: "It accumulates all the values from out_backprop into the feature dimension.\nFor NHWC data format, the feature dimension is the last. For NCHW data format,\nthe feature dimension is the third-to-last."
}
op {
  name: "BiasAddV1"
  input_arg {
    name: "value"
    description: "Any number of dimensions."
    type_attr: "T"
  }
  input_arg {
    name: "bias"
    description: "1-D with size the last dimension of `value`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Broadcasted sum of `value` and `bias`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Adds `bias` to `value`."
  description: "This is a deprecated version of BiasAdd and will be soon removed.\n\nThis is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions."
}
op {
  name: "Bitcast"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "type"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "type"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Bitcasts a tensor from one type to another without copying data."
  description: "Given a tensor `input`, this operation returns a tensor that has the same buffer\ndata as `input` with datatype `type`.\n\nIf the input datatype `T` is larger than the output datatype `type` then the\nshape changes from [...] to [..., sizeof(`T`)/sizeof(`type`)].\n\nIf `T` is smaller than `type`, the operator requires that the rightmost\ndimension be equal to sizeof(`type`)/sizeof(`T`). The shape then goes from\n[..., sizeof(`type`)/sizeof(`T`)] to [...]."
}
op {
  name: "BroadcastGradientArgs"
  input_arg {
    name: "s0"
    type: DT_INT32
  }
  input_arg {
    name: "s1"
    type: DT_INT32
  }
  output_arg {
    name: "r0"
    type: DT_INT32
  }
  output_arg {
    name: "r1"
    type: DT_INT32
  }
  summary: "Return the reduction indices for computing gradients of s0 op s1 with broadcast."
  description: "This is typically used by gradient computations for a broadcasting operation."
}
op {
  name: "CTCBeamSearchDecoder"
  input_arg {
    name: "inputs"
    description: "3-D, shape: `(max_time x batch_size x num_classes)`, the logits."
    type: DT_FLOAT
  }
  input_arg {
    name: "sequence_length"
    description: "A vector containing sequence lengths, size `(batch)`."
    type: DT_INT32
  }
  output_arg {
    name: "decoded_indices"
    description: "A list (length: top_paths) of indices matrices.  Matrix j,\nsize `(total_decoded_outputs[j] x 2)`, has indices of a\n`SparseTensor<int64, 2>`.  The rows store: [batch, time]."
    type: DT_INT64
    number_attr: "top_paths"
  }
  output_arg {
    name: "decoded_values"
    description: "A list (length: top_paths) of values vectors.  Vector j,\nsize `(length total_decoded_outputs[j])`, has the values of a\n`SparseTensor<int64, 2>`.  The vector stores the decoded classes for beam j."
    type: DT_INT64
    number_attr: "top_paths"
  }
  output_arg {
    name: "decoded_shape"
    description: "A list (length: top_paths) of shape vector.  Vector j,\nsize `(2)`, stores the shape of the decoded `SparseTensor[j]`.\nIts values are: `[batch_size, max_decoded_length[j]]`."
    type: DT_INT64
    number_attr: "top_paths"
  }
  output_arg {
    name: "log_probability"
    description: "A matrix, shaped: `(batch_size x top_paths)`.  The\nsequence log-probabilities."
    type: DT_FLOAT
  }
  attr {
    name: "beam_width"
    type: "int"
    description: "A scalar >= 0 (beam search beam width)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "top_paths"
    type: "int"
    description: "A scalar >= 0, <= beam_width (controls output size)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "merge_repeated"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true, merge repeated classes in output."
  }
  summary: "Performs beam search decoding on the logits given in input."
  description: "A note about the attribute merge_repeated: For the beam search decoder,\nthis means that if consecutive entries in a beam are the same, only\nthe first of these is emitted.  That is, when the top path is \"A B B B B\",\n\"A B\" is returned if merge_repeated = True but \"A B B B B\" is\nreturned if merge_repeated = False."
}
op {
  name: "CTCGreedyDecoder"
  input_arg {
    name: "inputs"
    description: "3-D, shape: `(max_time x batch_size x num_classes)`, the logits."
    type: DT_FLOAT
  }
  input_arg {
    name: "sequence_length"
    description: "A vector containing sequence lengths, size `(batch_size)`."
    type: DT_INT32
  }
  output_arg {
    name: "decoded_indices"
    description: "Indices matrix, size `(total_decoded_outputs x 2)`,\nof a `SparseTensor<int64, 2>`.  The rows store: [batch, time]."
    type: DT_INT64
  }
  output_arg {
    name: "decoded_values"
    description: "Values vector, size: `(total_decoded_outputs)`,\nof a `SparseTensor<int64, 2>`.  The vector stores the decoded classes."
    type: DT_INT64
  }
  output_arg {
    name: "decoded_shape"
    description: "Shape vector, size `(2)`, of the decoded SparseTensor.\nValues are: `[batch_size, max_decoded_length]`."
    type: DT_INT64
  }
  output_arg {
    name: "log_probability"
    description: "Matrix, size `(batch_size x 1)`, containing sequence\nlog-probabilities."
    type: DT_FLOAT
  }
  attr {
    name: "merge_repeated"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, merge repeated classes in output."
  }
  summary: "Performs greedy decoding on the logits given in inputs."
  description: "A note about the attribute merge_repeated: if enabled, when\nconsecutive logits\' maximum indices are the same, only the first of\nthese is emitted.  Labeling the blank \'*\', the sequence \"A B B * B B\"\nbecomes \"A B\" if merge_repeated = True and \"A B B B B\" if\nmerge_repeated = False.\n\nRegardless of the value of merge_repeated, if the maximum index of a given\ntime and batch corresponds to the blank, index `(num_classes - 1)`, no new\nelement is emitted."
}
op {
  name: "CTCLoss"
  input_arg {
    name: "inputs"
    description: "3-D, shape: `(max_time x batch_size x num_classes)`, the logits."
    type: DT_FLOAT
  }
  input_arg {
    name: "labels_indices"
    description: "The indices of a `SparseTensor<int32, 2>`.\n`labels_indices(i, :) == [b, t]` means `labels_values(i)` stores the id for\n`(batch b, time t)`."
    type: DT_INT64
  }
  input_arg {
    name: "labels_values"
    description: "The values (labels) associated with the given batch and time."
    type: DT_INT32
  }
  input_arg {
    name: "sequence_length"
    description: "A vector containing sequence lengths (batch)."
    type: DT_INT32
  }
  output_arg {
    name: "loss"
    description: "A vector (batch) containing log-probabilities."
    type: DT_FLOAT
  }
  output_arg {
    name: "gradient"
    description: "The gradient of `loss`.  3-D, shape:\n`(max_time x batch_size x num_classes)`."
    type: DT_FLOAT
  }
  attr {
    name: "preprocess_collapse_repeated"
    type: "bool"
    default_value {
      b: false
    }
    description: "Scalar, if true then repeated labels are\ncollapsed prior to the CTC calculation."
  }
  attr {
    name: "ctc_merge_repeated"
    type: "bool"
    default_value {
      b: true
    }
    description: "Scalar.  If set to false, *during* CTC calculation\nrepeated non-blank labels will not be merged and are interpreted as\nindividual labels.  This is a simplified version of CTC."
  }
  summary: "Calculates the CTC Loss (log probability) for each batch entry.  Also calculates"
  description: "the gradient.  This class performs the softmax operation for you, so inputs\nshould be e.g. linear projections of outputs by an LSTM."
}
op {
  name: "Cast"
  input_arg {
    name: "x"
    type_attr: "SrcT"
  }
  output_arg {
    name: "y"
    type_attr: "DstT"
  }
  attr {
    name: "SrcT"
    type: "type"
  }
  attr {
    name: "DstT"
    type: "type"
  }
  summary: "Cast x of type SrcT to y of DstT."
}
op {
  name: "Ceil"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns element-wise smallest integer in not less than x."
}
op {
  name: "CheckNumerics"
  input_arg {
    name: "tensor"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "message"
    type: "string"
    description: "Prefix of the error message."
  }
  summary: "Checks a tensor for NaN and Inf values."
  description: "When run, reports an `InvalidArgument` error if `tensor` has any values\nthat are not a number (NaN) or infinity (Inf). Otherwise, passes `tensor` as-is."
}
op {
  name: "Cholesky"
  input_arg {
    name: "input"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the Cholesky decomposition of a square matrix."
  description: "The input has to be symmetric and positive definite. Only the lower-triangular\npart of the input will be used for this operation. The upper-triangular part\nwill not be read.\n\nThe result is the lower-triangular matrix of the Cholesky decomposition of the\ninput, `L`, so that `input = L L^*`."
}
op {
  name: "CholeskyGrad"
  input_arg {
    name: "l"
    description: "Output of Cholesky algorithm l = chol(A). Shape is `[M, M]`. Algorithm depends only on lower triangular part of this matrix."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "df/dl where f is some scalar function. Shape is `[M, M]\'. Algorithm depends only on lower triangular part of this matrix."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Symmetrized version of df/dA . Shape is `[M, M]\'"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Calculates the reverse mode backpropagated gradient of the Cholesky algorithm."
  description: "For an explanation see \"Differentiation of the Cholesky algorithm\" by Iain Murray http://arxiv.org/abs/1602.07527."
}
op {
  name: "Complex"
  input_arg {
    name: "real"
    type: DT_FLOAT
  }
  input_arg {
    name: "imag"
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    type: DT_COMPLEX64
  }
  summary: "Converts two real numbers to a complex number."
  description: "Given a tensor `real` representing the real part of a complex number, and a\ntensor `imag` representing the imaginary part of a complex number, this\noperation returns complex numbers elementwise of the form \\\\(a + bj\\\\), where\n*a* represents the `real` part and *b* represents the `imag` part.\n\nThe input tensors `real` and `imag` must have the same shape.\n\nFor example:\n\n```\n# tensor \'real\' is [2.25, 3.25]\n# tensor `imag` is [4.75, 5.75]\ntf.complex(real, imag) ==> [[2.25 + 4.75j], [3.25 + 5.75j]]\n```"
}
op {
  name: "ComplexAbs"
  input_arg {
    name: "x"
    type: DT_COMPLEX64
  }
  output_arg {
    name: "y"
    type: DT_FLOAT
  }
  summary: "Computes the complex absolute value of a tensor."
  description: "Given a tensor `x` of complex numbers, this operation returns a tensor of type\n`float` that is the absolute value of each element in `x`. All elements in `x`\nmust be complex numbers of the form \\\\(a + bj\\\\). The absolute value is\ncomputed as \\\\( \\sqrt{a^2 + b^2}\\\\).\n\nFor example:\n\n```\n# tensor \'x\' is [[-2.25 + 4.75j], [-3.25 + 5.75j]]\ntf.complex_abs(x) ==> [5.25594902, 6.60492229]\n```"
}
op {
  name: "ComputeAccidentalHits"
  input_arg {
    name: "true_classes"
    description: "The true_classes output of UnpackSparseLabels."
    type: DT_INT64
  }
  input_arg {
    name: "sampled_candidates"
    description: "The sampled_candidates output of CandidateSampler."
    type: DT_INT64
  }
  output_arg {
    name: "indices"
    description: "A vector of indices corresponding to rows of true_candidates."
    type: DT_INT32
  }
  output_arg {
    name: "ids"
    description: "A vector of IDs of positions in sampled_candidates that match a true_label\nfor the row with the corresponding index in indices."
    type: DT_INT64
  }
  output_arg {
    name: "weights"
    description: "A vector of the same length as indices and ids, in which each element\nis -FLOAT_MAX."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Computes the ids of the positions in sampled_candidates that match true_labels."
  description: "When doing log-odds NCE, the result of this op should be passed through a\nSparseToDense op, then added to the logits of the sampled candidates. This has\nthe effect of \'removing\' the sampled labels that match the true labels by\nmaking the classifier sure that they are sampled labels."
}
op {
  name: "Concat"
  input_arg {
    name: "concat_dim"
    description: "0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values))."
    type: DT_INT32
  }
  input_arg {
    name: "values"
    description: "The `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`."
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "output"
    description: "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor\'s shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes."
    type_attr: "T"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 2
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Concatenates tensors along one dimension."
}
op {
  name: "ConcatOffset"
  input_arg {
    name: "concat_dim"
    description: "The dimension along which to concatenate."
    type: DT_INT32
  }
  input_arg {
    name: "shape"
    description: "The `N` int32 vectors representing shape of tensors being concatenated."
    type: DT_INT32
    number_attr: "N"
  }
  output_arg {
    name: "offset"
    type: DT_INT32
    number_attr: "N"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 2
  }
  summary: "Computes offsets of concat inputs within its output."
  description: "For example:\n\n```prettyprint\n# \'x\' is [2, 2, 7]\n# \'y\' is [2, 3, 7]\n# \'z\' is [2, 5, 7]\nconcat_offset(2, [x, y, z]) => [0, 0, 0], [0, 2, 0], [0, 5, 0]\n```"
}
op {
  name: "Conj"
  input_arg {
    name: "input"
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    type: DT_COMPLEX64
  }
  summary: "Returns the complex conjugate of a complex number."
  description: "Given a tensor `input` of complex numbers, this operation returns a tensor of\ncomplex numbers that are the complex conjugate of each element in `input`. The\ncomplex numbers in `input` must be of the form \\\\(a + bj\\\\), where *a* is the\nreal part and *b* is the imaginary part.\n\nThe complex conjugate returned by this operation is of the form \\\\(a - bj\\\\).\n\nFor example:\n\n```\n# tensor \'input\' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.conj(input) ==> [-2.25 - 4.75j, 3.25 - 5.75j]\n```"
}
op {
  name: "Const"
  output_arg {
    name: "output"
    type_attr: "dtype"
  }
  attr {
    name: "value"
    type: "tensor"
    description: "Attr `value` is the tensor to return."
  }
  attr {
    name: "dtype"
    type: "type"
  }
  summary: "Returns a constant tensor."
}
op {
  name: "ControlTrigger"
  summary: "Does nothing. Serves as a control trigger for scheduling. Only useful as a"
  description: "placeholder for control edges."
}
op {
  name: "Conv2D"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "filter"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`. Must be in the same order as the dimension specified with format."
  }
  attr {
    name: "use_cudnn_on_gpu"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  summary: "Computes a 2-D convolution given 4-D `input` and `filter` tensors."
  description: "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, out_channels]`, this op\nperforms the following:\n\n1. Flattens the filter to a 2-D matrix with shape\n   `[filter_height * filter_width * in_channels, output_channels]`.\n2. Extracts image patches from the input tensor to form a *virtual*\n   tensor of shape `[batch, out_height, out_width,\n   filter_height * filter_width * in_channels]`.\n3. For each patch, right-multiplies the filter matrix and the image patch\n   vector.\n\nIn detail, with the default NHWC format,\n\n    output[b, i, j, k] =\n        sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *\n                        filter[di, dj, q, k]\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`."
}
op {
  name: "Conv2DBackpropFilter"
  input_arg {
    name: "input"
    description: "4-D with shape `[batch, in_height, in_width, in_channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "filter_sizes"
    description: "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, out_channels]` tensor."
    type: DT_INT32
  }
  input_arg {
    name: "out_backprop"
    description: "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat."
  }
  attr {
    name: "use_cudnn_on_gpu"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  summary: "Computes the gradients of convolution with respect to the filter."
}
op {
  name: "Conv2DBackpropInput"
  input_arg {
    name: "input_sizes"
    description: "An integer vector representing the shape of `input`,\nwhere `input` is a 4-D `[batch, height, width, channels]` tensor."
    type: DT_INT32
  }
  input_arg {
    name: "filter"
    description: "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "out_backprop"
    description: "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient\nw.r.t. the input of the convolution."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat."
  }
  attr {
    name: "use_cudnn_on_gpu"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  summary: "Computes the gradients of convolution with respect to the input."
}
op {
  name: "Conv3D"
  input_arg {
    name: "input"
    description: "Shape `[batch, in_depth, in_height, in_width, in_channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "filter"
    description: "Shape `[filter_depth, filter_height, filter_width, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes a 3-D convolution given 5-D `input` and `filter` tensors."
  description: "In signal processing, cross-correlation is a measure of similarity of\ntwo waveforms as a function of a time-lag applied to one of them. This\nis also known as a sliding dot product or sliding inner-product.\n\nOur Conv3D implements a form of cross-correlation."
}
op {
  name: "Conv3DBackpropFilter"
  input_arg {
    name: "input"
    description: "Shape `[batch, depth, rows, cols, in_channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "filter"
    description: "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`."
    type_attr: "T"
  }
  input_arg {
    name: "out_backprop"
    description: "Backprop signal of shape `[batch, out_depth, out_rows, out_cols, out_channels]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes the gradients of 3D convolution with respect to the filter."
}
op {
  name: "Conv3DBackpropInput"
  input_arg {
    name: "input"
    description: "Shape `[batch, depth, rows, cols, in_channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "filter"
    description: "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`."
    type_attr: "T"
  }
  input_arg {
    name: "out_backprop"
    description: "Backprop signal of shape `[batch, out_depth, out_rows, out_cols, out_channels]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes the gradients of 3D convolution with respect to the input."
}
op {
  name: "Cos"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes cos of x element-wise."
}
op {
  name: "CountUpTo"
  input_arg {
    name: "ref"
    description: "Should be from a scalar `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "A copy of the input before increment. If nothing else modifies the\ninput, the values produced will all be distinct."
    type_attr: "T"
  }
  attr {
    name: "limit"
    type: "int"
    description: "If incrementing ref would bring it above limit, instead generates an\n\'OutOfRange\' error."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Increments \'ref\' until it reaches \'limit\'."
  description: "This operation outputs \"ref\" after the update is done.  This makes it\neasier to chain operations that need to use the updated value."
}
op {
  name: "Cross"
  input_arg {
    name: "a"
    description: "A tensor containing 3-element vectors."
    type_attr: "T"
  }
  input_arg {
    name: "b"
    description: "Another tensor, of same type and shape as `a`."
    type_attr: "T"
  }
  output_arg {
    name: "product"
    description: "Pairwise cross product of the vectors in `a` and `b`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Compute the pairwise cross product."
  description: "`a` and `b` must be the same shape; they can either be simple 3-element vectors,\nor any shape where the innermost dimension is 3. In the latter case, each pair\nof corresponding 3-element vectors is cross-multiplied independently."
}
op {
  name: "DecodeCSV"
  input_arg {
    name: "records"
    description: "Each string is a record/row in the csv and all records should have\nthe same format."
    type: DT_STRING
  }
  input_arg {
    name: "record_defaults"
    description: "One tensor per column of the input record, with either a\nscalar default value for that column or empty if the column is required."
    type_list_attr: "OUT_TYPE"
  }
  output_arg {
    name: "output"
    description: "Each tensor will have the same shape as records."
    type_list_attr: "OUT_TYPE"
  }
  attr {
    name: "OUT_TYPE"
    type: "list(type)"
    has_minimum: true
    minimum: 1
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT32
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "field_delim"
    type: "string"
    default_value {
      s: ","
    }
    description: "delimiter to separate fields in a record."
  }
  summary: "Convert CSV records to tensors. Each column maps to one tensor."
  description: "RFC 4180 format is expected for the CSV records.\n(https://tools.ietf.org/html/rfc4180)\nNote that we allow leading and trailing spaces with int or float field."
}
op {
  name: "DecodeJSONExample"
  input_arg {
    name: "json_examples"
    description: "Each string is a JSON object serialized according to the JSON\nmapping of the Example proto."
    type: DT_STRING
  }
  output_arg {
    name: "binary_examples"
    description: "Each string is a binary Example protocol buffer corresponding\nto the respective element of `json_examples`."
    type: DT_STRING
  }
  summary: "Convert JSON-encoded Example records to binary protocol buffer strings."
  description: "This op translates a tensor containing Example records, encoded using\nthe [standard JSON\nmapping](https://developers.google.com/protocol-buffers/docs/proto3#json),\ninto a tensor containing the same records encoded as binary protocol\nbuffers. The resulting tensor can then be fed to any of the other\nExample-parsing ops."
}
op {
  name: "DecodeJpeg"
  input_arg {
    name: "contents"
    description: "0-D.  The JPEG-encoded image."
    type: DT_STRING
  }
  output_arg {
    name: "image"
    description: "3-D with shape `[height, width, channels]`.."
    type: DT_UINT8
  }
  attr {
    name: "channels"
    type: "int"
    default_value {
      i: 0
    }
    description: "Number of color channels for the decoded image."
  }
  attr {
    name: "ratio"
    type: "int"
    default_value {
      i: 1
    }
    description: "Downscaling ratio."
  }
  attr {
    name: "fancy_upscaling"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only)."
  }
  attr {
    name: "try_recover_truncated"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true try to recover an image from truncated input."
  }
  attr {
    name: "acceptable_fraction"
    type: "float"
    default_value {
      f: 1
    }
    description: "The minimum required fraction of lines before a truncated\ninput is accepted."
  }
  summary: "Decode a JPEG-encoded image to a uint8 tensor."
  description: "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the JPEG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n\nIf needed, the JPEG-encoded image is transformed to match the requested number\nof color channels.\n\nThe attr `ratio` allows downscaling the image by an integer factor during\ndecoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\ndownscaling the image later."
}
op {
  name: "DecodePng"
  input_arg {
    name: "contents"
    description: "0-D.  The PNG-encoded image."
    type: DT_STRING
  }
  output_arg {
    name: "image"
    description: "3-D with shape `[height, width, channels]`."
    type_attr: "dtype"
  }
  attr {
    name: "channels"
    type: "int"
    default_value {
      i: 0
    }
    description: "Number of color channels for the decoded image."
  }
  attr {
    name: "dtype"
    type: "type"
    default_value {
      type: DT_UINT8
    }
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_UINT16
      }
    }
  }
  summary: "Decode a PNG-encoded image to a uint8 or uint16 tensor."
  description: "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the PNG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n*   4: output an RGBA image.\n\nIf needed, the PNG-encoded image is transformed to match the requested number\nof color channels."
}
op {
  name: "DecodeRaw"
  input_arg {
    name: "bytes"
    description: "All the elements must have the same length."
    type: DT_STRING
  }
  output_arg {
    name: "output"
    description: "A Tensor with one more dimension than the input `bytes`.  The\nadded dimension will have size equal to the length of the elements\nof `bytes` divided by the number of bytes to represent `out_type`."
    type_attr: "out_type"
  }
  attr {
    name: "out_type"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_INT64
      }
    }
  }
  attr {
    name: "little_endian"
    type: "bool"
    default_value {
      b: true
    }
    description: "Whether the input `bytes` are in little-endian order.\nIgnored for `out_type` values that are stored in a single byte like\n`uint8`."
  }
  summary: "Reinterpret the bytes of a string as a vector of numbers."
}
op {
  name: "DeleteSessionTensor"
  input_arg {
    name: "handle"
    description: "The handle for a tensor stored in the session state."
    type: DT_STRING
  }
  summary: "Delete the tensor specified by its handle in the session."
}
op {
  name: "DepthToSpace"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "block_size"
    type: "int"
    description: "The size of the spatial block, same as in Space2Depth."
  }
  summary: "DepthToSpace for tensors of type T."
  description: "Rearranges data from depth into blocks of spatial data.\nThis is the reverse transformation of SpaceToDepth. More specifically,\nthis op outputs a copy of the input tensor where values from the `depth`\ndimension are moved in spatial blocks to the `height` and `width` dimensions.\nThe attr `block_size` indicates the input block size and how the data is moved.\n\n  * Chunks of data of size `block_size * block_size` from depth are rearranged\n    into non-overlapping blocks of size `block_size x block_size`\n  * The width the output tensor is `input_depth * block_size`, whereas the\n    height is `input_height * block_size`.\n  * The depth of the input tensor must be divisible by\n    `block_size * block_size`.\n\nThat is, assuming the input is in the shape:\n`[batch, height, width, depth]`,\nthe shape of the output will be:\n`[batch, height*block_size, width*block_size, depth/(block_size*block_size)]`\n\nThis operation requires that the input tensor be of rank 4, and that\n`block_size` be >=1 and that `block_size * block_size` be a divisor of the\ninput depth.\n\nThis operation is useful for resizing the activations between convolutions\n(but keeping all data), e.g. instead of pooling. It is also useful for training\npurely convolutional models.\n\nFor example, given this input of shape `[1, 1, 1, 4]`, and a block size of 2:\n\n```prettyprint\nx = [[[[1, 2, 3, 4]]]]\n\n```\n\nThis operation will output a tensor of shape `[1, 2, 2, 1]`:\n\n```prettyprint\n   [[[[1], [2]],\n     [[3], [4]]]]\n```\n\nHere, the input has a batch of 1 and each batch element has shape `[1, 1, 4]`,\nthe corresponding output will have 2x2 elements and will have a depth of\n1 channel (1 = `4 / (block_size * block_size)`).\nThe output element shape is `[2, 2, 1]`.\n\nFor an input tensor with larger depth, here of shape `[1, 1, 1, 12]`, e.g.\n\n```prettyprint\nx = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n```\n\nThis operation, for block size of 2, will return the following tensor of shape\n`[1, 2, 2, 3]`\n\n```prettyprint\n   [[[[1, 2, 3], [4, 5, 6]],\n     [[7, 8, 9], [10, 11, 12]]]]\n\n```\n\nSimilarly, for the following input of shape `[1 2 2 4]`, and a block size of 2:\n\n```prettyprint\nx =  [[[[1, 2, 3, 4],\n       [5, 6, 7, 8]],\n      [[9, 10, 11, 12],\n       [13, 14, 15, 16]]]]\n```\n\nthe operator will return the following tensor of shape `[1 4 4 1]`:\n\n```prettyprint\nx = [[ [1],   [2],  [5],  [6]],\n     [ [3],   [4],  [7],  [8]],\n     [ [9],  [10], [13],  [14]],\n     [ [11], [12], [15],  [16]]]\n\n```"
}
op {
  name: "DepthwiseConv2dNative"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "filter"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`."
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors."
  description: "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, channel_multiplier]`, containing\n`in_channels` convolutional filters of depth 1, `depthwise_conv2d` applies\na different filter to each input channel (expanding from 1 channel to\n`channel_multiplier` channels for each), then concatenates the results\ntogether. Thus, the output has `in_channels * channel_multiplier` channels.\n\nfor k in 0..in_channels-1\n  for q in 0..channel_multiplier-1\n    output[b, i, j, k * channel_multiplier + q] =\n      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *\n                        filter[di, dj, k, q]\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`."
}
op {
  name: "DepthwiseConv2dNativeBackpropFilter"
  input_arg {
    name: "input"
    description: "4-D with shape `[batch, in_height, in_width, in_channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "filter_sizes"
    description: "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, depthwise_multiplier]` tensor."
    type: DT_INT32
  }
  input_arg {
    name: "out_backprop"
    description: "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the input\nof the convolution."
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes the gradients of depthwise convolution with respect to the filter."
}
op {
  name: "DepthwiseConv2dNativeBackpropInput"
  input_arg {
    name: "input_sizes"
    description: "An integer vector representing the shape of `input`,\nwhere `input` is a 4-D `[batch, height, width, channels]` tensor."
    type: DT_INT32
  }
  input_arg {
    name: "filter"
    description: "4-D with shape\n`[filter_height, filter_width, in_channels, depthwise_multiplier]`."
    type_attr: "T"
  }
  input_arg {
    name: "out_backprop"
    description: "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient\nw.r.t. the input of the convolution."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the input\nof the convolution."
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Computes the gradients of depthwise convolution with respect to the input."
}
op {
  name: "DeserializeManySparse"
  input_arg {
    name: "serialized_sparse"
    description: "2-D, The `N` serialized `SparseTensor` objects.\nMust have 3 columns."
    type: DT_STRING
  }
  output_arg {
    name: "sparse_indices"
    type: DT_INT64
  }
  output_arg {
    name: "sparse_values"
    type_attr: "dtype"
  }
  output_arg {
    name: "sparse_shape"
    type: DT_INT64
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The `dtype` of the serialized `SparseTensor` objects."
  }
  summary: "Deserialize and concatenate `SparseTensors` from a serialized minibatch."
  description: "The input `serialized_sparse` must be a string matrix of shape `[N x 3]` where\n`N` is the minibatch size and the rows correspond to packed outputs of\n`SerializeSparse`.  The ranks of the original `SparseTensor` objects\nmust all match.  When the final `SparseTensor` is created, it has rank one\nhigher than the ranks of the incoming `SparseTensor` objects\n(they have been concatenated along a new row dimension).\n\nThe output `SparseTensor` object\'s shape values for all dimensions but the\nfirst are the max across the input `SparseTensor` objects\' shape values\nfor the corresponding dimensions.  Its first shape value is `N`, the minibatch\nsize.\n\nThe input `SparseTensor` objects\' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the serialized input is a `[2 x 3]` matrix representing two\noriginal `SparseTensor` objects:\n\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n\nand\n\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n\nthen the final deserialized `SparseTensor` will be:\n\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]"
}
op {
  name: "DestroyTemporaryVariable"
  input_arg {
    name: "ref"
    description: "A reference to the temporary variable tensor."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "value"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "var_name"
    type: "string"
    description: "Name of the temporary variable, usually the name of the matching\n\'TemporaryVariable\' op."
  }
  summary: "Destroys the temporary variable and returns its final value."
  description: "Sets output to the value of the Tensor pointed to by \'ref\', then destroys\nthe temporary variable called \'var_name\'.\nAll other uses of \'ref\' *must* have executed before this op.\nThis is typically achieved by chaining the ref through each assign op, or by\nusing control dependencies.\n\nOutputs the final value of the tensor pointed to by \'ref\'."
}
op {
  name: "Diag"
  input_arg {
    name: "diagonal"
    description: "Rank k tensor where k is at most 3."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns a diagonal tensor with a given diagonal values."
  description: "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has dimensions [D1,..., Dk], then the output is a tensor of\nrank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:\n\n`output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]` and 0 everywhere else.\n\nFor example:\n\n```prettyprint\n# \'diagonal\' is [1, 2, 3, 4]\ntf.diag(diagonal) ==> [[1, 0, 0, 0]\n                       [0, 2, 0, 0]\n                       [0, 0, 3, 0]\n                       [0, 0, 0, 4]]\n```"
}
op {
  name: "DiagPart"
  input_arg {
    name: "input"
    description: "Rank k tensor where k is 2, 4, or 6."
    type_attr: "T"
  }
  output_arg {
    name: "diagonal"
    description: "The extracted diagonal."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the diagonal part of the tensor."
  description: "This operation returns a tensor with the `diagonal` part\nof the `input`. The `diagonal` part is computed as follows:\n\nAssume `input` has dimensions `[D1,..., Dk, D1,..., Dk]`, then the output is a\ntensor of rank `k` with dimensions `[D1,..., Dk]` where:\n\n`diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]`.\n\nFor example:\n\n```prettyprint\n# \'input\' is [[1, 0, 0, 0]\n              [0, 2, 0, 0]\n              [0, 0, 3, 0]\n              [0, 0, 0, 4]]\n\ntf.diag_part(input) ==> [1, 2, 3, 4]\n```"
}
op {
  name: "Digamma"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes Psi, the derivative of Lgamma (the log of the absolute value of"
  description: "`Gamma(x)`), element-wise."
}
op {
  name: "Div"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
      }
    }
  }
  summary: "Returns x / y element-wise."
}
op {
  name: "DrawBoundingBoxes"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, depth]`. A batch of images."
    type: DT_FLOAT
  }
  input_arg {
    name: "boxes"
    description: "3-D with shape `[batch, num_bounding_boxes, 4]` containing bounding\nboxes."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "4-D with the same shape as `images`. The batch of input images with\nbounding boxes drawn on the images."
    type: DT_FLOAT
  }
  summary: "Draw bounding boxes on a batch of images."
  description: "Outputs a copy of `images` but draws on top of the pixels zero or more bounding\nboxes specified by the locations in `boxes`. The coordinates of the each\nbounding box in `boxes are encoded as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example, if an image is 100 x 200 pixels and the bounding box is\n`[0.1, 0.5, 0.2, 0.9]`, the bottom-left and upper-right coordinates of the\nbounding box will be `(10, 40)` to `(50, 180)`.\n\nParts of the bounding box may fall outside the image."
}
op {
  name: "DynamicPartition"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "partitions"
    description: "Any shape.  Indices in the range `[0, num_partitions)`."
    type: DT_INT32
  }
  output_arg {
    name: "outputs"
    type_attr: "T"
    number_attr: "num_partitions"
  }
  attr {
    name: "num_partitions"
    type: "int"
    description: "The number of partitions to output."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Partitions `data` into `num_partitions` tensors using indices from `partitions`."
  description: "For each index tuple `js` of size `partitions.ndim`, the slice `data[js, ...]`\nbecomes part of `outputs[partitions[js]]`.  The slices with `partitions[js] = i`\nare placed in `outputs[i]` in lexicographic order of `js`, and the first\ndimension of `outputs[i]` is the number of entries in `partitions` equal to `i`.\nIn detail,\n\n    outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]\n\n    outputs[i] = pack([data[js, ...] for js if partitions[js] == i])\n\n`data.shape` must start with `partitions.shape`.\n\nFor example:\n\n    # Scalar partitions\n    partitions = 1\n    num_partitions = 2\n    data = [10, 20]\n    outputs[0] = []  # Empty with shape [0, 2]\n    outputs[1] = [[10, 20]]\n\n    # Vector partitions\n    partitions = [0, 0, 1, 1, 0]\n    num_partitions = 2\n    data = [10, 20, 30, 40, 50]\n    outputs[0] = [10, 20, 50]\n    outputs[1] = [30, 40]\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/DynamicPartition.png\" alt>\n</div>"
}
op {
  name: "DynamicStitch"
  input_arg {
    name: "indices"
    type: DT_INT32
    number_attr: "N"
  }
  input_arg {
    name: "data"
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "merged"
    type_attr: "T"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 2
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Interleave the values from the `data` tensors into a single tensor."
  description: "Builds a merged tensor such that\n\n    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n\nFor example, if each `indices[m]` is scalar or vector, we have\n\n    # Scalar indices\n    merged[indices[m], ...] = data[m][...]\n\n    # Vector indices\n    merged[indices[m][i], ...] = data[m][i, ...]\n\nEach `data[i].shape` must start with the corresponding `indices[i].shape`,\nand the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we\nmust have `data[i].shape = indices[i].shape + constant`.  In terms of this\n`constant`, the output shape is\n\n    merged.shape = [max(indices)] + constant\n\nValues are merged in order, so if an index appears in both `indices[m][i]` and\n`indices[n][j]` for `(m,i) < (n,j)` the slice `data[n][j]` will appear in the\nmerged result.\n\nFor example:\n\n    indices[0] = 6\n    indices[1] = [4, 1]\n    indices[2] = [[5, 2], [0, 3]]\n    data[0] = [61, 62]\n    data[1] = [[41, 42], [11, 12]]\n    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/DynamicStitch.png\" alt>\n</div>"
}
op {
  name: "EditDistance"
  input_arg {
    name: "hypothesis_indices"
    description: "The indices of the hypothesis list SparseTensor.\nThis is an N x R int64 matrix."
    type: DT_INT64
  }
  input_arg {
    name: "hypothesis_values"
    description: "The values of the hypothesis list SparseTensor.\nThis is an N-length vector."
    type_attr: "T"
  }
  input_arg {
    name: "hypothesis_shape"
    description: "The shape of the hypothesis list SparseTensor.\nThis is an R-length vector."
    type: DT_INT64
  }
  input_arg {
    name: "truth_indices"
    description: "The indices of the truth list SparseTensor.\nThis is an M x R int64 matrix."
    type: DT_INT64
  }
  input_arg {
    name: "truth_values"
    description: "The values of the truth list SparseTensor.\nThis is an M-length vector."
    type_attr: "T"
  }
  input_arg {
    name: "truth_shape"
    description: "truth indices, vector."
    type: DT_INT64
  }
  output_arg {
    name: "output"
    description: "A dense float tensor with rank R - 1.\n\nFor the example input:\n\n    // hypothesis represents a 2x1 matrix with variable-length values:\n    //   (0,0) = [\"a\"]\n    //   (1,0) = [\"b\"]\n    hypothesis_indices = [[0, 0, 0],\n                          [1, 0, 0]]\n    hypothesis_values = [\"a\", \"b\"]\n    hypothesis_shape = [2, 1, 1]\n\n    // truth represents a 2x2 matrix with variable-length values:\n    //   (0,0) = []\n    //   (0,1) = [\"a\"]\n    //   (1,0) = [\"b\", \"c\"]\n    //   (1,1) = [\"a\"]\n    truth_indices = [[0, 1, 0],\n                     [1, 0, 0],\n                     [1, 0, 1],\n                     [1, 1, 0]]\n    truth_values = [\"a\", \"b\", \"c\", \"a\"]\n    truth_shape = [2, 2, 2]\n    normalize = true\n\nThe output will be:\n\n    // output is a 2x2 matrix with edit distances normalized by truth lengths.\n    output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis\n              [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis"
    type: DT_FLOAT
  }
  attr {
    name: "normalize"
    type: "bool"
    default_value {
      b: true
    }
    description: "boolean (if true, edit distances are normalized by length of truth).\n\nThe output is:"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Computes the (possibly normalized) Levenshtein Edit Distance."
  description: "The inputs are variable-length sequences provided by SparseTensors\n  (hypothesis_indices, hypothesis_values, hypothesis_shape)\nand\n  (truth_indices, truth_values, truth_shape).\n\nThe inputs are:"
}
op {
  name: "Elu"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes exponential linear: `exp(features) - 1` if < 0, `features` otherwise."
  description: "See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)\n](http://arxiv.org/abs/1511.07289)"
}
op {
  name: "EluGrad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding Elu operation."
    type_attr: "T"
  }
  input_arg {
    name: "outputs"
    description: "The outputs of the corresponding Elu operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients: `gradients * (outputs + 1)` if outputs < 0,\n`gradients` otherwise."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes gradients for the exponential linear (Elu) operation."
}
op {
  name: "EncodeJpeg"
  input_arg {
    name: "image"
    description: "3-D with shape `[height, width, channels]`."
    type: DT_UINT8
  }
  output_arg {
    name: "contents"
    description: "0-D. JPEG-encoded image."
    type: DT_STRING
  }
  attr {
    name: "format"
    type: "string"
    default_value {
      s: ""
    }
    description: "Per pixel image format."
    allowed_values {
      list {
        s: ""
        s: "grayscale"
        s: "rgb"
      }
    }
  }
  attr {
    name: "quality"
    type: "int"
    default_value {
      i: 95
    }
    description: "Quality of the compression from 0 to 100 (higher is better and slower)."
  }
  attr {
    name: "progressive"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, create a JPEG that loads progressively (coarse to fine)."
  }
  attr {
    name: "optimize_size"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, spend CPU/RAM to reduce size with no quality change."
  }
  attr {
    name: "chroma_downsampling"
    type: "bool"
    default_value {
      b: true
    }
    description: "See http://en.wikipedia.org/wiki/Chroma_subsampling."
  }
  attr {
    name: "density_unit"
    type: "string"
    default_value {
      s: "in"
    }
    description: "Unit used to specify `x_density` and `y_density`:\npixels per inch (`\'in\'`) or centimeter (`\'cm\'`)."
    allowed_values {
      list {
        s: "in"
        s: "cm"
      }
    }
  }
  attr {
    name: "x_density"
    type: "int"
    default_value {
      i: 300
    }
    description: "Horizontal pixels per density unit."
  }
  attr {
    name: "y_density"
    type: "int"
    default_value {
      i: 300
    }
    description: "Vertical pixels per density unit."
  }
  attr {
    name: "xmp_metadata"
    type: "string"
    default_value {
      s: ""
    }
    description: "If not empty, embed this XMP metadata in the image header."
  }
  summary: "JPEG-encode an image."
  description: "`image` is a 3-D uint8 Tensor of shape `[height, width, channels]`.\n\nThe attr `format` can be used to override the color format of the encoded\noutput.  Values can be:\n\n*   `\'\'`: Use a default format based on the number of channels in the image.\n*   `grayscale`: Output a grayscale JPEG image.  The `channels` dimension\n    of `image` must be 1.\n*   `rgb`: Output an RGB JPEG image. The `channels` dimension\n    of `image` must be 3.\n\nIf `format` is not specified or is the empty string, a default format is picked\nin function of the number of channels in `image`:\n\n*   1: Output a grayscale image.\n*   3: Output an RGB image."
}
op {
  name: "EncodePng"
  input_arg {
    name: "image"
    description: "3-D with shape `[height, width, channels]`."
    type_attr: "T"
  }
  output_arg {
    name: "contents"
    description: "0-D. PNG-encoded image."
    type: DT_STRING
  }
  attr {
    name: "compression"
    type: "int"
    default_value {
      i: -1
    }
    description: "Compression level."
  }
  attr {
    name: "T"
    type: "type"
    default_value {
      type: DT_UINT8
    }
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_UINT16
      }
    }
  }
  summary: "PNG-encode an image."
  description: "`image` is a 3-D uint8 or uint16 Tensor of shape `[height, width, channels]`\nwhere `channels` is:\n\n*   1: for grayscale.\n*   2: for grayscale + alpha.\n*   3: for RGB.\n*   4: for RGBA.\n\nThe ZLIB compression level, `compression`, can be -1 for the PNG-encoder\ndefault or a value from 0 to 9.  9 is the highest compression level, generating\nthe smallest output, but is slower."
}
op {
  name: "Enter"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the child frame."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "frame_name"
    type: "string"
    description: "The name of the child frame."
  }
  attr {
    name: "is_constant"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, the output is constant within the child frame."
  }
  attr {
    name: "parallel_iterations"
    type: "int"
    default_value {
      i: 10
    }
    description: "The number of iterations allowed to run in parallel."
  }
  summary: "Creates or finds a child frame, and makes `data` available to the child frame."
  description: "This op is used together with `Exit` to create loops in the graph.\nThe unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame."
}
op {
  name: "Equal"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
        type: DT_QUINT8
        type: DT_QINT8
        type: DT_QINT32
        type: DT_STRING
        type: DT_BOOL
      }
    }
  }
  summary: "Returns the truth value of (x == y) element-wise."
  is_commutative: true
}
op {
  name: "Erf"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes the Gauss error function of `x` element-wise."
}
op {
  name: "Erfc"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes the complementary error function of `x` element-wise."
}
op {
  name: "Exit"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the parent frame."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Exits the current frame to its parent frame."
  description: "Exit makes its input `data` available to the parent frame."
}
op {
  name: "Exp"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes exponential of x element-wise.  \\\\(y = e^x\\\\)."
}
op {
  name: "ExpandDims"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "dim"
    description: "0-D (scalar). Specifies the dimension index at which to\nexpand the shape of `input`."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Contains the same data as `input`, but its shape has an additional\ndimension of size 1 added."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Inserts a dimension of 1 into a tensor\'s shape."
  description: "Given a tensor `input`, this operation inserts a dimension of 1 at the\ndimension index `dim` of `input`\'s shape. The dimension index `dim` starts at\nzero; if you specify a negative number for `dim` it is counted backward from\nthe end.\n\nThis operation is useful if you want to add a batch dimension to a single\nelement. For example, if you have a single image of shape `[height, width,\nchannels]`, you can make it a batch of 1 image with `expand_dims(image, 0)`,\nwhich will make the shape `[1, height, width, channels]`.\n\nOther examples:\n\n```prettyprint\n# \'t\' is a tensor of shape [2]\nshape(expand_dims(t, 0)) ==> [1, 2]\nshape(expand_dims(t, 1)) ==> [2, 1]\nshape(expand_dims(t, -1)) ==> [2, 1]\n\n# \'t2\' is a tensor of shape [2, 3, 5]\nshape(expand_dims(t2, 0)) ==> [1, 2, 3, 5]\nshape(expand_dims(t2, 2)) ==> [2, 3, 1, 5]\nshape(expand_dims(t2, 3)) ==> [2, 3, 5, 1]\n```\n\nThis operation requires that:\n\n`-1-input.dims() <= dim <= input.dims()`\n\nThis operation is related to `squeeze()`, which removes dimensions of\nsize 1."
}
op {
  name: "ExtractGlimpse"
  input_arg {
    name: "input"
    type: DT_FLOAT
  }
  input_arg {
    name: "size"
    type: DT_INT32
  }
  input_arg {
    name: "offsets"
    type: DT_FLOAT
  }
  output_arg {
    name: "glimpse"
    type: DT_FLOAT
  }
  attr {
    name: "centered"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "normalized"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "uniform_noise"
    type: "bool"
    default_value {
      b: true
    }
  }
  summary: "Extracts a glimpse from the input tensor."
  description: "Returns a set of windows called glimpses extracted at location\n`offsets` from the input tensor. If the windows only partially\noverlaps the inputs, the non overlapping areas will be filled with\nrandom noise.\n\nThe result is a 4-D tensor of shape `[batch_size, glimpse_height,\nglimpse_width, channels]`. The channels and batch dimensions are the\nsame as that of the input tensor. The height and width of the output\nwindows are specified in the `size` parameter.\n\nThe argument `normalized` and `centered` controls how the windows are"
}
op {
  name: "FFT"
  input_arg {
    name: "input"
    description: "A complex64 vector."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "The 1D Fourier Transform of `input`."
    type: DT_COMPLEX64
  }
  summary: "Compute the 1-dimensional discrete Fourier Transform."
}
op {
  name: "FFT2D"
  input_arg {
    name: "input"
    description: "A complex64 matrix."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "The 2D Fourier Transform of `input`."
    type: DT_COMPLEX64
  }
  summary: "Compute the 2-dimensional discrete Fourier Transform."
}
op {
  name: "FFT3D"
  input_arg {
    name: "input"
    description: "A complex64 3-D tensor."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "The 3D Fourier Transform of `input`."
    type: DT_COMPLEX64
  }
  summary: "Compute the 3-dimensional discrete Fourier Transform."
}
op {
  name: "FIFOQueue"
  output_arg {
    name: "handle"
    description: "The handle to the queue."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a value."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "shapes"
    type: "list(shape)"
    default_value {
      list {
      }
    }
    description: "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time."
    has_minimum: true
  }
  attr {
    name: "capacity"
    type: "int"
    default_value {
      i: -1
    }
    description: "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue will be shared under the given name\nacross multiple sessions."
  }
  summary: "A queue that produces elements in first-in first-out order."
  is_stateful: true
}
op {
  name: "Fact"
  output_arg {
    name: "fact"
    type: DT_STRING
  }
  summary: "Output a fact about factorials."
}
op {
  name: "Fill"
  input_arg {
    name: "dims"
    description: "1-D. Represents the shape of the output tensor."
    type: DT_INT32
  }
  input_arg {
    name: "value"
    description: "0-D (scalar). Value to fill the returned tensor."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Creates a tensor filled with a scalar value."
  description: "This operation creates a tensor of shape `dims` and fills it with `value`.\n\nFor example:\n\n```prettyprint\n# Output tensor has shape [2, 3].\nfill([2, 3], 9) ==> [[9, 9, 9]\n                     [9, 9, 9]]\n```"
}
op {
  name: "FixedLengthRecordReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "header_bytes"
    type: "int"
    default_value {
      i: 0
    }
  }
  attr {
    name: "record_bytes"
    type: "int"
  }
  attr {
    name: "footer_bytes"
    type: "int"
    default_value {
      i: 0
    }
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs fixed-length records from a file."
  is_stateful: true
}
op {
  name: "FixedUnigramCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "vocab_file"
    type: "string"
    default_value {
      s: ""
    }
    description: "Each valid line in this file (which should have a CSV-like format)\ncorresponds to a valid word ID. IDs are in sequential order, starting from\nnum_reserved_ids. The last entry in each line is expected to be a value\ncorresponding to the count or relative probability. Exactly one of vocab_file\nand unigrams needs to be passed to this op."
  }
  attr {
    name: "distortion"
    type: "float"
    default_value {
      f: 1
    }
    description: "The distortion is used to skew the unigram probability distribution.\nEach weight is first raised to the distortion\'s power before adding to the\ninternal unigram distribution. As a result, distortion = 1.0 gives regular\nunigram sampling (as defined by the vocab file), and distortion = 0.0 gives\na uniform distribution."
  }
  attr {
    name: "num_reserved_ids"
    type: "int"
    default_value {
      i: 0
    }
    description: "Optionally some reserved IDs can be added in the range [0,\n..., num_reserved_ids) by the users. One use case is that a special unknown\nword token is used as ID 0. These IDs will have a sampling probability of 0."
  }
  attr {
    name: "num_shards"
    type: "int"
    default_value {
      i: 1
    }
    description: "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with \'shard\') indicates the number of partitions that are being\nused in the overall computation."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "shard"
    type: "int"
    default_value {
      i: 0
    }
    description: "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with \'num_shards\') indicates the particular partition number of a\nsampler op, when partitioning is being used."
    has_minimum: true
  }
  attr {
    name: "unigrams"
    type: "list(float)"
    default_value {
      list {
      }
    }
    description: "A list of unigram counts or probabilities, one per ID in sequential\norder. Exactly one of vocab_file and unigrams should be passed to this op."
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a learned unigram distribution."
  description: "A unigram sampler could use a fixed unigram distribution read from a\nfile or passed in as an in-memory array instead of building up the distribution\nfrom data on the fly. There is also an option to skew the distribution by\napplying a distortion power to the weights.\n\nThe vocabulary file should be in CSV-like format, with the last field\nbeing the weight associated with the word.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Floor"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns element-wise largest integer not greater than x."
}
op {
  name: "Gather"
  input_arg {
    name: "params"
    type_attr: "Tparams"
  }
  input_arg {
    name: "indices"
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    type_attr: "Tparams"
  }
  attr {
    name: "validate_indices"
    type: "bool"
    default_value {
      b: true
    }
  }
  attr {
    name: "Tparams"
    type: "type"
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Gather slices from `params` according to `indices`."
  description: "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `indices.shape + params.shape[1:]` where:\n\n    # Scalar indices\n    output[:, ..., :] = params[indices, :, ... :]\n\n    # Vector indices\n    output[i, :, ..., :] = params[indices[i], :, ... :]\n\n    # Higher rank indices\n    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n\nIf `indices` is a permutation and `len(indices) == params.shape[0]` then\nthis operation will permute `params` accordingly.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/Gather.png\" alt>\n</div>"
}
op {
  name: "GatherNd"
  input_arg {
    name: "params"
    description: "R-D.  The tensor from which to gather values."
    type_attr: "Tparams"
  }
  input_arg {
    name: "indices"
    description: "(N+1)-D.  Index tensor having shape `[d_0, ..., d_N, R]`."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "N-D.  Values from `params` gathered from indices given by `indices`."
    type_attr: "Tparams"
  }
  attr {
    name: "Tparams"
    type: "type"
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Gather values from `params` according to `indices`."
  description: "`indices` must be integer tensor, containing indices into `params`.\nIt must be shape `[d_0, ..., d_N, R]` where `R` is the rank of `params`.\nThe innermost dimension of `indices` (with length `R`) corresponds to the\nindices of `params`.\n\nProduces an output tensor with shape `[d_0, ..., d_{n-1}]` where:\n\n    output[i, j, k, ...] = params[indices[i, j, k, ..., :]]\n\ne.g. for `indices` a matrix:\n\n    output[i] = params[indices[i, :]]"
}
op {
  name: "GetSessionHandle"
  input_arg {
    name: "value"
    description: "The tensor to be stored."
    type_attr: "T"
  }
  output_arg {
    name: "handle"
    description: "The handle for the tensor stored in the session state."
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Store the input tensor in the state of the current session."
}
op {
  name: "GetSessionTensor"
  input_arg {
    name: "handle"
    description: "The handle for a tensor stored in the session state."
    type: DT_STRING
  }
  output_arg {
    name: "value"
    description: "The tensor for the given handle."
    type_attr: "dtype"
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the output value."
  }
  summary: "Get the value of the tensor specified by its handle."
}
op {
  name: "Greater"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Returns the truth value of (x > y) element-wise."
}
op {
  name: "GreaterEqual"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Returns the truth value of (x >= y) element-wise."
}
op {
  name: "HSVToRGB"
  input_arg {
    name: "images"
    description: "1-D or higher rank. HSV data to convert. Last dimension must be size 3."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "`images` converted to RGB."
    type: DT_FLOAT
  }
  summary: "Convert one or more images from HSV to RGB."
  description: "Outputs a tensor of the same shape as the `images` tensor, containing the RGB\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\nSee `rgb_to_hsv` for a description of the HSV encoding."
}
op {
  name: "HashTable"
  output_arg {
    name: "table_handle"
    description: "Handle to a table."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this table is shared under the given name across\nmultiple sessions."
  }
  attr {
    name: "key_dtype"
    type: "type"
    description: "Type of the table keys."
  }
  attr {
    name: "value_dtype"
    type: "type"
    description: "Type of the table values."
  }
  summary: "Creates a non-initialized hash table."
  description: "This op creates a hash table, specifying the type of its keys and values.\nBefore using the table you will have to initialize it.  After initialization the\ntable will be immutable."
  is_stateful: true
}
op {
  name: "HistogramSummary"
  input_arg {
    name: "tag"
    description: "Scalar.  Tag to use for the `Summary.Value`."
    type: DT_STRING
  }
  input_arg {
    name: "values"
    description: "Any shape. Values to use to build the histogram."
    type_attr: "T"
  }
  output_arg {
    name: "summary"
    description: "Scalar. Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
    default_value {
      type: DT_FLOAT
    }
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Outputs a `Summary` protocol buffer with a histogram."
  description: "The generated\n[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\nhas one summary value containing a histogram for `values`.\n\nThis op reports an `InvalidArgument` error if any value is not finite."
}
op {
  name: "IFFT"
  input_arg {
    name: "input"
    description: "A complex64 vector."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "The inverse 1D Fourier Transform of `input`."
    type: DT_COMPLEX64
  }
  summary: "Compute the inverse 1-dimensional discrete Fourier Transform."
}
op {
  name: "IFFT2D"
  input_arg {
    name: "input"
    description: "A complex64 matrix."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "The inverse 2D Fourier Transform of `input`."
    type: DT_COMPLEX64
  }
  summary: "Compute the inverse 2-dimensional discrete Fourier Transform."
}
op {
  name: "IFFT3D"
  input_arg {
    name: "input"
    description: "A complex64 3-D tensor."
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    description: "The inverse 3D Fourier Transform of `input`."
    type: DT_COMPLEX64
  }
  summary: "Compute the inverse 3-dimensional discrete Fourier Transform."
}
op {
  name: "Identity"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Return a tensor with the same shape and contents as the input tensor or value."
}
op {
  name: "IdentityReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs the queued work as both the key and value."
  description: "To use, enqueue strings in a Queue.  ReaderRead will take the front\nwork string and output (work, work)."
  is_stateful: true
}
op {
  name: "Igamma"
  input_arg {
    name: "a"
    type_attr: "T"
  }
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Compute the lower regularized incomplete Gamma function `Q(a, x)`."
  description: "The lower regularized incomplete Gamma function is defined as:\n\n```\nP(a, x) = gamma(a, x) / Gamma(x) = 1 - Q(a, x)\n```\nwhere\n```\ngamma(a, x) = int_{0}^{x} t^{a-1} exp(-t) dt\n```\nis the lower incomplete Gamma function.\n\nNote, above `Q(a, x)` (`Igammac`) is the upper regularized complete\nGamma function."
}
op {
  name: "Igammac"
  input_arg {
    name: "a"
    type_attr: "T"
  }
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Compute the upper regularized incomplete Gamma function `Q(a, x)`."
  description: "The upper regularized incomplete Gamma function is defined as:\n\n```\nQ(a, x) = Gamma(a, x) / Gamma(x) = 1 - P(a, x)\n```\nwhere\n```\nGamma(a, x) = int_{x}^{\\infty} t^{a-1} exp(-t) dt\n```\nis the upper incomplete Gama function.\n\nNote, above `P(a, x)` (`Igamma`) is the lower regularized complete\nGamma function."
}
op {
  name: "Imag"
  input_arg {
    name: "input"
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    type: DT_FLOAT
  }
  summary: "Returns the imaginary part of a complex number."
  description: "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the imaginary part of each element in `input`. All\nelements in `input` must be complex numbers of the form \\\\(a + bj\\\\), where *a*\nis the real part and *b* is the imaginary part returned by this operation.\n\nFor example:\n\n```\n# tensor \'input\' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.imag(input) ==> [4.75, 5.75]\n```"
}
op {
  name: "ImageSummary"
  input_arg {
    name: "tag"
    description: "Scalar. Used to build the `tag` attribute of the summary values."
    type: DT_STRING
  }
  input_arg {
    name: "tensor"
    description: "4-D of shape `[batch_size, height, width, channels]` where\n`channels` is 1, 3, or 4."
    type_attr: "T"
  }
  output_arg {
    name: "summary"
    description: "Scalar. Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "max_images"
    type: "int"
    default_value {
      i: 3
    }
    description: "Max number of batch elements to generate images for."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
    default_value {
      type: DT_FLOAT
    }
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_FLOAT
      }
    }
  }
  attr {
    name: "bad_color"
    type: "tensor"
    default_value {
      tensor {
        dtype: DT_UINT8
        tensor_shape {
          dim {
            size: 4
          }
        }
        int_val: 255
        int_val: 0
        int_val: 0
        int_val: 255
      }
    }
    description: "Color to use for pixels with non-finite values."
  }
  summary: "Outputs a `Summary` protocol buffer with images."
  description: "The summary has up to `max_images` summary values containing images. The\nimages are built from `tensor` which must be 4-D with shape `[batch_size,\nheight, width, channels]` and where `channels` can be:\n\n*  1: `tensor` is interpreted as Grayscale.\n*  3: `tensor` is interpreted as RGB.\n*  4: `tensor` is interpreted as RGBA.\n\nThe images have the same number of channels as the input tensor. For float\ninput, the values are normalized one image at a time to fit in the range\n`[0, 255]`.  `uint8` values are unchanged.  The op uses two different\nnormalization algorithms:\n\n*  If the input values are all positive, they are rescaled so the largest one\n   is 255.\n\n*  If any input value is negative, the values are shifted so input value 0.0\n   is at 127.  They are then rescaled so that either the smallest value is 0,\n   or the largest one is 255.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_images` is 1, the summary value tag is \'*tag*/image\'.\n*  If `max_images` is greater than 1, the summary value tags are\n   generated sequentially as \'*tag*/image/0\', \'*tag*/image/1\', etc.\n\nThe `bad_color` argument is the color to use in the generated images for\nnon-finite input values.  It is a `unit8` 1-D tensor of length `channels`.\nEach element must be in the range `[0, 255]` (It represents the value of a\npixel in the output image).  Non-finite values in the input tensor are\nreplaced by this tensor in the output image.  The default value is the color\nred."
}
op {
  name: "ImmutableConst"
  output_arg {
    name: "tensor"
    type_attr: "dtype"
  }
  attr {
    name: "dtype"
    type: "type"
    description: "Type of the returned tensor."
  }
  attr {
    name: "shape"
    type: "shape"
    description: "Shape of the returned tensor."
  }
  attr {
    name: "memory_region_name"
    type: "string"
    description: "Name of readonly memory region used by the tensor, see\nNewReadOnlyMemoryRegionFromFile in tensorflow::Env."
  }
  summary: "Returns immutable tensor from memory region."
  description: "The current implementation memmaps the tensor from a file."
}
op {
  name: "InTopK"
  input_arg {
    name: "predictions"
    description: "A `batch_size` x `classes` tensor."
    type: DT_FLOAT
  }
  input_arg {
    name: "targets"
    description: "A `batch_size` vector of class ids."
    type_attr: "T"
  }
  output_arg {
    name: "precision"
    description: "Computed Precision at `k` as a `bool Tensor`."
    type: DT_BOOL
  }
  attr {
    name: "k"
    type: "int"
    description: "Number of top elements to look at for computing precision."
  }
  attr {
    name: "T"
    type: "type"
    default_value {
      type: DT_INT32
    }
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Says whether the targets are in the top `K` predictions."
  description: "This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the\nprediction for the target class is among the top `k` predictions among\nall predictions for example `i`. Note that the behavior of `InTopK` differs\nfrom the `TopK` op in its handling of ties; if multiple classes have the\nsame prediction value and straddle the top-`k` boundary, all of those\nclasses are considered to be in the top `k`.\n\nMore formally, let\n\n  \\\\(predictions_i\\\\) be the predictions for all classes for example `i`,\n  \\\\(targets_i\\\\) be the target class for example `i`,\n  \\\\(out_i\\\\) be the output for example `i`,\n\n$$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$"
}
op {
  name: "InitializeTable"
  input_arg {
    name: "table_handle"
    description: "Handle to a table which will be initialized."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "keys"
    description: "Keys of type Tkey."
    type_attr: "Tkey"
  }
  input_arg {
    name: "values"
    description: "Values of type Tval. Same shape as `keys`."
    type_attr: "Tval"
  }
  attr {
    name: "Tkey"
    type: "type"
  }
  attr {
    name: "Tval"
    type: "type"
  }
  summary: "Table initializer that takes two tensors for keys and values respectively."
}
op {
  name: "Inv"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes the reciprocal of x element-wise."
  description: "I.e., \\\\(y = 1 / x\\\\)."
}
op {
  name: "InvertPermutation"
  input_arg {
    name: "x"
    description: "1-D."
    type: DT_INT32
  }
  output_arg {
    name: "y"
    description: "1-D."
    type: DT_INT32
  }
  summary: "Computes the inverse permutation of a tensor."
  description: "This operation computes the inverse of an index permutation. It takes a 1-D\ninteger tensor `x`, which represents the indices of a zero-based array, and\nswaps each value with its index position. In other words, for an output tensor\n`y` and an input tensor `x`, this operation computes the following:\n\n`y[x[i]] = i for i in [0, 1, ..., len(x) - 1]`\n\nThe values must include 0. There can be no duplicate values or negative values.\n\nFor example:\n\n```prettyprint\n# tensor `x` is [3, 4, 0, 2, 1]\ninvert_permutation(x) ==> [2, 4, 3, 0, 1]\n```"
}
op {
  name: "IsFinite"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns which elements of x are finite."
}
op {
  name: "IsInf"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns which elements of x are Inf."
}
op {
  name: "IsNan"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns which elements of x are NaN."
}
op {
  name: "IsVariableInitialized"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node. May be uninitialized."
    type_attr: "dtype"
    is_ref: true
  }
  output_arg {
    name: "is_initialized"
    type: DT_BOOL
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of elements in the variable tensor."
  }
  summary: "Checks whether a tensor has been initialized."
  description: "Outputs boolean scalar indicating whether the tensor has been initialized."
  allows_uninitialized_input: true
}
op {
  name: "L2Loss"
  input_arg {
    name: "t"
    description: "Typically 2-D, but may have any dimensions."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "0-D."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "L2 Loss."
  description: "Computes half the L2 norm of a tensor without the `sqrt`:\n\n    output = sum(t ** 2) / 2"
}
op {
  name: "LRN"
  input_arg {
    name: "input"
    description: "4-D."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    type: DT_FLOAT
  }
  attr {
    name: "depth_radius"
    type: "int"
    default_value {
      i: 5
    }
    description: "0-D.  Half-width of the 1-D normalization window."
  }
  attr {
    name: "bias"
    type: "float"
    default_value {
      f: 1
    }
    description: "An offset (usually positive to avoid dividing by 0)."
  }
  attr {
    name: "alpha"
    type: "float"
    default_value {
      f: 1
    }
    description: "A scale factor, usually positive."
  }
  attr {
    name: "beta"
    type: "float"
    default_value {
      f: 0.5
    }
    description: "An exponent."
  }
  summary: "Local Response Normalization."
  description: "The 4-D `input` tensor is treated as a 3-D array of 1-D vectors (along the last\ndimension), and each vector is normalized independently.  Within a given vector,\neach component is divided by the weighted, squared sum of inputs within\n`depth_radius`.  In detail,\n\n    sqr_sum[a, b, c, d] =\n        sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)\n    output = input / (bias + alpha * sqr_sum) ** beta\n\nFor details, see [Krizhevsky et al., ImageNet classification with deep\nconvolutional neural networks (NIPS 2012)]\n(http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks)."
}
op {
  name: "LRNGrad"
  input_arg {
    name: "input_grads"
    description: "4-D with shape `[batch, height, width, channels]`."
    type: DT_FLOAT
  }
  input_arg {
    name: "input_image"
    description: "4-D with shape `[batch, height, width, channels]`."
    type: DT_FLOAT
  }
  input_arg {
    name: "output_image"
    description: "4-D with shape `[batch, height, width, channels]`."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "The gradients for LRN."
    type: DT_FLOAT
  }
  attr {
    name: "depth_radius"
    type: "int"
    default_value {
      i: 5
    }
    description: "A depth radius."
  }
  attr {
    name: "bias"
    type: "float"
    default_value {
      f: 1
    }
    description: "An offset (usually > 0 to avoid dividing by 0)."
  }
  attr {
    name: "alpha"
    type: "float"
    default_value {
      f: 1
    }
    description: "A scale factor, usually positive."
  }
  attr {
    name: "beta"
    type: "float"
    default_value {
      f: 0.5
    }
    description: "An exponent."
  }
  summary: "Gradients for Local Response Normalization."
}
op {
  name: "LearnedUnigramCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a learned unigram distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Less"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Returns the truth value of (x < y) element-wise."
}
op {
  name: "LessEqual"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Returns the truth value of (x <= y) element-wise."
}
op {
  name: "Lgamma"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes the log of the absolute value of `Gamma(x)` element-wise."
}
op {
  name: "LinSpace"
  input_arg {
    name: "start"
    description: "First entry in the range."
    type_attr: "T"
  }
  input_arg {
    name: "stop"
    description: "Last entry in the range."
    type_attr: "T"
  }
  input_arg {
    name: "num"
    description: "Number of values to generate."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "1-D. The generated values."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Generates values in an interval."
  description: "A sequence of `num` evenly-spaced values are generated beginning at `start`.\nIf `num > 1`, the values in the sequence increase by `stop - start / num - 1`,\nso that the last one is exactly `stop`.\n\nFor example:\n\n```\ntf.linspace(10.0, 12.0, 3, name=\"linspace\") => [ 10.0  11.0  12.0]\n```"
}
op {
  name: "ListDiff"
  input_arg {
    name: "x"
    description: "1-D. Values to keep."
    type_attr: "T"
  }
  input_arg {
    name: "y"
    description: "1-D. Values to remove."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "1-D. Values present in `x` but not in `y`."
    type_attr: "T"
  }
  output_arg {
    name: "idx"
    description: "1-D. Positions of `x` values preserved in `out`."
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Computes the difference between two lists of numbers or strings."
  description: "Given a list `x` and a list `y`, this operation returns a list `out` that\nrepresents all values that are in `x` but not in `y`. The returned list `out`\nis sorted in the same order that the numbers appear in `x` (duplicates are\npreserved). This operation also returns a list `idx` that represents the\nposition of each `out` element in `x`. In other words:\n\n`out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]`\n\nFor example, given this input:\n\n```prettyprint\nx = [1, 2, 3, 4, 5, 6]\ny = [1, 3, 5]\n```\n\nThis operation would return:\n\n```prettyprint\nout ==> [2, 4, 6]\nidx ==> [1, 3, 5]\n```"
}
op {
  name: "Log"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes natural logarithm of x element-wise."
  description: "I.e., \\\\(y = \\log_e x\\\\)."
}
op {
  name: "LogSoftmax"
  input_arg {
    name: "logits"
    description: "2-D with shape `[batch_size, num_classes]`."
    type_attr: "T"
  }
  output_arg {
    name: "logsoftmax"
    description: "Same shape as `logits`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes log softmax activations."
  description: "For each batch `i` and class `j` we have\n\n    logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))"
}
op {
  name: "LogUniformCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a log-uniform distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "LogicalAnd"
  input_arg {
    name: "x"
    type: DT_BOOL
  }
  input_arg {
    name: "y"
    type: DT_BOOL
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  summary: "Returns the truth value of x AND y element-wise."
  is_commutative: true
}
op {
  name: "LogicalNot"
  input_arg {
    name: "x"
    type: DT_BOOL
  }
  output_arg {
    name: "y"
    type: DT_BOOL
  }
  summary: "Returns the truth value of NOT x element-wise."
}
op {
  name: "LogicalOr"
  input_arg {
    name: "x"
    type: DT_BOOL
  }
  input_arg {
    name: "y"
    type: DT_BOOL
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  summary: "Returns the truth value of x OR y element-wise."
  is_commutative: true
}
op {
  name: "LookupTableFind"
  input_arg {
    name: "table_handle"
    description: "Handle to the table."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "keys"
    description: "Any shape.  Keys to look up."
    type_attr: "Tin"
  }
  input_arg {
    name: "default_value"
    type_attr: "Tout"
  }
  output_arg {
    name: "values"
    description: "Same shape as `keys`.  Values found in the table, or `default_values`\nfor missing keys."
    type_attr: "Tout"
  }
  attr {
    name: "Tin"
    type: "type"
  }
  attr {
    name: "Tout"
    type: "type"
  }
  summary: "Looks up keys in a table, outputs the corresponding values."
  description: "The tensor `keys` must of the same type as the keys of the table.\nThe output `values` is of the type of the table values.\n\nThe scalar `default_value` is the value output for keys not present in the\ntable. It must also be of the same type as the table values."
}
op {
  name: "LookupTableSize"
  input_arg {
    name: "table_handle"
    description: "Handle to the table."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "size"
    description: "Scalar that contains number of elements in the table."
    type: DT_INT64
  }
  summary: "Computes the number of elements in the given table."
}
op {
  name: "LoopCond"
  input_arg {
    name: "input"
    description: "A boolean scalar, representing the branch predicate of the Switch op."
    type: DT_BOOL
  }
  output_arg {
    name: "output"
    description: "The same tensor as `input`."
    type: DT_BOOL
  }
  summary: "Forwards the input to the output."
  description: "This operator represents the loop termination condition used by the\n\"pivot\" switches of a loop."
}
op {
  name: "MatMul"
  input_arg {
    name: "a"
    type_attr: "T"
  }
  input_arg {
    name: "b"
    type_attr: "T"
  }
  output_arg {
    name: "product"
    type_attr: "T"
  }
  attr {
    name: "transpose_a"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, \"a\" is transposed before multiplication."
  }
  attr {
    name: "transpose_b"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, \"b\" is transposed before multiplication."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
      }
    }
  }
  summary: "Multiply the matrix \"a\" by the matrix \"b\"."
  description: "The inputs must be two-dimensional matrices and the inner dimension of\n\"a\" (after being transposed if transpose_a is true) must match the\nouter dimension of \"b\" (after being transposed if transposed_b is\ntrue).\n\n*Note*: The default kernel implementation for MatMul on GPUs uses\ncublas."
}
op {
  name: "MatchingFiles"
  input_arg {
    name: "pattern"
    description: "A (scalar) shell wildcard pattern."
    type: DT_STRING
  }
  output_arg {
    name: "filenames"
    description: "A vector of matching filenames."
    type: DT_STRING
  }
  summary: "Returns the set of files matching a pattern."
  description: "Note that this routine only supports wildcard characters in the\nbasename portion of the pattern, not in the directory portion."
}
op {
  name: "MatrixDeterminant"
  input_arg {
    name: "input"
    description: "A tensor of shape `[M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A scalar, equal to the determinant of the input."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Calculates the determinant of a square matrix."
}
op {
  name: "MatrixInverse"
  input_arg {
    name: "input"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[M, M]`. If `adjoint` is `False` then `output` contains the\nmatrix inverse of `input`. If `adjoint` is `True` then `output` contains the\nmatrix inverse of the adjoint of `input`."
    type_attr: "T"
  }
  attr {
    name: "adjoint"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the inverse of a square invertible matrix or its adjoint (conjugate"
  description: "transpose).\n\nThe op uses LU decomposition with partial pivoting to compute the inverse.\n\nIf the matrix is not invertible there is no guarantee what the op does. It\nmay detect the condition and raise an exception or it may simply return a\ngarbage result."
}
op {
  name: "MatrixSolve"
  input_arg {
    name: "matrix"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  input_arg {
    name: "rhs"
    description: "Shape is `[M, K]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[M, K]`. If `adjoint` is `False` then `output` that solves\n`matrix` * `output` = `rhs`. If `adjoint` is `True` then `output` that solves\n`adjoint(matrix)` * `output` = `rhs`."
    type_attr: "T"
  }
  attr {
    name: "adjoint"
    type: "bool"
    default_value {
      b: false
    }
    description: "Boolean indicating whether to solve with `matrix` or its adjoint."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Solves a system of linear equations. Checks for invertibility."
}
op {
  name: "MatrixSolveLs"
  input_arg {
    name: "matrix"
    description: "Shape is `[M, N]`."
    type_attr: "T"
  }
  input_arg {
    name: "rhs"
    description: "Shape is `[M, K]`."
    type_attr: "T"
  }
  input_arg {
    name: "l2_regularizer"
    type: DT_DOUBLE
  }
  output_arg {
    name: "output"
    description: "Shape is `[N, K]` containing the tensor that solves\n`matrix * output = rhs` in the least-squares sense."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  attr {
    name: "fast"
    type: "bool"
    default_value {
      b: true
    }
  }
  summary: "Solves a linear least-squares problem."
  description: "Below we will use the following notation\n`matrix`=\\\\(A \\in \\Re^{m \\times n}\\\\),\n`rhs`=\\\\(B  \\in \\Re^{m \\times k}\\\\),\n`output`=\\\\(X  \\in \\Re^{n \\times k}\\\\),\n`l2_regularizer`=\\\\(\\lambda\\\\).\n\nIf `fast` is `True`, then the solution is computed by solving the normal\nequations using Cholesky decomposition. Specifically, if \\\\(m \\ge n\\\\) then\n\\\\(X = (A^T A + \\lambda I)^{-1} A^T B\\\\), which solves the least-squares\nproblem \\\\(X = \\mathrm{argmin}_{Z \\in \\Re^{n \\times k}} ||A Z - B||_F^2 +\n\\lambda ||Z||_F^2\\\\). If \\\\(m \\lt n\\\\) then `output` is computed as\n\\\\(X = A^T (A A^T + \\lambda I)^{-1} B\\\\),\nwhich (for \\\\(\\lambda = 0\\\\)) is the minimum-norm solution to the\nunder-determined linear system, i.e.\n\\\\(X = \\mathrm{argmin}_{Z \\in \\Re^{n \\times k}} ||Z||_F^2 \\\\),\nsubject to \\\\(A Z = B\\\\).\nNotice that the fast path is only numerically stable when \\\\(A\\\\) is\nnumerically full rank and has a condition number\n\\\\(\\mathrm{cond}(A) \\lt \\frac{1}{\\sqrt{\\epsilon_{mach}}}\\\\)\nor \\\\(\\lambda\\\\) is sufficiently large.\n\nIf `fast` is `False` an algorithm based on the numerically robust complete\northogonal decomposition is used. This computes the minimum-norm\nleast-squares solution, even when \\\\(A\\\\) is rank deficient. This path is\ntypically 6-7 times slower than the fast path. If `fast` is `False` then\n`l2_regularizer` is ignored."
}
op {
  name: "MatrixTriangularSolve"
  input_arg {
    name: "matrix"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  input_arg {
    name: "rhs"
    description: "Shape is `[M, K]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[M, K]`."
    type_attr: "T"
  }
  attr {
    name: "lower"
    type: "bool"
    default_value {
      b: true
    }
    description: "Boolean indicating whether `matrix` is lower or upper triangular"
  }
  attr {
    name: "adjoint"
    type: "bool"
    default_value {
      b: false
    }
    description: "Boolean indicating whether to solve with `matrix` or its adjoint."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Solves a system of linear equations with an upper or lower triangular matrix by"
  description: "backsubstitution.\n\n`matrix` is a matrix of shape `[M, M]`. If `lower` is `True` then the strictly\nupper triangular part of `matrix` is assumed to be zero and not accessed.\nIf `lower` is False then the strictly lower triangular part of `matrix` is\nassumed to be zero and not accessed.\n`rhs` is a matrix of shape [M, K]`.\n\nThe output is a matrix of shape `[M, K]`. If `adjoint` is `False` the output\nsatisfies the matrix equation `matrix` * `output` = `rhs`.\nIf `adjoint` is `False` then `output` satisfies the matrix equation\n`matrix` * `output` = `rhs`.\nIf `adjoint` is `True` then `output` satisfies the matrix equation\n`adjoint(matrix)` * `output` = `rhs`."
}
op {
  name: "Max"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Computes the maximum of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "MaxPool"
  input_arg {
    name: "input"
    description: "4-D input to pool over."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "The max pooled output tensor."
    type: DT_FLOAT
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the window for each dimension of the input tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the\ninput tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  summary: "Performs max pooling on the input."
}
op {
  name: "MaxPool3D"
  input_arg {
    name: "input"
    description: "Shape `[batch, depth, rows, cols, channels]` tensor to pool over."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The max pooled output tensor."
    type_attr: "T"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[1] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Performs 3D max pooling on the input."
}
op {
  name: "MaxPool3DGrad"
  input_arg {
    name: "orig_input"
    description: "The original input tensor."
    type: DT_FLOAT
  }
  input_arg {
    name: "orig_output"
    description: "The original output tensor."
    type: DT_FLOAT
  }
  input_arg {
    name: "grad"
    description: "Output backprop of shape `[batch, depth, rows, cols, channels]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[1] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`."
    has_minimum: true
    minimum: 5
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Computes gradients of max pooling function."
}
op {
  name: "MaxPoolGrad"
  input_arg {
    name: "orig_input"
    description: "The original input tensor."
    type: DT_FLOAT
  }
  input_arg {
    name: "orig_output"
    description: "The original output tensor."
    type: DT_FLOAT
  }
  input_arg {
    name: "grad"
    description: "4-D.  Gradients w.r.t. the output of `max_pool`."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "Gradients w.r.t. the input to `max_pool`."
    type: DT_FLOAT
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the window for each dimension of the input tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the\ninput tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "data_format"
    type: "string"
    default_value {
      s: "NHWC"
    }
    description: "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width]."
    allowed_values {
      list {
        s: "NHWC"
        s: "NCHW"
      }
    }
  }
  summary: "Computes gradients of the maxpooling function."
}
op {
  name: "MaxPoolGradWithArgmax"
  input_arg {
    name: "input"
    description: "The original input."
    type: DT_FLOAT
  }
  input_arg {
    name: "grad"
    description: "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the\noutput of `max_pool`."
    type: DT_FLOAT
  }
  input_arg {
    name: "argmax"
    description: "The indices of the maximum values chosen for each output of `max_pool`."
    type_attr: "Targmax"
  }
  output_arg {
    name: "output"
    description: "Gradients w.r.t. the input of `max_pool`."
    type: DT_FLOAT
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the window for each dimension of the input tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the\ninput tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  attr {
    name: "Targmax"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes gradients of the maxpooling function."
}
op {
  name: "MaxPoolWithArgmax"
  input_arg {
    name: "input"
    description: "4-D with shape `[batch, height, width, channels]`.  Input to pool over."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "The max pooled output tensor."
    type: DT_FLOAT
  }
  output_arg {
    name: "argmax"
    description: "4-D.  The flattened indices of the max values chosen for each output."
    type_attr: "Targmax"
  }
  attr {
    name: "ksize"
    type: "list(int)"
    description: "The size of the window for each dimension of the input tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "strides"
    type: "list(int)"
    description: "The stride of the sliding window for each dimension of the\ninput tensor."
    has_minimum: true
    minimum: 4
  }
  attr {
    name: "Targmax"
    type: "type"
    default_value {
      type: DT_INT64
    }
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "padding"
    type: "string"
    description: "The type of padding algorithm to use."
    allowed_values {
      list {
        s: "SAME"
        s: "VALID"
      }
    }
  }
  summary: "Performs max pooling on the input and outputs both max values and indices."
  description: "The indices in `argmax` are flattened, so that a maximum value at position\n`[b, y, x, c]` becomes flattened index\n`((b * height + y) * width + x) * channels + c`."
}
op {
  name: "Maximum"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the max of x and y (i.e. x > y ? x : y) element-wise, broadcasts."
  is_commutative: true
}
op {
  name: "Mean"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Computes the mean of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "Merge"
  input_arg {
    name: "inputs"
    description: "The input tensors, exactly one of which will become available."
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "output"
    description: "Will be set to the available input tensor."
    type_attr: "T"
  }
  output_arg {
    name: "value_index"
    description: "The index of the chosen input tensor in `inputs`."
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  summary: "Forwards the value of an available tensor from `inputs` to `output`."
  description: "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor for become available to `output`, and sets\n`value_index` to its index in `inputs`.\n\nIt is an error if more than one tensor in `inputs` is available."
}
op {
  name: "MergeSummary"
  input_arg {
    name: "inputs"
    description: "Can be of any shape.  Each must contain serialized `Summary` protocol\nbuffers."
    type: DT_STRING
    number_attr: "N"
  }
  output_arg {
    name: "summary"
    description: "Scalar. Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  summary: "Merges summaries."
  description: "This op creates a\n[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\nprotocol buffer that contains the union of all the values in the input\nsummaries.\n\nWhen the Op is run, it reports an `InvalidArgument` error if multiple values\nin the summaries to merge use the same tag."
}
op {
  name: "Min"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Computes the minimum of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "Minimum"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Returns the min of x and y (i.e. x < y ? x : y) element-wise, broadcasts."
  is_commutative: true
}
op {
  name: "MirrorPad"
  input_arg {
    name: "input"
    description: "The input tensor to be padded."
    type_attr: "T"
  }
  input_arg {
    name: "paddings"
    description: "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The padded tensor."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "mode"
    type: "string"
    description: "Either `REFLECT` or `SYMMETRIC`. In reflect mode the padded regions\ndo not include the borders, while in symmetric mode the padded regions\ndo include the borders. For example, if `input` is `[1, 2, 3]` and `paddings`\nis `[0, 2]`, then the output is `[1, 2, 3, 2, 1]` in reflect mode, and\nit is `[1, 2, 3, 3, 2]` in symmetric mode."
    allowed_values {
      list {
        s: "REFLECT"
        s: "SYMMETRIC"
      }
    }
  }
  summary: "Pads a tensor with mirrored values."
  description: "This operation pads a `input` with mirrored values according to the `paddings`\nyou specify. `paddings` is an integer tensor with shape `[n, 2]`, where n is\nthe rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many values to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many values to add after the contents of `input`\nin that dimension. Both `paddings[D, 0]` and `paddings[D, 1]` must be no greater\nthan `input.dim_size(D)` (or `input.dim_size(D) - 1`) if `copy_border` is true\n(if false, respectively).\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```prettyprint\n# \'t\' is [[1, 2, 3], [4, 5, 6]].\n# \'paddings\' is [[1, 1]], [2, 2]].\n# \'mode\' is SYMMETRIC.\n# rank of \'t\' is 2.\npad(t, paddings) ==> [[2, 1, 1, 2, 3, 3, 2]\n                      [2, 1, 1, 2, 3, 3, 2]\n                      [5, 4, 4, 5, 6, 6, 5]\n                      [5, 4, 4, 5, 6, 6, 5]]\n```"
}
op {
  name: "MirrorPadGrad"
  input_arg {
    name: "input"
    description: "The input tensor to be folded."
    type_attr: "T"
  }
  input_arg {
    name: "paddings"
    description: "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The folded tensor."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "mode"
    type: "string"
    description: "The mode used in the `MirrorPad` op."
    allowed_values {
      list {
        s: "REFLECT"
        s: "SYMMETRIC"
      }
    }
  }
  summary: "Gradient op for `MirrorPad` op. This op folds a mirror-padded tensor."
  description: "This operation folds the padded areas of `input` by `MirrorPad` according to the\n`paddings` you specify. `paddings` must be the same as `paddings` argument\ngiven to the corresponding `MirrorPad` op.\n\nThe folded size of each dimension D of the output is:\n\n`input.dim_size(D) - paddings(D, 0) - paddings(D, 1)`\n\nFor example:\n\n```prettyprint\n# \'t\' is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].\n# \'paddings\' is [[0, 1]], [0, 1]].\n# \'mode\' is SYMMETRIC.\n# rank of \'t\' is 2.\npad(t, paddings) ==> [[ 1,  5]\n                      [11, 28]]\n```"
}
op {
  name: "Mod"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Returns element-wise remainder of division."
}
op {
  name: "Mul"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
      }
    }
  }
  summary: "Returns x * y element-wise."
  is_commutative: true
}
op {
  name: "Multinomial"
  input_arg {
    name: "logits"
    description: "2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]`\nrepresents the unnormalized log probabilities for all classes."
    type_attr: "T"
  }
  input_arg {
    name: "num_samples"
    description: "0-D.  Number of independent samples to draw for each row slice."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "2-D Tensor with shape `[batch_size, num_samples]`.  Each slice `[i, :]`\ncontains the drawn class labels with range `[0, num_classes)`."
    type: DT_INT64
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 is set to be non-zero, the internal random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Draws samples from a multinomial distribution."
  is_stateful: true
}
op {
  name: "Neg"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes numerical negative value element-wise."
  description: "I.e., \\\\(y = -x\\\\)."
}
op {
  name: "NegTrain"
  input_arg {
    name: "w_in"
    description: "input word embedding."
    type: DT_FLOAT
    is_ref: true
  }
  input_arg {
    name: "w_out"
    description: "output word embedding."
    type: DT_FLOAT
    is_ref: true
  }
  input_arg {
    name: "examples"
    description: "A vector of word ids."
    type: DT_INT32
  }
  input_arg {
    name: "labels"
    description: "A vector of word ids."
    type: DT_INT32
  }
  input_arg {
    name: "lr"
    type: DT_FLOAT
  }
  attr {
    name: "vocab_count"
    type: "list(int)"
    description: "Count of words in the vocabulary."
  }
  attr {
    name: "num_negative_samples"
    type: "int"
    description: "Number of negative samples per example."
  }
  summary: "Training via negative sampling."
  is_stateful: true
}
op {
  name: "NextIteration"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the next iteration."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Makes its input available to the next iteration."
}
op {
  name: "NoOp"
  summary: "Does nothing. Only useful as a placeholder for control edges."
}
op {
  name: "NotEqual"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type: DT_BOOL
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
        type: DT_QUINT8
        type: DT_QINT8
        type: DT_QINT32
        type: DT_STRING
        type: DT_BOOL
      }
    }
  }
  summary: "Returns the truth value of (x != y) element-wise."
  is_commutative: true
}
op {
  name: "OneHot"
  input_arg {
    name: "indices"
    description: "A tensor of indices."
    type: DT_INT64
  }
  input_arg {
    name: "depth"
    description: "A scalar defining the depth of the one hot dimension."
    type: DT_INT32
  }
  input_arg {
    name: "on_value"
    description: "A scalar defining the value to fill in output when `indices[j] = i`."
    type_attr: "T"
  }
  input_arg {
    name: "off_value"
    description: "A scalar defining the value to fill in output when `indices[j] != i`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The one-hot tensor."
    type_attr: "T"
  }
  attr {
    name: "axis"
    type: "int"
    default_value {
      i: -1
    }
    description: "The axis to fill (default: -1, a new inner-most axis)."
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns a one-hot tensor."
  description: "The locations represented by indices in `indices` take value `on_value`,\nwhile all other locations take value `off_value`.\n\nIf the input `indices` is rank `N`, the output will have rank `N+1`,\nThe new axis is created at dimension `axis` (default: the new axis is\nappended at the end).\n\nIf `indices` is a scalar the output shape will be a vector of length `depth`.\n\nIf `indices` is a vector of length `features`, the output shape will be:\n```\n  features x depth if axis == -1\n  depth x features if axis == 0\n```\n\nIf `indices` is a matrix (batch) with shape `[batch, features]`,\nthe output shape will be:\n```\n  batch x features x depth if axis == -1\n  batch x depth x features if axis == 1\n  depth x batch x features if axis == 0\n```\n\n\nExamples\n=========\n\nSuppose that\n\n```\n  indices = [0, 2, -1, 1]\n  depth = 3\n  on_value = 5.0\n  off_value = 0.0\n  axis = -1\n```\n\nThen output is `[4 x 3]`:\n\n    ```output =\n      [5.0 0.0 0.0]  // one_hot(0)\n      [0.0 0.0 5.0]  // one_hot(2)\n      [0.0 0.0 0.0]  // one_hot(-1)\n      [0.0 5.0 0.0]  // one_hot(1)\n    ```\n\nSuppose that\n\n```\n  indices = [0, 2, -1, 1]\n  depth = 3\n  on_value = 0.0\n  off_value = 3.0\n  axis = 0\n```\n\nThen output is `[3 x 4]`:\n\n    ```output =\n      [0.0 3.0 3.0 3.0]\n      [3.0 3.0 3.0 0.0]\n      [3.0 3.0 3.0 3.0]\n      [3.0 0.0 3.0 3.0]\n    //  ^                one_hot(0)\n    //      ^            one_hot(2)\n    //          ^        one_hot(-1)\n    //              ^    one_hot(1)\n    ```\nSuppose that\n\n```\n  indices = [[0, 2], [1, -1]]\n  depth = 3\n  on_value = 1.0\n  off_value = 0.0\n  axis = -1\n```\n\nThen output is `[2 x 2 x 3]`:\n\n    ```output =\n      [\n        [1.0, 0.0, 0.0]  // one_hot(0)\n        [0.0, 0.0, 1.0]  // one_hot(2)\n      ][\n        [0.0, 1.0, 0.0]  // one_hot(1)\n        [0.0, 0.0, 0.0]  // one_hot(-1)\n      ]```"
}
op {
  name: "Pack"
  input_arg {
    name: "values"
    description: "Must be of same shape and type."
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "output"
    description: "The packed tensor."
    type_attr: "T"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor."
  description: "Packs the `N` tensors in `values` into a tensor with rank one higher than each\ntensor in `values` and shape `[N] + values[0].shape`. The output satisfies\n`output[i, ...] = values[i][...]`.\n\nThis is the opposite of `unpack`."
}
op {
  name: "Pad"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "paddings"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Pads a tensor with zeros."
  description: "This operation pads a `input` with zeros according to the `paddings` you\nspecify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the\nrank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many zeros to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many zeros to add after the contents of `input`\nin that dimension.\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```prettyprint\n# \'t\' is [[1, 1], [2, 2]]\n# \'paddings\' is [[1, 1], [2, 2]]\n# rank of \'t\' is 2\npad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]\n                      [0, 0, 1, 1, 0, 0]\n                      [0, 0, 2, 2, 0, 0]\n                      [0, 0, 0, 0, 0, 0]]\n```"
}
op {
  name: "PaddingFIFOQueue"
  output_arg {
    name: "handle"
    description: "The handle to the queue."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a value."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "shapes"
    type: "list(shape)"
    default_value {
      list {
      }
    }
    description: "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types.\nShapes of fixed rank but variable size are allowed by setting\nany shape dimension to -1.  In this case, the inputs\' shape may vary along\nthe given dimension, and DequeueMany will pad the given dimension with\nzeros up to the maximum shape of all elements in the given batch.\nIf the length of this attr is 0, different queue elements may have\ndifferent ranks and shapes, but only one element may be dequeued at a time."
    has_minimum: true
  }
  attr {
    name: "capacity"
    type: "int"
    default_value {
      i: -1
    }
    description: "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue will be shared under the given name\nacross multiple sessions."
  }
  summary: "A queue that produces elements in first-in first-out order."
  description: "Variable-size shapes are allowed by setting the corresponding shape dimensions\nto 0 in the shape attr.  In this case DequeueMany will pad up to the maximum\nsize of any given element in the minibatch.  See below for details."
  is_stateful: true
}
op {
  name: "ParseExample"
  input_arg {
    name: "serialized"
    description: "A vector containing a batch of binary serialized Example protos."
    type: DT_STRING
  }
  input_arg {
    name: "names"
    description: "A vector containing the names of the serialized protos.\nMay contain, for example, table key (descriptive) names for the\ncorresponding serialized protos.  These are purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no names are available.\nIf non-empty, this vector must be the same length as \"serialized\"."
    type: DT_STRING
  }
  input_arg {
    name: "sparse_keys"
    description: "A list of Nsparse string Tensors (scalars).\nThe keys expected in the Examples\' features associated with sparse values."
    type: DT_STRING
    number_attr: "Nsparse"
  }
  input_arg {
    name: "dense_keys"
    description: "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples\' features associated with dense values."
    type: DT_STRING
    number_attr: "Ndense"
  }
  input_arg {
    name: "dense_defaults"
    description: "A list of Ndense Tensors (some may be empty).\ndense_defaults[j] provides default values\nwhen the example\'s feature_map lacks dense_key[j].  If an empty Tensor is\nprovided for dense_defaults[j], then the Feature dense_keys[j] is required.\nThe input type is inferred from dense_defaults[j], even when it\'s empty.\nIf dense_defaults[j] is not empty, its shape must match dense_shapes[j]."
    type_list_attr: "Tdense"
  }
  output_arg {
    name: "sparse_indices"
    type: DT_INT64
    number_attr: "Nsparse"
  }
  output_arg {
    name: "sparse_values"
    type_list_attr: "sparse_types"
  }
  output_arg {
    name: "sparse_shapes"
    type: DT_INT64
    number_attr: "Nsparse"
  }
  output_arg {
    name: "dense_values"
    type_list_attr: "Tdense"
  }
  attr {
    name: "Nsparse"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "Ndense"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "sparse_types"
    type: "list(type)"
    description: "A list of Nsparse types; the data types of data in each Feature\ngiven in sparse_keys.\nCurrently the ParseExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList)."
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "Tdense"
    type: "list(type)"
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "dense_shapes"
    type: "list(shape)"
    description: "A list of Ndense shapes; the shapes of data in each Feature\ngiven in dense_keys.\nThe number of elements in the Feature corresponding to dense_key[j]\nmust always equal dense_shapes[j].NumEntries().\nIf dense_shapes[j] == (D0, D1, ..., DN) then the shape of output\nTensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):\nThe dense outputs are just the inputs row-stacked by batch."
    has_minimum: true
  }
  summary: "Transforms a vector of brain.Example protos (as strings) into typed tensors."
}
op {
  name: "ParseSingleSequenceExample"
  input_arg {
    name: "serialized"
    description: "A scalar containing a binary serialized SequenceExample proto."
    type: DT_STRING
  }
  input_arg {
    name: "feature_list_dense_missing_assumed_empty"
    description: "A vector listing the\nFeatureList keys which may be missing from the SequenceExample.  If the\nassociated FeatureList is missing, it is treated as empty.  By default,\nany FeatureList not listed in this vector must exist in the SequenceExample."
    type: DT_STRING
  }
  input_arg {
    name: "context_sparse_keys"
    description: "A list of Ncontext_sparse string Tensors (scalars).\nThe keys expected in the Examples\' features associated with context_sparse\nvalues."
    type: DT_STRING
    number_attr: "Ncontext_sparse"
  }
  input_arg {
    name: "context_dense_keys"
    description: "A list of Ncontext_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples\' context features associated with\ndense values."
    type: DT_STRING
    number_attr: "Ncontext_dense"
  }
  input_arg {
    name: "feature_list_sparse_keys"
    description: "A list of Nfeature_list_sparse string Tensors\n(scalars).  The keys expected in the FeatureLists associated with sparse\nvalues."
    type: DT_STRING
    number_attr: "Nfeature_list_sparse"
  }
  input_arg {
    name: "feature_list_dense_keys"
    description: "A list of Nfeature_list_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples\' feature_lists associated\nwith lists of dense values."
    type: DT_STRING
    number_attr: "Nfeature_list_dense"
  }
  input_arg {
    name: "context_dense_defaults"
    description: "A list of Ncontext_dense Tensors (some may be empty).\ncontext_dense_defaults[j] provides default values\nwhen the SequenceExample\'s context map lacks context_dense_key[j].\nIf an empty Tensor is provided for context_dense_defaults[j],\nthen the Feature context_dense_keys[j] is required.\nThe input type is inferred from context_dense_defaults[j], even when it\'s\nempty.  If context_dense_defaults[j] is not empty, its shape must match\ncontext_dense_shapes[j]."
    type_list_attr: "Tcontext_dense"
  }
  input_arg {
    name: "debug_name"
    description: "A scalar containing the name of the serialized proto.\nMay contain, for example, table key (descriptive) name for the\ncorresponding serialized proto.  This is purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty scalar if no name is available."
    type: DT_STRING
  }
  output_arg {
    name: "context_sparse_indices"
    type: DT_INT64
    number_attr: "Ncontext_sparse"
  }
  output_arg {
    name: "context_sparse_values"
    type_list_attr: "context_sparse_types"
  }
  output_arg {
    name: "context_sparse_shapes"
    type: DT_INT64
    number_attr: "Ncontext_sparse"
  }
  output_arg {
    name: "context_dense_values"
    type_list_attr: "Tcontext_dense"
  }
  output_arg {
    name: "feature_list_sparse_indices"
    type: DT_INT64
    number_attr: "Nfeature_list_sparse"
  }
  output_arg {
    name: "feature_list_sparse_values"
    type_list_attr: "feature_list_sparse_types"
  }
  output_arg {
    name: "feature_list_sparse_shapes"
    type: DT_INT64
    number_attr: "Nfeature_list_sparse"
  }
  output_arg {
    name: "feature_list_dense_values"
    type_list_attr: "feature_list_dense_types"
  }
  attr {
    name: "Ncontext_sparse"
    type: "int"
    default_value {
      i: 0
    }
    has_minimum: true
  }
  attr {
    name: "Ncontext_dense"
    type: "int"
    default_value {
      i: 0
    }
    has_minimum: true
  }
  attr {
    name: "Nfeature_list_sparse"
    type: "int"
    default_value {
      i: 0
    }
    has_minimum: true
  }
  attr {
    name: "Nfeature_list_dense"
    type: "int"
    default_value {
      i: 0
    }
    has_minimum: true
  }
  attr {
    name: "context_sparse_types"
    type: "list(type)"
    default_value {
      list {
      }
    }
    description: "A list of Ncontext_sparse types; the data types of data in\neach context Feature given in context_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList)."
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "Tcontext_dense"
    type: "list(type)"
    default_value {
      list {
      }
    }
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "feature_list_dense_types"
    type: "list(type)"
    default_value {
      list {
      }
    }
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "context_dense_shapes"
    type: "list(shape)"
    default_value {
      list {
      }
    }
    description: "A list of Ncontext_dense shapes; the shapes of data in\neach context Feature given in context_dense_keys.\nThe number of elements in the Feature corresponding to context_dense_key[j]\nmust always equal context_dense_shapes[j].NumEntries().\nThe shape of context_dense_values[j] will match context_dense_shapes[j]."
    has_minimum: true
  }
  attr {
    name: "feature_list_sparse_types"
    type: "list(type)"
    default_value {
      list {
      }
    }
    description: "A list of Nfeature_list_sparse types; the data types\nof data in each FeatureList given in feature_list_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList)."
    has_minimum: true
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT64
        type: DT_STRING
      }
    }
  }
  attr {
    name: "feature_list_dense_shapes"
    type: "list(shape)"
    default_value {
      list {
      }
    }
    description: "A list of Nfeature_list_dense shapes; the shapes of\ndata in each FeatureList given in feature_list_dense_keys.\nThe shape of each Feature in the FeatureList corresponding to\nfeature_list_dense_key[j] must always equal\nfeature_list_dense_shapes[j].NumEntries()."
    has_minimum: true
  }
  summary: "Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors."
}
op {
  name: "Placeholder"
  output_arg {
    name: "output"
    description: "A placeholder tensor that must be replaced using the feed mechanism."
    type_attr: "dtype"
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of elements in the tensor."
  }
  attr {
    name: "shape"
    type: "shape"
    default_value {
      shape {
      }
    }
    description: "(Optional) The shape of the tensor. If the shape has 0 dimensions, the\nshape is unconstrained."
  }
  summary: "A placeholder op for a value that will be fed into the computation."
  description: "N.B. This operation will fail with an error if it is executed. It is\nintended as a way to represent a value that will always be fed, and to\nprovide attrs that enable the fed value to be checked at runtime."
}
op {
  name: "PlaceholderWithDefault"
  input_arg {
    name: "input"
    description: "The default value to produce when `output` is not fed."
    type_attr: "dtype"
  }
  output_arg {
    name: "output"
    description: "A placeholder tensor that defaults to `input` if it is not fed."
    type_attr: "dtype"
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of elements in the tensor."
  }
  attr {
    name: "shape"
    type: "shape"
    description: "The (possibly partial) shape of the tensor."
  }
  summary: "A placeholder op that passes though `input` when its output is not fed."
}
op {
  name: "Pow"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes the power of one value to another."
  description: "Given a tensor `x` and a tensor `y`, this operation computes \\\\(x^y\\\\) for\ncorresponding elements in `x` and `y`. For example:\n\n```\n# tensor \'x\' is [[2, 2]], [3, 3]]\n# tensor \'y\' is [[8, 16], [2, 3]]\ntf.pow(x, y) ==> [[256, 65536], [9, 27]]\n```"
}
op {
  name: "Print"
  input_arg {
    name: "input"
    description: "The tensor passed to `output`"
    type_attr: "T"
  }
  input_arg {
    name: "data"
    description: "A list of tensors to print out when op is evaluated."
    type_list_attr: "U"
  }
  output_arg {
    name: "output"
    description: "= The unmodified `input` tensor"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "U"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "message"
    type: "string"
    default_value {
      s: ""
    }
    description: "A string, prefix of the error message."
  }
  attr {
    name: "first_n"
    type: "int"
    default_value {
      i: -1
    }
    description: "Only log `first_n` number of times. -1 disables logging."
  }
  attr {
    name: "summarize"
    type: "int"
    default_value {
      i: 3
    }
    description: "Only print this many entries of each tensor."
  }
  summary: "Prints a list of tensors."
  description: "Passes `input` through to `output` and prints `data` when evaluating."
  is_stateful: true
}
op {
  name: "Prod"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Computes the product of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "PyFunc"
  input_arg {
    name: "input"
    description: "List of Tensors that will provide input to the Op."
    type_list_attr: "Tin"
  }
  output_arg {
    name: "output"
    description: "The outputs from the Op."
    type_list_attr: "Tout"
  }
  attr {
    name: "token"
    type: "string"
    description: "A token representing a registered python function in this address space."
  }
  attr {
    name: "Tin"
    type: "list(type)"
    description: "Data types of the inputs to the op."
    has_minimum: true
  }
  attr {
    name: "Tout"
    type: "list(type)"
    description: "Data types of the outputs from the op.\nThe length of the list specifies the number of outputs."
    has_minimum: true
    minimum: 1
  }
  summary: "Invokes a python function to compute func(input)->output."
  is_stateful: true
}
op {
  name: "QueueClose"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "cancel_pending_enqueues"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, all pending enqueue requests that are\nblocked on the given queue will be cancelled."
  }
  summary: "Closes the given queue."
  description: "This operation signals that no more elements will be enqueued in the\ngiven queue. Subsequent Enqueue(Many) operations will fail.\nSubsequent Dequeue(Many) operations will continue to succeed if\nsufficient elements remain in the queue. Subsequent Dequeue(Many)\noperations that would block will fail immediately."
}
op {
  name: "QueueDequeue"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "components"
    description: "One or more tensors that were dequeued as a tuple."
    type_list_attr: "component_types"
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a tuple."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Dequeues a tuple of one or more tensors from the given queue."
  description: "This operation has k outputs, where k is the number of components\nin the tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until an element\nhas been dequeued (or \'timeout_ms\' elapses, if specified)."
}
op {
  name: "QueueDequeueMany"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "n"
    description: "The number of tuples to dequeue."
    type: DT_INT32
  }
  output_arg {
    name: "components"
    description: "One or more tensors that were dequeued as a tuple."
    type_list_attr: "component_types"
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a tuple."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Dequeues n tuples of one or more tensors from the given queue."
  description: "If the queue is closed and there are fewer than n elements, then an\nOutOfRange error is returned.\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size n in the 0th dimension.\n\nThis operation has k outputs, where k is the number of components in\nthe tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until n elements\nhave been dequeued (or \'timeout_ms\' elapses, if specified)."
}
op {
  name: "QueueDequeueUpTo"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "n"
    description: "The number of tuples to dequeue."
    type: DT_INT32
  }
  output_arg {
    name: "components"
    description: "One or more tensors that were dequeued as a tuple."
    type_list_attr: "component_types"
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a tuple."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Dequeues n tuples of one or more tensors from the given queue."
  description: "This operation is not supported by all queues.  If a queue does not support\nDequeueUpTo, then an Unimplemented error is returned.\n\nIf the queue is closed and there are more than 0 but less than n elements\nremaining, then instead of returning an OutOfRange error like\nQueueDequeueMany, the remaining elements are returned immediately.  If the queue\nis closed and there are 0 elements left in the queue, then an OutOfRange\nerror is returned just like in QueueDequeueMany.  Otherwise the behavior\nis identical to QueueDequeueMany:\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size n in the 0th dimension.\n\nThis operation has k outputs, where k is the number of components in\nthe tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple."
}
op {
  name: "QueueEnqueue"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "components"
    description: "One or more tensors from which the enqueued tensors should be taken."
    type_list_attr: "Tcomponents"
  }
  attr {
    name: "Tcomponents"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue is full, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Enqueues a tuple of one or more tensors in the given queue."
  description: "The components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelement has been enqueued (or \'timeout_ms\' elapses, if specified)."
}
op {
  name: "QueueEnqueueMany"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "components"
    description: "One or more tensors from which the enqueued tensors should\nbe taken."
    type_list_attr: "Tcomponents"
  }
  attr {
    name: "Tcomponents"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "timeout_ms"
    type: "int"
    default_value {
      i: -1
    }
    description: "If the queue is too full, this operation will block for up\nto timeout_ms milliseconds.\nNote: This option is not supported yet."
  }
  summary: "Enqueues zero or more tuples of one or more tensors in the given queue."
  description: "This operation slices each component tensor along the 0th dimension to\nmake multiple queue elements. All of the tuple components must have the\nsame size in the 0th dimension.\n\nThe components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelements have been enqueued (or \'timeout_ms\' elapses, if specified)."
}
op {
  name: "QueueSize"
  input_arg {
    name: "handle"
    description: "The handle to a queue."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "size"
    description: "The number of elements in the given queue."
    type: DT_INT32
  }
  summary: "Computes the number of elements in the given queue."
}
op {
  name: "RGBToHSV"
  input_arg {
    name: "images"
    description: "1-D or higher rank. RGB data to convert. Last dimension must be size 3."
    type: DT_FLOAT
  }
  output_arg {
    name: "output"
    description: "`images` converted to HSV."
    type: DT_FLOAT
  }
  summary: "Converts one or more images from RGB to HSV."
  description: "Outputs a tensor of the same shape as the `images` tensor, containing the HSV\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\n`output[..., 0]` contains hue, `output[..., 1]` contains saturation, and\n`output[..., 2]` contains value. All HSV values are in `[0,1]`. A hue of 0\ncorresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue."
}
op {
  name: "RandomCrop"
  input_arg {
    name: "image"
    description: "3-D of shape `[height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "1-D of length 2 containing: `crop_height`, `crop_width`.."
    type: DT_INT64
  }
  output_arg {
    name: "output"
    description: "3-D of shape `[crop_height, crop_width, channels].`"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Randomly crop `image`."
  description: "`size` is a 1-D int64 tensor with 2 elements representing the crop height and\nwidth.  The values must be non negative.\n\nThis Op picks a random location in `image` and crops a `height` by `width`\nrectangle from that location.  The random location is picked so the cropped\narea will fit inside the original image."
  deprecation {
    version: 8
    explanation: "Random crop is now pure Python"
  }
  is_stateful: true
}
op {
  name: "RandomShuffle"
  input_arg {
    name: "value"
    description: "The tensor to be shuffled."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A tensor of same shape and type as `value`, shuffled along its first\ndimension."
    type_attr: "T"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Randomly shuffles a tensor along its first dimension."
  description: "  The tensor is shuffled along dimension 0, such that each `value[j]` is mapped\n  to one and only one `output[i]`. For example, a mapping that might occur for a\n  3x2 tensor is:\n\n```prettyprint\n[[1, 2],       [[5, 6],\n [3, 4],  ==>   [1, 2],\n [5, 6]]        [3, 4]]\n```"
  is_stateful: true
}
op {
  name: "RandomShuffleQueue"
  output_arg {
    name: "handle"
    description: "The handle to the queue."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "component_types"
    type: "list(type)"
    description: "The type of each component in a value."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "shapes"
    type: "list(shape)"
    default_value {
      list {
      }
    }
    description: "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time."
    has_minimum: true
  }
  attr {
    name: "capacity"
    type: "int"
    default_value {
      i: -1
    }
    description: "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit."
  }
  attr {
    name: "min_after_dequeue"
    type: "int"
    default_value {
      i: 0
    }
    description: "Dequeue will block unless there would be this\nmany elements after the dequeue or the queue is closed. This\nensures a minimum level of mixing of elements."
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 is set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this queue will be shared under the given name\nacross multiple sessions."
  }
  summary: "A queue that randomizes the order of elements."
  is_stateful: true
}
op {
  name: "RandomStandardNormal"
  input_arg {
    name: "shape"
    description: "The shape of the output tensor."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A tensor of the specified shape filled with random normal values."
    type_attr: "dtype"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the output."
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Outputs random values from a normal distribution."
  description: "The generated values will have mean 0 and standard deviation 1."
  is_stateful: true
}
op {
  name: "RandomUniform"
  input_arg {
    name: "shape"
    description: "The shape of the output tensor."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A tensor of the specified shape filled with uniform random values."
    type_attr: "dtype"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the output."
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Outputs random values from a uniform distribution."
  description: "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded."
  is_stateful: true
}
op {
  name: "RandomUniformInt"
  input_arg {
    name: "shape"
    description: "The shape of the output tensor."
    type_attr: "T"
  }
  input_arg {
    name: "minval"
    description: "0-D.  Inclusive lower bound on the generated integers."
    type_attr: "Tout"
  }
  input_arg {
    name: "maxval"
    description: "0-D.  Exclusive upper bound on the generated integers."
    type_attr: "Tout"
  }
  output_arg {
    name: "output"
    description: "A tensor of the specified shape filled with uniform random integers."
    type_attr: "Tout"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "Tout"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Outputs random integers from a uniform distribution."
  description: "The generated values are uniform integers in the range `[minval, maxval)`.\nThe lower bound `minval` is included in the range, while the upper bound\n`maxval` is excluded.\n\nThe random integers are slightly biased unless `maxval - minval` is an exact\npower of two.  The bias is small for values of `maxval - minval` significantly\nsmaller than the range of the output (either `2^32` or `2^64`)."
  is_stateful: true
}
op {
  name: "Range"
  input_arg {
    name: "start"
    description: "0-D (scalar). First entry in the sequence."
    type: DT_INT32
  }
  input_arg {
    name: "limit"
    description: "0-D (scalar). Upper limit of sequence, exclusive."
    type: DT_INT32
  }
  input_arg {
    name: "delta"
    description: "0-D (scalar). Optional. Default is 1. Number that increments `start`."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "1-D."
    type: DT_INT32
  }
  summary: "Creates a sequence of integers."
  description: "This operation creates a sequence of integers that begins at `start` and\nextends by increments of `delta` up to but not including `limit`.\n\nFor example:\n\n```\n# \'start\' is 3\n# \'limit\' is 18\n# \'delta\' is 3\ntf.range(start, limit, delta) ==> [3, 6, 9, 12, 15]\n```"
}
op {
  name: "Rank"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the rank of a tensor."
  description: "This operation returns an integer representing the rank of `input`.\n\nFor example:\n\n```prettyprint\n# \'t\' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\n# shape of tensor \'t\' is [2, 2, 3]\nrank(t) ==> 3\n```\n\n**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank\nof a tensor is the number of indices required to uniquely select each element\nof the tensor. Rank is also known as \"order\", \"degree\", or \"ndims.\""
}
op {
  name: "ReadFile"
  input_arg {
    name: "filename"
    type: DT_STRING
  }
  output_arg {
    name: "contents"
    type: DT_STRING
  }
  summary: "Reads and outputs the entire contents of the input filename."
}
op {
  name: "ReaderNumRecordsProduced"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "records_produced"
    type: DT_INT64
  }
  summary: "Returns the number of records this Reader has produced."
  description: "This is the same as the number of ReaderRead executions that have\nsucceeded."
}
op {
  name: "ReaderNumWorkUnitsCompleted"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "units_completed"
    type: DT_INT64
  }
  summary: "Returns the number of work units this Reader has finished processing."
}
op {
  name: "ReaderRead"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "queue_handle"
    description: "Handle to a Queue, with string work items."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "key"
    description: "A scalar."
    type: DT_STRING
  }
  output_arg {
    name: "value"
    description: "A scalar."
    type: DT_STRING
  }
  summary: "Returns the next record (key, value pair) produced by a Reader."
  description: "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file)."
}
op {
  name: "ReaderReset"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  summary: "Restore a Reader to its initial clean state."
}
op {
  name: "ReaderRestoreState"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "state"
    description: "Result of a ReaderSerializeState of a Reader with type\nmatching reader_handle."
    type: DT_STRING
  }
  summary: "Restore a reader to a previously saved state."
  description: "Not all Readers support being restored, so this can produce an\nUnimplemented error."
}
op {
  name: "ReaderSerializeState"
  input_arg {
    name: "reader_handle"
    description: "Handle to a Reader."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "state"
    type: DT_STRING
  }
  summary: "Produce a string tensor that encodes the state of a Reader."
  description: "Not all Readers support being serialized, so this can produce an\nUnimplemented error."
}
op {
  name: "Real"
  input_arg {
    name: "input"
    type: DT_COMPLEX64
  }
  output_arg {
    name: "output"
    type: DT_FLOAT
  }
  summary: "Returns the real part of a complex number."
  description: "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the real part of each element in `input`. All elements in\n`input` must be complex numbers of the form \\\\(a + bj\\\\), where *a* is the real\n part returned by this operation and *b* is the imaginary part.\n\nFor example:\n\n```\n# tensor \'input\' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.real(input) ==> [-2.25, 3.25]\n```"
}
op {
  name: "ReduceJoin"
  input_arg {
    name: "inputs"
    description: "The input to be joined.  All reduced indices must have non-zero size."
    type: DT_STRING
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce over.  Dimensions are reduced in the\norder specified.  If `reduction_indices` has higher rank than `1`, it is\nflattened.  Omitting `reduction_indices` is equivalent to passing\n`[n-1, n-2, ..., 0]`.  Negative indices from `-n` to `-1` are supported."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Has shape equal to that of the input with reduced dimensions removed or\nset to `1` depending on `keep_dims`."
    type: DT_STRING
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, retain reduced dimensions with length `1`."
  }
  attr {
    name: "separator"
    type: "string"
    default_value {
      s: ""
    }
    description: "The separator to use when joining."
  }
  summary: "Joins a string Tensor across the given dimensions."
  description: "Computes the string join across dimensions in the given string Tensor of shape\n`[d_0, d_1, ..., d_n-1]`.  Returns a new Tensor created by joining the input\nstrings with the given separator (default: empty string).  Negative indices are\ncounted backwards from the end, with `-1` being equivalent to `n - 1`.  Passing\nan empty `reduction_indices` joins all strings in linear index order and outputs\na scalar string.\n\n\nFor example:\n```\n# tensor `a` is [[\"a\", \"b\"], [\"c\", \"d\"]]\ntf.reduce_join(a, 0) ==> [\"ac\", \"bd\"]\ntf.reduce_join(a, 1) ==> [\"ab\", \"cd\"]\ntf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==> [\"ac\", \"bd\"]\ntf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==> [\"ab\", \"cd\"]\ntf.reduce_join(a, 0, keep_dims=True) ==> [[\"ac\", \"bd\"]]\ntf.reduce_join(a, 1, keep_dims=True) ==> [[\"ab\"], [\"cd\"]]\ntf.reduce_join(a, 0, separator=\".\") ==> [\"a.c\", \"b.d\"]\ntf.reduce_join(a, [0, 1]) ==> [\"acbd\"]\ntf.reduce_join(a, [1, 0]) ==> [\"abcd\"]\ntf.reduce_join(a, []) ==> [\"abcd\"]\n```"
}
op {
  name: "RefEnter"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the child frame."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "frame_name"
    type: "string"
    description: "The name of the child frame."
  }
  attr {
    name: "is_constant"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, the output is constant within the child frame."
  }
  attr {
    name: "parallel_iterations"
    type: "int"
    default_value {
      i: 10
    }
    description: "The number of iterations allowed to run in parallel."
  }
  summary: "Creates or finds a child frame, and makes `data` available to the child frame."
  description: "The unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame."
}
op {
  name: "RefExit"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the parent frame."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Exits the current frame to its parent frame."
  description: "Exit makes its input `data` available to the parent frame."
}
op {
  name: "RefIdentity"
  input_arg {
    name: "input"
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output"
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Return the same ref tensor as the input ref tensor."
}
op {
  name: "RefMerge"
  input_arg {
    name: "inputs"
    description: "The input tensors, exactly one of which will become available."
    type_attr: "T"
    number_attr: "N"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "Will be set to the available input tensor."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "value_index"
    description: "The index of the chosen input tensor in `inputs`."
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  summary: "Forwards the value of an available tensor from `inputs` to `output`."
  description: "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor for become available to `output`, and sets\n`value_index` to its index in `inputs`.\n\nIt is an error if more than one tensor in `inputs` is available."
}
op {
  name: "RefNextIteration"
  input_arg {
    name: "data"
    description: "The tensor to be made available to the next iteration."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "The same tensor as `data`."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Makes its input available to the next iteration."
}
op {
  name: "RefSelect"
  input_arg {
    name: "index"
    description: "A scalar that determines the input that gets selected."
    type: DT_INT32
  }
  input_arg {
    name: "inputs"
    description: "A list of ref tensors, one of which will be forwarded to `output`."
    type_attr: "T"
    number_attr: "N"
    is_ref: true
  }
  output_arg {
    name: "output"
    description: "The forwarded tensor."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  summary: "Forwards the `index`th element of `inputs` to `output`."
}
op {
  name: "RefSwitch"
  input_arg {
    name: "data"
    description: "The ref tensor to be forwarded to the appropriate output."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "pred"
    description: "A scalar that specifies which output port will receive data."
    type: DT_BOOL
  }
  output_arg {
    name: "output_false"
    description: "If `pred` is false, data will be forwarded to this output."
    type_attr: "T"
    is_ref: true
  }
  output_arg {
    name: "output_true"
    description: "If `pred` is true, data will be forwarded to this output."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Forwards the ref tensor `data` to the output port determined by `pred`."
  description: "If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `Switch` and `Merge`."
}
op {
  name: "Relu"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes rectified linear: `max(features, 0)`."
}
op {
  name: "Relu6"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes rectified linear 6: `min(max(features, 0), 6)`."
}
op {
  name: "Relu6Grad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding Relu6 operation."
    type_attr: "T"
  }
  input_arg {
    name: "features"
    description: "The features passed as input to the corresponding Relu6 operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients:\n`gradients * features * (features > 0) * (features < 6)`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes rectified linear 6 gradients for a Relu6 operation."
}
op {
  name: "ReluGrad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding Relu operation."
    type_attr: "T"
  }
  input_arg {
    name: "features"
    description: "The features passed as input to the corresponding Relu operation, OR\nthe outputs of that operation (both work equivalently)."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "`gradients * (features > 0)`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes rectified linear gradients for a Relu operation."
}
op {
  name: "Reshape"
  input_arg {
    name: "tensor"
    type_attr: "T"
  }
  input_arg {
    name: "shape"
    description: "Defines the shape of the output tensor."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Reshapes a tensor."
  description: "Given `tensor`, this operation returns a tensor that has the same values\nas `tensor` with shape `shape`.\n\nIf one component of `shape` is the special value -1, the size of that dimension\nis computed so that the total size remains constant.  In particular, a `shape`\nof `[-1]` flattens into 1-D.  At most one component of `shape` can be -1.\n\nIf `shape` is 1-D or higher, then the operation returns a tensor with shape\n`shape` filled with the values of `tensor`. In this case, the number of elements\nimplied by `shape` must be the same as the number of elements in `tensor`.\n\nFor example:\n\n```prettyprint\n# tensor \'t\' is [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# tensor \'t\' has shape [9]\nreshape(t, [3, 3]) ==> [[1, 2, 3]\n                        [4, 5, 6]\n                        [7, 8, 9]]\n\n# tensor \'t\' is [[[1, 1], [2, 2]]\n#                [[3, 3], [4, 4]]]\n# tensor \'t\' has shape [2, 2, 2]\nreshape(t, [2, 4]) ==> [[1, 1, 2, 2]\n                        [3, 3, 4, 4]]\n\n# tensor \'t\' is [[[1, 1, 1],\n#                 [2, 2, 2]],\n#                [[3, 3, 3],\n#                 [4, 4, 4]],\n#                [[5, 5, 5],\n#                 [6, 6, 6]]]\n# tensor \'t\' has shape [3, 2, 3]\n# pass \'[-1]\' to flatten \'t\'\nreshape(t, [-1]) ==> [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]\n# -1 can also be used with higher dimensional shapes\nreshape(t, [2, -1]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n\n# tensor \'t\' is [7]\n# shape `[]` reshapes to a scalar\nreshape(t, []) ==> 7\n```"
}
op {
  name: "ResizeArea"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images."
    type: DT_INT32
  }
  output_arg {
    name: "resized_images"
    description: "4-D with shape\n`[batch, new_height, new_width, channels]`."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "align_corners"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension."
  }
  summary: "Resize `images` to `size` using area interpolation."
  description: "Input images can be of different types but output images are always float."
}
op {
  name: "ResizeBicubic"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images."
    type: DT_INT32
  }
  output_arg {
    name: "resized_images"
    description: "4-D with shape\n`[batch, new_height, new_width, channels]`."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "align_corners"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension."
  }
  summary: "Resize `images` to `size` using bicubic interpolation."
  description: "Input images can be of different types but output images are always float."
}
op {
  name: "ResizeBilinear"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images."
    type: DT_INT32
  }
  output_arg {
    name: "resized_images"
    description: "4-D with shape\n`[batch, new_height, new_width, channels]`."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "align_corners"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension."
  }
  summary: "Resize `images` to `size` using bilinear interpolation."
  description: "Input images can be of different types but output images are always float."
}
op {
  name: "ResizeBilinearGrad"
  input_arg {
    name: "grads"
    description: "4-D with shape `[batch, height, width, channels]`."
    type: DT_FLOAT
  }
  input_arg {
    name: "original_image"
    description: "4-D with shape `[batch, orig_height, orig_width, channels]`,\nThe image tensor that was resized."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "4-D with shape `[batch, orig_height, orig_width, channels]`.\nGradients with respect to the input image. Input image must have been\nfloat or double."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "align_corners"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, rescale grads by (orig_height - 1) / (height - 1), which\nexactly aligns the 4 corners of grads and original_image. If false, rescale by\norig_height / height. Treat similarly the width dimension."
  }
  summary: "Computes the gradient of bilinear interpolation."
}
op {
  name: "ResizeNearestNeighbor"
  input_arg {
    name: "images"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images."
    type: DT_INT32
  }
  output_arg {
    name: "resized_images"
    description: "4-D with shape\n`[batch, new_height, new_width, channels]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "align_corners"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension."
  }
  summary: "Resize `images` to `size` using nearest neighbor interpolation."
}
op {
  name: "ResizeNearestNeighborGrad"
  input_arg {
    name: "grads"
    description: "4-D with shape `[batch, height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "size"
    description: "= A 1-D int32 Tensor of 2 elements: `orig_height, orig_width`. The\noriginal input size."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "4-D with shape `[batch, orig_height, orig_width, channels]`. Gradients\nwith respect to the input image."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT32
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "align_corners"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, rescale grads by (orig_height - 1) / (height - 1), which\nexactly aligns the 4 corners of grads and original_image. If false, rescale by\norig_height / height. Treat similarly the width dimension."
  }
  summary: "Computes the gradient of nearest neighbor interpolation."
}
op {
  name: "Restore"
  input_arg {
    name: "file_pattern"
    description: "Must have a single element. The pattern of the files from\nwhich we read the tensor."
    type: DT_STRING
  }
  input_arg {
    name: "tensor_name"
    description: "Must have a single element. The name of the tensor to be\nrestored."
    type: DT_STRING
  }
  output_arg {
    name: "tensor"
    description: "The restored tensor."
    type_attr: "dt"
  }
  attr {
    name: "dt"
    type: "type"
    description: "The type of the tensor to be restored."
  }
  attr {
    name: "preferred_shard"
    type: "int"
    default_value {
      i: -1
    }
    description: "Index of file to open first if multiple files match\n`file_pattern`."
  }
  summary: "Restores a tensor from checkpoint files."
  description: "Reads a tensor stored in one or several files. If there are several files (for\ninstance because a tensor was saved as slices), `file_pattern` may contain\nwildcard symbols (`*` and `?`) in the filename portion only, not in the\ndirectory portion.\n\nIf a `file_pattern` matches several files, `preferred_shard` can be used to hint\nin which file the requested tensor is likely to be found. This op will first\nopen the file at index `preferred_shard` in the list of matching files and try\nto restore tensors from that file.  Only if some tensors or tensor slices are\nnot found in that first file, then the Op opens all the files. Setting\n`preferred_shard` to match the value passed as the `shard` input\nof a matching `Save` Op may speed up Restore.  This attribute only affects\nperformance, not correctness.  The default value -1 means files are processed in\norder.\n\nSee also `RestoreSlice`."
}
op {
  name: "RestoreSlice"
  input_arg {
    name: "file_pattern"
    description: "Must have a single element. The pattern of the files from\nwhich we read the tensor."
    type: DT_STRING
  }
  input_arg {
    name: "tensor_name"
    description: "Must have a single element. The name of the tensor to be\nrestored."
    type: DT_STRING
  }
  input_arg {
    name: "shape_and_slice"
    description: "Scalar. The shapes and slice specifications to use when\nrestoring a tensors."
    type: DT_STRING
  }
  output_arg {
    name: "tensor"
    description: "The restored tensor."
    type_attr: "dt"
  }
  attr {
    name: "dt"
    type: "type"
    description: "The type of the tensor to be restored."
  }
  attr {
    name: "preferred_shard"
    type: "int"
    default_value {
      i: -1
    }
    description: "Index of file to open first if multiple files match\n`file_pattern`. See the documentation for `Restore`."
  }
  summary: "Restores a tensor from checkpoint files."
  description: "This is like `Restore` except that restored tensor can be listed as filling\nonly a slice of a larger tensor.  `shape_and_slice` specifies the shape of the\nlarger tensor and the slice that the restored tensor covers.\n\nThe `shape_and_slice` input has the same format as the\nelements of the `shapes_and_slices` input of the `SaveSlices` op."
}
op {
  name: "Reverse"
  input_arg {
    name: "tensor"
    description: "Up to 8-D."
    type_attr: "T"
  }
  input_arg {
    name: "dims"
    description: "1-D. The dimensions to reverse."
    type: DT_BOOL
  }
  output_arg {
    name: "output"
    description: "The same shape as `tensor`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT32
        type: DT_BOOL
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Reverses specific dimensions of a tensor."
  description: "Given a `tensor`, and a `bool` tensor `dims` representing the dimensions\nof `tensor`, this operation reverses each dimension i of `tensor` where\n`dims[i]` is `True`.\n\n`tensor` can have up to 8 dimensions. The number of dimensions\nof `tensor` must equal the number of elements in `dims`. In other words:\n\n`rank(tensor) = size(dims)`\n\nFor example:\n\n```prettyprint\n# tensor \'t\' is [[[[ 0,  1,  2,  3],\n#                  [ 4,  5,  6,  7],\n#                  [ 8,  9, 10, 11]],\n#                 [[12, 13, 14, 15],\n#                  [16, 17, 18, 19],\n#                  [20, 21, 22, 23]]]]\n# tensor \'t\' shape is [1, 2, 3, 4]\n\n# \'dims\' is [False, False, False, True]\nreverse(t, dims) ==> [[[[ 3,  2,  1,  0],\n                        [ 7,  6,  5,  4],\n                        [ 11, 10, 9, 8]],\n                       [[15, 14, 13, 12],\n                        [19, 18, 17, 16],\n                        [23, 22, 21, 20]]]]\n\n# \'dims\' is [False, True, False, False]\nreverse(t, dims) ==> [[[[12, 13, 14, 15],\n                        [16, 17, 18, 19],\n                        [20, 21, 22, 23]\n                       [[ 0,  1,  2,  3],\n                        [ 4,  5,  6,  7],\n                        [ 8,  9, 10, 11]]]]\n\n# \'dims\' is [False, False, True, False]\nreverse(t, dims) ==> [[[[8, 9, 10, 11],\n                        [4, 5, 6, 7],\n                        [0, 1, 2, 3]]\n                       [[20, 21, 22, 23],\n                        [16, 17, 18, 19],\n                        [12, 13, 14, 15]]]]\n```"
}
op {
  name: "ReverseSequence"
  input_arg {
    name: "input"
    description: "The input to reverse."
    type_attr: "T"
  }
  input_arg {
    name: "seq_lengths"
    description: "1-D with length `input.dims(batch_dim)` and\n`max(seq_lengths) < input.dims(seq_dim)`"
    type: DT_INT64
  }
  output_arg {
    name: "output"
    description: "The partially reversed input. It has the same shape as `input`."
    type_attr: "T"
  }
  attr {
    name: "seq_dim"
    type: "int"
    description: "The dimension which is partially reversed."
  }
  attr {
    name: "batch_dim"
    type: "int"
    default_value {
      i: 0
    }
    description: "The dimension along which reversal is performed."
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Reverses variable length slices."
  description: "This op first slices `input` along the dimension `batch_dim`, and for each\nslice `i`, reverses the first `seq_lengths[i]` elements along\nthe dimension `seq_dim`.\n\nThe elements of `seq_lengths` must obey `seq_lengths[i] < input.dims[seq_dim]`,\nand `seq_lengths` must be a vector of length `input.dims[batch_dim]`.\n\nThe output slice `i` along dimension `batch_dim` is then given by input\nslice `i`, with the first `seq_lengths[i]` slices along dimension\n`seq_dim` reversed.\n\nFor example:\n\n```prettyprint\n# Given this:\nbatch_dim = 0\nseq_dim = 1\ninput.dims = (4, 8, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]\noutput[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]\noutput[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]\noutput[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[0, 7:, :, ...] = input[0, 7:, :, ...]\noutput[1, 2:, :, ...] = input[1, 2:, :, ...]\noutput[2, 3:, :, ...] = input[2, 3:, :, ...]\noutput[3, 2:, :, ...] = input[3, 2:, :, ...]\n```\n\nIn contrast, if:\n\n```prettyprint\n# Given this:\nbatch_dim = 2\nseq_dim = 0\ninput.dims = (8, ?, 4, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]\noutput[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]\noutput[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]\noutput[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]\noutput[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]\noutput[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]\noutput[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]\n```"
}
op {
  name: "Rsqrt"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes reciprocal of square root of x element-wise."
  description: "I.e., \\\\(y = 1 / \\sqrt{x}\\\\)."
}
op {
  name: "SampleDistortedBoundingBox"
  input_arg {
    name: "image_size"
    description: "1-D, containing `[height, width, channels]`."
    type_attr: "T"
  }
  input_arg {
    name: "bounding_boxes"
    description: "3-D with shape `[batch, N, 4]` describing the N bounding boxes\nassociated with the image."
    type: DT_FLOAT
  }
  output_arg {
    name: "begin"
    description: "1-D, containing `[offset_height, offset_width, 0]`. Provide as input to\n`tf.slice`."
    type_attr: "T"
  }
  output_arg {
    name: "size"
    description: "1-D, containing `[target_height, target_width, -1]`. Provide as input to\n`tf.slice`."
    type_attr: "T"
  }
  output_arg {
    name: "bboxes"
    description: "3-D with shape `[1, 1, 4]` containing the distorted bounding box.\nProvide as input to `tf.image.draw_bounding_boxes`."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_UINT8
        type: DT_INT8
        type: DT_INT16
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to non-zero, the random number\ngenerator is seeded by the given `seed`.  Otherwise, it is seeded by a random\nseed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "min_object_covered"
    type: "float"
    default_value {
      f: 0.1
    }
    description: "The cropped area of the image must contain at least this\nfraction of any bounding box supplied."
  }
  attr {
    name: "aspect_ratio_range"
    type: "list(float)"
    default_value {
      list {
        f: 0.75
        f: 1.33
      }
    }
    description: "The cropped area of the image must have an aspect ratio =\nwidth / height within this range."
  }
  attr {
    name: "area_range"
    type: "list(float)"
    default_value {
      list {
        f: 0.05
        f: 1
      }
    }
    description: "The cropped area of the image must contain a fraction of the\nsupplied image within in this range."
  }
  attr {
    name: "max_attempts"
    type: "int"
    default_value {
      i: 100
    }
    description: "Number of attempts at generating a cropped region of the image\nof the specified constraints. After `max_attempts` failures, return the entire\nimage."
  }
  attr {
    name: "use_image_if_no_bounding_boxes"
    type: "bool"
    default_value {
      b: false
    }
    description: "Controls behavior if no bounding boxes supplied.\nIf true, assume an implicit bounding box covering the whole input. If false,\nraise an error."
  }
  summary: "Generate a single randomly distorted bounding box for an image."
  description: "Bounding box annotations are often supplied in addition to ground-truth labels\nin image recognition or object localization tasks. A common technique for\ntraining such a system is to randomly distort an image while preserving\nits content, i.e. *data augmentation*. This Op outputs a randomly distorted\nlocalization of an object, i.e. bounding box, given an `image_size`,\n`bounding_boxes` and a series of constraints.\n\nThe output of this Op is a single bounding box that may be used to crop the\noriginal image. The output is returned as 3 tensors: `begin`, `size` and\n`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the\nimage. The latter may be supplied to `tf.image.draw_bounding_box` to visualize\nwhat the bounding box looks like.\n\nBounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example,\n\n    # Generate a single distorted bounding box.\n    begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n        tf.shape(image),\n        bounding_boxes=bounding_boxes)\n\n    # Draw the bounding box in an image summary.\n    image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n                                                  bbox_for_draw)\n    tf.image_summary(\'images_with_box\', image_with_box)\n\n    # Employ the bounding box to distort the image.\n    distorted_image = tf.slice(image, begin, size)\n\nNote that if no bounding box information is available, setting\n`use_image_if_no_bounding_boxes = true` will assume there is a single implicit\nbounding box covering the whole image. If `use_image_if_no_bounding_boxes` is\nfalse and no bounding boxes are supplied, an error is raised."
  is_stateful: true
}
op {
  name: "Save"
  input_arg {
    name: "filename"
    description: "Must have a single element. The name of the file to which we write\nthe tensor."
    type: DT_STRING
  }
  input_arg {
    name: "tensor_names"
    description: "Shape `[N]`. The names of the tensors to be saved."
    type: DT_STRING
  }
  input_arg {
    name: "data"
    description: "`N` tensors to save."
    type_list_attr: "T"
  }
  attr {
    name: "T"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  summary: "Saves the input tensors to disk."
  description: "The size of `tensor_names` must match the number of tensors in `data`. `data[i]`\nis written to `filename` with name `tensor_names[i]`.\n\nSee also `SaveSlices`."
}
op {
  name: "SaveSlices"
  input_arg {
    name: "filename"
    description: "Must have a single element. The name of the file to which we write the\ntensor."
    type: DT_STRING
  }
  input_arg {
    name: "tensor_names"
    description: "Shape `[N]`. The names of the tensors to be saved."
    type: DT_STRING
  }
  input_arg {
    name: "shapes_and_slices"
    description: "Shape `[N]`.  The shapes and slice specifications to use when\nsaving the tensors."
    type: DT_STRING
  }
  input_arg {
    name: "data"
    description: "`N` tensors to save."
    type_list_attr: "T"
  }
  attr {
    name: "T"
    type: "list(type)"
    has_minimum: true
    minimum: 1
  }
  summary: "Saves input tensors slices to disk."
  description: "This is like `Save` except that tensors can be listed in the saved file as being\na slice of a larger tensor.  `shapes_and_slices` specifies the shape of the\nlarger tensor and the slice that this tensor covers. `shapes_and_slices` must\nhave as many elements as `tensor_names`.\n\nElements of the `shapes_and_slices` input must either be:\n\n*  The empty string, in which case the corresponding tensor is\n   saved normally.\n*  A string of the form `dim0 dim1 ... dimN-1 slice-spec` where the\n   `dimI` are the dimensions of the larger tensor and `slice-spec`\n   specifies what part is covered by the tensor to save.\n\n`slice-spec` itself is a `:`-separated list: `slice0:slice1:...:sliceN-1`\nwhere each `sliceI` is either:\n\n*  The string `-` meaning that the slice covers all indices of this dimension\n*  `start,length` where `start` and `length` are integers.  In that\n   case the slice covers `length` indices starting at `start`.\n\nSee also `Save`."
}
op {
  name: "ScalarSummary"
  input_arg {
    name: "tags"
    description: "Tags for the summary."
    type: DT_STRING
  }
  input_arg {
    name: "values"
    description: "Same shape as `tags.  Values for the summary."
    type_attr: "T"
  }
  output_arg {
    name: "summary"
    description: "Scalar.  Serialized `Summary` protocol buffer."
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Outputs a `Summary` protocol buffer with scalar values."
  description: "The input `tags` and `values` must have the same shape.  The generated summary\nhas a summary value for each tag-value pair in `tags` and `values`."
}
op {
  name: "ScatterAdd"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "indices"
    description: "A tensor of indices into the first dimension of `ref`."
    type_attr: "Tindices"
  }
  input_arg {
    name: "updates"
    description: "A tensor of updated values to add to `ref`."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Adds sparse updates to a variable reference."
  description: "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] += updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] += updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/ScatterAdd.png\" alt>\n</div>"
}
op {
  name: "ScatterSub"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "indices"
    description: "A tensor of indices into the first dimension of `ref`."
    type_attr: "Tindices"
  }
  input_arg {
    name: "updates"
    description: "A tensor of updated values to subtract from `ref`."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Subtracts sparse updates to a variable reference."
  description: "    # Scalar indices\n    ref[indices, ...] -= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] -= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their (negated) contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/ScatterSub.png\" alt>\n</div>"
}
op {
  name: "ScatterUpdate"
  input_arg {
    name: "ref"
    description: "Should be from a `Variable` node."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "indices"
    description: "A tensor of indices into the first dimension of `ref`."
    type_attr: "Tindices"
  }
  input_arg {
    name: "updates"
    description: "A tensor of updated values to store in `ref`."
    type_attr: "T"
  }
  output_arg {
    name: "output_ref"
    description: "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: true
    }
    description: "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."
  }
  summary: "Applies sparse updates to a variable reference."
  description: "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nIf values in `ref` is to be updated more than once, because there are\nduplicate entires in `indices`, the order at which the updates happen\nfor each value is undefined.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/ScatterUpdate.png\" alt>\n</div>"
}
op {
  name: "SegmentMax"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the maximum along segments of a tensor."
  description: "Read [the section on Segmentation](../../api_docs/python/math_ops.md#segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\max_j(data_j)\\\\) where `max` is over `j` such\nthat `segment_ids[j] == i`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentMax.png\" alt>\n</div>"
}
op {
  name: "SegmentMean"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the mean along segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nComputes a tensor such that\n\\\\(output_i = \\frac{\\sum_j data_j}{N}\\\\) where `mean` is\nover `j` such that `segment_ids[j] == i` and `N` is the total number of\nvalues summed.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentMean.png\" alt>\n</div>"
}
op {
  name: "SegmentMin"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the minimum along segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nComputes a tensor such that\n\\\\(output_i = \\min_j(data_j)\\\\) where `min` is over `j` such\nthat `segment_ids[j] == i`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentMin.png\" alt>\n</div>"
}
op {
  name: "SegmentProd"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the product along segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nComputes a tensor such that\n\\\\(output_i = \\prod_j data_j\\\\) where the product is over `j` such\nthat `segment_ids[j] == i`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentProd.png\" alt>\n</div>"
}
op {
  name: "SegmentSum"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension.  Values should be sorted and can be repeated."
    type_attr: "Tindices"
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the sum along segments of a tensor."
  description: "Read [the section on Segmentation](../../api_docs/python/math_ops.md#segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\sum_j data_j\\\\) where sum is over `j` such\nthat `segment_ids[j] == i`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/SegmentSum.png\" alt>\n</div>"
}
op {
  name: "Select"
  input_arg {
    name: "condition"
    type: DT_BOOL
  }
  input_arg {
    name: "t"
    description: "= A `Tensor` which may have the same shape as `condition`.\nIf `condition` is rank 1, `t` may have higher rank,\nbut its first dimension must match the size of `condition`."
    type_attr: "T"
  }
  input_arg {
    name: "e"
    description: "= A `Tensor` with the same type and shape as `t`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "= A `Tensor` with the same type and shape as `t` and `e`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Selects elements from `t` or `e`, depending on `condition`."
  description: "The `t`, and `e` tensors must all have the same shape,\nand the output will also have that shape.  The `condition` tensor\nmust be a scalar if `t` and `e` are scalars.  If `t` and `e` are vectors\nor higher rank, then `condition` must be either a vector with size\nmatching the first dimension of `t`, or must have the same shape as `t`.\n\nThe `condition` tensor acts as a mask that chooses, based on the value at each\nelement, whether the corresponding element / row in the output should be\ntaken from `t` (if true) or `e` (if false).\n\nIf `condition` is a vector and `t` and `e` are higher rank matrices, then\nit chooses which row (outer dimension) to copy from `t` and `e`.\nIf `condition` has the same shape as `t` and `e`, then it chooses which\nelement to copy from `t` and `e`.\n\nFor example:\n\n```prettyprint\n# \'condition\' tensor is [[True,  False]\n#                        [False, True]]\n# \'t\' is [[1, 2],\n#         [3, 4]]\n# \'e\' is [[5, 6],\n#         [7, 8]]\nselect(condition, t, e) ==> [[1, 6],\n                             [7, 4]]\n\n\n# \'condition\' tensor is [True, False]\n# \'t\' is [[1, 2],\n#         [3, 4]]\n# \'e\' is [[5, 6],\n#         [7, 8]]\nselect(condition, t, e) ==> [[1, 2],\n                             [7, 8]]\n\n```"
}
op {
  name: "SelfAdjointEig"
  input_arg {
    name: "input"
    description: "Shape is `[M, M]`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Shape is `[M+1, M]`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_DOUBLE
        type: DT_FLOAT
      }
    }
  }
  summary: "Calculates the Eigen Decomposition of a square Self-Adjoint matrix."
  description: "Only the lower-triangular part of the input will be used in this case. The\nupper-triangular part will not be read.\n\nThe result is a M+1 x M matrix whose first row is the eigenvalues, and\nsubsequent rows are eigenvectors."
}
op {
  name: "SerializeManySparse"
  input_arg {
    name: "sparse_indices"
    description: "2-D.  The `indices` of the minibatch `SparseTensor`."
    type: DT_INT64
  }
  input_arg {
    name: "sparse_values"
    description: "1-D.  The `values` of the minibatch `SparseTensor`."
    type_attr: "T"
  }
  input_arg {
    name: "sparse_shape"
    description: "1-D.  The `shape` of the minibatch `SparseTensor`."
    type: DT_INT64
  }
  output_arg {
    name: "serialized_sparse"
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` string `Tensor`."
  description: "The `SparseTensor` must have rank `R` greater than 1, and the first dimension\nis treated as the minibatch dimension.  Elements of the `SparseTensor`\nmust be sorted in increasing order of this first dimension.  The serialized\n`SparseTensor` objects going into each row of `serialized_sparse` will have\nrank `R-1`.\n\nThe minibatch size `N` is extracted from `sparse_shape[0]`."
}
op {
  name: "SerializeSparse"
  input_arg {
    name: "sparse_indices"
    description: "2-D.  The `indices` of the `SparseTensor`."
    type: DT_INT64
  }
  input_arg {
    name: "sparse_values"
    description: "1-D.  The `values` of the `SparseTensor`."
    type_attr: "T"
  }
  input_arg {
    name: "sparse_shape"
    description: "1-D.  The `shape` of the `SparseTensor`."
    type: DT_INT64
  }
  output_arg {
    name: "serialized_sparse"
    type: DT_STRING
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Serialize a `SparseTensor` into a string 3-vector (1-D `Tensor`) object."
}
op {
  name: "Shape"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the shape of a tensor."
  description: "This operation returns a 1-D integer tensor representing the shape of `input`.\n\nFor example:\n\n```prettyprint\n# \'t\' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\nshape(t) ==> [2, 2, 3]\n```"
}
op {
  name: "ShapeN"
  input_arg {
    name: "input"
    type_attr: "T"
    number_attr: "N"
  }
  output_arg {
    name: "output"
    type: DT_INT32
    number_attr: "N"
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns shape of tensors."
  description: "This operation returns N 1-D integer tensors representing shape of `input[i]s`."
}
op {
  name: "ShardedFilename"
  input_arg {
    name: "basename"
    type: DT_STRING
  }
  input_arg {
    name: "shard"
    type: DT_INT32
  }
  input_arg {
    name: "num_shards"
    type: DT_INT32
  }
  output_arg {
    name: "filename"
    type: DT_STRING
  }
  summary: "Generate a sharded filename. The filename is printf formatted as"
  description: "   %s-%05d-of-%05d, basename, shard, num_shards."
}
op {
  name: "ShardedFilespec"
  input_arg {
    name: "basename"
    type: DT_STRING
  }
  input_arg {
    name: "num_shards"
    type: DT_INT32
  }
  output_arg {
    name: "filename"
    type: DT_STRING
  }
  summary: "Generate a glob pattern matching all sharded file names."
}
op {
  name: "Sigmoid"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes sigmoid of `x` element-wise."
  description: "Specifically, `y = 1 / (1 + exp(-x))`."
}
op {
  name: "Sign"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_COMPLEX64
      }
    }
  }
  summary: "Returns an element-wise indication of the sign of a number."
  description: "`y = sign(x) = -1` if `x < 0`; 0 if `x == 0`; 1 if `x > 0`.\n\nFor complex numbers, `y = sign(x) = x / |x|` if `x != 0`, otherwise `y = 0`."
}
op {
  name: "Sin"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes sin of x element-wise."
}
op {
  name: "Size"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the size of a tensor."
  description: "This operation returns an integer representing the number of elements in\n`input`.\n\nFor example:\n\n```prettyprint\n# \'t\' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]\nsize(t) ==> 12\n```"
}
op {
  name: "Skipgram"
  output_arg {
    name: "vocab_word"
    description: "A vector of words in the corpus."
    type: DT_STRING
  }
  output_arg {
    name: "vocab_freq"
    description: "Frequencies of words. Sorted in the non-ascending order."
    type: DT_INT32
  }
  output_arg {
    name: "words_per_epoch"
    description: "Number of words per epoch in the data file."
    type: DT_INT64
  }
  output_arg {
    name: "current_epoch"
    description: "The current epoch number."
    type: DT_INT32
  }
  output_arg {
    name: "total_words_processed"
    description: "The total number of words processed so far."
    type: DT_INT64
  }
  output_arg {
    name: "examples"
    description: "A vector of word ids."
    type: DT_INT32
  }
  output_arg {
    name: "labels"
    description: "A vector of word ids."
    type: DT_INT32
  }
  attr {
    name: "filename"
    type: "string"
    description: "The corpus\'s text file name."
  }
  attr {
    name: "batch_size"
    type: "int"
    description: "The size of produced batch."
  }
  attr {
    name: "window_size"
    type: "int"
    default_value {
      i: 5
    }
    description: "The number of words to predict to the left and right of the target."
  }
  attr {
    name: "min_count"
    type: "int"
    default_value {
      i: 5
    }
    description: "The minimum number of word occurrences for it to be included in the\nvocabulary."
  }
  attr {
    name: "subsample"
    type: "float"
    default_value {
      f: 0.001
    }
    description: "Threshold for word occurrence. Words that appear with higher\nfrequency will be randomly down-sampled. Set to 0 to disable."
  }
  summary: "Parses a text file and creates a batch of examples."
  is_stateful: true
}
op {
  name: "Slice"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "begin"
    description: "begin[i] specifies the offset into the \'i\'th dimension of\n\'input\' to slice from."
    type_attr: "Index"
  }
  input_arg {
    name: "size"
    description: "size[i] specifies the number of elements of the \'i\'th dimension\nof \'input\' to slice. If size[i] is -1, all remaining elements in dimension\ni are included in the slice (i.e. this is equivalent to setting\nsize[i] = input.dim_size(i) - begin[i])."
    type_attr: "Index"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "Index"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Return a slice from \'input\'."
  description: "The output tensor is a tensor with dimensions described by \'size\'\nwhose values are extracted from \'input\' starting at the offsets in\n\'begin\'.\n\n*Requirements*:\n  0 <= begin[i] <= begin[i] + size[i] <= Di  for i in [0, n)"
}
op {
  name: "Softmax"
  input_arg {
    name: "logits"
    description: "2-D with shape `[batch_size, num_classes]`."
    type_attr: "T"
  }
  output_arg {
    name: "softmax"
    description: "Same shape as `logits`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes softmax activations."
  description: "For each batch `i` and class `j` we have\n\n    softmax[i, j] = exp(logits[i, j]) / sum(exp(logits[i]))"
}
op {
  name: "SoftmaxCrossEntropyWithLogits"
  input_arg {
    name: "features"
    description: "batch_size x num_classes matrix"
    type_attr: "T"
  }
  input_arg {
    name: "labels"
    description: "batch_size x num_classes matrix\nThe caller must ensure that each batch of labels represents a valid\nprobability distribution."
    type_attr: "T"
  }
  output_arg {
    name: "loss"
    description: "Per example loss (batch_size vector)."
    type_attr: "T"
  }
  output_arg {
    name: "backprop"
    description: "backpropagated gradients (batch_size x num_classes matrix)."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes softmax cross entropy cost and gradients to backpropagate."
  description: "Inputs are the logits, not probabilities."
}
op {
  name: "Softplus"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes softplus: `log(exp(features) + 1)`."
}
op {
  name: "SoftplusGrad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding softplus operation."
    type_attr: "T"
  }
  input_arg {
    name: "features"
    description: "The features passed as input to the corresponding softplus operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients: `gradients / (1 + exp(-features))`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes softplus gradients for a softplus operation."
}
op {
  name: "Softsign"
  input_arg {
    name: "features"
    type_attr: "T"
  }
  output_arg {
    name: "activations"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes softsign: `features / (abs(features) + 1)`."
}
op {
  name: "SoftsignGrad"
  input_arg {
    name: "gradients"
    description: "The backpropagated gradients to the corresponding softsign operation."
    type_attr: "T"
  }
  input_arg {
    name: "features"
    description: "The features passed as input to the corresponding softsign operation."
    type_attr: "T"
  }
  output_arg {
    name: "backprops"
    description: "The gradients: `gradients / (1 + abs(-features)) ** 2`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes softsign gradients for a softsign operation."
}
op {
  name: "SpaceToBatch"
  input_arg {
    name: "input"
    description: "4-D with shape `[batch, height, width, depth]`."
    type_attr: "T"
  }
  input_arg {
    name: "paddings"
    description: "2-D tensor of non-negative integers with shape `[2, 2]`. It specifies\n  the padding of the input with zeros across the spatial dimensions as follows:\n\n      paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]\n\n  The effective spatial dimensions of the zero-padded input tensor will be:\n\n      height_pad = pad_top + height + pad_bottom\n      width_pad = pad_left + width + pad_right\n\nThe attr `block_size` must be greater than one. It indicates the block size.\n\n  * Non-overlapping blocks of size `block_size x block size` in the height and\n    width dimensions are rearranged into the batch dimension at each location.\n  * The batch of the output tensor is `batch * block_size * block_size`.\n  * Both height_pad and width_pad must be divisible by block_size.\n\nThe shape of the output will be:\n\n    [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n     depth]"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "block_size"
    type: "int"
  }
  summary: "SpaceToBatch for 4-D tensors of type T."
  description: "Zero-pads and then rearranges (permutes) blocks of spatial data into batch.\nMore specifically, this op outputs a copy of the input tensor where values from\nthe `height` and `width` dimensions are moved to the `batch` dimension. After\nthe zero-padding, both `height` and `width` of the input must be divisible by the\nblock size."
}
op {
  name: "SpaceToDepth"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "block_size"
    type: "int"
    description: "The size of the spatial block."
  }
  summary: "SpaceToDepth for tensors of type T."
  description: "Rearranges blocks of spatial data, into depth. More specifically,\nthis op outputs a copy of the input tensor where values from the `height`\nand `width` dimensions are moved to the `depth` dimension.\nThe attr `block_size` indicates the input block size and how the data is moved.\n\n  * Non-overlapping blocks of size `block_size x block size` are rearranged\n    into depth at each location.\n  * The depth of the output tensor is `input_depth * block_size * block_size`.\n  * The input tensor\'s height and width must be divisible by block_size.\n\nThat is, assuming the input is in the shape:\n`[batch, height, width, depth]`,\nthe shape of the output will be:\n`[batch, height/block_size, width/block_size, depth*block_size*block_size]`\n\nThis operation requires that the input tensor be of rank 4, and that\n`block_size` be >=1 and a divisor of both the input `height` and `width`.\n\nThis operation is useful for resizing the activations between convolutions\n(but keeping all data), e.g. instead of pooling. It is also useful for training\npurely convolutional models.\n\nFor example, given this input of shape `[1, 2, 2, 1]`, and block_size of 2:\n\n```prettyprint\nx = [[[[1], [2]],\n      [[3], [4]]]]\n```\n\nThis operation will output a tensor of shape `[1, 1, 1, 4]`:\n\n```prettyprint\n[[[[1, 2, 3, 4]]]]\n```\n\nHere, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,\nthe corresponding output will have a single element (i.e. width and height are\nboth 1) and will have a depth of 4 channels (1 * block_size * block_size).\nThe output element shape is `[1, 1, 4]`.\n\nFor an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.\n\n```prettyprint\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThis operation, for block_size of 2, will return the following tensor of shape\n`[1, 1, 1, 12]`\n\n```prettyprint\n[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n```\n\nSimilarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:\n\n```prettyprint\nx = [[ [1],   [2],  [5],  [6]],\n     [ [3],   [4],  [7],  [8]],\n     [ [9],  [10], [13],  [14]],\n     [ [11], [12], [15],  [16]]]\n```\n\nthe operator will return the following tensor of shape `[1 2 2 4]`:\n\n```prettyprint\nx = [[[[1, 2, 3, 4],\n       [5, 6, 7, 8]],\n      [[9, 10, 11, 12],\n       [13, 14, 15, 16]]]]\n```"
}
op {
  name: "SparseAdd"
  input_arg {
    name: "a_indices"
    description: "2-D.  The `indices` of the first `SparseTensor`, size `[nnz, ndims]` Matrix."
    type: DT_INT64
  }
  input_arg {
    name: "a_values"
    description: "1-D.  The `values` of the first `SparseTensor`, size `[nnz]` Vector."
    type_attr: "T"
  }
  input_arg {
    name: "a_shape"
    description: "1-D.  The `shape` of the first `SparseTensor`, size `[ndims]` Vector."
    type: DT_INT64
  }
  input_arg {
    name: "b_indices"
    description: "2-D.  The `indices` of the second `SparseTensor`, size `[nnz, ndims]` Matrix."
    type: DT_INT64
  }
  input_arg {
    name: "b_values"
    description: "1-D.  The `values` of the second `SparseTensor`, size `[nnz]` Vector."
    type_attr: "T"
  }
  input_arg {
    name: "b_shape"
    description: "1-D.  The `shape` of the second `SparseTensor`, size `[ndims]` Vector."
    type: DT_INT64
  }
  input_arg {
    name: "thresh"
    description: "0-D.  The magnitude threshold that determines if an output value/index\npair takes space."
    type_attr: "Treal"
  }
  output_arg {
    name: "sum_indices"
    type: DT_INT64
  }
  output_arg {
    name: "sum_values"
    type_attr: "T"
  }
  output_arg {
    name: "sum_shape"
    type: DT_INT64
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Treal"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Adds two `SparseTensor` objects to produce another `SparseTensor`."
  description: "The input `SparseTensor` objects\' indices are assumed ordered in standard\nlexicographic order.  If this is not the case, before this step run\n`SparseReorder` to restore index ordering.\n\nBy default, if two values sum to zero at some index, the output `SparseTensor`\nwould still include that particular location in its index, storing a zero in the\ncorresponding value slot.  To override this, callers can specify `thresh`,\nindicating that if the sum has a magnitude strictly smaller than `thresh`, its\ncorresponding value and index would then not be included.  In particular,\n`thresh == 0` (default) means everything is kept and actual thresholding happens\nonly for a positive value.\n\nIn the following shapes, `nnz` is the count after taking `thresh` into account."
}
op {
  name: "SparseAddGrad"
  input_arg {
    name: "backprop_val_grad"
    description: "1-D with shape `[nnz(sum)]`.  The gradient with respect to\nthe non-empty values of the sum."
    type_attr: "T"
  }
  input_arg {
    name: "a_indices"
    description: "2-D.  The `indices` of the `SparseTensor` A, size `[nnz(A), ndims]`."
    type: DT_INT64
  }
  input_arg {
    name: "b_indices"
    description: "2-D.  The `indices` of the `SparseTensor` B, size `[nnz(B), ndims]`."
    type: DT_INT64
  }
  input_arg {
    name: "sum_indices"
    description: "2-D.  The `indices` of the sum `SparseTensor`, size\n`[nnz(sum), ndims]`."
    type: DT_INT64
  }
  output_arg {
    name: "a_val_grad"
    description: "1-D with shape `[nnz(A)]`. The gradient with respect to the\nnon-empty values of A."
    type_attr: "T"
  }
  output_arg {
    name: "b_val_grad"
    description: "1-D with shape `[nnz(B)]`. The gradient with respect to the\nnon-empty values of B."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "The gradient operator for the SparseAdd op."
  description: "The SparseAdd op calculates A + B, where A, B, and the sum are all represented\nas `SparseTensor` objects.  This op takes in the upstream gradient w.r.t.\nnon-empty values of the sum, and outputs the gradients w.r.t. the non-empty\nvalues of A and B."
}
op {
  name: "SparseApplyAdadelta"
  input_arg {
    name: "var"
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum_update"
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    type_attr: "T"
  }
  input_arg {
    name: "rho"
    type_attr: "T"
  }
  input_arg {
    name: "epsilon"
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    type_attr: "Tindices"
  }
  output_arg {
    name: "out"
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
  }
  summary: "var: Should be from a Variable()."
}
op {
  name: "SparseApplyAdagrad"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Learning rate. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A vector of indices into the first dimension of var and accum."
    type_attr: "Tindices"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention."
  }
  summary: "Update relevant entries in \'*var\' and \'*accum\' according to the adagrad scheme."
  description: "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))"
}
op {
  name: "SparseApplyFtrl"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "linear"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A vector of indices into the first dimension of var and accum."
    type_attr: "Tindices"
  }
  input_arg {
    name: "lr"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "l1"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "l2"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "lr_power"
    description: "Scaling factor. Must be a scalar."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention."
  }
  summary: "Update relevant entries in \'*var\' according to the Ftrl-proximal scheme."
  description: "That is for rows we have grad for, we update var, accum and linear as follows:\naccum_new = accum + grad * grad\nlinear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new"
}
op {
  name: "SparseApplyMomentum"
  input_arg {
    name: "var"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "accum"
    description: "Should be from a Variable()."
    type_attr: "T"
    is_ref: true
  }
  input_arg {
    name: "lr"
    description: "Learning rate. Must be a scalar."
    type_attr: "T"
  }
  input_arg {
    name: "grad"
    description: "The gradient."
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A vector of indices into the first dimension of var and accum."
    type_attr: "Tindices"
  }
  input_arg {
    name: "momentum"
    description: "Momentum. Must be a scalar."
    type_attr: "T"
  }
  output_arg {
    name: "out"
    description: "Same as \"var\"."
    type_attr: "T"
    is_ref: true
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  attr {
    name: "use_locking"
    type: "bool"
    default_value {
      b: false
    }
    description: "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention."
  }
  summary: "Update relevant entries in \'*var\' and \'*accum\' according to the momentum scheme."
  description: "That is for rows we have grad for, we update var and accum as follows:\n\naccum = accum * momentum + grad\nvar -= lr * accum"
}
op {
  name: "SparseConcat"
  input_arg {
    name: "indices"
    description: "2-D.  Indices of each input `SparseTensor`."
    type: DT_INT64
    number_attr: "N"
  }
  input_arg {
    name: "values"
    description: "1-D.  Non-empty values of each `SparseTensor`."
    type_attr: "T"
    number_attr: "N"
  }
  input_arg {
    name: "shapes"
    description: "1-D.  Shapes of each `SparseTensor`."
    type: DT_INT64
    number_attr: "N"
  }
  output_arg {
    name: "output_indices"
    description: "2-D.  Indices of the concatenated `SparseTensor`."
    type: DT_INT64
  }
  output_arg {
    name: "output_values"
    description: "1-D.  Non-empty values of the concatenated `SparseTensor`."
    type_attr: "T"
  }
  output_arg {
    name: "output_shape"
    description: "1-D.  Shape of the concatenated `SparseTensor`."
    type: DT_INT64
  }
  attr {
    name: "concat_dim"
    type: "int"
    description: "Dimension to concatenate along."
    has_minimum: true
  }
  attr {
    name: "N"
    type: "int"
    has_minimum: true
    minimum: 2
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Concatenates a list of `SparseTensor` along the specified dimension."
  description: "Concatenation is with respect to the dense versions of these sparse tensors.\nIt is assumed that each input is a `SparseTensor` whose elements are ordered\nalong increasing dimension number.\n\nAll inputs\' shapes must match, except for the concat dimension.  The\n`indices`, `values`, and `shapes` lists must have the same length.\n\nThe output shape is identical to the inputs\', except along the concat\ndimension, where it is the sum of the inputs\' sizes along that dimension.\n\nThe output elements will be resorted to preserve the sort order along\nincreasing dimension number.\n\nThis op runs in `O(M log M)` time, where `M` is the total number of non-empty\nvalues across all inputs. This is due to the need for an internal sort in\norder to concatenate efficiently across an arbitrary dimension.\n\nFor example, if `concat_dim = 1` and the inputs are\n\n    sp_inputs[0]: shape = [2, 3]\n    [0, 2]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    sp_inputs[1]: shape = [2, 4]\n    [0, 1]: \"d\"\n    [0, 2]: \"e\"\n\nthen the output will be\n\n    shape = [2, 7]\n    [0, 2]: \"a\"\n    [0, 4]: \"d\"\n    [0, 5]: \"e\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\nGraphically this is equivalent to doing\n\n    [    a] concat [  d e  ] = [    a   d e  ]\n    [b c  ]        [       ]   [b c          ]"
}
op {
  name: "SparseDenseCwiseDiv"
  input_arg {
    name: "sp_indices"
    description: "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering."
    type: DT_INT64
  }
  input_arg {
    name: "sp_values"
    description: "1-D.  `N` non-empty values corresponding to `sp_indices`."
    type_attr: "T"
  }
  input_arg {
    name: "sp_shape"
    description: "1-D.  Shape of the input SparseTensor."
    type: DT_INT64
  }
  input_arg {
    name: "dense"
    description: "`R`-D.  The dense Tensor operand."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "1-D.  The `N` values that are operated on."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Component-wise divides a SparseTensor by a dense Tensor."
  description: "*Limitation*: this Op only broadcasts the dense side to the sparse side, but not\nthe other direction."
}
op {
  name: "SparseDenseCwiseMul"
  input_arg {
    name: "sp_indices"
    description: "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering."
    type: DT_INT64
  }
  input_arg {
    name: "sp_values"
    description: "1-D.  `N` non-empty values corresponding to `sp_indices`."
    type_attr: "T"
  }
  input_arg {
    name: "sp_shape"
    description: "1-D.  Shape of the input SparseTensor."
    type: DT_INT64
  }
  input_arg {
    name: "dense"
    description: "`R`-D.  The dense Tensor operand."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "1-D.  The `N` values that are operated on."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Component-wise multiplies a SparseTensor by a dense Tensor."
  description: "*Limitation*: this Op only broadcasts the dense side to the sparse side, but not\nthe other direction."
}
op {
  name: "SparseMatMul"
  input_arg {
    name: "a"
    type_attr: "Ta"
  }
  input_arg {
    name: "b"
    type_attr: "Tb"
  }
  output_arg {
    name: "product"
    type: DT_FLOAT
  }
  attr {
    name: "transpose_a"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "transpose_b"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "a_is_sparse"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "b_is_sparse"
    type: "bool"
    default_value {
      b: false
    }
  }
  attr {
    name: "Ta"
    type: "type"
    default_value {
      type: DT_FLOAT
    }
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_BFLOAT16
      }
    }
  }
  attr {
    name: "Tb"
    type: "type"
    default_value {
      type: DT_FLOAT
    }
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_BFLOAT16
      }
    }
  }
  summary: "Multiply matrix \"a\" by matrix \"b\"."
  description: "The inputs must be two-dimensional matrices and the inner dimension of \"a\" must\nmatch the outer dimension of \"b\". This op is optimized for the case where at\nleast one of \"a\" or \"b\" is sparse. The breakeven for using this versus a dense\nmatrix multiply on one platform was 30% zero values in the sparse matrix."
}
op {
  name: "SparseReduceSum"
  input_arg {
    name: "input_indices"
    description: "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering."
    type: DT_INT64
  }
  input_arg {
    name: "input_values"
    description: "1-D.  `N` non-empty values corresponding to `input_indices`."
    type_attr: "T"
  }
  input_arg {
    name: "input_shape"
    description: "1-D.  Shape of the input SparseTensor."
    type: DT_INT64
  }
  input_arg {
    name: "reduction_axes"
    description: "1-D.  Length-`K` vector containing the reduction axes."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "`R-K`-D.  The reduced Tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Computes the sum of elements across dimensions of a SparseTensor."
  description: "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_sum()`.  In particular, this Op also returns a dense `Tensor`\ninstead of a sparse one.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned."
}
op {
  name: "SparseReorder"
  input_arg {
    name: "input_indices"
    description: "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering."
    type: DT_INT64
  }
  input_arg {
    name: "input_values"
    description: "1-D.  `N` non-empty values corresponding to `input_indices`."
    type_attr: "T"
  }
  input_arg {
    name: "input_shape"
    description: "1-D.  Shape of the input SparseTensor."
    type: DT_INT64
  }
  output_arg {
    name: "output_indices"
    description: "2-D.  `N x R` matrix with the same indices as input_indices, but\nin canonical row-major ordering."
    type: DT_INT64
  }
  output_arg {
    name: "output_values"
    description: "1-D.  `N` non-empty values corresponding to `output_indices`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Reorders a SparseTensor into the canonical, row-major ordering."
  description: "Note that by convention, all sparse ops preserve the canonical ordering along\nincreasing dimension number. The only time ordering can be violated is during\nmanual manipulation of the indices and values vectors to add entries.\n\nReordering does not affect the shape of the SparseTensor.\n\nIf the tensor has rank `R` and `N` non-empty values, `input_indices` has\nshape `[N, R]`, input_values has length `N`, and input_shape has length `R`."
}
op {
  name: "SparseSegmentMean"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A 1-D tensor. Has same rank as `segment_ids`."
    type: DT_INT32
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor. Values should be sorted and can be repeated."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes the mean along sparse segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nLike `SegmentMean`, but `segment_ids` can have rank less than `data`\'s first\ndimension, selecting a subset of dimension 0, specified by `indices`."
}
op {
  name: "SparseSegmentMeanGrad"
  input_arg {
    name: "grad"
    description: "gradient propagated to the SparseSegmentMean op."
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "indices passed to the corresponding SparseSegmentMean op."
    type: DT_INT32
  }
  input_arg {
    name: "segment_ids"
    description: "segment_ids passed to the corresponding SparseSegmentMean op."
    type: DT_INT32
  }
  input_arg {
    name: "output_dim0"
    description: "dimension 0 of \"data\" passed to SparseSegmentMean op."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes gradients for SparseSegmentMean."
  description: "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0."
}
op {
  name: "SparseSegmentSqrtN"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A 1-D tensor. Has same rank as `segment_ids`."
    type: DT_INT32
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor. Values should be sorted and can be repeated."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes the sum along sparse segments of a tensor divided by the sqrt of N."
  description: "N is the size of the segment being reduced.\n\nRead [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments."
}
op {
  name: "SparseSegmentSqrtNGrad"
  input_arg {
    name: "grad"
    description: "gradient propagated to the SparseSegmentSqrtN op."
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "indices passed to the corresponding SparseSegmentSqrtN op."
    type: DT_INT32
  }
  input_arg {
    name: "segment_ids"
    description: "segment_ids passed to the corresponding SparseSegmentSqrtN op."
    type: DT_INT32
  }
  input_arg {
    name: "output_dim0"
    description: "dimension 0 of \"data\" passed to SparseSegmentSqrtN op."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  summary: "Computes gradients for SparseSegmentSqrtN."
  description: "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0."
}
op {
  name: "SparseSegmentSum"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "indices"
    description: "A 1-D tensor. Has same rank as `segment_ids`."
    type: DT_INT32
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor. Values should be sorted and can be repeated."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Computes the sum along sparse segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nLike `SegmentSum`, but `segment_ids` can have rank less than `data`\'s first\ndimension, selecting a subset of dimension 0, specified by `indices`.\n\nFor example:\n\n```prettyprint\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n\n# Select two rows, one segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))\n  ==> [[0 0 0 0]]\n\n# Select two rows, two segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))\n  ==> [[ 1  2  3  4]\n       [-1 -2 -3 -4]]\n\n# Select all rows, two segments.\ntf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))\n  ==> [[0 0 0 0]\n       [5 6 7 8]]\n\n# Which is equivalent to:\ntf.segment_sum(c, tf.constant([0, 0, 1]))\n```"
}
op {
  name: "SparseSoftmaxCrossEntropyWithLogits"
  input_arg {
    name: "features"
    description: "batch_size x num_classes matrix"
    type_attr: "T"
  }
  input_arg {
    name: "labels"
    description: "batch_size vector with values in [0, num_classes).\nThis is the label for the given minibatch entry."
    type_attr: "Tlabels"
  }
  output_arg {
    name: "loss"
    description: "Per example loss (batch_size vector)."
    type_attr: "T"
  }
  output_arg {
    name: "backprop"
    description: "backpropagated gradients (batch_size x num_classes matrix)."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "Tlabels"
    type: "type"
    default_value {
      type: DT_INT64
    }
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes softmax cross entropy cost and gradients to backpropagate."
  description: "Unlike `SoftmaxCrossEntropyWithLogits`, this operation does not accept\na matrix of label probabilities, but rather a single label per row\nof features.  This label is considered to have probability 1.0 for the\ngiven row.\n\nInputs are the logits, not probabilities."
}
op {
  name: "SparseSplit"
  input_arg {
    name: "split_dim"
    description: "0-D.  The dimension along which to split.  Must be in the range\n`[0, rank(shape))`."
    type: DT_INT64
  }
  input_arg {
    name: "indices"
    description: "2-D tensor represents the indices of the sparse tensor."
    type: DT_INT64
  }
  input_arg {
    name: "values"
    description: "1-D tensor represents the values of the sparse tensor."
    type_attr: "T"
  }
  input_arg {
    name: "shape"
    description: "1-D. tensor represents the shape of the sparse tensor.\noutput indices: A list of 1-D tensors represents the indices of the output\nsparse tensors."
    type: DT_INT64
  }
  output_arg {
    name: "output_indices"
    type: DT_INT64
    number_attr: "num_split"
  }
  output_arg {
    name: "output_values"
    description: "A list of 1-D tensors represents the values of the output sparse\ntensors."
    type_attr: "T"
    number_attr: "num_split"
  }
  output_arg {
    name: "output_shape"
    description: "A list of 1-D tensors represents the shape of the output sparse\ntensors."
    type: DT_INT64
    number_attr: "num_split"
  }
  attr {
    name: "num_split"
    type: "int"
    description: "The number of ways to split."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Split a `SparseTensor` into `num_split` tensors along one dimension."
  description: "If the `shape[split_dim]` is not an integer multiple of `num_split`. Slices\n`[0 : shape[split_dim] % num_split]` gets one extra dimension.\nFor example, if `split_dim = 1` and `num_split = 2` and the input is\n\n    input_tensor = shape = [2, 7]\n    [    a   d e  ]\n    [b c          ]\n\nGraphically the output tensors are:\n\n    output_tensor[0] = shape = [2, 4]\n    [    a  ]\n    [b c    ]\n\n    output_tensor[1] = shape = [2, 3]\n    [ d e  ]\n    [      ]"
}
op {
  name: "SparseTensorDenseAdd"
  input_arg {
    name: "a_indices"
    description: "2-D.  The `indices` of the `SparseTensor`, with shape `[nnz, ndims]`."
    type_attr: "Tindices"
  }
  input_arg {
    name: "a_values"
    description: "1-D.  The `values` of the `SparseTensor`, with shape `[nnz]`."
    type_attr: "T"
  }
  input_arg {
    name: "a_shape"
    description: "1-D.  The `shape` of the `SparseTensor`, with shape `[ndims]`."
    type_attr: "Tindices"
  }
  input_arg {
    name: "b"
    description: "`ndims`-D Tensor.  With shape `a_shape`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Adds up a `SparseTensor` and a dense `Tensor`, producing a dense `Tensor`."
  description: "This Op does not require `a_indices` be sorted in standard lexicographic order."
}
op {
  name: "SparseTensorDenseMatMul"
  input_arg {
    name: "a_indices"
    description: "2-D.  The `indices` of the `SparseTensor`, size `[nnz, 2]` Matrix."
    type: DT_INT64
  }
  input_arg {
    name: "a_values"
    description: "1-D.  The `values` of the `SparseTensor`, size `[nnz]` Vector."
    type_attr: "T"
  }
  input_arg {
    name: "a_shape"
    description: "1-D.  The `shape` of the `SparseTensor`, size `[2]` Vector."
    type: DT_INT64
  }
  input_arg {
    name: "b"
    description: "2-D.  A dense Matrix."
    type_attr: "T"
  }
  output_arg {
    name: "product"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "adjoint_a"
    type: "bool"
    default_value {
      b: false
    }
    description: "Use the adjoint of A in the matrix multiply.  If A is complex, this\nis transpose(conj(A)).  Otherwise it\'s transpose(A)."
  }
  attr {
    name: "adjoint_b"
    type: "bool"
    default_value {
      b: false
    }
    description: "Use the adjoint of B in the matrix multiply.  If B is complex, this\nis transpose(conj(B)).  Otherwise it\'s transpose(B)."
  }
  summary: "Multiply SparseTensor (of rank 2) \"A\" by dense matrix \"B\"."
  description: "No validity checking is performed on the indices of A.  However, the following\ninput format is recommended for optimal behavior:\n\nif adjoint_a == false:\n  A should be sorted in lexicographically increasing order.  Use SparseReorder\n  if you\'re not sure.\nif adjoint_a == true:\n  A should be sorted in order of increasing dimension 1 (i.e., \"column major\"\n  order instead of \"row major\" order)."
}
op {
  name: "SparseToDense"
  input_arg {
    name: "sparse_indices"
    description: "0-D, 1-D, or 2-D.  `sparse_indices[i]` contains the complete\nindex where `sparse_values[i]` will be placed."
    type_attr: "Tindices"
  }
  input_arg {
    name: "output_shape"
    description: "1-D.  Shape of the dense output tensor."
    type_attr: "Tindices"
  }
  input_arg {
    name: "sparse_values"
    description: "1-D.  Values corresponding to each row of `sparse_indices`,\nor a scalar value to be used for all sparse indices."
    type_attr: "T"
  }
  input_arg {
    name: "default_value"
    description: "Scalar value to set for indices not specified in\n`sparse_indices`."
    type_attr: "T"
  }
  output_arg {
    name: "dense"
    description: "Dense output tensor of shape `output_shape`."
    type_attr: "T"
  }
  attr {
    name: "validate_indices"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true, indices are checked to make sure they are sorted in\nlexicographic order and that there are no repeats."
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Converts a sparse representation into a dense tensor."
  description: "Builds an array `dense` with shape `output_shape` such that\n\n```prettyprint\n# If sparse_indices is scalar\ndense[i] = (i == sparse_indices ? sparse_values : default_value)\n\n# If sparse_indices is a vector, then for each i\ndense[sparse_indices[i]] = sparse_values[i]\n\n# If sparse_indices is an n by d matrix, then for each i in [0, n)\ndense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]\n```\n\nAll other values in `dense` are set to `default_value`.  If `sparse_values` is a\nscalar, all sparse indices are set to this single value.\n\nIndices should be sorted in lexicographic order, and indices must not\ncontain any repeats. If `validate_indices` is true, these properties\nare checked during execution."
}
op {
  name: "Split"
  input_arg {
    name: "split_dim"
    description: "0-D.  The dimension along which to split.  Must be in the range\n`[0, rank(value))`."
    type: DT_INT32
  }
  input_arg {
    name: "value"
    description: "The tensor to split."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "They are identically shaped tensors, whose shape matches that of `value`\nexcept along `split_dim`, where their sizes are\n`values.shape[split_dim] / num_split`."
    type_attr: "T"
    number_attr: "num_split"
  }
  attr {
    name: "num_split"
    type: "int"
    description: "The number of ways to split.  Must evenly divide\n`value.shape[split_dim]`."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Splits a tensor into `num_split` tensors along one dimension."
}
op {
  name: "Sqrt"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes square root of x element-wise."
  description: "I.e., \\\\(y = \\sqrt{x} = x^{1/2}\\\\)."
}
op {
  name: "Square"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes square of x element-wise."
  description: "I.e., \\\\(y = x * x = x^2\\\\)."
}
op {
  name: "SquaredDifference"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Returns (x - y)(x - y) element-wise."
  is_commutative: true
}
op {
  name: "Squeeze"
  input_arg {
    name: "input"
    description: "The `input` to squeeze."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "Contains the same data as `input`, but has one or more dimensions of\nsize 1 removed."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "squeeze_dims"
    type: "list(int)"
    default_value {
      list {
      }
    }
    description: "If specified, only squeezes the dimensions listed. The dimension\nindex starts at 0. It is an error to squeeze a dimension that is not 1."
    has_minimum: true
  }
  summary: "Removes dimensions of size 1 from the shape of a tensor."
  description: "Given a tensor `input`, this operation returns a tensor of the same type with\nall dimensions of size 1 removed. If you don\'t want to remove all size 1\ndimensions, you can remove specific size 1 dimensions by specifying\n`squeeze_dims`.\n\nFor example:\n\n```prettyprint\n# \'t\' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t)) ==> [2, 3]\n```\n\nOr, to remove specific size 1 dimensions:\n\n```prettyprint\n# \'t\' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t, [2, 4])) ==> [1, 2, 3, 1]\n```"
}
op {
  name: "Stack"
  output_arg {
    name: "handle"
    description: "The handle to the stack."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "elem_type"
    type: "type"
    description: "The type of the elements on the stack."
  }
  attr {
    name: "stack_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "Overrides the name used for the temporary stack resource. Default\nvalue is the name of the \'Stack\' op (which is guaranteed unique)."
  }
  summary: "A stack that produces elements in first-in last-out order."
  is_stateful: true
}
op {
  name: "StackClose"
  input_arg {
    name: "handle"
    description: "The handle to a stack."
    type: DT_STRING
    is_ref: true
  }
  summary: "Delete the stack from its resource container."
}
op {
  name: "StackPop"
  input_arg {
    name: "handle"
    description: "The handle to a stack."
    type: DT_STRING
    is_ref: true
  }
  output_arg {
    name: "elem"
    description: "The tensor that is popped from the top of the stack."
    type_attr: "elem_type"
  }
  attr {
    name: "elem_type"
    type: "type"
    description: "The type of the elem that is popped."
  }
  summary: "Pop the element at the top of the stack."
}
op {
  name: "StackPush"
  input_arg {
    name: "handle"
    description: "The handle to a stack."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "elem"
    description: "The tensor to be pushed onto the stack."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The same tensor as the input \'elem\'."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  attr {
    name: "swap_memory"
    type: "bool"
    default_value {
      b: false
    }
    description: "Swap `elem` to CPU. Default to false."
  }
  summary: "Push an element onto the stack."
}
op {
  name: "StopGradient"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Stops gradient computation."
  description: "When executed in a graph, this op outputs its input tensor as-is.\n\nWhen building ops to compute gradients, this op prevents the contribution of\nits inputs to be taken into account.  Normally, the gradient generator adds ops\nto a graph to compute the derivatives of a specified \'loss\' by recursively\nfinding out inputs that contributed to its computation.  If you insert this op\nin the graph it inputs are masked from the gradient generator.  They are not\ntaken into account for computing gradients.\n\nThis is useful any time you want to compute a value with TensorFlow but need\nto pretend that the value was a constant. Some examples include:\n\n*  The *EM* algorithm where the *M-step* should not involve backpropagation\n   through the output of the *E-step*.\n*  Contrastive divergence training of Boltzmann machines where, when\n   differentiating the energy function, the training must not backpropagate\n   through the graph that generated the samples from the model.\n*  Adversarial training, where no backprop should happen through the adversarial\n   example generation process."
}
op {
  name: "StringToHashBucket"
  input_arg {
    name: "string_tensor"
    type: DT_STRING
  }
  output_arg {
    name: "output"
    description: "A Tensor of the same shape as the input `string_tensor`."
    type: DT_INT64
  }
  attr {
    name: "num_buckets"
    type: "int"
    description: "The number of buckets."
    has_minimum: true
    minimum: 1
  }
  summary: "Converts each string in the input Tensor to its hash mod by a number of buckets."
  description: "The hash function is deterministic on the content of the string within the\nprocess.\n\nNote that the hash function may change from time to time."
}
op {
  name: "StringToNumber"
  input_arg {
    name: "string_tensor"
    type: DT_STRING
  }
  output_arg {
    name: "output"
    description: "A Tensor of the same shape as the input `string_tensor`."
    type_attr: "out_type"
  }
  attr {
    name: "out_type"
    type: "type"
    default_value {
      type: DT_FLOAT
    }
    description: "The numeric type to interpret each string in string_tensor as."
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_INT32
      }
    }
  }
  summary: "Converts each string in the input Tensor to the specified numeric type."
  description: "(Note that int32 overflow results in an error while float overflow\nresults in a rounded value.)"
}
op {
  name: "Sub"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "y"
    type_attr: "T"
  }
  output_arg {
    name: "z"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Returns x - y element-wise."
}
op {
  name: "Sum"
  input_arg {
    name: "input"
    description: "The tensor to reduce."
    type_attr: "T"
  }
  input_arg {
    name: "reduction_indices"
    description: "The dimensions to reduce."
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "The reduced tensor."
    type_attr: "T"
  }
  attr {
    name: "keep_dims"
    type: "bool"
    default_value {
      b: false
    }
    description: "If true, retain reduced dimensions with length 1."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT64
        type: DT_INT32
        type: DT_UINT8
        type: DT_UINT16
        type: DT_INT16
        type: DT_INT8
        type: DT_COMPLEX64
        type: DT_COMPLEX128
        type: DT_QINT8
        type: DT_QUINT8
        type: DT_QINT32
        type: DT_HALF
      }
    }
  }
  summary: "Computes the sum of elements across dimensions of a tensor."
  description: "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1."
}
op {
  name: "Switch"
  input_arg {
    name: "data"
    description: "The tensor to be forwarded to the appropriate output."
    type_attr: "T"
  }
  input_arg {
    name: "pred"
    description: "A scalar that specifies which output port will receive data."
    type: DT_BOOL
  }
  output_arg {
    name: "output_false"
    description: "If `pred` is false, data will be forwarded to this output."
    type_attr: "T"
  }
  output_arg {
    name: "output_true"
    description: "If `pred` is true, data will be forwarded to this output."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Forwards `data` to the output port determined by `pred`."
  description: "If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `RefSwitch` and `Merge`."
}
op {
  name: "SymbolicGradient"
  input_arg {
    name: "input"
    description: "a list of input tensors of size N + M;"
    type_list_attr: "Tin"
  }
  output_arg {
    name: "output"
    description: "a list of output tensors of size N;"
    type_list_attr: "Tout"
  }
  attr {
    name: "Tin"
    type: "list(type)"
    description: "the type list for the input list."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "Tout"
    type: "list(type)"
    description: "the type list for the input list."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "f"
    type: "func"
    description: "The function we want to compute the gradient for.\n\nThe function \'f\' must be a numerical function which takes N inputs and\nproduces M outputs. Its gradient function \'g\', which is computed by\nthis SymbolicGradient op is a function taking N + M inputs and\nproduces N outputs.\n\nI.e. if we have\n   (y1, y2, ..., y_M) = f(x1, x2, ..., x_N),\nthen, g is\n   (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N,\n                                     dL/dy1, dL/dy2, ..., dL/dy_M),\n\nwhere L is a scalar-value function of (x1, x2, ..., xN) (e.g., the\nloss function). dL/dx_i is the partial derivative of L with respect\nto x_i.\n\n(Needs some math expert to say the comment above better.)"
  }
  summary: "Computes the gradient function for function f via backpropagation."
}
op {
  name: "TFRecordReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs the records from a TensorFlow Records file."
  is_stateful: true
}
op {
  name: "Tanh"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_COMPLEX64
        type: DT_INT64
      }
    }
  }
  summary: "Computes hyperbolic tangent of `x` element-wise."
}
op {
  name: "TemporaryVariable"
  output_arg {
    name: "ref"
    description: "A reference to the variable tensor."
    type_attr: "dtype"
    is_ref: true
  }
  attr {
    name: "shape"
    type: "shape"
    description: "The shape of the variable tensor."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of elements in the variable tensor."
  }
  attr {
    name: "var_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "Overrides the name used for the temporary variable resource. Default\nvalue is the name of the \'TemporaryVariable\' op (which is guaranteed unique)."
  }
  summary: "Returns a tensor that may be mutated, but only persists within a single step."
  description: "This is an experimental op for internal use only and it is possible to use this\nop in unsafe ways.  DO NOT USE unless you fully understand the risks.\n\nIt is the caller\'s responsibility to ensure that \'ref\' is eventually passed to a\nmatching \'DestroyTemporaryVariable\' op after all other uses have completed.\n\nOutputs a ref to the tensor state so it may be read or modified.\n\n  E.g.\n      var = state_ops._temporary_variable([1, 2], types.float_)\n      var_name = var.op.name\n      var = state_ops.assign(var, [[4.0, 5.0]])\n      var = state_ops.assign_add(var, [[6.0, 7.0]])\n      final = state_ops._destroy_temporary_variable(var, var_name=var_name)"
  is_stateful: true
}
op {
  name: "TensorArray"
  input_arg {
    name: "size"
    description: "The size of the array."
    type: DT_INT32
  }
  output_arg {
    name: "handle"
    description: "The handle to the TensorArray."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the elements on the tensor_array."
  }
  attr {
    name: "dynamic_size"
    type: "bool"
    default_value {
      b: false
    }
    description: "A boolean that determines whether writes to the TensorArray\nare allowed to grow the size.  By default, this is not allowed."
  }
  attr {
    name: "clear_after_read"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true (default), Tensors in the TensorArray are cleared\nafter being read.  This disables multiple read semantics but allows early\nrelease of memory."
  }
  attr {
    name: "tensor_array_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "Overrides the name used for the temporary tensor_array\nresource. Default value is the name of the \'TensorArray\' op (which\nis guaranteed unique)."
  }
  summary: "An array of Tensors of given size, with data written via Write and read"
  description: "via Read or Pack."
  is_stateful: true
}
op {
  name: "TensorArrayClose"
  input_arg {
    name: "handle"
    description: "The handle to a TensorArray (output of TensorArray or TensorArrayGrad)."
    type: DT_STRING
    is_ref: true
  }
  summary: "Delete the TensorArray from its resource container.  This enables"
  description: "the user to close and release the resource in the middle of a step/run."
}
op {
  name: "TensorArrayConcat"
  input_arg {
    name: "handle"
    description: "The handle to a TensorArray."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "flow_in"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  output_arg {
    name: "value"
    description: "All of the elements in the TensorArray, concatenated along the first\naxis."
    type_attr: "dtype"
  }
  output_arg {
    name: "lengths"
    description: "A vector of the row sizes of the original T elements in the\nvalue output.  In the example above, this would be the values:\n`(n1, n2, ..., n(T-1))`."
    type: DT_INT64
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the elem that is returned."
  }
  summary: "Concat the elements from the TensorArray into value `value`."
  description: "Takes `T` elements of shapes\n\n  ```\n  (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)\n  ```\n\nand concatenates them into a Tensor of shape:\n\n  ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```\n\nAll elements must have the same shape (excepting the first dimension)."
}
op {
  name: "TensorArrayGrad"
  input_arg {
    name: "handle"
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "flow_in"
    type: DT_FLOAT
  }
  output_arg {
    name: "grad_handle"
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "source"
    type: "string"
  }
  summary: "Creates a TensorArray for storing the gradients of values in the given handle."
  description: "If the given TensorArray gradient already exists, returns a reference to it.\n\nLocks the size of the original TensorArray by disabling its dynamic size flag.\n\n**A note about the input flow_in:**\n\nThe handle flow_in forces the execution of the gradient lookup to occur\nonly after certain other operations have occurred.  For example, when\nthe forward TensorArray is dynamically sized, writes to this TensorArray\nmay resize the object.  The gradient TensorArray is statically sized based\non the size of the forward TensorArray when this operation executes.\nFurthermore, the size of the forward TensorArray is frozen by this call.\nAs a result, the flow is used to ensure that the call to generate the gradient\nTensorArray only happens after all writes are executed.\n\nIn terms of e.g. python TensorArray sugar wrappers when using dynamically sized"
  is_stateful: true
}
op {
  name: "TensorArrayPack"
  input_arg {
    name: "handle"
    description: "The handle to a TensorArray."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "flow_in"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  output_arg {
    name: "value"
    description: "All of the elements in the TensorArray, concatenated along a new\naxis (the new dimension 0)."
    type_attr: "dtype"
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the elem that is returned."
  }
  summary: "Pack the elements from the TensorArray into output `value`."
  description: "All elements must have the same shape."
}
op {
  name: "TensorArrayRead"
  input_arg {
    name: "handle"
    description: "The handle to a TensorArray."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "index"
    type: DT_INT32
  }
  input_arg {
    name: "flow_in"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  output_arg {
    name: "value"
    description: "The tensor that is read from the TensorArray."
    type_attr: "dtype"
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the elem that is returned."
  }
  summary: "Read an element from the TensorArray into output `value`."
}
op {
  name: "TensorArraySize"
  input_arg {
    name: "handle"
    description: "The handle to a TensorArray (output of TensorArray or TensorArrayGrad)."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "flow_in"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  output_arg {
    name: "size"
    description: "The current size of the TensorArray."
    type: DT_INT32
  }
  summary: "Get the current size of the TensorArray."
}
op {
  name: "TensorArraySplit"
  input_arg {
    name: "handle"
    description: "The handle to a TensorArray."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "value"
    description: "The concatenated tensor to write to the TensorArray."
    type_attr: "T"
  }
  input_arg {
    name: "lengths"
    description: "The vector of lengths, how to split the rows of value into the\nTensorArray."
    type: DT_INT64
  }
  input_arg {
    name: "flow_in"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  output_arg {
    name: "flow_out"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Split the data from the input value into TensorArray elements."
  description: "Assuming that `lengths` takes on values\n\n  ```(n0, n1, ..., n(T-1))```\n\nand that `value` has shape\n\n  ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```,\n\nthis splits values into a TensorArray with T tensors.\n\nTensorArray index t will be the subtensor of values with starting position\n\n  ```(n0 + n1 + ... + n(t-1), 0, 0, ...)```\n\nand having size\n\n  ```nt x d0 x d1 x ...```"
}
op {
  name: "TensorArrayUnpack"
  input_arg {
    name: "handle"
    description: "The handle to a TensorArray."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "value"
    description: "The concatenated tensor to write to the TensorArray."
    type_attr: "T"
  }
  input_arg {
    name: "flow_in"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  output_arg {
    name: "flow_out"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Unpack the data from the input value into TensorArray elements."
}
op {
  name: "TensorArrayWrite"
  input_arg {
    name: "handle"
    description: "The handle to a TensorArray."
    type: DT_STRING
    is_ref: true
  }
  input_arg {
    name: "index"
    description: "The position to write to inside the TensorArray."
    type: DT_INT32
  }
  input_arg {
    name: "value"
    description: "The tensor to write to the TensorArray."
    type_attr: "T"
  }
  input_arg {
    name: "flow_in"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  output_arg {
    name: "flow_out"
    description: "A float scalar that enforces proper chaining of operations."
    type: DT_FLOAT
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Push an element onto the tensor_array."
}
op {
  name: "TextLineReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "skip_header_lines"
    type: "int"
    default_value {
      i: 0
    }
    description: "Number of lines to skip from the beginning of every file."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs the lines of a file delimited by \'\\n\'."
  is_stateful: true
}
op {
  name: "ThreadUnsafeUnigramCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a learned unigram distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Tile"
  input_arg {
    name: "input"
    description: "1-D or higher."
    type_attr: "T"
  }
  input_arg {
    name: "multiples"
    description: "1-D. Length must be the same as the number of dimensions in `input`"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Constructs a tensor by tiling a given tensor."
  description: "This operation creates a new tensor by replicating `input` `multiples` times.\nThe output tensor\'s i\'th dimension has `input.dims(i) * multiples[i]` elements,\nand the values of `input` are replicated `multiples[i]` times along the \'i\'th\ndimension. For example, tiling `[a b c d]` by `[2]` produces\n`[a b c d a b c d]`."
}
op {
  name: "TileGrad"
  input_arg {
    name: "input"
    type_attr: "T"
  }
  input_arg {
    name: "multiples"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns the gradient of `Tile`."
  description: "Since `Tile` takes an input and repeats the input `multiples` times\nalong each dimension, `TileGrad` takes in `multiples` and aggregates\neach repeated tile of `input` into `output`."
  deprecation {
    version: 3
    explanation: "TileGrad has been replaced with reduce_sum"
  }
}
op {
  name: "TopK"
  input_arg {
    name: "input"
    description: "1-D or higher with last dimension at least `k`."
    type_attr: "T"
  }
  output_arg {
    name: "values"
    description: "The `k` largest elements along each last dimensional slice."
    type_attr: "T"
  }
  output_arg {
    name: "indices"
    description: "The indices of `values` within the last dimension of `input`."
    type: DT_INT32
  }
  attr {
    name: "k"
    type: "int"
    description: "Number of top elements to look for along the last dimension (along each\nrow for matrices)."
    has_minimum: true
  }
  attr {
    name: "sorted"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true the resulting `k` elements will be sorted by the values in\ndescending order."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Finds values and indices of the `k` largest elements for the last dimension."
  description: "If the input is a vector (rank-1), finds the `k` largest entries in the vector\nand outputs their values and indices as vectors.  Thus `values[j]` is the\n`j`-th largest entry in `input`, and its index is `indices[j]`.\n\nFor matrices (resp. higher rank input), computes the top `k` entries in each\nrow (resp. vector along the last dimension).  Thus,\n\n    values.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.\n\nIf `k` varies dynamically, use `TopKV2` below."
  deprecation {
    version: 7
    explanation: "Use TopKV2 instead"
  }
}
op {
  name: "TopKV2"
  input_arg {
    name: "input"
    description: "1-D or higher with last dimension at least `k`."
    type_attr: "T"
  }
  input_arg {
    name: "k"
    description: "0-D.  Number of top elements to look for along the last dimension (along each\nrow for matrices)."
    type: DT_INT32
  }
  output_arg {
    name: "values"
    description: "The `k` largest elements along each last dimensional slice."
    type_attr: "T"
  }
  output_arg {
    name: "indices"
    description: "The indices of `values` within the last dimension of `input`."
    type: DT_INT32
  }
  attr {
    name: "sorted"
    type: "bool"
    default_value {
      b: true
    }
    description: "If true the resulting `k` elements will be sorted by the values in\ndescending order."
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  summary: "Finds values and indices of the `k` largest elements for the last dimension."
  description: "If the input is a vector (rank-1), finds the `k` largest entries in the vector\nand outputs their values and indices as vectors.  Thus `values[j]` is the\n`j`-th largest entry in `input`, and its index is `indices[j]`.\n\nFor matrices (resp. higher rank input), computes the top `k` entries in each\nrow (resp. vector along the last dimension).  Thus,\n\n    values.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.\n\nThis is the same as `TopK`, but takes `k` as in input rather than an attr."
}
op {
  name: "Transpose"
  input_arg {
    name: "x"
    type_attr: "T"
  }
  input_arg {
    name: "perm"
    type: DT_INT32
  }
  output_arg {
    name: "y"
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Shuffle dimensions of x according to a permutation."
  description: "The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:\n  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`"
}
op {
  name: "TruncatedNormal"
  input_arg {
    name: "shape"
    description: "The shape of the output tensor."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "A tensor of the specified shape filled with random truncated normal\nvalues."
    type_attr: "dtype"
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "A second seed to avoid seed collision."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of the output."
    allowed_values {
      list {
        type: DT_HALF
        type: DT_FLOAT
        type: DT_DOUBLE
      }
    }
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Outputs random values from a truncated normal distribution."
  description: "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked."
  is_stateful: true
}
op {
  name: "UniformCandidateSampler"
  input_arg {
    name: "true_classes"
    description: "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label."
    type: DT_INT64
  }
  output_arg {
    name: "sampled_candidates"
    description: "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate."
    type: DT_INT64
  }
  output_arg {
    name: "true_expected_count"
    description: "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability."
    type: DT_FLOAT
  }
  output_arg {
    name: "sampled_expected_count"
    description: "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability."
    type: DT_FLOAT
  }
  attr {
    name: "num_true"
    type: "int"
    description: "Number of true labels per context."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "num_sampled"
    type: "int"
    description: "Number of candidates to randomly sample per batch."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "unique"
    type: "bool"
    description: "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities."
  }
  attr {
    name: "range_max"
    type: "int"
    description: "The sampler will sample integers from the interval [0, range_max)."
    has_minimum: true
    minimum: 1
  }
  attr {
    name: "seed"
    type: "int"
    default_value {
      i: 0
    }
    description: "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed."
  }
  attr {
    name: "seed2"
    type: "int"
    default_value {
      i: 0
    }
    description: "An second seed to avoid seed collision."
  }
  summary: "Generates labels for candidate sampling with a uniform distribution."
  description: "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels."
}
op {
  name: "Unique"
  input_arg {
    name: "x"
    description: "1-D."
    type_attr: "T"
  }
  output_arg {
    name: "y"
    description: "1-D."
    type_attr: "T"
  }
  output_arg {
    name: "idx"
    description: "1-D."
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Finds unique elements in a 1-D tensor."
  description: "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`. This operation also returns a\ntensor `idx` the same size as `x` that contains the index of each value of `x`\nin the unique output `y`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```prettyprint\n# tensor \'x\' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx = unique(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\n```"
}
op {
  name: "UniqueWithCounts"
  input_arg {
    name: "x"
    description: "1-D."
    type_attr: "T"
  }
  output_arg {
    name: "y"
    description: "1-D."
    type_attr: "T"
  }
  output_arg {
    name: "idx"
    description: "1-D."
    type: DT_INT32
  }
  output_arg {
    name: "count"
    description: "1-D."
    type: DT_INT32
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Finds unique elements in a 1-D tensor."
  description: "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`. This operation also returns a\ntensor `idx` the same size as `x` that contains the index of each value of `x`\nin the unique output `y`. Finally, it returns a third tensor `count` that\ncontains the count of each element of `y` in `x`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```prettyprint\n# tensor \'x\' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx, count = unique_with_counts(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\ncount ==> [2, 1, 3, 1, 2]\n```"
}
op {
  name: "Unpack"
  input_arg {
    name: "value"
    description: "1-D or higher, with first dimension `num`."
    type_attr: "T"
  }
  output_arg {
    name: "output"
    description: "The list of tensors unpacked from `value`."
    type_attr: "T"
    number_attr: "num"
  }
  attr {
    name: "num"
    type: "int"
    has_minimum: true
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Unpacks the outer dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors."
  description: "Unpacks `num` tensors from `value` by chipping it along the first dimension.\nThe i\'th tensor in `output` is the slice `value[i, ...]`. Each tensor in\n`output` has shape `value.shape[1:]`.\n\nThis is the opposite of `pack`."
}
op {
  name: "UnsortedSegmentSum"
  input_arg {
    name: "data"
    type_attr: "T"
  }
  input_arg {
    name: "segment_ids"
    description: "A 1-D tensor whose rank is equal to the rank of `data`\'s\nfirst dimension."
    type_attr: "Tindices"
  }
  input_arg {
    name: "num_segments"
    type: DT_INT32
  }
  output_arg {
    name: "output"
    description: "Has same shape as data, except for dimension 0 which\nhas size `num_segments`."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
    allowed_values {
      list {
        type: DT_FLOAT
        type: DT_DOUBLE
        type: DT_INT32
        type: DT_INT64
        type: DT_UINT8
        type: DT_INT16
        type: DT_INT8
        type: DT_UINT16
        type: DT_HALF
      }
    }
  }
  attr {
    name: "Tindices"
    type: "type"
    allowed_values {
      list {
        type: DT_INT32
        type: DT_INT64
      }
    }
  }
  summary: "Computes the sum along segments of a tensor."
  description: "Read [the section on\nSegmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation\nof segments.\n\nComputes a tensor such that\n\\\\(output_i = \\sum_j data_j\\\\) where sum is over `j` such\nthat `segment_ids[j] == i`. Unlike `SegmentSum`, `segment_ids`\nneed not be sorted and need not cover all values in the full\n  range of valid values.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\n\n`num_segments` should equal the number of distinct segment IDs.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"../../images/UnsortedSegmentSum.png\" alt>\n</div>"
}
op {
  name: "Variable"
  output_arg {
    name: "ref"
    description: "A reference to the variable tensor."
    type_attr: "dtype"
    is_ref: true
  }
  attr {
    name: "shape"
    type: "shape"
    description: "The shape of the variable tensor."
  }
  attr {
    name: "dtype"
    type: "type"
    description: "The type of elements in the variable tensor."
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this variable is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this variable is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "Holds state in the form of a tensor that persists across steps."
  description: "Outputs a ref to the tensor state so it may be read or modified.\nTODO(zhifengc/mrry): Adds a pointer to a more detail document\nabout sharing states in tensorflow."
  is_stateful: true
}
op {
  name: "Where"
  input_arg {
    name: "input"
    type: DT_BOOL
  }
  output_arg {
    name: "index"
    type: DT_INT64
  }
  summary: "Returns locations of true values in a boolean tensor."
  description: "This operation returns the coordinates of true elements in `input`. The\ncoordinates are returned in a 2-D tensor where the first dimension (rows)\nrepresents the number of true elements, and the second dimension (columns)\nrepresents the coordinates of the true elements. Keep in mind, the shape of\nthe output tensor can vary depending on how many true values there are in\n`input`. Indices are output in row-major order.\n\nFor example:\n\n```prettyprint\n# \'input\' tensor is [[True, False]\n#                    [True, False]]\n# \'input\' has two true values, so output has two coordinates.\n# \'input\' has rank of 2, so coordinates have two indices.\nwhere(input) ==> [[0, 0],\n                  [1, 0]]\n\n# `input` tensor is [[[True, False]\n#                     [True, False]]\n#                    [[False, True]\n#                     [False, True]]\n#                    [[False, False]\n#                     [False, True]]]\n# \'input\' has 5 true values, so output has 5 coordinates.\n# \'input\' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n```"
}
op {
  name: "WholeFileReader"
  output_arg {
    name: "reader_handle"
    description: "The handle to reference the Reader."
    type: DT_STRING
    is_ref: true
  }
  attr {
    name: "container"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used."
  }
  attr {
    name: "shared_name"
    type: "string"
    default_value {
      s: ""
    }
    description: "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead."
  }
  summary: "A Reader that outputs the entire contents of a file as a value."
  description: "To use, enqueue filenames in a Queue.  The output of ReaderRead will\nbe a filename (key) and the contents of that file (value)."
  is_stateful: true
}
op {
  name: "ZerosLike"
  input_arg {
    name: "x"
    description: "a tensor of type T."
    type_attr: "T"
  }
  output_arg {
    name: "y"
    description: "a tensor of the same shape and type as x but filled with zeros."
    type_attr: "T"
  }
  attr {
    name: "T"
    type: "type"
  }
  summary: "Returns a tensor of zeros with the same shape and type as x."
}
