// -*- C++ -*-
//===------------------------ functional ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_FUNCTIONAL
#define _LIBCPP_FUNCTIONAL

/*
    functional synopsis

namespace std
{

template <class Arg, class Result>
struct unary_function
{
    typedef Arg    argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function
{
    typedef Arg1   first_argument_type;
    typedef Arg2   second_argument_type;
    typedef Result result_type;
};

template <class T>
class reference_wrapper
    : public unary_function<T1, R> // if wrapping a unary functor
    : public binary_function<T1, T2, R> // if wraping a binary functor
{
public:
    // types
    typedef T type;
    typedef see below result_type; // Not always defined

    // construct/copy/destroy
    reference_wrapper(T&) noexcept;
    reference_wrapper(T&&) = delete; // do not bind to temps
    reference_wrapper(const reference_wrapper<T>& x) noexcept;

    // assignment
    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;

    // access
    operator T& () const noexcept;
    T& get() const noexcept;

    // invoke
    template <class... ArgTypes>
      typename result_of<T&(ArgTypes&&...)>::type
          operator() (ArgTypes&&...) const;
};

template <class T> reference_wrapper<T> ref(T& t) noexcept;
template <class T> void ref(const T&& t) = delete;
template <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;

template <class T> reference_wrapper<const T> cref(const T& t) noexcept;
template <class T> void cref(const T&& t) = delete;
template <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;

template <class T> // <class T=void> in C++14
struct plus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct minus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct multiplies : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct divides : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct modulus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct negate : unary_function<T, T>
{
    T operator()(const T& x) const;
};

template <class T> // <class T=void> in C++14
struct equal_to : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct not_equal_to : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct greater : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct less : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct greater_equal : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct less_equal : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_and : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_or : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_not : unary_function<T, bool>
{
    bool operator()(const T& x) const;
};

template <class T> // <class T=void> in C++14
struct bit_and : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct bit_or : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct bit_xor : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T=void> // C++14
struct bit_xor : unary_function<T, bool>
{
    bool operator()(const T& x) const;
};

template <class Predicate>
class unary_negate
    : public unary_function<typename Predicate::argument_type, bool>
{
public:
    explicit unary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::argument_type& x) const;
};

template <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);

template <class Predicate>
class binary_negate
    : public binary_function<typename Predicate::first_argument_type,
                             typename Predicate::second_argument_type,
                             bool>
{
public:
    explicit binary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::first_argument_type& x,
                    const typename Predicate::second_argument_type& y) const;
};

template <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);

template<class T> struct is_bind_expression;
template<class T> struct is_placeholder;

template<class Fn, class... BoundArgs>
  unspecified bind(Fn&&, BoundArgs&&...);
template<class R, class Fn, class... BoundArgs>
  unspecified bind(Fn&&, BoundArgs&&...);

namespace placeholders {
  // M is the implementation-defined number of placeholders
  extern unspecified _1;
  extern unspecified _2;
  .
  .
  .
  extern unspecified _Mp;
}

template <class Operation>
class binder1st
    : public unary_function<typename Operation::second_argument_type,
                            typename Operation::result_type>
{
protected:
    Operation                               op;
    typename Operation::first_argument_type value;
public:
    binder1st(const Operation& x, const typename Operation::first_argument_type y);
    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;
    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;
};

template <class Operation, class T>
binder1st<Operation> bind1st(const Operation& op, const T& x);

template <class Operation>
class binder2nd
    : public unary_function<typename Operation::first_argument_type,
                            typename Operation::result_type>
{
protected:
    Operation                                op;
    typename Operation::second_argument_type value;
public:
    binder2nd(const Operation& x, const typename Operation::second_argument_type y);
    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;
    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;
};

template <class Operation, class T>
binder2nd<Operation> bind2nd(const Operation& op, const T& x);

template <class Arg, class Result>
class pointer_to_unary_function : public unary_function<Arg, Result>
{
public:
    explicit pointer_to_unary_function(Result (*f)(Arg));
    Result operator()(Arg x) const;
};

template <class Arg, class Result>
pointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));

template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>
{
public:
    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
    Result operator()(Arg1 x, Arg2 y) const;
};

template <class Arg1, class Arg2, class Result>
pointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));

template<class S, class T>
class mem_fun_t : public unary_function<T*, S>
{
public:
    explicit mem_fun_t(S (T::*p)());
    S operator()(T* p) const;
};

template<class S, class T, class A>
class mem_fun1_t : public binary_function<T*, A, S>
{
public:
    explicit mem_fun1_t(S (T::*p)(A));
    S operator()(T* p, A x) const;
};

template<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());
template<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));

template<class S, class T>
class mem_fun_ref_t : public unary_function<T, S>
{
public:
    explicit mem_fun_ref_t(S (T::*p)());
    S operator()(T& p) const;
};

template<class S, class T, class A>
class mem_fun1_ref_t : public binary_function<T, A, S>
{
public:
    explicit mem_fun1_ref_t(S (T::*p)(A));
    S operator()(T& p, A x) const;
};

template<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());
template<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));

template <class S, class T>
class const_mem_fun_t : public unary_function<const T*, S>
{
public:
    explicit const_mem_fun_t(S (T::*p)() const);
    S operator()(const T* p) const;
};

template <class S, class T, class A>
class const_mem_fun1_t : public binary_function<const T*, A, S>
{
public:
    explicit const_mem_fun1_t(S (T::*p)(A) const);
    S operator()(const T* p, A x) const;
};

template <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);
template <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);

template <class S, class T>
class const_mem_fun_ref_t : public unary_function<T, S>
{
public:
    explicit const_mem_fun_ref_t(S (T::*p)() const);
    S operator()(const T& p) const;
};

template <class S, class T, class A>
class const_mem_fun1_ref_t : public binary_function<T, A, S>
{
public:
    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
    S operator()(const T& p, A x) const;
};

template <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);
template <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);

template<class R, class T> unspecified mem_fn(R T::*);

class bad_function_call
    : public exception
{
};

template<class> class function; // undefined

template<class R, class... ArgTypes>
class function<R(ArgTypes...)>
  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and
                                      // ArgTypes contains T1
  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and
                                      // ArgTypes contains T1 and T2
{
public:
    typedef R result_type;

    // construct/copy/destroy:
    function() noexcept;
    function(nullptr_t) noexcept;
    function(const function&);
    function(function&&) noexcept;
    template<class F>
      function(F);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&) noexcept;
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept;
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, const function&);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, function&&);
    template<class F, Allocator Alloc>
      function(allocator_arg_t, const Alloc&, F);

    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class F>
      function& operator=(F&&);
    template<class F>
      function& operator=(reference_wrapper<F>) noexcept;

    ~function();

    // function modifiers:
    void swap(function&) noexcept;
    template<class F, class Alloc>
      void assign(F&&, const Alloc&);

    // function capacity:
    explicit operator bool() const noexcept;

    // function invocation:
    R operator()(ArgTypes...) const;

    // function target access:
    const std::type_info& target_type() const noexcept;
    template <typename T>       T* target() noexcept;
    template <typename T> const T* target() const noexcept;
};

// Null pointer comparisons:
template <class R, class ... ArgTypes>
  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

template <class R, class ... ArgTypes>
  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

template <class R, class ... ArgTypes>
  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

template <class  R, class ... ArgTypes>
  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

// specialized algorithms:
template <class  R, class ... ArgTypes>
  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;

template <class T> struct hash;

template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long>;
template <> struct hash<unsigned long long>;

template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;

template<class T> struct hash<T*>;

}  // std

POLICY:  For non-variadic implementations, the number of arguments is limited
         to 3.  It is hoped that the need for non-variadic implementations
         will be minimal.

*/

#include <__config>
#include <type_traits>
#include <typeinfo>
#include <exception>
#include <memory>
#include <tuple>

#include <__functional_base>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY plus : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY plus<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY minus : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY minus<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY multiplies : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY multiplies<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY divides : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY divides<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY modulus : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY modulus<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY negate : unary_function<_Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY negate<void>
{
    template <class _Tp>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_Tp&& __x) const
        { return -_VSTD::forward<_Tp>(__x); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY equal_to : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY equal_to<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY not_equal_to : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY not_equal_to<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY greater : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY greater<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


// less in <__functional_base>

#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY greater_equal : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY greater_equal<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY less_equal : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY less_equal<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY logical_and : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY logical_and<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY logical_or : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY logical_or<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY logical_not : unary_function<_Tp, bool>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const _Tp& __x) const
        {return !__x;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY logical_not<void>
{
    template <class _Tp>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_Tp&& __x) const
        { return !_VSTD::forward<_Tp>(__x); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY bit_and : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY bit_and<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY bit_or : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY bit_or<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
#else
template <class _Tp>
#endif
struct _LIBCPP_TYPE_VIS_ONLY bit_xor : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};

#if _LIBCPP_STD_VER > 11
template <>
struct _LIBCPP_TYPE_VIS_ONLY bit_xor<void>
{
    template <class _T1, class _T2>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_T1&& __t, _T2&& __u) const
        { return _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }
    typedef void is_transparent;
};
#endif


#if _LIBCPP_STD_VER > 11
template <class _Tp = void>
struct _LIBCPP_TYPE_VIS_ONLY bit_not : unary_function<_Tp, _Tp>
{
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY bit_not<void>
{
    template <class _Tp>
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    auto operator()(_Tp&& __x) const
        { return ~_VSTD::forward<_Tp>(__x); }
    typedef void is_transparent;
};
#endif

template <class _Predicate>
class _LIBCPP_TYPE_VIS_ONLY unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class _LIBCPP_TYPE_VIS_ONLY binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}

template <class __Operation>
class _LIBCPP_TYPE_VIS_ONLY binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation                               op;
    typename __Operation::first_argument_type value;
public:
    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class _LIBCPP_TYPE_VIS_ONLY binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation                                op;
    typename __Operation::second_argument_type value;
public:
    _LIBCPP_INLINE_VISIBILITY
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        (      typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class _LIBCPP_TYPE_VIS_ONLY pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
inline _LIBCPP_INLINE_VISIBILITY
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class _LIBCPP_TYPE_VIS_ONLY pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
inline _LIBCPP_INLINE_VISIBILITY
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class _LIBCPP_TYPE_VIS_ONLY mem_fun_t : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class _LIBCPP_TYPE_VIS_ONLY mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline _LIBCPP_INLINE_VISIBILITY
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class _LIBCPP_TYPE_VIS_ONLY mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class _LIBCPP_TYPE_VIS_ONLY mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline _LIBCPP_INLINE_VISIBILITY
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class _LIBCPP_TYPE_VIS_ONLY const_mem_fun_t : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline _LIBCPP_INLINE_VISIBILITY
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class _LIBCPP_TYPE_VIS_ONLY const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline _LIBCPP_INLINE_VISIBILITY
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

#ifdef _LIBCPP_HAS_NO_VARIADICS

#include <__functional_03>

#else  // _LIBCPP_HAS_NO_VARIADICS

template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:
    // types
    typedef _Tp type;
private:
    type __f_;

public:
    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) : __f_(__f) {}

    // invoke
    template <class... _ArgTypes>
       _LIBCPP_INLINE_VISIBILITY
       typename __invoke_return<type, _ArgTypes...>::type
          operator() (_ArgTypes&&... __args) const
          {
              return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);
          }
};

template<class _Rp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm)
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}

// bad_function_call

class _LIBCPP_EXCEPTION_ABI bad_function_call
    : public exception
{
};

template<class _Fp> class _LIBCPP_TYPE_VIS_ONLY function; // undefined

namespace __function
{

template<class _Rp, class ..._ArgTypes>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Rp, class ..._ArgTypes>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template<class _Fp> class __base;

template<class _Rp, class ..._ArgTypes>
class __base<_Rp(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    _LIBCPP_INLINE_VISIBILITY __base() {}
    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() _NOEXCEPT = 0;
    virtual void destroy_deallocate() _NOEXCEPT = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;
#ifndef _LIBCPP_NO_RTTI
    virtual const void* target(const type_info&) const _NOEXCEPT = 0;
    virtual const std::type_info& target_type() const _NOEXCEPT = 0;
#endif  // _LIBCPP_NO_RTTI
};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public  __base<_Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    _LIBCPP_INLINE_VISIBILITY
    explicit __func(_Fp&& __f)
        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),
                                    _VSTD::forward_as_tuple()) {}
    _LIBCPP_INLINE_VISIBILITY
    explicit __func(const _Fp& __f, const _Alloc& __a)
        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),
                                    _VSTD::forward_as_tuple(__a)) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit __func(const _Fp& __f, _Alloc&& __a)
        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),
                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit __func(_Fp&& __f, _Alloc&& __a)
        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),
                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}
    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
    virtual void destroy() _NOEXCEPT;
    virtual void destroy_deallocate() _NOEXCEPT;
    virtual _Rp operator()(_ArgTypes&& ... __arg);
#ifndef _LIBCPP_NO_RTTI
    virtual const void* target(const type_info&) const _NOEXCEPT;
    virtual const std::type_info& target_type() const _NOEXCEPT;
#endif  // _LIBCPP_NO_RTTI
};

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
__base<_Rp(_ArgTypes...)>*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
_Rp
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    return __invoke(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);
}

#ifndef _LIBCPP_NO_RTTI

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
const void*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT
{
    return typeid(_Fp);
}

#endif  // _LIBCPP_NO_RTTI

}  // __function

template<class _Rp, class ..._ArgTypes>
class _LIBCPP_TYPE_VIS_ONLY function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
{
    typedef __function::__base<_Rp(_ArgTypes...)> __base;
    typename aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        _LIBCPP_INLINE_VISIBILITY
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class ..._Ap>
        _LIBCPP_INLINE_VISIBILITY
        static bool __not_null(_R2 (*__p)(_Ap...)) {return __p;}
    template <class _R2, class _Cp, class ..._Ap>
        _LIBCPP_INLINE_VISIBILITY
        static bool __not_null(_R2 (_Cp::*__p)(_Ap...)) {return __p;}
    template <class _R2, class _Cp, class ..._Ap>
        _LIBCPP_INLINE_VISIBILITY
        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const) {return __p;}
    template <class _R2, class _Cp, class ..._Ap>
        _LIBCPP_INLINE_VISIBILITY
        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) volatile) {return __p;}
    template <class _R2, class _Cp, class ..._Ap>
        _LIBCPP_INLINE_VISIBILITY
        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const volatile) {return __p;}
    template <class _R2, class ..._Ap>
        _LIBCPP_INLINE_VISIBILITY
        static bool __not_null(const function<_R2(_Ap...)>& __p) {return !!__p;}

    template <class _Fp, bool = !is_same<_Fp, function>::value &&
                                __invokable<_Fp&, _ArgTypes...>::value>
        struct __callable;
    template <class _Fp>
        struct __callable<_Fp, true>
        {
            static const bool value =
                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,
                               _Rp>::value;
        };
    template <class _Fp>
        struct __callable<_Fp, false>
        {
            static const bool value = false;
        };
public:
    typedef _Rp result_type;

    // construct/copy/destroy:
    _LIBCPP_INLINE_VISIBILITY
    function() _NOEXCEPT : __f_(0) {}
    _LIBCPP_INLINE_VISIBILITY
    function(nullptr_t) _NOEXCEPT : __f_(0) {}
    function(const function&);
    function(function&&) _NOEXCEPT;
    template<class _Fp>
      function(_Fp, typename enable_if
                                     <
                                        __callable<_Fp>::value &&
                                        !is_same<_Fp, function>::value
                                      >::type* = 0);

    template<class _Alloc>
      _LIBCPP_INLINE_VISIBILITY
      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}
    template<class _Alloc>
      _LIBCPP_INLINE_VISIBILITY
      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, function&&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<__callable<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(function&&) _NOEXCEPT;
    function& operator=(nullptr_t) _NOEXCEPT;
    template<class _Fp>
      typename enable_if
      <
        __callable<typename decay<_Fp>::type>::value &&
        !is_same<typename remove_reference<_Fp>::type, function>::value,
        function&
      >::type
      operator=(_Fp&&);

    ~function();

    // function modifiers:
    void swap(function&) _NOEXCEPT;
    template<class _Fp, class _Alloc>
      _LIBCPP_INLINE_VISIBILITY
      void assign(_Fp&& __f, const _Alloc& __a)
        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}

    // function capacity:
    _LIBCPP_INLINE_VISIBILITY
        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}

    // deleted overloads close possible hole in the type system
    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
public:
    // function invocation:
    _Rp operator()(_ArgTypes...) const;

#ifndef _LIBCPP_NO_RTTI
    // function target access:
    const std::type_info& target_type() const _NOEXCEPT;
    template <typename _Tp> _Tp* target() _NOEXCEPT;
    template <typename _Tp> const _Tp* target() const _NOEXCEPT;
#endif  // _LIBCPP_NO_RTTI
};

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                     const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}

template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                     function&& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp>
function<_Rp(_ArgTypes...)>::function(_Fp __f,
                                     typename enable_if
                                     <
                                        __callable<_Fp>::value &&
                                        !is_same<_Fp, function>::value
                                     >::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(_VSTD::move(__f));
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp, class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<__callable<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;
        typedef typename __alloc_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind_alloc<_FF>
#else
            rebind_alloc<_FF>::other
#endif
            _Ap;
        _Ap __a(__a0);
        if (sizeof(_FF) <= sizeof(__buf_) && 
            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(_VSTD::move(__f), _Alloc(__a));
        }
        else
        {
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
    return *this;
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp>
typename enable_if
<
    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&
    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,
    function<_Rp(_ArgTypes...)>&
>::type
function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
{
    function(_VSTD::forward<_Fp>(__f)).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class ..._ArgTypes>
void
function<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        _VSTD::swap(__f_, __f.__f_);
}

template<class _Rp, class ..._ArgTypes>
_Rp
function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    if (__f_ == 0)
        throw bad_function_call();
#endif  // _LIBCPP_NO_EXCEPTIONS
    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);
}

#ifndef _LIBCPP_NO_RTTI

template<class _Rp, class ..._ArgTypes>
const std::type_info&
function<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
_Tp*
function<_Rp(_ArgTypes...)>::target() _NOEXCEPT
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
const _Tp*
function<_Rp(_ArgTypes...)>::target() const _NOEXCEPT
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}

#endif  // _LIBCPP_NO_RTTI

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline _LIBCPP_INLINE_VISIBILITY
void
swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT
{return __x.swap(__y);}

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

namespace placeholders
{

template <int _Np> struct __ph {};

_LIBCPP_FUNC_VIS extern __ph<1>   _1;
_LIBCPP_FUNC_VIS extern __ph<2>   _2;
_LIBCPP_FUNC_VIS extern __ph<3>   _3;
_LIBCPP_FUNC_VIS extern __ph<4>   _4;
_LIBCPP_FUNC_VIS extern __ph<5>   _5;
_LIBCPP_FUNC_VIS extern __ph<6>   _6;
_LIBCPP_FUNC_VIS extern __ph<7>   _7;
_LIBCPP_FUNC_VIS extern __ph<8>   _8;
_LIBCPP_FUNC_VIS extern __ph<9>   _9;
_LIBCPP_FUNC_VIS extern __ph<10> _10;

}  // placeholders

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};

template <class _Tp, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline _LIBCPP_INLINE_VISIBILITY
typename __invoke_of<_Ti&, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
{
    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    is_bind_expression<_Ti>::value,
    typename __invoke_of<_Ti&, _Uj...>::type
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return  __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj&)
{
    return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct ____mu_return;

template <bool _Invokable, class _Ti, class ..._Uj>
struct ____mu_return_invokable  // false
{
    typedef __nat type;
};

template <class _Ti, class ..._Uj>
struct ____mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};

template <class _Ti, class ..._Uj>
struct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >
    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public ____mu_return<_Ti,
                           __is_reference_wrapper<_Ti>::value,
                           is_bind_expression<_Ti>::value,
                           0 < is_placeholder<_Ti>::value &&
                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                           _TupleUj>
{
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct _is_valid_bind_return
{
    static const bool value = false;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct _is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct _is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = _is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline _LIBCPP_INLINE_VISIBILITY
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind
    : public __weak_result_type<typename decay<_Fp>::type>
{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS

    _LIBCPP_INLINE_VISIBILITY
    __bind(const __bind& __b)
        : __f_(__b.__f_),
          __bound_args_(__b.__bound_args_) {}

    _LIBCPP_INLINE_VISIBILITY
    __bind& operator=(const __bind& __b)
    {
        __f_ = __b.__f_;
        __bound_args_ = __b.__bound_args_;
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    __bind(__bind&& __b)
        : __f_(_VSTD::move(__b.__f_)),
          __bound_args_(_VSTD::move(__b.__bound_args_)) {}

    _LIBCPP_INLINE_VISIBILITY
    __bind& operator=(__bind&& __b)
    {
        __f_ = _VSTD::move(__b.__f_);
        __bound_args_ = _VSTD::move(__b.__bound_args_);
        return *this;
    }

#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS

    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind>::value
                               >::type>
      _LIBCPP_INLINE_VISIBILITY
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(_VSTD::forward<_Gp>(__f)),
          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            return __apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
        }

    template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return __apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;

#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS

    _LIBCPP_INLINE_VISIBILITY
    __bind_r(const __bind_r& __b)
        : base(_VSTD::forward<const base&>(__b)) {}

    _LIBCPP_INLINE_VISIBILITY
    __bind_r& operator=(const __bind_r& __b)
    {
        base::operator=(_VSTD::forward<const base&>(__b));
        return *this;
    }

    _LIBCPP_INLINE_VISIBILITY
    __bind_r(__bind_r&& __b)
        : base(_VSTD::forward<base>(__b)) {}

    _LIBCPP_INLINE_VISIBILITY
    __bind_r& operator=(__bind_r&& __b)
    {
        base::operator=(_VSTD::forward<base>(__b));
        return *this;
    }

#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS

    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind_r>::value
                               >::type>
      _LIBCPP_INLINE_VISIBILITY
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(_VSTD::forward<_Gp>(__f),
               _VSTD::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if
        <
            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
                           result_type>::value,
            result_type
        >::type
        operator()(_Args&& ...__args)
        {
            return base::operator()(_VSTD::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if
        <
            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
                           result_type>::value,
            result_type
        >::type
        operator()(_Args&& ...__args) const
        {
            return base::operator()(_VSTD::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline _LIBCPP_INLINE_VISIBILITY
__bind<_Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<_Fp, _BoundArgs...> type;
    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline _LIBCPP_INLINE_VISIBILITY
__bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
}

#endif  // _LIBCPP_HAS_NO_VARIADICS

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<bool>
    : public unary_function<bool, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<char>
    : public unary_function<char, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<signed char>
    : public unary_function<signed char, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<short>
    : public unary_function<short, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<int>
    : public unary_function<int, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<long>
    : public unary_function<long, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<float>
    : public __scalar_hash<float>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(float __v) const _NOEXCEPT
    {
        // -0.0 and 0.0 should return same hash
       if (__v == 0)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<double>
    : public __scalar_hash<double>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(double __v) const _NOEXCEPT
    {
        // -0.0 and 0.0 should return same hash
       if (__v == 0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct _LIBCPP_TYPE_VIS_ONLY hash<long double>
    : public __scalar_hash<long double>
{
    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(long double __v) const _NOEXCEPT
    {
        // -0.0 and 0.0 should return same hash
        if (__v == 0)
            return 0;
#if defined(__i386__)
        // Zero out padding bits
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            };
        } __u;
        __u.__a = 0;
        __u.__b = 0;
        __u.__c = 0;
        __u.__d = 0;
        __u.__t = __v;
        return __u.__a ^ __u.__b ^ __u.__c ^ __u.__d;
#elif defined(__x86_64__)
        // Zero out padding bits
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__a = 0;
        __u.__b = 0;
        __u.__t = __v;
        return __u.__a ^ __u.__b;
#else
        return __scalar_hash<long double>::operator()(__v);
#endif
    }
};

#if _LIBCPP_STD_VER > 11
template <class _Tp>
struct _LIBCPP_TYPE_VIS_ONLY hash
    : public unary_function<_Tp, size_t>
{
    static_assert(is_enum<_Tp>::value, "This hash only works for enumeration types");

    _LIBCPP_INLINE_VISIBILITY
    size_t operator()(_Tp __v) const _NOEXCEPT
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>{}(static_cast<type>(__v));
    }
};
#endif

// struct hash<T*> in <memory>

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_FUNCTIONAL
