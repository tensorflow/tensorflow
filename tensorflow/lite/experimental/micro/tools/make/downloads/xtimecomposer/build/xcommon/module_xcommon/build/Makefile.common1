
###########################################################
# COMMON MAKEFILE FOR BUILDING XMOS/XCORE CODE REPOSITORIES
#
# Include this makefile *after* defining the following variables
#
# BASE_DIR = home directory of project (i.e. where the bin/ and src/ directories are)
#
# TARGET = target board/device
#
# SOURCE_DIRS = directories under the src/ directory containing source to compiler
# INCLUDE_DIRS = directories under the src/ direcotry containing header files
#
# LIB_DIRS = directories under the src directory containing libraries
#
# SOURCE_FILES_[binary] = source files specific to a particular binary
#
# EXCLUDE_FILES = list of files to exclude from the build (just the file names - no path needed)
#
# XCC_FLAGS = flags for xcc
#
# XCC_FLAGS_[source_file] = flags for a specific source file (will
#                           overide XCC_FLAGS)
#
# BUILD_NAME = The name of the build. This affects where binaries and libraries
#               are put under bin/ and lib/ and the
#               directory under current directory that the intermediate build
#               files are kept in. . Defaults to $(TARGET).
#
##########################################

# User must use xmake and not make
ifneq ($(basename $(notdir $(lastword $(MAKE)))),xmake)
  $(error You must use `xmake' to build the project and not `$(MAKE)')
endif

USE_LLVM_BITCODE ?= 0
LLVM_LD ?= llvm-ld
LLVM_LLC ?= llc
XDE_ONLINE_URL ?= https://www.xmos.com
ifeq ($(XDE_ONLINE_REG_KEY),)
  XDE_ONLINE_REG_KEY_ARG :=
else
  XDE_ONLINE_REG_KEY_ARG := --reg-key $(XDE_ONLINE_REG_KEY)
endif


ENABLE_STAGED_BUILD ?= 1

JUST_CHECKING_MODULES := 0
ifeq ($(MAKECMDGOALS),check_modules)
  JUST_CHECKING_MODULES := 1
endif

ifeq ($(MAKECMDGOALS),check_modules_msg)
  JUST_CHECKING_MODULES := 1
endif

_COMMON1:=1
export _COMMON1
-include Makefile
_COMMON1:=0
ifeq ($(EXTRA_INCLUDE),)
else
  ifneq ($(CURRENT_LIB),)
    GEN_DIR=.build_$(CURRENT_LIB)/generated
    CURRENT_MAKEFILE :=
  endif
  -include $(EXTRA_INCLUDE)
endif

BASE_DIR ?= .
VERBOSE ?= 0

export VERBOSE

# Find the xcommon build directory
MAKEFILE_LIST1 := $(foreach x, $(MAKEFILE_LIST), $(if $(wildcard $x),$x,$(CHAR1)$x$(CHAR1)))
MAKEFILE_LIST2 := $(subst $(CHAR1),,$(subst $(CHAR1)  $(CHAR1),$(CHAR2),$(MAKEFILE_LIST1)))

XCOMMON_MAKEFILE := $(subst $(CHAR2),\ ,$(filter %Makefile.common1,$(MAKEFILE_LIST2)))

MODULE_XCOMMON_DIR := $(subst /build/../build/..,,$(patsubst %/Makefile.common1,%,$(XCOMMON_MAKEFILE))/..)

XCOMMON_DIR := $(MODULE_XCOMMON_DIR)/..


include $(MODULE_XCOMMON_DIR)/build/Makefile.file_handling

# A generic function for applying multiple suffix substitutions
APPLY_SUFFIX_SUBS = $(if $(strip $1),$(call APPLY_SUFFIX_SUBS,$(filter-out $(firstword $1),$1),$(2:$(firstword $1))),$2)


TARGET:=$(call UNESCAPE_SPACES,$(TARGET))

# Define some generic OS functions
ifeq ($(OS),WINDOWS)
  WINFLAG=1
else
  ifeq ($(findstring Windows, $(OS)),Windows)
    WINFLAG=1
  else
    WINFLAG=0
  endif
endif


CPP_SUFFICES = .cpp .cc .cp .c++ .C .cxx

FIXDEPSUBS = .s.d=.d .xc.d=.d .c.d=.d $(patsubst %,%.d=.d,$(CPP_SUFFICES))

FIXDEP = $(call APPLY_SUFFIX_SUBS,$(FIXDEPSUBS),$1)

# XCP(item,source_location,destination)
#   example, copy local directory foo to bar/foo
#     $(call XCP,foo,.,bar)
# 	unix expansion
#     cp -r ./foo bar
#   windows expansion
#     xcopy /i ./foo bar/foo
ifeq ($(WINFLAG),1)
  JYTHON = (echo source $1>$(TARGET_DIR)/tmp.xta) & (echo exit >> $(TARGET_DIR)/tmp.xta) & (xta source $(TARGET_DIR)/tmp.xta)
  CMDQUOTE="
  ECHOQUOTE="
  CMDLPAREN=(
  CMDRPAREN=)
  PATHSEP=;
  CP=copy $(subst /,\,$(1)) > nul 2>&1
  XCP=xcopy /i $(subst /,\,$(2)/$(1)) $(subst /,\,$(3)/$(1)) > nul 2>&1
  MV=move /Y $(subst /,\,$(1)) > nul 2>&1
  DIFF=FC $(subst /,\,$(1)) > nul 2>&1
  RM=cmd /c if exist "$(subst /,\,$(1))" del /Q /F "$(subst /,\,$(1))"
  RMRF=cmd /c if exist "$(subst /,\,$(1))" RMDIR /S /Q "$(subst /,\,$(1))"
  MKDIR="$(subst /,\,$(subst \ , ,$(MODULE_XCOMMON_DIR)))/build/mkdir.bat" $(subst /, ,$(1)) > nul 2>&1
  NULL=nul
  CAT=type
  OS=WINDOWS
  SHELL=$(windir)\system32\cmd.exe
  TO_OS=$(subst /,\,$(1))
  AUTO_PROJ = $(call TO_OS,$(subst \ , ,$(XCOMMON_DIR))/auto_proj/bin/auto_proj.exe)
  CHANGEDEP = "$(call TO_OS,$(subst \ , ,$(MODULE_XCOMMON_DIR))/build/changedep.exe)" "$(call TO_OS,$(TARGET_DIR)/$(call FIXDEP,$(notdir $1)))" "$1 $(call TO_BUILD_DIR,$(call TO_OBJ, $2)) $(call TO_PCA,$(call TO_BUILD_DIR, $2))" " ../" " ././" " ./../" " ./" > $1 & $(call RM, $(TARGET_DIR)/$(call FIXDEP,$(notdir $1)))
  ESCAPED_GT = ^>
  NOP = rem
else
  # Jython
  # This is a bit of a hack since the jython interpreter is contained in the xta
  JYTHON = echo "source $1">$(TARGET_DIR)/tmp.xta;echo "exit" >> $(TARGET_DIR)/tmp.xta;xta source $(TARGET_DIR)/tmp.xta
  CMDQUOTE='
  ECHOQUOTE=\"
  CMDLPAREN=\(
  CMDRPAREN=\)
  SHELL=bash
  PATHSEP=:
  CP=cp $(1)
  XCP=cp -r $(2)/$(1) $(3)
  MV=mv $(1)
  DIFF=diff -q $(1) &>/dev/null
  RM=rm -f '$(strip $1)'
  RMRF=rm -rf '$(strip $1)'
  MKDIR=mkdir -p '$(strip $1)'
  NULL=/dev/null
  CAT=cat
  TO_OS=$(1)
  AUTO_PROJ = $(call TO_OS,$(subst \ , ,$(XCOMMON_DIR))/auto_proj/bin/auto_proj)
  CHANGEDEP = sed -e 's/\(\/[^.\\]*\) /\1\\ /g' -e 's/\(\/[^.\\]*\) /\1\\ /g' -e 's/\(\/[^.\\]*\) /\1\\ /g' -e 's/\(\/[^.\\]*\) /\1\\ /g' -e 's/\(\/[^.\\]*\) /\1\\ /g'   -e 's/ \.\.\// \.\//g' -e 's/$(subst /,\/,$(abspath ../..)/)/..\/..\//g'  -e 's/.*:/$(subst /,\/,$1 $(call TO_BUILD_DIR,$(call TO_OBJ, $2))) $(subst /,\/,$(call TO_PCA,$(call TO_BUILD_DIR, $2))):/g' '$(TARGET_DIR)/$(call FIXDEP,$(call UNMANGLE_NO_ESCAPE,$(notdir $1)))' > '$(strip $1)';$(call RM, $(TARGET_DIR)/$(call FIXDEP,$(notdir $1)))
  ESCAPED_GT = \>
  NOP = echo -n
endif

.SUFFIXES:


# General utility function

IS_DIR = $(wildcard $(call UNMANGLE,$1)/*)

KEEP_IF_DIR = $(if $(call IS_DIR,$1),$1,)



MAKEFILE_COMMON = $(filter %module_xcommon/build/Makefile.common,$(MAKEFILE_LIST))xs

MAKEFILE_COMMON_DIR = $(patsubst %/build/Makefile.common,%,$(MAKEFILE_COMMON))

PARENT_DIRNAME = $(notdir $(abspath ..))

IS_REPO = $(filter lib_% sc_% sw_% ap_% tool_%,$(notdir $(abspath $(1))))$(wildcard $1/xpd.xml)$(wildcard $1/.git)$(wildcard $1/.xcommon_repo)

AUTO_MODULE_PATH = $(BASE_DIR)/..
WS_PATH := $(BASE_DIR)/..

ifeq ($(if $(call IS_REPO,$(BASE_DIR)/..),1,),1)
  AUTO_MODULE_PATH += $(call WILDCARD,$(BASE_DIR)/../../*)
  WS_PATH := $(BASE_DIR)/../..
else
  ifeq ($(if $(call IS_REPO,$(BASE_DIR)/../..),1,),1)
    AUTO_MODULE_PATH += $(call WILDCARD,$(BASE_DIR)/../../../*)
    WS_PATH := $(BASE_DIR)/../../..
  endif
endif

MANGLE_SYSTEM_PATH_LIST=$(foreach x,$(subst ;, ,$(call MANGLE_NO_DRIVES,$(subst $(PATHSEP),;,$(subst $(QUOTE),,$(subst \,/,$(subst \ , ,$1)))))),$(call MANGLE_DRIVES,$x))

XMOS_MODULE_PATH := $(subst \ , ,$(XMOS_MODULE_PATH))
XMOS_MODULE_PATH := $(subst \,/,$(XMOS_MODULE_PATH))
XMOS_MODULE_PATH := $(subst ",,$(XMOS_MODULE_PATH))
XMOS_MODULE_PATH := $(subst $(PATHSEP),;,$(XMOS_MODULE_PATH))
XMOS_MODULE_PATH := $(call MANGLE_NO_DRIVES,$(XMOS_MODULE_PATH))
XMOS_MODULE_PATH := $(subst ;, ,$(XMOS_MODULE_PATH))
XMOS_MODULE_PATH := $(foreach x,$(XMOS_MODULE_PATH),$(call MANGLE_DRIVES,$x))
CANDIDATE_MODULES_FOR_PATH = $(1) $(foreach x,$(call WILDCARD,$(1)/*),$(call KEEP_IF_DIR,$x)) $(foreach x,$(call WILDCARD,$(1)/*),$(if $(call IS_REPO,$x),$(foreach y,$(call WILDCARD,$x/*),$(call KEEP_IF_DIR,$y)),))

CANDIDATE_MODULES = $(foreach x,$(XMOS_MODULE_PATH),$(call CANDIDATE_MODULES_FOR_PATH,$x))

ifeq ($(XCOMMON_DISABLE_AUTO_MODULE_SEARCH),1)
else
  CANDIDATE_MODULES := $(CANDIDATE_MODULES) $(foreach x,$(AUTO_MODULE_PATH),$(call CANDIDATE_MODULES_FOR_PATH,$x))
endif

CANDIDATE_MODULES := $(foreach x,$(CANDIDATE_MODULES),$(call MANGLE,$(abspath $x)))
CANDIDATE_MODULES := $(sort $(CANDIDATE_MODULES))


NON_EXPLORED_DIRS ?=
NON_EXPLORED_DIRS += %archive %.git %CVS %.svn %export %_build

GET_ALL_SUBDIRS = $1 $(foreach x,$(filter-out $(NON_EXPLORED_DIRS), $(call WILDCARD,$1/*)),$(if $(call IS_DIR, $x), $(call GET_ALL_SUBDIRS, $x),))

EXPAND_DIR = $(patsubst %/.,%,$(subst ./.,.,$(if $(filter %*,$1), $(call GET_ALL_SUBDIRS,$(subst *,.,$(patsubst %/*,%,$1))),$1)))

GET_C_FILES = $(foreach x, $(foreach y,$(1), $(call EXPAND_DIR,$(if $(CURRENT_MODULE_DIR),$(CURRENT_MODULE_DIR)/,)$y)), $(call WILDCARD,$x/*.c))
GET_CPP_FILES = $(foreach x, $(foreach y, $(1), $(call EXPAND_DIR,$(if $(CURRENT_MODULE_DIR),$(CURRENT_MODULE_DIR)/,)$y)), $(foreach suffix,$(CPP_SUFFICES), $(call WILDCARD,$x/*$(suffix))))
GET_XC_FILES = $(foreach x, $(foreach y, $(1), $(call EXPAND_DIR,$(if $(CURRENT_MODULE_DIR),$(CURRENT_MODULE_DIR)/,)$y)), $(call WILDCARD,$x/*.xc))
GET_ASM_FILES = $(foreach x, $(foreach y, $(1), $(call EXPAND_DIR,$(if $(CURRENT_MODULE_DIR),$(CURRENT_MODULE_DIR)/,)$y)), $(call WILDCARD,$x/*.s)) $(foreach x, $(foreach y, $(1), $(call EXPAND_DIR,$(if $(CURRENT_MODULE_DIR),$(CURRENT_MODULE_DIR)/,)$y)), $(call WILDCARD,$x/*.S))
GET_ALL_FILES = $(call GET_C_FILES, $1) $(call GET_XC_FILES, $1) $(call GET_ASM_FILES, $1) $(call GET_CPP_FILES, $1)


SET_XCC_FLAGS = $(foreach z, $(call GET_ALL_FILES, $1), $(if $(XCC_FLAGS_$z),,$(eval XCC_FLAGS_$z = $2)))
SET_XCC_C_FLAGS = $(foreach z, $(call GET_C_FILES, $1), $(if $(XCC_FLAGS_$z),,$(eval XCC_FLAGS_$z = $2)))
SET_XCC_CPP_FLAGS = $(foreach z, $(call GET_CPP_FILES, $1), $(if $(XCC_FLAGS_$z),,$(eval XCC_FLAGS_$z = $2)))
SET_XCC_XC_FLAGS = $(foreach z, $(call GET_XC_FILES, $1), $(if $(XCC_FLAGS_$z),,$(eval XCC_FLAGS_$z = $2)))
SET_XCC_ASM_FLAGS = $(foreach z, $(call GET_ASM_FILES, $1), $(if $(XCC_FLAGS_$z),,$(eval XCC_FLAGS_$z = $2)))

OBJSUBS = .xc=.xc.o .c=.c.o .S=.s.o .s=.s.o $(foreach suffix,$(CPP_SUFFICES),$(suffix)=$(suffix).o)

TO_OBJ = $(call APPLY_SUFFIX_SUBS,$(OBJSUBS),$1)

DEPSUBS = .xc=.xc.d .c=.c.d .S=.s.d $(foreach suffix,$(CPP_SUFFICES),$(suffix)=$(suffix).d)

TO_DEP = $(call APPLY_SUFFIX_SUBS,$(DEPSUBS),$1)

PCASUBS = .xc=.xc.pca.xml .c=.c.pca.xml .S=.S.pca.xml .s=.s.pca.xml $(foreach suffix,$(CPP_SUFFICES),$(suffix)=$(suffix).pca.xml)

TO_PCA = $(call APPLY_SUFFIX_SUBS,$(PCASUBS),$1)

ifeq ($(SRC_PREFIX),1)
  MY_SRCDIR = $(BASE_DIR)/src
else
  MY_SRCDIR = $(BASE_DIR)
endif
ifeq ($(BUILDING_LIBRARY),)
  UM := $(call HANDLE_QUOTES, $(USED_MODULES))
else
  UM := $(call HANDLE_QUOTES, $(LIBRARY_USED_MODULES))
endif

RPAREN = )
LPAREN = (
UM := $(foreach x,$(UM),$(word 1,$(subst $(LPAREN), ,$x)))

FIND_MODULE = $(BASE_DIR)/../$(filter $1%,$(UM))

IS_MODULE_DIR = $(filter %::,$(subst ::,:: ,$1))
GET_MODULE_DIR = $(call FIND_MODULE,$(word 1,$(subst ::, ,$1)))/$(word 2,$(subst ::, ,$1))


REMOVE_OLDSTYLE_MODULE_VERSION = $(if $(findstring .,$1),$(strip $(subst .,,$(firstword $(subst .,. ,$1)))),$1)

MOST_SPECIFIC_MODULE = $(if $(strip $1),$(if $(wildcard $1/$(basename $1)/module_build_info),$1/$(basename $1),$1),$1)

SEARCH_FOR_MODULE = $(strip $(call MOST_SPECIFIC_MODULE, $(strip $(filter %$1,$(CANDIDATE_MODULES)))))


GET_VERSIONED_MODULE_DIR = $(call SEARCH_FOR_MODULE,$(strip $1))
GET_ARCHIVED_MODULE_NAME = $(call REMOVE_OLDSTYLE_MODULE_VERSION,$1)/archive/$(call GET_MODULE_VERSION,$1)
GET_ARCHIVED_MODULE_DIR = $(call SEARCH_FOR_MODULE,$(GET_ARCHIVED_MODULE_NAME))
DIR_EXISTS = $(if $(strip $1),$(strip $(call WILDCARD,$1/*)),)

GET_MODULE_NAME = \
$(if $(call DIR_EXISTS, $(call GET_VERSIONED_MODULE_DIR,$1)),\
$1,\
$(if $(call DIR_EXISTS, $(call GET_ARCHIVED_MODULE_DIR,$1)),\
$(call GET_ARCHIVED_MODULE_NAME,$1),\
$(call REMOVE_OLDSTYLE_MODULE_VERSION,$1)))




SRCDIR = $(if $(call IS_MODULE_DIR,$1),$(call GET_MODULE_DIR,$1),$(MY_SRCDIR)/$1)

TARGET := $(patsubst %.xn,%,$(TARGET))

# Work out the directories and file lists
APP_NAME ?= $(subst .,_,$(notdir $(lastword $(abspath .))))

ifeq ($(strip $(TARGET)$(BUILDING_LIBRARY)),)
  $(error No TARGET specified in application Makefile)
endif

ifeq ($(strip $(APP_NAME)),)
  APP_NAME := $(subst .,_,$(notdir $(lastword $(abspath .))))
endif

ifneq ($(strip $(APP_NAME0)),)
  APP_NAME := $(APP_NAME0)
endif

ifeq ($(BUILDING_LIBRARY),)
  CONFIG ?= Default
else
  CONFIG := $(CURRENT_LIB)
endif

ifeq ($(CONFIG),Default)
  XCC_C_FLAGS ?= $(XCC_FLAGS)
  XCC_CPP_FLAGS ?= $(XCC_FLAGS)
  XCC_XC_FLAGS ?= $(XCC_FLAGS)
  XCC_ASM_FLAGS ?= $(XCC_FLAGS)
  XCC_MAP_FLAGS ?= $(XCC_FLAGS)
else
  ifeq ($(BUILDING_LIBRARY),)
    XCC_C_FLAGS_$(CONFIG) ?= $(XCC_FLAGS_$(CONFIG))
    XCC_CPP_FLAGS_$(CONFIG) ?= $(XCC_FLAGS_$(CONFIG))
    XCC_XC_FLAGS_$(CONFIG) ?= $(XCC_FLAGS_$(CONFIG))
    XCC_ASM_FLAGS_$(CONFIG) ?= $(XCC_FLAGS_$(CONFIG))
    XCC_MAP_FLAGS_$(CONFIG) ?= $(XCC_FLAGS_$(CONFIG))

    XCC_FLAGS     := $(XCC_FLAGS_$(CONFIG))
    XCC_XC_FLAGS  := $(XCC_XC_FLAGS_$(CONFIG))
    XCC_C_FLAGS   := $(XCC_C_FLAGS_$(CONFIG))
    XCC_CPP_FLAGS := $(XCC_CPP_FLAGS_$(CONFIG))
    XCC_ASM_FLAGS := $(XCC_ASM_FLAGS_$(CONFIG))
    XCC_MAP_FLAGS := $(XCC_MAP_FLAGS_$(CONFIG))
  else
    XCC_C_FLAGS ?= $(XCC_FLAGS)
    XCC_CPP_FLAGS ?= $(XCC_FLAGS)
    XCC_XC_FLAGS ?= $(XCC_FLAGS)
    XCC_ASM_FLAGS ?= $(XCC_FLAGS)
    XCC_MAP_FLAGS ?= $(XCC_FLAGS)
  endif
endif

ARCH ?= xs1b

ifeq ($(BUILDING_LIBRARY),1)
  BUILD_NAME := $(CURRENT_LIB)
  WORKING_DIR := .build_$(CURRENT_LIB)_$(ARCH)
  INCLUDE_DIRS := *
  SOURCE_DIRS := *
  LIB_DIRS := *
else
  BUILD_NAME ?= $(CONFIG)
  WORKING_DIR ?= $(if $(filter Default,$(CONFIG)),.build,.build_$(CONFIG))
  INCLUDE_DIRS ?= *
  SOURCE_DIRS ?= *
  LIB_DIRS ?= *
endif

WORKING_DIR := $(WORKING_DIR)

ifeq ($(strip $(WORKING_DIR)),)
  $(error "WORKING_DIR is not set")
endif
TARGET_DIR = $(WORKING_DIR)
FAKE_INC_DIR = $(TARGET_DIR)/fake_inc

BIN_DIR=$(BASE_DIR)/bin/$(if $(filter Default,$(CONFIG)),,$(CONFIG))
LIB_DIR=$(BASE_DIR)/lib/$(ARCH)

ALL_GENERATED_FILES =
GEN_DIRS =

ifeq ($(wildcard app_build_info),)
else
  GEN_DIR := $(TARGET_DIR)/generated
  -include app_build_info
endif

ifeq ($(GENERATED_FILES),)
else
  ALL_GENERATED_FILES := $(ALL_GENERATED_FILES) $(foreach x,$(GENERATED_FILES),$(GEN_DIR)/$x)
  GEN_FILES_MODULE_DIRS := $(GEN_FILES_MODULE_DIRS) $(foreach x,$(GENERATED_FILES),$(GEN_DIR)/$x*****.)
  GEN_DIRS := $(GEN_DIRS) $(GEN_DIR)
endif

XCC_FLAG_CONFIGS = $(strip $(foreach x,$(filter XCC_FLAGS_%,$(.VARIABLES)),$(if $(findstring .,$x),,$(subst XCC_FLAGS_,,$x))))

ALL_CONFIGS = $(sort Default $(XCC_FLAG_CONFIGS) $(strip $(foreach x,$(filter INCLUDE_ONLY_IN_%,$(.VARIABLES)),$(subst INCLUDE_ONLY_IN_,,$x))))

OTHER_CONFIGS = $(filter-out $(CONFIG),$(ALL_CONFIGS))
EXCLUDE_DIRS = $(foreach x, $(OTHER_CONFIGS), $(foreach y,$(INCLUDE_ONLY_IN_$x),$y))

FULL_INCLUDE_DIRS := $(foreach x, $(INCLUDE_DIRS), $(call EXPAND_DIR,$(call SRCDIR,$x)))
FULL_SOURCE_DIRS := $(foreach x, $(SOURCE_DIRS), $(call EXPAND_DIR,$(call SRCDIR,$x)))
FULL_LIB_DIRS := $(foreach x, $(LIB_DIRS), $(call EXPAND_DIR,$(call SRCDIR,$x)))

EXCLUDE_SOURCE_DIRS := $(foreach x, $(EXPORT_SOURCE_DIRS), $(call EXPAND_DIR,$(call SRCDIR,$x)))

XCORE_ONLY_DIRS := $(foreach x, $(XCORE_ONLY_DIRS), $(call EXPAND_DIR,$(call SRCDIR,$x)))

SAME_DIR = $(if $(filter $(abspath $(call UNMANGLE,$1)),$(abspath $(call UNMANGLE,$2))),1,)

FULL_SOURCE_DIRS := $(filter-out $(EXCLUDE_SOURCE_DIRS),$(FULL_SOURCE_DIRS))
FULL_SOURCE_DIRS := $(filter-out $(EXCLUDE_DIRS),$(FULL_SOURCE_DIRS))
FULL_INCLUDE_DIRS := $(filter-out $(EXCLUDE_DIRS),$(FULL_INCLUDE_DIRS))

APP_SOURCE_DIRS := $(FULL_SOURCE_DIRS)

$(foreach x, $(call GET_ALL_FILES, $(FULL_SOURCE_DIRS)), $(if $(XCC_FLAGS_$(notdir $x)), $(eval XCC_FLAGS_$x := $(XCC_FLAGS_$(notdir $x))),))

PREBUILD_MAKEFILES :=

GET_LIBRARY = $(if $(filter $(MODULE_LIBRARIES),$1),$(firstword $(filter $(MODULE_LIBRARIES), $1)),$(firstword $1))

CURRENT_REPO = $(notdir $(abspath ..))
ECLIPSE_PROJECTS :=
EXTERNAL_INCLUDE_DIRS :=
REPO_PATHS :=

ALL_OPTIONAL_HEADERS := $(OPTIONAL_HEADERS)

APP_XSCOPE_SOURCE_FILES := $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.xscope))

DIRS_WITH_BUILD_INFO = $(foreach x, $1, $(if $(strip $(call WILDCARD,$x/module_build_info)),$x,))

ALL_MODULE_DIRS :=


define INCLUDE_MODULE
_LIBRARIES := $$(LIBRARIES)
_EXPORT_SOURCE_DIRS := $$(EXPORT_SOURCE_DIRS)
LIBRARY :=
LIBRARIES :=
SOURCE_DIRS :=
INCLUDE_DIRS :=
VERSION :=
LIB_DIRS :=
CURRENT_MODULE := $$(strip $$(call GET_MODULE_NAME,$1))
CURRENT_MODULE_DIR := $$(if $$(call SEARCH_FOR_MODULE,$$(CURRENT_MODULE)), $$(call SEARCH_FOR_MODULE,$$(CURRENT_MODULE)), not_found)
CURRENT_MODULE_DIR := $$(filter-out %/doc/$$(CURRENT_MODULE),$$(CURRENT_MODULE_DIR))
ifeq ($$(words $$(CURRENT_MODULE_DIR)),1)
else
  ifeq ($$(words $$(filter %/$$(CURRENT_REPO)/$$(CURRENT_MODULE),$$(CURRENT_MODULE_DIR))),1)
    CURRENT_MODULE_DIR := $$(filter %/$$(CURRENT_REPO)/$$(CURRENT_MODULE),$$(CURRENT_MODULE_DIR))
  else
    ifeq ($$(words $$(call DIRS_WITH_BUILD_INFO, $$(CURRENT_MODULE_DIR))), 1)
      CURRENT_MODULE_DIR := $$(strip $$(call DIRS_WITH_BUILD_INFO,$$(CURRENT_MODULE_DIR)))
    else
      $$(error Multiple copies of $$(CURRENT_MODULE) found: $$(CURRENT_MODULE_DIR))
    endif
  endif
endif


MODULE_XCC_FLAGS :=
MODULE_XCC_C_FLAGS :=
MODULE_XCC_XC_FLAGS :=
MODULE_XCC_ASM_FLAGS :=
EXPORT_SOURCE_DIRS :=
DEPENDENT_MODULES :=
XCORE_ONLY_DIRS :=
$$(if $$(call WILDCARD,$$(CURRENT_MODULE_DIR)/*),,$$(error Missing build modules. Cannot continue))
VERSION :=
GEN_DIR := $$(TARGET_DIR)/generated/$$(CURRENT_MODULE)
GENERATED_FILES :=
_CURRENT_MODULE_DIR := $$(CURRENT_MODULE_DIR)
CURRENT_MODULE_DIR := $$(call UNMANGLE,$(CURRENT_MODULE_DIR))
OPTIONAL_HEADERS :=
CURRENT_MODULE_DIR := $$(_CURRENT_MODULE_DIR)
REPO := $$(notdir $$(abspath $$(call UNMANGLE,$$(CURRENT_MODULE_DIR))/..))
REPO := $$(if $$(filter $$(REPO),$$(ECLIPSE_PROJECTS)),,$$(REPO))
REPO := $$(if $$(filter $$(REPO),$$(CURRENT_REPO)),,$$(REPO))
REPO_PATH := $$(patsubst %/$$(CURRENT_MODULE),%,$$(CURRENT_MODULE_DIR))
REPO_PATHS := $$(filter-out $$(REPO_PATH),$$(REPO_PATHS)) $$(REPO_PATH)

ECLIPSE_PROJECTS += $$(REPO)


ALL_MODULE_DIRS := $$(ALL_MODULE_DIRS) $$(CURRENT_MODULE_DIR)


-include $$(call UNMANGLE,$$(CURRENT_MODULE_DIR)/module_build_info)

ifneq ($$(VERSION),)
ACTUAL_VERSION_$$(CURRENT_MODULE) := $$(VERSION)
endif

ALL_OPTIONAL_HEADERS := $$(ALL_OPTIONAL_HEADERS) $$(OPTIONAL_HEADERS)
LIBRARY := $$(if $$(LIBRARIES),$$(call GET_LIBRARY,$$(LIBRARIES)),$$(LIBRARY))
EXCLUDE_LIBS := $$(EXCLUDE_LIBS) $$(filter-out $$(LIBRARY),$$(LIBRARIES))
LIBRARY := $$(if $$(filter 1,$$(EXPORTED)),,$$(LIBRARY))
SOURCE_DIRS := $$(if $$(SOURCE_DIRS), $$(SOURCE_DIRS), *)
INCLUDE_DIRS := $$(if $$(INCLUDE_DIRS), $$(INCLUDE_DIRS), *)
LIB_DIRS := $$(if $$(LIB_DIRS), $$(LIB_DIRS), *)
MODULE_SOURCE_DIRS := $$(foreach x,$$(SOURCE_DIRS), $$(call EXPAND_DIR,$$(CURRENT_MODULE_DIR)/$$x))
MODULE_EXPORT_DIRS := $$(foreach x, $$(EXPORT_SOURCE_DIRS), $$(CURRENT_MODULE_DIR)/$$x)
MODULE_SOURCE_DIRS := $$(if $$(LIBRARY), $$(filter $$(MODULE_EXPORT_DIRS), $$(MODULE_SOURCE_DIRS)), $$(MODULE_SOURCE_DIRS))
MODULE_INCLUDE_DIRS := $$(foreach x,$$(INCLUDE_DIRS), $$(call EXPAND_DIR,$$(CURRENT_MODULE_DIR)/$$x))
MODULE_INCLUDE_DIRS := $$(if $$(LIBRARY), $$(filter $$(MODULE_EXPORT_DIRS), $$(MODULE_INCLUDE_DIRS)), $$(MODULE_INCLUDE_DIRS))
PREBUILD_MAKEFILES := $$(if $$(LIBRARY), $$(if $$(call WILDCARD,$$(CURRENT_MODULE_DIR)/Makefile), $$(CURRENT_MODULE_DIR)/Makefile,),) $$(PREBUILD_MAKEFILES)

MODULE_SOURCE_DIRS := $$(MODULE_SOURCE_DIRS)
MODULE_INCLUDE_DIRS := $$(MODULE_INCLUDE_DIRS)

ifeq ($$(GENERATED_FILES),)
else
  ALL_GENERATED_FILES := $$(ALL_GENERATED_FILES) $$(foreach x,$$(GENERATED_FILES),$$(GEN_DIR)/$$x)
  GEN_DIRS := $$(GEN_DIR) $$(GEN_DIRS)
  GEN_FILES_MODULE_DIRS := $$(GEN_FILES_MODULE_DIRS) $$(foreach x,$$(GENERATED_FILES),$$(GEN_DIR)/$$(x)*****$$(strip $$(CURRENT_MODULE_DIR)))
endif


FULL_SOURCE_DIRS := $(FULL_SOURCE_DIRS) $$(MODULE_SOURCE_DIRS)
FULL_INCLUDE_DIRS := $(FULL_INCLUDE_DIRS) $$(MODULE_INCLUDE_DIRS)
EXTERNAL_INCLUDE_DIRS := $(EXTERNAL_INCLUDE_DIRS) $$(MODULE_INCLUDE_DIRS)

FULL_LIB_DIRS := $(FULL_LIB_DIRS) $$(foreach x,$$(LIB_DIRS), $$(call EXPAND_DIR, $$(CURRENT_MODULE_DIR)/$$x))

$$(foreach x, $$(call GET_ALL_FILES, $$(SOURCE_DIRS)), $$(if $$(XCC_FLAGS_$$(notdir $$x)), $$(eval XCC_FLAGS_$$x := $$(XCC_FLAGS_$$(notdir $$x))),))


$$(if $$(MODULE_XCC_FLAGS), $$(call SET_XCC_FLAGS, $$(SOURCE_DIRS), $$(MODULE_XCC_FLAGS)),)
$$(if $$(MODULE_XCC_C_FLAGS), $$(call SET_XCC_C_FLAGS, $$(SOURCE_DIRS), $$(MODULE_XCC_C_FLAGS)),)


$$(if $$(MODULE_XCC_CPP_FLAGS), $$(call SET_XCC_CPP_FLAGS, $$(SOURCE_DIRS), $$(MODULE_XCC_CPP_FLAGS)),)
$$(if $$(MODULE_XCC_XC_FLAGS), $$(call SET_XCC_XC_FLAGS, $$(SOURCE_DIRS), $$(MODULE_XCC_XC_FLAGS)),)
$$(if $$(MODULE_XCC_ASM_FLAGS), $$(call SET_XCC_ASM_FLAGS, $$(SOURCE_DIRS), $$(MODULE_XCC_ASM_FLAGS)),)

DM := $$(foreach x,$$(DEPENDENT_MODULES),$$(word 1,$$(subst $$(LPAREN), ,$$x)))
NEW_MODULES := $$(strip $$(filter-out $$(UM),$$(DM)))

UM += $$(NEW_MODULES)
USED_MODULES := $$(USED_MODULES) $$(strip $$(filter-out $$(USED_MODULES),$$(DEPENDENT_MODULES)))
TO_PROCESS += $$(NEW_MODULES)

_LIBRARIES := $$(LIBRARIES)
_EXPORT_SOURCE_DIRS := $$(EXPORT_SOURCE_DIRS)
endef

define INCLUDE_MODULES
PROCESS_NOW := $$(strip $$(TO_PROCESS))
TO_PROCESS :=
$$(foreach x,$$(PROCESS_NOW),$$(eval $$(call INCLUDE_MODULE,$$x)))
endef

define INCLUDE_ALL_MODULES
$(if $(TO_PROCESS),$(eval $(call INCLUDE_MODULES)))
$(if $(TO_PROCESS),$(eval $(call INCLUDE_ALL_MODULES)))
endef

TO_PROCESS := $(UM)

ifeq ($(JUST_CHECKING_MODULES),0)
  $(eval $(call INCLUDE_ALL_MODULES))
endif

TBD0 = $(patsubst ./%,td/%,$(patsubst ./../%,td/%,$(patsubst ./../../%,td/%,$1)))

TBD1 = $(if $(filter td%,$(call TBD0,$1)),$(call TBD0,$1),td/$1)

TO_BUILD_DIR0 = $(patsubst td/%,/%,$(call TBD1,$1))

TO_BUILD_DIR1 = $(if $(call IS_RELATIVE,$1),$(call TO_BUILD_DIR0,$1),$1)

GET_BASE_DIR = $(lastword $(subst /, ,$(subst \, ,$1)))

TRY_AND_SHORTEN = $(if $(filter $1%,$2),$(subst $1,$(call GET_BASE_DIR,$1),$2),)

SHORTEN1 = $(strip $(firstword $(foreach x,$(ALL_MODULE_DIRS),$(call TRY_AND_SHORTEN,$x,$1))))

SHORTEN2 = /$(subst module_,_m_,$(subst lib_,_l_,$1))

SHORTEN = $(if $(call SHORTEN1,$1),$(call SHORTEN2,$(call SHORTEN1,$1)),$1)

SHORTEN_DIR = $(call SHORTEN,$(dir $1))$(notdir $1)

TO_BUILD_DIR2 = $(TARGET_DIR)$(call SHORTEN_DIR,$(call TO_BUILD_DIR1,$1))

TO_BUILD_DIR = $(call TO_BUILD_DIR2,$(strip $1))

EXCLUDE_PATTERN = $(foreach x, $(EXCLUDE_FILES), %$x)
EXCLUDE_PATTERN += $(foreach x, $(OTHER_CONFIGS), $(foreach y,$(INCLUDE_ONLY_IN_$x),%$y))

C_SOURCE_FILES := $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.c))
C_SOURCE_FILES := $(filter-out $(EXCLUDE_PATTERN), $(C_SOURCE_FILES))
C_SOURCE_FILES += $(filter %.c, $(ALL_GENERATED_FILES))

C_OBJ_FILES = $(patsubst %.c, %.c.o, $(C_SOURCE_FILES))
C_DEP_FILES = $(foreach x,$(C_SOURCE_FILES:.c=.c.d),$(call TO_BUILD_DIR, $x))
C_PCA_FILES = $(foreach x,$(C_SOURCE_FILES:.c=.c.pca.xml),$(call TO_BUILD_DIR, $x))

CPP_SOURCE_FILES := $(foreach x, $(FULL_SOURCE_DIRS), $(foreach suffix,$(CPP_SUFFICES),$(call WILDCARD,$x/*$(suffix))))
CPP_SOURCE_FILES := $(filter-out $(EXCLUDE_PATTERN), $(CPP_SOURCE_FILES))
CPP_SOURCE_FILES += $(filter %.cc %.cp %.c++ %.C %.cxx %.cpp, $(ALL_GENERATED_FILES))

CPP_OBJ_FILES = $(call APPLY_SUFFIX_SUBS, $(OBJSUBS), $(CPP_SOURCE_FILES))
CPP_DEP_FILES = $(foreach x,$(call APPLY_SUFFIX_SUBS,$(DEPSUBS),$(CPP_SOURCE_FILES)),$(call TO_BUILD_DIR, $x))
CPP_PCA_FILES = $(foreach x,$(call APPLY_SUFFIX_SUBS,$(PCASUBS),$(CPP_SOURCE_FILES)),$(call TO_BUILD_DIR, $x))

XC_SOURCE_FILES := $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.xc))
XC_SOURCE_FILES := $(filter-out $(EXCLUDE_PATTERN), $(XC_SOURCE_FILES))
XC_SOURCE_FILES += $(filter %.xc, $(ALL_GENERATED_FILES))

XC_OBJ_FILES = $(patsubst %.xc, %.xc.o, $(XC_SOURCE_FILES))
XC_DEP_FILES = $(foreach x,$(XC_SOURCE_FILES:.xc=.xc.d),$(call TO_BUILD_DIR, $x))
XC_PCA_FILES = $(foreach x,$(XC_SOURCE_FILES:.xc=.xc.pca.xml),$(call TO_BUILD_DIR, $x))

ASM_SOURCE_FILES := $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.s)) $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.S))
ASM_SOURCE_FILES := $(filter-out $(EXCLUDE_PATTERN), $(ASM_SOURCE_FILES))
ASM_SOURCE_FILES += $(filter %.S, $(ALL_GENERATED_FILES)) $(filter %.s, $(ALL_GENERATED_FILES))

ASM_OBJ_FILES = $(patsubst %.S, %.s.o, $(patsubst %.s, %.o, $(ASM_SOURCE_FILES)))
ASM_DEP_FILES = $(foreach x,$(ASM_SOURCE_FILES:.S=.s.d),$(call TO_BUILD_DIR, $x))
ASM_PCA_FILES = $(foreach x,$(call APPLY_SUFFIX_SUBS,$(PCASUBS),$(ASM_SOURCE_FILES)),$(call TO_BUILD_DIR, $x))

XTA_SOURCE_FILES := $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.xta))
XTA_SOURCE_FILES := $(filter-out $(EXCLUDE_PATTERN), $(XTA_SOURCE_FILES))

XSCOPE_SOURCE_FILES := $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.xscope))
XSCOPE_SOURCE_FILES := $(filter-out $(EXCLUDE_PATTERN), $(XSCOPE_SOURCE_FILES))
MODULE_XSCOPE_SOURCE_FILES := $(filter-out $(APP_XSCOPE_SOURCE_FILES), $(XSCOPE_SOURCE_FILES))

OBJ_SOURCE_FILES := $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.o))
OBJ_SOURCE_FILES := $(filter-out $(EXCLUDE_PATTERN), $(OBJ_SOURCE_FILES))

XN_SOURCE_FILES0 = $(foreach x, $(FULL_SOURCE_DIRS), $(call WILDCARD,$x/*.xn))
XN_SOURCE_FILES := $(filter %$(call MANGLE,$(TARGET).xn), $(XN_SOURCE_FILES0))
XN_SOURCE_FILES := $(filter-out $(EXCLUDE_PATTERN), $(XN_SOURCE_FILES))
XN_SOURCE_FILES:=$(strip $(XN_SOURCE_FILES))

SOURCE_FILES = $(C_SOURCE_FILES) $(CPP_SOURCE_FILES) $(XC_SOURCE_FILES) $(ASM_SOURCE_FILES)

OBJ_FILES := $(foreach x,$(SOURCE_FILES),$(call TO_OBJ,$(call TO_BUILD_DIR,$x)))

DEP_FILES_0 = $(CPP_DEP_FILES) $(C_DEP_FILES) $(XC_DEP_FILES) $(ASM_DEP_FILES)
DEP_FILES = $(patsubst %.d, %.0.d, $(DEP_FILES_0))

PCA_FILES = $(CPP_PCA_FILES) $(C_PCA_FILES) $(XC_PCA_FILES) $(ASM_PCA_FILES)

FULL_INCLUDE_DIRS := $(filter-out $(EXCLUDE_PATTERN), $(FULL_INCLUDE_DIRS))
FULL_INCLUDE_DIRS := $(FULL_INCLUDE_DIRS) $(GEN_DIRS)

HEADER_FILES = $(filter-out $(EXCLUDE_FILES),$(foreach x, $(FULL_INCLUDE_DIRS), $(call WILDCARD,$x/*.h)))

GEN_HEADER_FILES = $(filter %.h,$(ALL_GENERATED_FILES))

NOTDIR_HEADER_FILES = $(foreach x,$(HEADER_FILES),$(notdir $x))

define HWARNING_RULE
.PHONY: $1.header_warning
$1.header_warning:
	@echo WARNING: Duplicate header found: $1
	@echo "WARNING: Found in: $$(foreach x,$$(filter %$1,$$(HEADER_FILES)),$$(call UNMANGLE,$$x))"
endef

ifeq ($(words $(NOTDIR_HEADER_FILES)),$(words $(sort $(NOTDIR_HEADER_FILES))))
  HEADER_WARNINGS=
else
  IS_DUP_HEADER=$(strip $(filter $(1)$(1),$(subst $(SP),,$(filter $1,$(NOTDIR_HEADER_FILES)))))

  DUP_HEADERS = $(foreach x,$(sort $(NOTDIR_HEADER_FILES)),$(if $(call IS_DUP_HEADER,$x),$x,))

  HEADER_WARNINGS := $(foreach x,$(DUP_HEADERS),$x.header_warning)

  $(foreach x,$(DUP_HEADERS),$(eval $(call HWARNING_RULE,$x)))
endif

HEADER_DEP_FILES := $(foreach x,$(HEADER_FILES:.h=.dh),$(call TO_BUILD_DIR, $x))

HEADER_STATUS_FILES = $(HEADER_DEP_FILES:%.dh=%.hstat)

QUOTED_INCLUDE_DIRS = $(foreach x, $(FULL_INCLUDE_DIRS),$(CMDQUOTE)$(call DOTDOT,$x)$(CMDQUOTE))
INCLUDE_FLAGS = $(foreach x,$(QUOTED_INCLUDE_DIRS),-I$(call UNMANGLE_NO_ESCAPE,$x))

WORKSPACE_RELATIVE = $(strip $(foreach p,$(REPO_PATHS),$(patsubst $p/%,%,$(filter $p/%,$1))))

WORKSPACE_RELATIVE_INCLUDE_DIRS = \
  $(foreach x,$(EXTERNAL_INCLUDE_DIRS),$(call WORKSPACE_RELATIVE,$x))

OPTIONAL_HEADER_FLAG=$(if $(filter $1,$(NOTDIR_HEADER_FILES)),-D__$(strip $(subst .,_,$1))_exists__=1,)

OPTIONAL_HEADER_FLAGS=$(foreach x,$(ALL_OPTIONAL_HEADERS),$(call OPTIONAL_HEADER_FLAG,$x))

VPATH += $(FAKE_INC_DIR)

REMOVE_TRAILING_SLASH = $(strip $(subst !!!,,$(subst / !!!, !!!,$1 !!!)))

IS_LIB_DIR = $(strip $(call WILDCARD,$1/xs1b/lib*.a) $(call WILDCARD,$1/xs2a/lib*.a))
LIB_FILES := $(foreach x, $(FULL_LIB_DIRS), $(call WILDCARD,$x/xs1b/lib*.a)) $(foreach x, $(FULL_LIB_DIRS), $(call WILDCARD,$x/xs2a/lib*.a))
EXCLUDE_LIB_PATTERN = $(foreach x, $(EXCLUDE_LIBS), %lib$x.a)
LIB_FILES := $(filter-out $(EXCLUDE_LIB_PATTERN), $(LIB_FILES))
LIB_DIRS := $(foreach x, $(FULL_LIB_DIRS), $(if $(call IS_LIB_DIR,$x),$x,))
#remove duplicates
LIB_DIRS := $(sort $(LIB_DIRS))
LIB_FLAGS = $(foreach x,$(LIB_DIRS), -L "$(strip $(call TO_OS, $(call REMOVE_TRAILING_SLASH,$(call UNMANGLE_NO_ESCAPE,$(call DOTDOT,$x)))))")

LIB_FLAGS := $(LIB_FLAGS) $(sort $(foreach x,$(LIB_FILES),-l$(patsubst lib%.a,%,$(notdir $x))))
define NO_SOURCE


ERROR: No source files found


endef


# Make rules for directories

$(FAKE_INC_DIR)/ : | $(TARGET_DIR)/
	@-$(call MKDIR, $(FAKE_INC_DIR)) > $(NULL)

$(TARGET_DIR)/ :
	@-$(call MKDIR, $(TARGET_DIR)) > $(NULL)

ifeq ($(CONFIG),Default)
else
$(BIN_DIR)/:
	@-$(call MKDIR,$(BIN_DIR)) > $(NULL)
endif

$(LIB_DIR)/:
	@-$(call MKDIR,$(LIB_DIR)) > $(NULL)

$(BASE_DIR)/bin/:
	@-$(call MKDIR,$(BASE_DIR)/bin) > $(NULL)

$(GEN_DIRS):
	@-$(call MKDIR,$@) > $(NULL)

$(ALL_GENERATED_FILES) : | $(GEN_DIRS) $(BIN_DIR)

define GEN_DIR_DEF
$1 : GEN_DIR = $(patsubst %/,%,$(dir $1))
$1 : CURRENT_MODULE_DIR = $(strip $(subst $1*****,,$(filter $1*****%,$(GEN_FILES_MODULE_DIRS))))
endef

$(foreach x,$(ALL_GENERATED_FILES),$(eval $(call GEN_DIR_DEF,$x)))

# Make rules for source


# Make rules for objects
XPCA = $(XMOS_TOOL_PATH)/libexec/xpca
XCC = xcc
XAR = xmosar
XOBJDUMP = xobjdump

TARGET_PATH := $(subst \ , ,$(XCC_TARGET_PATH))
TARGET_PATH := $(subst \,/,$(TARGET_PATH))
TARGET_PATH := $(subst ",,$(TARGET_PATH))
TARGET_PATH := $(subst ;, ,$(call MANGLE,$(subst $(PATHSEP),;,$(TARGET_PATH))))

POSSIBLE_TARGETS = $(foreach y,$(foreach x,$(TARGET_PATH),$(call WILDCARD,$x/*)),$(notdir $y))

.PHONY: xmosupdate
xmosupdate:
	-@xmosupdate getbsp $(TARGET)

ifeq ($(BUILDING_LIBRARY),)
  ifeq (,$(XN_SOURCE_FILES))
    XMOSUPDATE = $(if $(strip $(filter $(TARGET),$(POSSIBLE_TARGETS))),,xmosupdate)
    TARGET_FLAGS = -target="$(TARGET)"
  else
    XMOSUPDATE =
  endif
else
  TARGET_FLAGS = -march=$(ARCH)
endif

define LANG
$(strip $(if $(filter %.c, $1), C,
  $(if $(filter %.xc, $1), XC,
     $(if $(filter %.cpp %.cc %.cp %.c++ %.C %.cxx, $1), CPP,
	$(if $(filter %.S, $1), ASM,
	   $(if $(filter %.s, $1), ASM, ))))))
endef

define lang_flags_xcore
$(if $(XCC_$(call LANG,$1)_FLAGS), $(XCC_$(call LANG,$1)_FLAGS), $(XCC_FLAGS))
endef

define make_flags_xcore
$(if $(XCC_FLAGS_$1), $(XCC_FLAGS_$1)  $(TARGET_FLAGS) $(EXTRA_$(call LANG,$1)_FLAGS), $(call lang_flags_xcore, $1) $(TARGET_FLAGS)) $(EXTRA_$(call LANG,$1)_FLAGS) -DCONFIG=$(CONFIG)
endef

NON_GEN_HEADER_FILES = $(filter-out $(ALL_GENERATED_FILES),$(HEADER_FILES))


$(NON_GEN_HEADER_FILES):
	@$(NOP)


ifneq ($(VERBOSE),1)
.SILENT: $(OBJ_FILES) $(BIN_DIR) $(TARGET_DIR) $(FAKE_INC_DIR)
endif

%.h: | $(FAKE_INC_DIR)
	$(if $(filter $@,$(GEN_HEADER_FILES)),,@echo WARNING: Include file $@ missing)
	@echo "Missing include file" > $(FAKE_INC_DIR)/$(notdir $@)

#USE_LLVM_BITCODE
ifeq ($(USE_LLVM_BITCODE),1)

define obj_command
$(if $(filter C CPP,$(call LANG,$1)),-S -Xcompiler-c -emit-llvm-bc,$(if $(filter XC,$(call LANG,$1)),-S -Xcompiler-xc -emit-llvm-bc,-c))
endef

LLVM_ALL_BC_FILE=$(TARGET_DIR)/all.llvm.bc
LLVM_ALL_S_FILE=$(TARGET_DIR)/all.llvm.s
LLVM_ALL_OBJ_FILE=$(TARGET_DIR)/all.llvm.o
REAL_OBJ_FILES=$(filter-out %.xc.o %.c.o %.s.o %.cc.o %.cp.o %.c++.o %.C.o %.cxx.o %.cpp.o,$(OBJ_FILES)) $(LLVM_ALL_OBJ_FILE)
LLVM_OBJ_FILES=$(filter-out $(REAL_OBJ_FILES),$(OBJ_FILES))


$(LLVM_ALL_OBJ_FILE): $(LLVM_OBJ_FILES)
	@echo Compiling LLVM bitcode
	$(LLVM_LD) -disable-internalize -disable-opt $(LLVM_OBJ_FILES) -b $(LLVM_ALL_BC_FILE)
	$(LLVM_LLC) $(LLVM_ALL_BC_FILE) -o $(LLVM_ALL_S_FILE)
	$(XCC) -c $(TARGET_FLAGS) $(LLVM_ALL_S_FILE) -o $(LLVM_ALL_OBJ_FILE)

else
#!USE_LLVM_BITCODE

obj_command=-c

REAL_OBJ_FILES=$(OBJ_FILES)

endif
#USE_LLVM_BITCODE


# '@' Response files are used to reduce the command line length.
# (must be < 8K in windows)
define RSP_FILE
$(TARGET_DIR)/$1.rsp : $3 | $(TARGET_DIR)/
	@echo Rebuild $(TARGET_DIR)/$1.rsp
	$$(file > $(call TO_OS,$(TARGET_DIR)/$1.rsp),$2)
endef

# '_iflag.rsp' holds -I paths.... can't add dependencies tho'
$(eval $(call RSP_FILE,_iflag,$(INCLUDE_FLAGS),))

# '_obj.rsp' holds a list of all <source>.o files.
$(eval $(call RSP_FILE,_obj,$(foreach x,$(REAL_OBJ_FILES),$(call TO_OS,$(call DOTDOT,$x))),$(REAL_OBJ_FILES)))

# '_pca.rsp' holds a list of all <source>.pca.xml files.
$(eval $(call RSP_FILE,_pca,$(PCA_FILES),$(PCA_FILES)))

XSCOPE_ARGS := $(call TO_OS,$(foreach x,$(MODULE_XSCOPE_SOURCE_FILES),$(CMDQUOTE)$(call UNMANGLE_NO_ESCAPE,$(call DOTDOT,$x))$(CMDQUOTE))) $(call TO_OS,$(foreach x,$(APP_XSCOPE_SOURCE_FILES),$(CMDQUOTE)$(call UNMANGLE_NO_ESCAPE,$(call DOTDOT,$x))$(CMDQUOTE)))

define OBJ_RULE
$(call TO_OBJ,$(call TO_BUILD_DIR,$1)) : $(call UNMANGLE,$1) $(call UNMANGLE,$(XN_SOURCE_FILES)) $(CURRENT_MAKEFILE) $(TARGET_DIR)/_iflag.rsp| $(TARGET_DIR)/
	@echo Compiling $$(call UNMANGLE_NO_ESCAPE, $(notdir $1))
	$(AT)cd $(TARGET_DIR) && $(XCC) $$(call obj_command,$1) $$(OPTIONAL_HEADER_FLAGS) @_iflag.rsp $$(call make_flags_xcore,$1) $$(PCA_FLAG) $(CMDQUOTE)$$(call DOTDOT,$$<)$(CMDQUOTE) -x none $(foreach x,$(XN_SOURCE_FILES),$(CMDQUOTE)$(call DOTDOT,$(call UNMANGLE_NO_ESCAPE,$x))$(CMDQUOTE)) $(XSCOPE_ARGS) -o $(CMDQUOTE)../$$@$(CMDQUOTE)
endef

$(foreach x,$(SOURCE_FILES),$(eval $(call OBJ_RULE,$x)))

ifeq ($(strip $(PREBUILD_MAKEFILES)),)
  NO_PREBUILD := 1
endif

QUOTE_IF_NEEDED_ITEM = $(if $(filter %$(CHAR2),$(subst $(CHAR2),$(CHAR2) ,$1)),$(ECHOQUOTE)$(subst $(CHAR2), ,$1)$(ECHOQUOTE),$1)
QUOTE_IF_NEEDED = $(foreach x,$1,$(call QUOTE_IF_NEEDED_ITEM,$x))

UM_VERSIONED = $(foreach x,$(UM),$(if $(ACTUAL_VERSION_$x),$x$(CMDLPAREN)$(ACTUAL_VERSION_$x)$(CMDRPAREN),$x))

ifeq ($(strip $(UM_VERSIONED)),)
  USING_MODULES_MSG = No build modules used.
else
  USING_MODULES_MSG = Using build modules: $(strip $(call QUOTE_IF_NEEDED,$(UM_VERSIONED)))
endif


define CHECK_VERSION_RULE
.PHONY: check_version_$1
check_version_$1:
	@$(CMDQUOTE)$(call TO_OS,$(XCC_EXEC_PREFIX)/xmos_check_module_version)$(CMDQUOTE) $1 $$(ACTUAL_VERSION_$1) $$(call GET_REQ_MODULE_VERSION,$1)
endef

GET_REQ_MODULE_VERSION = $(strip $(foreach x,$(filter $1%, $(USED_MODULES)), $(subst >=,gte,$(word 2,$(subst $(LPAREN), ,$(subst $(RPAREN), ,$x))))))

NEEDS_VERSION_CHECK = $(if $(ACTUAL_VERSION_$1),$(if $(call GET_REQ_MODULE_VERSION,$1),$1,),)

CHECK_VERSIONS = $(foreach x, $(UM), $(if $(call NEEDS_VERSION_CHECK,$x),$x,))

CHECK_VERSION_TARGETS = $(foreach x, $(CHECK_VERSIONS), check_version_$x)
$(foreach x,$(CHECK_VERSIONS),$(eval $(call CHECK_VERSION_RULE,$x)))


.PHONY: check_modules_msg
check_modules_msg:
	@echo Checking build modules

.PHONY: check_module_deps
check_module_deps: $(CHECK_VERSION_TARGETS)
	@echo $(USING_MODULES_MSG)


ifeq ($(JUST_CHECKING_MODULES),1)
# JUST_CHECKING_MODULES
CHECK_MODULES_MSG :=
FINDLIB_MODULES :=

define DUMMY_INCLUDE_MODULE
CURRENT_MODULE := $$(strip $$(call GET_MODULE_NAME,$1))
CURRENT_MODULE_DIR := $$(if $$(call SEARCH_FOR_MODULE,$$(CURRENT_MODULE)), $$(call SEARCH_FOR_MODULE,$$(CURRENT_MODULE)), not_found)
CURRENT_MODULE_DIR := $$(filter-out %/doc/$$(CURRENT_MODULE),$$(CURRENT_MODULE_DIR))
 ifneq ($$(words $$(CURRENT_MODULE_DIR)),1)
  ifeq ($$(words $$(filter %/$$(CURRENT_REPO)/$$(CURRENT_MODULE),$$(CURRENT_MODULE_DIR))),1)
   CURRENT_MODULE_DIR := $$(filter %/$$(CURRENT_REPO)/$$(CURRENT_MODULE),$$(CURRENT_MODULE_DIR))
  else
   ifeq ($$(words $$(call DIRS_WITH_BUILD_INFO, $$(CURRENT_MODULE_DIR))), 1)
    CURRENT_MODULE_DIR := $$(strip $$(call DIRS_WITH_BUILD_INFO,$$(CURRENT_MODULE_DIR)))
   endif
  endif
 endif
REQ_VERSION := $$(subst gte,$(ESCAPED_GT)=,$$(call GET_REQ_MODULE_VERSION,$1))
VERSION_OR_NONE := $$(if $$(strip $$(REQ_VERSION)),$(CMDLPAREN)$$(strip $$(REQ_VERSION))$(CMDRPAREN),)
VERSION_OR_LATEST := $$(CMDQUOTE)$$(if $$(strip $$(REQ_VERSION)),$$(subst $(ESCAPED_GT)=,>=,$$(strip $$(REQ_VERSION))),latest)$$(CMDQUOTE)
CHECK_MODULES_MSG := $$(CHECK_MODULES_MSG) $$(if $$(call WILDCARD,$$(CURRENT_MODULE_DIR)/*),,$$(call UNMANGLE_NO_ESCAPE, $$(CURRENT_MODULE))::$$(VERSION_OR_NONE))
FINDLIB_MODULES := $$(FINDLIB_MODULES) $$(if $$(call WILDCARD,$$(CURRENT_MODULE_DIR)/*),,$$(CMDQUOTE)$$(call UNMANGLE_NO_ESCAPE, $$(CURRENT_MODULE))$$(CMDQUOTE) $$(VERSION_OR_LATEST))
DEPENDENT_MODULES :=
-include $$(call UNMANGLE,$$(CURRENT_MODULE_DIR)/module_build_info)
DM := $$(foreach x,$$(DEPENDENT_MODULES),$$(word 1,$$(subst $$(LPAREN), ,$$x)))
NEW_MODULES := $$(strip $$(filter-out $$(UM),$$(DM)))
UM += $$(NEW_MODULES)
USED_MODULES := $$(USED_MODULES) $$(strip $$(filter-out $$(USED_MODULES),$$(DEPENDENT_MODULES)))
TO_PROCESS += $$(NEW_MODULES)
endef

define DUMMY_INCLUDE_MODULES
PROCESS_NOW := $$(strip $$(TO_PROCESS))
TO_PROCESS :=
$$(foreach x,$$(PROCESS_NOW),$$(eval $$(call DUMMY_INCLUDE_MODULE,$$x)))
endef

define DUMMY_INCLUDE_ALL_MODULES
$(if $(TO_PROCESS),$(eval $(call DUMMY_INCLUDE_MODULES)))
$(if $(TO_PROCESS),$(eval $(call DUMMY_INCLUDE_ALL_MODULES)))
endef

$(eval $(call DUMMY_INCLUDE_ALL_MODULES))

 ifeq ($(MAKECMDGOALS),check_modules)
  ifneq ($(strip $(CHECK_MODULES_MSG)),)
  # check_modules & CHECK_MODULES_MSG

define MISSING_MODULE_MSG
$$(warning Cannot find build module: $$(strip $1))
endef
#$(foreach x,$(CHECK_MODULES_MSG),$(eval $(call MISSING_MODULE_MSG,$x)))

.PHONY: do_check_modules
do_check_modules:
   ifeq ($(XDE_BUILD),)
	@xfindlib --xde-online-url $(CMDQUOTE)$(XDE_ONLINE_URL)$(CMDQUOTE) $(XDE_ONLINE_REG_KEY_ARG) $(WS_PATH) $(FINDLIB_MODULES)
   else
	@$(foreach x, $(CHECK_MODULES_MSG), echo ERROR: Cannot find module: $(subst ::, ,$x) &&)$(NOP)
   endif

-include do_check_modules

  endif
  # CHECK_MODULES_MSG

check_modules:
	@$(NOP)

 endif
  # check_modules

.PHONY: check_modules

endif
# JUST_CHECKING_MODULES


.PHONY: report_modules
report_modules:
	@echo $(USING_MODULES_MSG)

.PHONY: list_modules
list_modules:
	@echo **-modules-**
ifneq ($(strip $(UM)),)
	@echo $(strip $(call QUOTE_IF_NEEDED,$(UM)))
endif

# taskgraph
ifeq ($(MAKECMDGOALS),taskgraph)

TGSUBS = .xc=.xc.tg.xml .c=.c.tg.xml .S=.s.tg.xml .s=.s.tg.xml $(foreach suffix,$(CPP_SUFFICES),$(suffix)=$(suffix).tg.xml)

TO_TG = $(call APPLY_SUFFIX_SUBS,$(TGSUBS),$1)

define TG_RULE
.PHONY: $(call TO_TG,$(call TO_BUILD_DIR,$1))
$(call TO_TG,$(call TO_BUILD_DIR,$1)) : $(call UNMANGLE,$1) $(CURRENT_MAKEFILE) $(TARGET_DIR)/_iflag.rsp | $(TARGET_DIR)/
	@echo Creating task graph for $$(call UNMANGLE_NO_ESCAPE, $(notdir $1))
	$(AT)-$$(call MKDIR, $$(dir $$@))
	$(AT)cd $(TARGET_DIR) && $(XCC) -taskgraph $$(OPTIONAL_HEADER_FLAGS) @_iflag.rsp $$(call make_flags_xcore,$1) $(CMDQUOTE)$$(call DOTDOT,$$<)$(CMDQUOTE) -x none $(foreach x,$(XN_SOURCE_FILES),$(CMDQUOTE)$(call DOTDOT,$(call UNMANGLE_NO_ESCAPE,$x))$(CMDQUOTE)) $(XSCOPE_ARGS) -o $(CMDQUOTE)../$$@$(CMDQUOTE)
endef

$(foreach x,$(SOURCE_FILES),$(eval $(call TG_RULE,$(call MANGLE,$(call abspath,$x)))))

SRCFILE1 := $(subst \,/,$(SRCFILE))

TG_TARGET = $(call TO_TG,$(call TO_BUILD_DIR,$(call MANGLE,$(SRCFILE1))))

 ifneq ($(OUTFILE),)
 # $(OUTFILE)
.PHONY: $(OUTFILE)
$(OUTFILE): $(TG_TARGET)
	$(call CP,"$(TG_TARGET)" "$(OUTFILE)")

.PHONY: taskgraph
taskgraph: $(OUTFILE)
	@echo "Task graph created for $(notdir $(SRCFILE))"

 else
 # ! $(OUTFILE)
.PHONY: taskgraph
taskgraph: $(TG_TARGET)
	@echo "Task graph created for $(notdir $(SRCFILE))"

 endif
 # $(OUTFILE)
endif
# taskgraph

ifeq ($(VERBOSE),1)
  AT =
else
  AT = @
endif

ifeq ($(NO_PREBUILD),1)
# NO_PREBUILD

$(BIN_DIR)/$(APP_NAME) : $(XMOSUPDATE) $(HEADER_WARNINGS) $(REAL_OBJ_FILES) $(call UNMANGLE,$(XN_SOURCE_FILES))  $(call UNMANGLE, $(XTA_SOURCE_FILES)) $(call UNMANGLE,$(LIB_FILES)) $(call UNMANGLE, $(MODULE_XSCOPE_SOURCE_FILES)) $(call UNMANGLE, $(APP_XSCOPE_SOURCE_FILES)) $(CURRENT_MAKEFILE) $(TARGET_DIR)/_obj.rsp | $(BIN_DIR)/
	@echo Creating $(notdir $@)
	$(AT)cd $(TARGET_DIR) && $(XCC) $(XCC_MAP_FLAGS) $(XCC_EXTRA_MAP_FLAGS) $(LIB_FLAGS) @_obj.rsp $(call TO_OS,$(foreach x,$(XN_SOURCE_FILES),$(CMDQUOTE)$(call DOTDOT,$(call UNMANGLE_NO_ESCAPE,$x))$(CMDQUOTE))) $(call TO_OS,$(foreach x,$(XTA_SOURCE_FILES),$(CMDQUOTE)$(call UNMANGLE_NO_ESCAPE,$(call DOTDOT,$x))$(CMDQUOTE))) $(XSCOPE_ARGS) -o $(CMDQUOTE)$(call TO_OS,$(call DOTDOT,$@))$(CMDQUOTE)

$(BIN_DIR)/$(APP_NAME).xe : $(XMOSUPDATE) $(HEADER_WARNINGS) $(REAL_OBJ_FILES) $(call UNMANGLE,$(XN_SOURCE_FILES))  $(call UNMANGLE, $(XTA_SOURCE_FILES)) $(call UNMANGLE,$(LIB_FILES)) $(call UNMANGLE, $(MODULE_XSCOPE_SOURCE_FILES)) $(call UNMANGLE, $(APP_XSCOPE_SOURCE_FILES)) $(PCA_FILE) $(CURRENT_MAKEFILE) $(TARGET_DIR)/_obj.rsp | $(BIN_DIR)/
	@echo Creating $(notdir $@)
	$(AT)cd $(TARGET_DIR) && $(XCC) $(TARGET_FLAGS) $(XCC_MAP_FLAGS) $(XCC_EXTRA_MAP_FLAGS) $(LIB_FLAGS) @_obj.rsp $(call TO_OS,$(foreach x,$(XN_SOURCE_FILES),$(CMDQUOTE)$(call DOTDOT,$(call UNMANGLE_NO_ESCAPE,$x))$(CMDQUOTE))) $(call TO_OS,$(foreach x,$(XTA_SOURCE_FILES),$(CMDQUOTE)$(call UNMANGLE_NO_ESCAPE,$(call DOTDOT,$x))$(CMDQUOTE))) $(XSCOPE_ARGS) -o $(CMDQUOTE)$(call TO_OS,$(call DOTDOT,$@))$(CMDQUOTE)

$(LIB_DIR)/%.a :  $(OBJ_FILES) $(call UNMANGLE,$(XN_SOURCE_FILES)) |$(LIB_DIR)/
	@echo Creating $(notdir $@) $(CMDLPAREN)$(ARCH)$(CMDRPAREN)
	$(AT)cd $(TARGET_DIR) && $(XAR) cru ../$@ $(addprefix ../, $(OBJ_FILES))

else
# !NO_PREBUILD
#export NO_PREBUILD
.PHONY: prebuild
%.prebuild: prebuild
	@echo ***Building $(notdir $(patsubst %/,%,$(call UNMANGLE_NO_ESCAPE,$(dir $*))))***
	@cd "$(call TO_OS,$(call UNMANGLE_NO_ESCAPE,$(dir $*)))" && $(MAKE) --no-print-directory -f $(notdir $*) all

$(BIN_DIR)/%.xe: $(foreach x, $(PREBUILD_MAKEFILES), $x.prebuild)
	@echo ***Building main application***
	@$(MAKE) NO_PREBUILD=1 --no-print-directory $(BIN_DIR)/$*.xe
endif
# NO_PREBUILD

define DEP_RULE
$(call TO_DEP,$(call TO_BUILD_DIR,$1)) : $(call UNMANGLE,$1)  $(XMOSUPDATE) $(GEN_HEADER_FILES) $(CURRENT_MAKEFILE) $(TARGET_DIR)/_iflag.rsp | $(TARGET_DIR)/
	@echo Creating dependencies for $$(call UNMANGLE_NO_ESCAPE,$(notdir $1))
	$(AT)cd $(TARGET_DIR) && $(XCC) -MMD -E $$(call make_flags_xcore,$1) $$(OPTIONAL_HEADER_FLAGS) @_iflag.rsp $(CMDQUOTE)$$(call DOTDOT,$$<)$(CMDQUOTE) -x none $(foreach x,$(XN_SOURCE_FILES),$(CMDQUOTE)$(call DOTDOT,$(call UNMANGLE_NO_ESCAPE,$x))$(CMDQUOTE)) $(XSCOPE_ARGS) > $(NULL)
	$(AT)-$$(call MKDIR, $$(dir $$@))
	$(AT)$$(call CHANGEDEP,$$@,$1)
	$(AT)$(NOP)
endef

$(foreach x,$(SOURCE_FILES),$(eval $(call DEP_RULE,$x)))

lib: $(LIB_DIR)/lib$(CURRENT_LIB).a

.report_modules: report_modules

%.pca.xml : %.pca.xml.decouple
	@cd $(TARGET_DIR) && $(call DIFF,$(CMDQUOTE)../$<$(CMDQUOTE) $(CMDQUOTE)../$@$(CMDQUOTE)) || $(call CP,$(CMDQUOTE)../$<$(CMDQUOTE) $(CMDQUOTE)../$@$(CMDQUOTE))

ifeq ($(ENABLE_STAGED_BUILD),1)
 ifeq ($(BUILDING_LIBRARY),1)
 #ENABLE_STAGED_BUILD & BUILDING_LIBRARY
PCA_FILE =
PCA_FLAG =
analyze:
	@$(NOP)
 else
 #ENABLE_STAGED_BUILD & !BUILDING_LIBRARY
define PCA_RULE
$(foreach x,$(call TO_PCA,$(call TO_BUILD_DIR,$1)),$x.decouple) : $(call UNMANGLE,$1)  $(XMOSUPDATE) $(GEN_HEADER_FILES) $(CURRENT_MAKEFILE) $(TARGET_DIR)/_iflag.rsp | $(TARGET_DIR)/
	@echo Analyzing $$(call UNMANGLE_NO_ESCAPE,$(notdir $1))
	$(AT)-$$(call MKDIR, $$(dir $$@))
	$(AT)cd $(TARGET_DIR) && $(XCC) -pre-compilation-analysis $$(call make_flags_xcore,$1) $$(OPTIONAL_HEADER_FLAGS) @_iflag.rsp $(CMDQUOTE)$$(call DOTDOT,$$<)$(CMDQUOTE) -x none $(foreach x,$(XN_SOURCE_FILES),$(CMDQUOTE)$(call DOTDOT,$(call UNMANGLE_NO_ESCAPE,$x))$(CMDQUOTE)) $(XSCOPE_ARGS) -o $(CMDQUOTE)../$$@$(CMDQUOTE) > $(NULL)
endef

$(foreach x,$(SOURCE_FILES),$(eval $(call PCA_RULE,$x)))

# N.B. spaces are added inside the $(CMDQUOTE) to make sure they are never empty e.g. $(ALL_MODULE_DIRS), otherwise they become non-arguments
$(TARGET_DIR)/pca.xml : $(PCA_FILES) $(TARGET_DIR)/_pca.rsp | $(TARGET_DIR)/
	@echo Propagating analysis
	$(AT)$(CMDQUOTE)$(call TO_OS,$(XPCA))$(CMDQUOTE) $(CMDQUOTE)$(call TO_OS,$@)$(CMDQUOTE) -deps $(CMDQUOTE)$(call TO_OS,$(TARGET_DIR)/pca.d)$(CMDQUOTE) $(CMDQUOTE) $(call TO_OS,$(TARGET_DIR)$(CMDQUOTE)) $(CMDQUOTE) $(call UNMANGLE,$(ALL_MODULE_DIRS))$(CMDQUOTE) $(CMDQUOTE)@$(call TO_OS,$(TARGET_DIR)/_pca.rsp)$(CMDQUOTE)


PCA_FILE = $(TARGET_DIR)/pca.xml
PCA_FLAG = -Xcompiler-xc -analysis -Xcompiler-xc $(call DOTDOT,$(TARGET_DIR)/pca.xml)
analyze: $(PCA_FILE)
	@$(NOP)
 endif
 # BUILDING_LIBRARY
else
# !ENABLE_STAGED_BUILD
PCA_FILE =
PCA_FLAG =
analyze:
	@$(NOP)
endif
# ENABLE_STAGED_BUILD, BUILDING_LIBRARY


ifneq ($(MAKECMDGOALS),clean_common)
ifneq ($(MAKECMDGOALS),clean_lib)
ifneq ($(MAKECMDGOALS),list_includes)
ifneq ($(MAKECMDGOALS),show_xcore_dirs)
ifneq ($(MAKECMDGOALS),list_modules)
ifneq ($(MAKECMDGOALS),taskgraph)
ifneq ($(MAKECMDGOALS),check_module_deps)
ifneq ($(MAKECMDGOALS),check_modules)
ifneq ($(MAKECMDGOALS),check_modules_msg)
ifneq ($(MAKECMDGOALS),analyze)
  ifeq ($(strip $(OBJ_FILES)),)
    $(error $(call NO_SOURCE))
  endif
  ifeq  ($(BUILDING_LIBRARY),1)
    -include $(DEP_FILES_0)
  else
    ifeq ($(NO_PREBUILD),1)
      -include $(DEP_FILES_0)
      ifeq ($(ENABLE_STAGED_BUILD),1)
        -include $(TARGET_DIR)/pca.d
      endif
      ifeq ($(MAKE_RESTARTS),)
        $(TARGET_DIR)/pca.d : $(TARGET_DIR)/pca.xml
      endif
    endif
  endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif

.PRECIOUS: $(OBJ_FILES)
.SECONDARY: $(OBJ_FILES)


# Top level rules

%.prebuild.clean:
	@echo Cleaning $(abspath $(call UNMANGLE,$(dir $*)))
	cd "$(call TO_OS,$(call UNMANGLE_NO_ESCAPE,$(dir $*)))" && $(MAKE) --no-print-directory -f $(notdir $*) clean

clean_common: $(foreach x, $(PREBUILD_MAKEFILES), $x.prebuild.clean)
	@echo $(CMDQUOTE)Cleaning $(abspath $(dir .))$(CMDQUOTE)
	-$(call RMRF,$(BIN_DIR))
	-$(call RMRF,$(TARGET_DIR))

clean_build: $(foreach x, $(PREBUILD_MAKEFILES), $x.prebuild.clean)
	-$(call RMRF,$(TARGET_DIR))

clean_lib:
	-$(call RMRF,$(LIB_DIR))
	-$(call RMRF,$(TARGET_DIR))

partial_clean:
	-$(call RMRF,$(TARGET_DIR))

clean_fake_includes : | $(FAKE_INC_DIR)/
	@-$(call RMRF,$(FAKE_INC_DIR))

all: clean_fake_includes


ifeq ($(BUILDING_LIBRARY),1)
# BUILDING_LIBRARY
MODULE_NAME ?= $(subst .,_,$(notdir $(call MANGLE,$(abspath .))))
EXPORT_DIR = $(BASE_DIR)/export/$(MODULE_NAME)
EXPORT_LIB_DIR = $(EXPORT_DIR)/lib/$(ARCH)

$(EXPORT_DIR):
	@echo Creating export directory
	@$(call MKDIR,$(EXPORT_DIR))

$(EXPORT_LIB_DIR)/lib%.a:
	@$(call MKDIR,$(BASE_DIR)/export/$(MODULE_NAME)/lib/$(ARCH))
	@echo Copying library
	@$(call CP,$(LIB_DIR)/lib$*.a $(BASE_DIR)/export/$(MODULE_NAME)/lib/$(ARCH)/lib$*.a)

%.export:
	@echo Exporting directory: $*
	@$(call XCP,$*,.,$(EXPORT_DIR))

.PHONY: $(EXPORT_DIR)/module_build_info

$(EXPORT_DIR)/module_build_info:
	@echo Copying module_build_info
	@$(call CP, module_build_info $(EXPORT_DIR)/module_build_info)
	@echo "EXPORTED = 1" >> $(EXPORT_DIR)/module_build_info

.PHONY: do_export

.PHONY: export_libs

export_libs: | $(EXPORT_DIR)
	@echo Copying libs
	@$(call XCP,lib,.,$(EXPORT_DIR))

%.generated_export:
	@$(call XCP,$*,$(TARGET_DIR)/generated,$(EXPORT_DIR)/$(GENERATED_HEADER_EXPORT_DIR))

do_export: export_libs $(foreach x, $(EXPORT_SOURCE_DIRS), $x.export) $(EXPORT_DIR)/module_build_info $(if $(GENERATED_HEADER_EXPORT_DIR),$(foreach x,$(filter %.h,$(GENERATED_FILES)),$x.generated_export))
	@echo Export complete

.PHONY: export

  ifeq ($(OVERRIDE_EXPORT_TARGET),)
export:
	@$(call RMRF, export)
	@$(MAKE) -f $(XCOMMON_MAKEFILE) do_export
  endif

endif
# BUILDING_LIBRARY

show_xcore_dirs:
	@echo **-xcore-dirs-**
ifneq ($(APP_SOURCE_DIRS),)
	@echo $(APP_SOURCE_DIRS)
endif


list_includes:
	@echo **-xcore-includes-**
ifneq ($(WORKSPACE_RELATIVE_INCLUDE_DIRS),)
	@echo $(WORKSPACE_RELATIVE_INCLUDE_DIRS)
endif
