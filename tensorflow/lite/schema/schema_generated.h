/* Copyright 2024 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

namespace tflite {

struct CustomQuantization;
struct CustomQuantizationBuilder;
struct CustomQuantizationT;

struct QuantizationParameters;
struct QuantizationParametersBuilder;
struct QuantizationParametersT;

struct Int32Vector;
struct Int32VectorBuilder;
struct Int32VectorT;

struct Uint16Vector;
struct Uint16VectorBuilder;
struct Uint16VectorT;

struct Uint8Vector;
struct Uint8VectorBuilder;
struct Uint8VectorT;

struct DimensionMetadata;
struct DimensionMetadataBuilder;
struct DimensionMetadataT;

struct SparsityParameters;
struct SparsityParametersBuilder;
struct SparsityParametersT;

struct VariantSubType;
struct VariantSubTypeBuilder;
struct VariantSubTypeT;

struct Tensor;
struct TensorBuilder;
struct TensorT;

struct StablehloGatherOptions;
struct StablehloGatherOptionsBuilder;
struct StablehloGatherOptionsT;

struct StablehloTransposeOptions;
struct StablehloTransposeOptionsBuilder;
struct StablehloTransposeOptionsT;

struct StablehloDotGeneralOptions;
struct StablehloDotGeneralOptionsBuilder;
struct StablehloDotGeneralOptionsT;

struct StablehloReduceWindowOptions;
struct StablehloReduceWindowOptionsBuilder;
struct StablehloReduceWindowOptionsT;

struct StablehloWhileOptions;
struct StablehloWhileOptionsBuilder;
struct StablehloWhileOptionsT;

struct StablehloSortOptions;
struct StablehloSortOptionsBuilder;
struct StablehloSortOptionsT;

struct StablehloConcatenateOptions;
struct StablehloConcatenateOptionsBuilder;
struct StablehloConcatenateOptionsT;

struct StablehloBroadcastInDimOptions;
struct StablehloBroadcastInDimOptionsBuilder;
struct StablehloBroadcastInDimOptionsT;

struct StablehloCompareOptions;
struct StablehloCompareOptionsBuilder;
struct StablehloCompareOptionsT;

struct StablehloDynamicSliceOptions;
struct StablehloDynamicSliceOptionsBuilder;
struct StablehloDynamicSliceOptionsT;

struct StablehloPadOptions;
struct StablehloPadOptionsBuilder;
struct StablehloPadOptionsT;

struct StablehloIotaOptions;
struct StablehloIotaOptionsBuilder;
struct StablehloIotaOptionsT;

struct StablehloCustomCallOptions;
struct StablehloCustomCallOptionsBuilder;
struct StablehloCustomCallOptionsT;

struct StablehloReduceOptions;
struct StablehloReduceOptionsBuilder;
struct StablehloReduceOptionsT;

struct StablehloSliceOptions;
struct StablehloSliceOptionsBuilder;
struct StablehloSliceOptionsT;

struct StablehloConvolutionOptions;
struct StablehloConvolutionOptionsBuilder;
struct StablehloConvolutionOptionsT;

struct StablehloScatterOptions;
struct StablehloScatterOptionsBuilder;
struct StablehloScatterOptionsT;

struct StablehloRngBitGeneratorOptions;
struct StablehloRngBitGeneratorOptionsBuilder;
struct StablehloRngBitGeneratorOptionsT;

struct Conv2DOptions;
struct Conv2DOptionsBuilder;
struct Conv2DOptionsT;

struct Conv3DOptions;
struct Conv3DOptionsBuilder;
struct Conv3DOptionsT;

struct Pool2DOptions;
struct Pool2DOptionsBuilder;
struct Pool2DOptionsT;

struct DepthwiseConv2DOptions;
struct DepthwiseConv2DOptionsBuilder;
struct DepthwiseConv2DOptionsT;

struct ConcatEmbeddingsOptions;
struct ConcatEmbeddingsOptionsBuilder;
struct ConcatEmbeddingsOptionsT;

struct LSHProjectionOptions;
struct LSHProjectionOptionsBuilder;
struct LSHProjectionOptionsT;

struct SVDFOptions;
struct SVDFOptionsBuilder;
struct SVDFOptionsT;

struct RNNOptions;
struct RNNOptionsBuilder;
struct RNNOptionsT;

struct SequenceRNNOptions;
struct SequenceRNNOptionsBuilder;
struct SequenceRNNOptionsT;

struct BidirectionalSequenceRNNOptions;
struct BidirectionalSequenceRNNOptionsBuilder;
struct BidirectionalSequenceRNNOptionsT;

struct FullyConnectedOptions;
struct FullyConnectedOptionsBuilder;
struct FullyConnectedOptionsT;

struct SoftmaxOptions;
struct SoftmaxOptionsBuilder;
struct SoftmaxOptionsT;

struct ConcatenationOptions;
struct ConcatenationOptionsBuilder;
struct ConcatenationOptionsT;

struct AddOptions;
struct AddOptionsBuilder;
struct AddOptionsT;

struct MulOptions;
struct MulOptionsBuilder;
struct MulOptionsT;

struct L2NormOptions;
struct L2NormOptionsBuilder;
struct L2NormOptionsT;

struct LocalResponseNormalizationOptions;
struct LocalResponseNormalizationOptionsBuilder;
struct LocalResponseNormalizationOptionsT;

struct LSTMOptions;
struct LSTMOptionsBuilder;
struct LSTMOptionsT;

struct UnidirectionalSequenceLSTMOptions;
struct UnidirectionalSequenceLSTMOptionsBuilder;
struct UnidirectionalSequenceLSTMOptionsT;

struct BidirectionalSequenceLSTMOptions;
struct BidirectionalSequenceLSTMOptionsBuilder;
struct BidirectionalSequenceLSTMOptionsT;

struct ResizeBilinearOptions;
struct ResizeBilinearOptionsBuilder;
struct ResizeBilinearOptionsT;

struct ResizeNearestNeighborOptions;
struct ResizeNearestNeighborOptionsBuilder;
struct ResizeNearestNeighborOptionsT;

struct CallOptions;
struct CallOptionsBuilder;
struct CallOptionsT;

struct PadOptions;
struct PadOptionsBuilder;
struct PadOptionsT;

struct PadV2Options;
struct PadV2OptionsBuilder;
struct PadV2OptionsT;

struct ReshapeOptions;
struct ReshapeOptionsBuilder;
struct ReshapeOptionsT;

struct SpaceToBatchNDOptions;
struct SpaceToBatchNDOptionsBuilder;
struct SpaceToBatchNDOptionsT;

struct BatchToSpaceNDOptions;
struct BatchToSpaceNDOptionsBuilder;
struct BatchToSpaceNDOptionsT;

struct SkipGramOptions;
struct SkipGramOptionsBuilder;
struct SkipGramOptionsT;

struct SpaceToDepthOptions;
struct SpaceToDepthOptionsBuilder;
struct SpaceToDepthOptionsT;

struct DepthToSpaceOptions;
struct DepthToSpaceOptionsBuilder;
struct DepthToSpaceOptionsT;

struct SubOptions;
struct SubOptionsBuilder;
struct SubOptionsT;

struct DivOptions;
struct DivOptionsBuilder;
struct DivOptionsT;

struct TopKV2Options;
struct TopKV2OptionsBuilder;
struct TopKV2OptionsT;

struct EmbeddingLookupSparseOptions;
struct EmbeddingLookupSparseOptionsBuilder;
struct EmbeddingLookupSparseOptionsT;

struct GatherOptions;
struct GatherOptionsBuilder;
struct GatherOptionsT;

struct TransposeOptions;
struct TransposeOptionsBuilder;
struct TransposeOptionsT;

struct ExpOptions;
struct ExpOptionsBuilder;
struct ExpOptionsT;

struct CosOptions;
struct CosOptionsBuilder;
struct CosOptionsT;

struct ReducerOptions;
struct ReducerOptionsBuilder;
struct ReducerOptionsT;

struct SqueezeOptions;
struct SqueezeOptionsBuilder;
struct SqueezeOptionsT;

struct SplitOptions;
struct SplitOptionsBuilder;
struct SplitOptionsT;

struct SplitVOptions;
struct SplitVOptionsBuilder;
struct SplitVOptionsT;

struct StridedSliceOptions;
struct StridedSliceOptionsBuilder;
struct StridedSliceOptionsT;

struct LogSoftmaxOptions;
struct LogSoftmaxOptionsBuilder;
struct LogSoftmaxOptionsT;

struct CastOptions;
struct CastOptionsBuilder;
struct CastOptionsT;

struct DequantizeOptions;
struct DequantizeOptionsBuilder;
struct DequantizeOptionsT;

struct MaximumMinimumOptions;
struct MaximumMinimumOptionsBuilder;
struct MaximumMinimumOptionsT;

struct TileOptions;
struct TileOptionsBuilder;
struct TileOptionsT;

struct ArgMaxOptions;
struct ArgMaxOptionsBuilder;
struct ArgMaxOptionsT;

struct ArgMinOptions;
struct ArgMinOptionsBuilder;
struct ArgMinOptionsT;

struct GreaterOptions;
struct GreaterOptionsBuilder;
struct GreaterOptionsT;

struct GreaterEqualOptions;
struct GreaterEqualOptionsBuilder;
struct GreaterEqualOptionsT;

struct LessOptions;
struct LessOptionsBuilder;
struct LessOptionsT;

struct LessEqualOptions;
struct LessEqualOptionsBuilder;
struct LessEqualOptionsT;

struct NegOptions;
struct NegOptionsBuilder;
struct NegOptionsT;

struct SelectOptions;
struct SelectOptionsBuilder;
struct SelectOptionsT;

struct SliceOptions;
struct SliceOptionsBuilder;
struct SliceOptionsT;

struct TransposeConvOptions;
struct TransposeConvOptionsBuilder;
struct TransposeConvOptionsT;

struct ExpandDimsOptions;
struct ExpandDimsOptionsBuilder;
struct ExpandDimsOptionsT;

struct SparseToDenseOptions;
struct SparseToDenseOptionsBuilder;
struct SparseToDenseOptionsT;

struct EqualOptions;
struct EqualOptionsBuilder;
struct EqualOptionsT;

struct NotEqualOptions;
struct NotEqualOptionsBuilder;
struct NotEqualOptionsT;

struct ShapeOptions;
struct ShapeOptionsBuilder;
struct ShapeOptionsT;

struct RankOptions;
struct RankOptionsBuilder;
struct RankOptionsT;

struct PowOptions;
struct PowOptionsBuilder;
struct PowOptionsT;

struct FakeQuantOptions;
struct FakeQuantOptionsBuilder;
struct FakeQuantOptionsT;

struct PackOptions;
struct PackOptionsBuilder;
struct PackOptionsT;

struct LogicalOrOptions;
struct LogicalOrOptionsBuilder;
struct LogicalOrOptionsT;

struct OneHotOptions;
struct OneHotOptionsBuilder;
struct OneHotOptionsT;

struct AbsOptions;
struct AbsOptionsBuilder;
struct AbsOptionsT;

struct HardSwishOptions;
struct HardSwishOptionsBuilder;
struct HardSwishOptionsT;

struct LogicalAndOptions;
struct LogicalAndOptionsBuilder;
struct LogicalAndOptionsT;

struct LogicalNotOptions;
struct LogicalNotOptionsBuilder;
struct LogicalNotOptionsT;

struct UnpackOptions;
struct UnpackOptionsBuilder;
struct UnpackOptionsT;

struct FloorDivOptions;
struct FloorDivOptionsBuilder;
struct FloorDivOptionsT;

struct SquareOptions;
struct SquareOptionsBuilder;
struct SquareOptionsT;

struct ZerosLikeOptions;
struct ZerosLikeOptionsBuilder;
struct ZerosLikeOptionsT;

struct FillOptions;
struct FillOptionsBuilder;
struct FillOptionsT;

struct FloorModOptions;
struct FloorModOptionsBuilder;
struct FloorModOptionsT;

struct RangeOptions;
struct RangeOptionsBuilder;
struct RangeOptionsT;

struct LeakyReluOptions;
struct LeakyReluOptionsBuilder;
struct LeakyReluOptionsT;

struct SquaredDifferenceOptions;
struct SquaredDifferenceOptionsBuilder;
struct SquaredDifferenceOptionsT;

struct MirrorPadOptions;
struct MirrorPadOptionsBuilder;
struct MirrorPadOptionsT;

struct UniqueOptions;
struct UniqueOptionsBuilder;
struct UniqueOptionsT;

struct ReverseV2Options;
struct ReverseV2OptionsBuilder;
struct ReverseV2OptionsT;

struct AddNOptions;
struct AddNOptionsBuilder;
struct AddNOptionsT;

struct GatherNdOptions;
struct GatherNdOptionsBuilder;
struct GatherNdOptionsT;

struct WhereOptions;
struct WhereOptionsBuilder;
struct WhereOptionsT;

struct ReverseSequenceOptions;
struct ReverseSequenceOptionsBuilder;
struct ReverseSequenceOptionsT;

struct MatrixDiagOptions;
struct MatrixDiagOptionsBuilder;
struct MatrixDiagOptionsT;

struct QuantizeOptions;
struct QuantizeOptionsBuilder;
struct QuantizeOptionsT;

struct MatrixSetDiagOptions;
struct MatrixSetDiagOptionsBuilder;
struct MatrixSetDiagOptionsT;

struct IfOptions;
struct IfOptionsBuilder;
struct IfOptionsT;

struct CallOnceOptions;
struct CallOnceOptionsBuilder;
struct CallOnceOptionsT;

struct WhileOptions;
struct WhileOptionsBuilder;
struct WhileOptionsT;

struct NonMaxSuppressionV4Options;
struct NonMaxSuppressionV4OptionsBuilder;
struct NonMaxSuppressionV4OptionsT;

struct NonMaxSuppressionV5Options;
struct NonMaxSuppressionV5OptionsBuilder;
struct NonMaxSuppressionV5OptionsT;

struct ScatterNdOptions;
struct ScatterNdOptionsBuilder;
struct ScatterNdOptionsT;

struct SelectV2Options;
struct SelectV2OptionsBuilder;
struct SelectV2OptionsT;

struct DensifyOptions;
struct DensifyOptionsBuilder;
struct DensifyOptionsT;

struct SegmentSumOptions;
struct SegmentSumOptionsBuilder;
struct SegmentSumOptionsT;

struct BatchMatMulOptions;
struct BatchMatMulOptionsBuilder;
struct BatchMatMulOptionsT;

struct CumsumOptions;
struct CumsumOptionsBuilder;
struct CumsumOptionsT;

struct BroadcastToOptions;
struct BroadcastToOptionsBuilder;
struct BroadcastToOptionsT;

struct Rfft2dOptions;
struct Rfft2dOptionsBuilder;
struct Rfft2dOptionsT;

struct HashtableOptions;
struct HashtableOptionsBuilder;
struct HashtableOptionsT;

struct HashtableFindOptions;
struct HashtableFindOptionsBuilder;
struct HashtableFindOptionsT;

struct HashtableImportOptions;
struct HashtableImportOptionsBuilder;
struct HashtableImportOptionsT;

struct HashtableSizeOptions;
struct HashtableSizeOptionsBuilder;
struct HashtableSizeOptionsT;

struct VarHandleOptions;
struct VarHandleOptionsBuilder;
struct VarHandleOptionsT;

struct ReadVariableOptions;
struct ReadVariableOptionsBuilder;
struct ReadVariableOptionsT;

struct AssignVariableOptions;
struct AssignVariableOptionsBuilder;
struct AssignVariableOptionsT;

struct RandomOptions;
struct RandomOptionsBuilder;
struct RandomOptionsT;

struct BucketizeOptions;
struct BucketizeOptionsBuilder;
struct BucketizeOptionsT;

struct GeluOptions;
struct GeluOptionsBuilder;
struct GeluOptionsT;

struct DynamicUpdateSliceOptions;
struct DynamicUpdateSliceOptionsBuilder;
struct DynamicUpdateSliceOptionsT;

struct UnsortedSegmentProdOptions;
struct UnsortedSegmentProdOptionsBuilder;
struct UnsortedSegmentProdOptionsT;

struct UnsortedSegmentMaxOptions;
struct UnsortedSegmentMaxOptionsBuilder;
struct UnsortedSegmentMaxOptionsT;

struct UnsortedSegmentSumOptions;
struct UnsortedSegmentSumOptionsBuilder;
struct UnsortedSegmentSumOptionsT;

struct ATan2Options;
struct ATan2OptionsBuilder;
struct ATan2OptionsT;

struct UnsortedSegmentMinOptions;
struct UnsortedSegmentMinOptionsBuilder;
struct UnsortedSegmentMinOptionsT;

struct SignOptions;
struct SignOptionsBuilder;
struct SignOptionsT;

struct BitcastOptions;
struct BitcastOptionsBuilder;
struct BitcastOptionsT;

struct BitwiseXorOptions;
struct BitwiseXorOptionsBuilder;
struct BitwiseXorOptionsT;

struct RightShiftOptions;
struct RightShiftOptionsBuilder;
struct RightShiftOptionsT;

struct DilateOptions;
struct DilateOptionsBuilder;
struct DilateOptionsT;

struct ReduceWindowOptions;
struct ReduceWindowOptionsBuilder;
struct ReduceWindowOptionsT;

struct OperatorCode;
struct OperatorCodeBuilder;
struct OperatorCodeT;

struct StableHLOCompositeOptions;
struct StableHLOCompositeOptionsBuilder;
struct StableHLOCompositeOptionsT;

struct Operator;
struct OperatorBuilder;
struct OperatorT;

struct SubGraph;
struct SubGraphBuilder;
struct SubGraphT;

struct Buffer;
struct BufferBuilder;
struct BufferT;

struct Metadata;
struct MetadataBuilder;
struct MetadataT;

struct TensorMap;
struct TensorMapBuilder;
struct TensorMapT;

struct SignatureDef;
struct SignatureDefBuilder;
struct SignatureDefT;

struct Model;
struct ModelBuilder;
struct ModelT;

enum TensorType : int8_t {
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_FLOAT64 = 10,
  TensorType_COMPLEX128 = 11,
  TensorType_UINT64 = 12,
  TensorType_RESOURCE = 13,
  TensorType_VARIANT = 14,
  TensorType_UINT32 = 15,
  TensorType_UINT16 = 16,
  TensorType_INT4 = 17,
  TensorType_BFLOAT16 = 18,
  TensorType_MIN = TensorType_FLOAT32,
  TensorType_MAX = TensorType_BFLOAT16
};

inline const TensorType (&EnumValuesTensorType())[19] {
  static const TensorType values[] = {
    TensorType_FLOAT32,
    TensorType_FLOAT16,
    TensorType_INT32,
    TensorType_UINT8,
    TensorType_INT64,
    TensorType_STRING,
    TensorType_BOOL,
    TensorType_INT16,
    TensorType_COMPLEX64,
    TensorType_INT8,
    TensorType_FLOAT64,
    TensorType_COMPLEX128,
    TensorType_UINT64,
    TensorType_RESOURCE,
    TensorType_VARIANT,
    TensorType_UINT32,
    TensorType_UINT16,
    TensorType_INT4,
    TensorType_BFLOAT16
  };
  return values;
}

inline const char * const *EnumNamesTensorType() {
  static const char * const names[20] = {
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "UINT8",
    "INT64",
    "STRING",
    "BOOL",
    "INT16",
    "COMPLEX64",
    "INT8",
    "FLOAT64",
    "COMPLEX128",
    "UINT64",
    "RESOURCE",
    "VARIANT",
    "UINT32",
    "UINT16",
    "INT4",
    "BFLOAT16",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorType(TensorType e) {
  if (::flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_BFLOAT16)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails : uint8_t {
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2] {
  static const QuantizationDetails values[] = {
    QuantizationDetails_NONE,
    QuantizationDetails_CustomQuantization
  };
  return values;
}

inline const char * const *EnumNamesQuantizationDetails() {
  static const char * const names[3] = {
    "NONE",
    "CustomQuantization",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e) {
  if (::flatbuffers::IsOutRange(e, QuantizationDetails_NONE, QuantizationDetails_CustomQuantization)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizationDetails()[index];
}

template<typename T> struct QuantizationDetailsTraits {
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template<> struct QuantizationDetailsTraits<tflite::CustomQuantization> {
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

template<typename T> struct QuantizationDetailsUnionTraits {
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template<> struct QuantizationDetailsUnionTraits<tflite::CustomQuantizationT> {
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

struct QuantizationDetailsUnion {
  QuantizationDetails type;
  void *value;

  QuantizationDetailsUnion() : type(QuantizationDetails_NONE), value(nullptr) {}
  QuantizationDetailsUnion(QuantizationDetailsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(QuantizationDetails_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  QuantizationDetailsUnion(const QuantizationDetailsUnion &);
  QuantizationDetailsUnion &operator=(const QuantizationDetailsUnion &u)
    { QuantizationDetailsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  QuantizationDetailsUnion &operator=(QuantizationDetailsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~QuantizationDetailsUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = QuantizationDetailsUnionTraits<RT>::enum_value;
    if (type != QuantizationDetails_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, QuantizationDetails type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::CustomQuantizationT *AsCustomQuantization() {
    return type == QuantizationDetails_CustomQuantization ?
      reinterpret_cast<tflite::CustomQuantizationT *>(value) : nullptr;
  }
  const tflite::CustomQuantizationT *AsCustomQuantization() const {
    return type == QuantizationDetails_CustomQuantization ?
      reinterpret_cast<const tflite::CustomQuantizationT *>(value) : nullptr;
  }
};

bool VerifyQuantizationDetails(::flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);
bool VerifyQuantizationDetailsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum DimensionType : int8_t {
  DimensionType_DENSE = 0,
  DimensionType_SPARSE_CSR = 1,
  DimensionType_MIN = DimensionType_DENSE,
  DimensionType_MAX = DimensionType_SPARSE_CSR
};

inline const DimensionType (&EnumValuesDimensionType())[2] {
  static const DimensionType values[] = {
    DimensionType_DENSE,
    DimensionType_SPARSE_CSR
  };
  return values;
}

inline const char * const *EnumNamesDimensionType() {
  static const char * const names[3] = {
    "DENSE",
    "SPARSE_CSR",
    nullptr
  };
  return names;
}

inline const char *EnumNameDimensionType(DimensionType e) {
  if (::flatbuffers::IsOutRange(e, DimensionType_DENSE, DimensionType_SPARSE_CSR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionType()[index];
}

enum SparseIndexVector : uint8_t {
  SparseIndexVector_NONE = 0,
  SparseIndexVector_Int32Vector = 1,
  SparseIndexVector_Uint16Vector = 2,
  SparseIndexVector_Uint8Vector = 3,
  SparseIndexVector_MIN = SparseIndexVector_NONE,
  SparseIndexVector_MAX = SparseIndexVector_Uint8Vector
};

inline const SparseIndexVector (&EnumValuesSparseIndexVector())[4] {
  static const SparseIndexVector values[] = {
    SparseIndexVector_NONE,
    SparseIndexVector_Int32Vector,
    SparseIndexVector_Uint16Vector,
    SparseIndexVector_Uint8Vector
  };
  return values;
}

inline const char * const *EnumNamesSparseIndexVector() {
  static const char * const names[5] = {
    "NONE",
    "Int32Vector",
    "Uint16Vector",
    "Uint8Vector",
    nullptr
  };
  return names;
}

inline const char *EnumNameSparseIndexVector(SparseIndexVector e) {
  if (::flatbuffers::IsOutRange(e, SparseIndexVector_NONE, SparseIndexVector_Uint8Vector)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSparseIndexVector()[index];
}

template<typename T> struct SparseIndexVectorTraits {
  static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template<> struct SparseIndexVectorTraits<tflite::Int32Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template<> struct SparseIndexVectorTraits<tflite::Uint16Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template<> struct SparseIndexVectorTraits<tflite::Uint8Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

template<typename T> struct SparseIndexVectorUnionTraits {
  static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template<> struct SparseIndexVectorUnionTraits<tflite::Int32VectorT> {
  static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template<> struct SparseIndexVectorUnionTraits<tflite::Uint16VectorT> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template<> struct SparseIndexVectorUnionTraits<tflite::Uint8VectorT> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

struct SparseIndexVectorUnion {
  SparseIndexVector type;
  void *value;

  SparseIndexVectorUnion() : type(SparseIndexVector_NONE), value(nullptr) {}
  SparseIndexVectorUnion(SparseIndexVectorUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(SparseIndexVector_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  SparseIndexVectorUnion(const SparseIndexVectorUnion &);
  SparseIndexVectorUnion &operator=(const SparseIndexVectorUnion &u)
    { SparseIndexVectorUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  SparseIndexVectorUnion &operator=(SparseIndexVectorUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~SparseIndexVectorUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = SparseIndexVectorUnionTraits<RT>::enum_value;
    if (type != SparseIndexVector_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, SparseIndexVector type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::Int32VectorT *AsInt32Vector() {
    return type == SparseIndexVector_Int32Vector ?
      reinterpret_cast<tflite::Int32VectorT *>(value) : nullptr;
  }
  const tflite::Int32VectorT *AsInt32Vector() const {
    return type == SparseIndexVector_Int32Vector ?
      reinterpret_cast<const tflite::Int32VectorT *>(value) : nullptr;
  }
  tflite::Uint16VectorT *AsUint16Vector() {
    return type == SparseIndexVector_Uint16Vector ?
      reinterpret_cast<tflite::Uint16VectorT *>(value) : nullptr;
  }
  const tflite::Uint16VectorT *AsUint16Vector() const {
    return type == SparseIndexVector_Uint16Vector ?
      reinterpret_cast<const tflite::Uint16VectorT *>(value) : nullptr;
  }
  tflite::Uint8VectorT *AsUint8Vector() {
    return type == SparseIndexVector_Uint8Vector ?
      reinterpret_cast<tflite::Uint8VectorT *>(value) : nullptr;
  }
  const tflite::Uint8VectorT *AsUint8Vector() const {
    return type == SparseIndexVector_Uint8Vector ?
      reinterpret_cast<const tflite::Uint8VectorT *>(value) : nullptr;
  }
};

bool VerifySparseIndexVector(::flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type);
bool VerifySparseIndexVectorVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator : int32_t {
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEPTH_TO_SPACE = 5,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_UNIQUE = 103,
  BuiltinOperator_CEIL = 104,
  BuiltinOperator_REVERSE_V2 = 105,
  BuiltinOperator_ADD_N = 106,
  BuiltinOperator_GATHER_ND = 107,
  BuiltinOperator_COS = 108,
  BuiltinOperator_WHERE = 109,
  BuiltinOperator_RANK = 110,
  BuiltinOperator_ELU = 111,
  BuiltinOperator_REVERSE_SEQUENCE = 112,
  BuiltinOperator_MATRIX_DIAG = 113,
  BuiltinOperator_QUANTIZE = 114,
  BuiltinOperator_MATRIX_SET_DIAG = 115,
  BuiltinOperator_ROUND = 116,
  BuiltinOperator_HARD_SWISH = 117,
  BuiltinOperator_IF = 118,
  BuiltinOperator_WHILE = 119,
  BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
  BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
  BuiltinOperator_SCATTER_ND = 122,
  BuiltinOperator_SELECT_V2 = 123,
  BuiltinOperator_DENSIFY = 124,
  BuiltinOperator_SEGMENT_SUM = 125,
  BuiltinOperator_BATCH_MATMUL = 126,
  BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  BuiltinOperator_CUMSUM = 128,
  BuiltinOperator_CALL_ONCE = 129,
  BuiltinOperator_BROADCAST_TO = 130,
  BuiltinOperator_RFFT2D = 131,
  BuiltinOperator_CONV_3D = 132,
  BuiltinOperator_IMAG = 133,
  BuiltinOperator_REAL = 134,
  BuiltinOperator_COMPLEX_ABS = 135,
  BuiltinOperator_HASHTABLE = 136,
  BuiltinOperator_HASHTABLE_FIND = 137,
  BuiltinOperator_HASHTABLE_IMPORT = 138,
  BuiltinOperator_HASHTABLE_SIZE = 139,
  BuiltinOperator_REDUCE_ALL = 140,
  BuiltinOperator_CONV_3D_TRANSPOSE = 141,
  BuiltinOperator_VAR_HANDLE = 142,
  BuiltinOperator_READ_VARIABLE = 143,
  BuiltinOperator_ASSIGN_VARIABLE = 144,
  BuiltinOperator_BROADCAST_ARGS = 145,
  BuiltinOperator_RANDOM_STANDARD_NORMAL = 146,
  BuiltinOperator_BUCKETIZE = 147,
  BuiltinOperator_RANDOM_UNIFORM = 148,
  BuiltinOperator_MULTINOMIAL = 149,
  BuiltinOperator_GELU = 150,
  BuiltinOperator_DYNAMIC_UPDATE_SLICE = 151,
  BuiltinOperator_RELU_0_TO_1 = 152,
  BuiltinOperator_UNSORTED_SEGMENT_PROD = 153,
  BuiltinOperator_UNSORTED_SEGMENT_MAX = 154,
  BuiltinOperator_UNSORTED_SEGMENT_SUM = 155,
  BuiltinOperator_ATAN2 = 156,
  BuiltinOperator_UNSORTED_SEGMENT_MIN = 157,
  BuiltinOperator_SIGN = 158,
  BuiltinOperator_BITCAST = 159,
  BuiltinOperator_BITWISE_XOR = 160,
  BuiltinOperator_RIGHT_SHIFT = 161,
  BuiltinOperator_STABLEHLO_LOGISTIC = 162,
  BuiltinOperator_STABLEHLO_ADD = 163,
  BuiltinOperator_STABLEHLO_DIVIDE = 164,
  BuiltinOperator_STABLEHLO_MULTIPLY = 165,
  BuiltinOperator_STABLEHLO_MAXIMUM = 166,
  BuiltinOperator_STABLEHLO_RESHAPE = 167,
  BuiltinOperator_STABLEHLO_CLAMP = 168,
  BuiltinOperator_STABLEHLO_CONCATENATE = 169,
  BuiltinOperator_STABLEHLO_BROADCAST_IN_DIM = 170,
  BuiltinOperator_STABLEHLO_CONVOLUTION = 171,
  BuiltinOperator_STABLEHLO_SLICE = 172,
  BuiltinOperator_STABLEHLO_CUSTOM_CALL = 173,
  BuiltinOperator_STABLEHLO_REDUCE = 174,
  BuiltinOperator_STABLEHLO_ABS = 175,
  BuiltinOperator_STABLEHLO_AND = 176,
  BuiltinOperator_STABLEHLO_COSINE = 177,
  BuiltinOperator_STABLEHLO_EXPONENTIAL = 178,
  BuiltinOperator_STABLEHLO_FLOOR = 179,
  BuiltinOperator_STABLEHLO_LOG = 180,
  BuiltinOperator_STABLEHLO_MINIMUM = 181,
  BuiltinOperator_STABLEHLO_NEGATE = 182,
  BuiltinOperator_STABLEHLO_OR = 183,
  BuiltinOperator_STABLEHLO_POWER = 184,
  BuiltinOperator_STABLEHLO_REMAINDER = 185,
  BuiltinOperator_STABLEHLO_RSQRT = 186,
  BuiltinOperator_STABLEHLO_SELECT = 187,
  BuiltinOperator_STABLEHLO_SUBTRACT = 188,
  BuiltinOperator_STABLEHLO_TANH = 189,
  BuiltinOperator_STABLEHLO_SCATTER = 190,
  BuiltinOperator_STABLEHLO_COMPARE = 191,
  BuiltinOperator_STABLEHLO_CONVERT = 192,
  BuiltinOperator_STABLEHLO_DYNAMIC_SLICE = 193,
  BuiltinOperator_STABLEHLO_DYNAMIC_UPDATE_SLICE = 194,
  BuiltinOperator_STABLEHLO_PAD = 195,
  BuiltinOperator_STABLEHLO_IOTA = 196,
  BuiltinOperator_STABLEHLO_DOT_GENERAL = 197,
  BuiltinOperator_STABLEHLO_REDUCE_WINDOW = 198,
  BuiltinOperator_STABLEHLO_SORT = 199,
  BuiltinOperator_STABLEHLO_WHILE = 200,
  BuiltinOperator_STABLEHLO_GATHER = 201,
  BuiltinOperator_STABLEHLO_TRANSPOSE = 202,
  BuiltinOperator_DILATE = 203,
  BuiltinOperator_STABLEHLO_RNG_BIT_GENERATOR = 204,
  BuiltinOperator_REDUCE_WINDOW = 205,
  BuiltinOperator_STABLEHLO_COMPOSITE = 206,
  BuiltinOperator_MIN = BuiltinOperator_ADD,
  BuiltinOperator_MAX = BuiltinOperator_STABLEHLO_COMPOSITE
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[207] {
  static const BuiltinOperator values[] = {
    BuiltinOperator_ADD,
    BuiltinOperator_AVERAGE_POOL_2D,
    BuiltinOperator_CONCATENATION,
    BuiltinOperator_CONV_2D,
    BuiltinOperator_DEPTHWISE_CONV_2D,
    BuiltinOperator_DEPTH_TO_SPACE,
    BuiltinOperator_DEQUANTIZE,
    BuiltinOperator_EMBEDDING_LOOKUP,
    BuiltinOperator_FLOOR,
    BuiltinOperator_FULLY_CONNECTED,
    BuiltinOperator_HASHTABLE_LOOKUP,
    BuiltinOperator_L2_NORMALIZATION,
    BuiltinOperator_L2_POOL_2D,
    BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
    BuiltinOperator_LOGISTIC,
    BuiltinOperator_LSH_PROJECTION,
    BuiltinOperator_LSTM,
    BuiltinOperator_MAX_POOL_2D,
    BuiltinOperator_MUL,
    BuiltinOperator_RELU,
    BuiltinOperator_RELU_N1_TO_1,
    BuiltinOperator_RELU6,
    BuiltinOperator_RESHAPE,
    BuiltinOperator_RESIZE_BILINEAR,
    BuiltinOperator_RNN,
    BuiltinOperator_SOFTMAX,
    BuiltinOperator_SPACE_TO_DEPTH,
    BuiltinOperator_SVDF,
    BuiltinOperator_TANH,
    BuiltinOperator_CONCAT_EMBEDDINGS,
    BuiltinOperator_SKIP_GRAM,
    BuiltinOperator_CALL,
    BuiltinOperator_CUSTOM,
    BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
    BuiltinOperator_PAD,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_GATHER,
    BuiltinOperator_BATCH_TO_SPACE_ND,
    BuiltinOperator_SPACE_TO_BATCH_ND,
    BuiltinOperator_TRANSPOSE,
    BuiltinOperator_MEAN,
    BuiltinOperator_SUB,
    BuiltinOperator_DIV,
    BuiltinOperator_SQUEEZE,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_STRIDED_SLICE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_EXP,
    BuiltinOperator_TOPK_V2,
    BuiltinOperator_SPLIT,
    BuiltinOperator_LOG_SOFTMAX,
    BuiltinOperator_DELEGATE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_CAST,
    BuiltinOperator_PRELU,
    BuiltinOperator_MAXIMUM,
    BuiltinOperator_ARG_MAX,
    BuiltinOperator_MINIMUM,
    BuiltinOperator_LESS,
    BuiltinOperator_NEG,
    BuiltinOperator_PADV2,
    BuiltinOperator_GREATER,
    BuiltinOperator_GREATER_EQUAL,
    BuiltinOperator_LESS_EQUAL,
    BuiltinOperator_SELECT,
    BuiltinOperator_SLICE,
    BuiltinOperator_SIN,
    BuiltinOperator_TRANSPOSE_CONV,
    BuiltinOperator_SPARSE_TO_DENSE,
    BuiltinOperator_TILE,
    BuiltinOperator_EXPAND_DIMS,
    BuiltinOperator_EQUAL,
    BuiltinOperator_NOT_EQUAL,
    BuiltinOperator_LOG,
    BuiltinOperator_SUM,
    BuiltinOperator_SQRT,
    BuiltinOperator_RSQRT,
    BuiltinOperator_SHAPE,
    BuiltinOperator_POW,
    BuiltinOperator_ARG_MIN,
    BuiltinOperator_FAKE_QUANT,
    BuiltinOperator_REDUCE_PROD,
    BuiltinOperator_REDUCE_MAX,
    BuiltinOperator_PACK,
    BuiltinOperator_LOGICAL_OR,
    BuiltinOperator_ONE_HOT,
    BuiltinOperator_LOGICAL_AND,
    BuiltinOperator_LOGICAL_NOT,
    BuiltinOperator_UNPACK,
    BuiltinOperator_REDUCE_MIN,
    BuiltinOperator_FLOOR_DIV,
    BuiltinOperator_REDUCE_ANY,
    BuiltinOperator_SQUARE,
    BuiltinOperator_ZEROS_LIKE,
    BuiltinOperator_FILL,
    BuiltinOperator_FLOOR_MOD,
    BuiltinOperator_RANGE,
    BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
    BuiltinOperator_LEAKY_RELU,
    BuiltinOperator_SQUARED_DIFFERENCE,
    BuiltinOperator_MIRROR_PAD,
    BuiltinOperator_ABS,
    BuiltinOperator_SPLIT_V,
    BuiltinOperator_UNIQUE,
    BuiltinOperator_CEIL,
    BuiltinOperator_REVERSE_V2,
    BuiltinOperator_ADD_N,
    BuiltinOperator_GATHER_ND,
    BuiltinOperator_COS,
    BuiltinOperator_WHERE,
    BuiltinOperator_RANK,
    BuiltinOperator_ELU,
    BuiltinOperator_REVERSE_SEQUENCE,
    BuiltinOperator_MATRIX_DIAG,
    BuiltinOperator_QUANTIZE,
    BuiltinOperator_MATRIX_SET_DIAG,
    BuiltinOperator_ROUND,
    BuiltinOperator_HARD_SWISH,
    BuiltinOperator_IF,
    BuiltinOperator_WHILE,
    BuiltinOperator_NON_MAX_SUPPRESSION_V4,
    BuiltinOperator_NON_MAX_SUPPRESSION_V5,
    BuiltinOperator_SCATTER_ND,
    BuiltinOperator_SELECT_V2,
    BuiltinOperator_DENSIFY,
    BuiltinOperator_SEGMENT_SUM,
    BuiltinOperator_BATCH_MATMUL,
    BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES,
    BuiltinOperator_CUMSUM,
    BuiltinOperator_CALL_ONCE,
    BuiltinOperator_BROADCAST_TO,
    BuiltinOperator_RFFT2D,
    BuiltinOperator_CONV_3D,
    BuiltinOperator_IMAG,
    BuiltinOperator_REAL,
    BuiltinOperator_COMPLEX_ABS,
    BuiltinOperator_HASHTABLE,
    BuiltinOperator_HASHTABLE_FIND,
    BuiltinOperator_HASHTABLE_IMPORT,
    BuiltinOperator_HASHTABLE_SIZE,
    BuiltinOperator_REDUCE_ALL,
    BuiltinOperator_CONV_3D_TRANSPOSE,
    BuiltinOperator_VAR_HANDLE,
    BuiltinOperator_READ_VARIABLE,
    BuiltinOperator_ASSIGN_VARIABLE,
    BuiltinOperator_BROADCAST_ARGS,
    BuiltinOperator_RANDOM_STANDARD_NORMAL,
    BuiltinOperator_BUCKETIZE,
    BuiltinOperator_RANDOM_UNIFORM,
    BuiltinOperator_MULTINOMIAL,
    BuiltinOperator_GELU,
    BuiltinOperator_DYNAMIC_UPDATE_SLICE,
    BuiltinOperator_RELU_0_TO_1,
    BuiltinOperator_UNSORTED_SEGMENT_PROD,
    BuiltinOperator_UNSORTED_SEGMENT_MAX,
    BuiltinOperator_UNSORTED_SEGMENT_SUM,
    BuiltinOperator_ATAN2,
    BuiltinOperator_UNSORTED_SEGMENT_MIN,
    BuiltinOperator_SIGN,
    BuiltinOperator_BITCAST,
    BuiltinOperator_BITWISE_XOR,
    BuiltinOperator_RIGHT_SHIFT,
    BuiltinOperator_STABLEHLO_LOGISTIC,
    BuiltinOperator_STABLEHLO_ADD,
    BuiltinOperator_STABLEHLO_DIVIDE,
    BuiltinOperator_STABLEHLO_MULTIPLY,
    BuiltinOperator_STABLEHLO_MAXIMUM,
    BuiltinOperator_STABLEHLO_RESHAPE,
    BuiltinOperator_STABLEHLO_CLAMP,
    BuiltinOperator_STABLEHLO_CONCATENATE,
    BuiltinOperator_STABLEHLO_BROADCAST_IN_DIM,
    BuiltinOperator_STABLEHLO_CONVOLUTION,
    BuiltinOperator_STABLEHLO_SLICE,
    BuiltinOperator_STABLEHLO_CUSTOM_CALL,
    BuiltinOperator_STABLEHLO_REDUCE,
    BuiltinOperator_STABLEHLO_ABS,
    BuiltinOperator_STABLEHLO_AND,
    BuiltinOperator_STABLEHLO_COSINE,
    BuiltinOperator_STABLEHLO_EXPONENTIAL,
    BuiltinOperator_STABLEHLO_FLOOR,
    BuiltinOperator_STABLEHLO_LOG,
    BuiltinOperator_STABLEHLO_MINIMUM,
    BuiltinOperator_STABLEHLO_NEGATE,
    BuiltinOperator_STABLEHLO_OR,
    BuiltinOperator_STABLEHLO_POWER,
    BuiltinOperator_STABLEHLO_REMAINDER,
    BuiltinOperator_STABLEHLO_RSQRT,
    BuiltinOperator_STABLEHLO_SELECT,
    BuiltinOperator_STABLEHLO_SUBTRACT,
    BuiltinOperator_STABLEHLO_TANH,
    BuiltinOperator_STABLEHLO_SCATTER,
    BuiltinOperator_STABLEHLO_COMPARE,
    BuiltinOperator_STABLEHLO_CONVERT,
    BuiltinOperator_STABLEHLO_DYNAMIC_SLICE,
    BuiltinOperator_STABLEHLO_DYNAMIC_UPDATE_SLICE,
    BuiltinOperator_STABLEHLO_PAD,
    BuiltinOperator_STABLEHLO_IOTA,
    BuiltinOperator_STABLEHLO_DOT_GENERAL,
    BuiltinOperator_STABLEHLO_REDUCE_WINDOW,
    BuiltinOperator_STABLEHLO_SORT,
    BuiltinOperator_STABLEHLO_WHILE,
    BuiltinOperator_STABLEHLO_GATHER,
    BuiltinOperator_STABLEHLO_TRANSPOSE,
    BuiltinOperator_DILATE,
    BuiltinOperator_STABLEHLO_RNG_BIT_GENERATOR,
    BuiltinOperator_REDUCE_WINDOW,
    BuiltinOperator_STABLEHLO_COMPOSITE
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOperator() {
  static const char * const names[208] = {
    "ADD",
    "AVERAGE_POOL_2D",
    "CONCATENATION",
    "CONV_2D",
    "DEPTHWISE_CONV_2D",
    "DEPTH_TO_SPACE",
    "DEQUANTIZE",
    "EMBEDDING_LOOKUP",
    "FLOOR",
    "FULLY_CONNECTED",
    "HASHTABLE_LOOKUP",
    "L2_NORMALIZATION",
    "L2_POOL_2D",
    "LOCAL_RESPONSE_NORMALIZATION",
    "LOGISTIC",
    "LSH_PROJECTION",
    "LSTM",
    "MAX_POOL_2D",
    "MUL",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "RESHAPE",
    "RESIZE_BILINEAR",
    "RNN",
    "SOFTMAX",
    "SPACE_TO_DEPTH",
    "SVDF",
    "TANH",
    "CONCAT_EMBEDDINGS",
    "SKIP_GRAM",
    "CALL",
    "CUSTOM",
    "EMBEDDING_LOOKUP_SPARSE",
    "PAD",
    "UNIDIRECTIONAL_SEQUENCE_RNN",
    "GATHER",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "TRANSPOSE",
    "MEAN",
    "SUB",
    "DIV",
    "SQUEEZE",
    "UNIDIRECTIONAL_SEQUENCE_LSTM",
    "STRIDED_SLICE",
    "BIDIRECTIONAL_SEQUENCE_RNN",
    "EXP",
    "TOPK_V2",
    "SPLIT",
    "LOG_SOFTMAX",
    "DELEGATE",
    "BIDIRECTIONAL_SEQUENCE_LSTM",
    "CAST",
    "PRELU",
    "MAXIMUM",
    "ARG_MAX",
    "MINIMUM",
    "LESS",
    "NEG",
    "PADV2",
    "GREATER",
    "GREATER_EQUAL",
    "LESS_EQUAL",
    "SELECT",
    "SLICE",
    "SIN",
    "TRANSPOSE_CONV",
    "SPARSE_TO_DENSE",
    "TILE",
    "EXPAND_DIMS",
    "EQUAL",
    "NOT_EQUAL",
    "LOG",
    "SUM",
    "SQRT",
    "RSQRT",
    "SHAPE",
    "POW",
    "ARG_MIN",
    "FAKE_QUANT",
    "REDUCE_PROD",
    "REDUCE_MAX",
    "PACK",
    "LOGICAL_OR",
    "ONE_HOT",
    "LOGICAL_AND",
    "LOGICAL_NOT",
    "UNPACK",
    "REDUCE_MIN",
    "FLOOR_DIV",
    "REDUCE_ANY",
    "SQUARE",
    "ZEROS_LIKE",
    "FILL",
    "FLOOR_MOD",
    "RANGE",
    "RESIZE_NEAREST_NEIGHBOR",
    "LEAKY_RELU",
    "SQUARED_DIFFERENCE",
    "MIRROR_PAD",
    "ABS",
    "SPLIT_V",
    "UNIQUE",
    "CEIL",
    "REVERSE_V2",
    "ADD_N",
    "GATHER_ND",
    "COS",
    "WHERE",
    "RANK",
    "ELU",
    "REVERSE_SEQUENCE",
    "MATRIX_DIAG",
    "QUANTIZE",
    "MATRIX_SET_DIAG",
    "ROUND",
    "HARD_SWISH",
    "IF",
    "WHILE",
    "NON_MAX_SUPPRESSION_V4",
    "NON_MAX_SUPPRESSION_V5",
    "SCATTER_ND",
    "SELECT_V2",
    "DENSIFY",
    "SEGMENT_SUM",
    "BATCH_MATMUL",
    "PLACEHOLDER_FOR_GREATER_OP_CODES",
    "CUMSUM",
    "CALL_ONCE",
    "BROADCAST_TO",
    "RFFT2D",
    "CONV_3D",
    "IMAG",
    "REAL",
    "COMPLEX_ABS",
    "HASHTABLE",
    "HASHTABLE_FIND",
    "HASHTABLE_IMPORT",
    "HASHTABLE_SIZE",
    "REDUCE_ALL",
    "CONV_3D_TRANSPOSE",
    "VAR_HANDLE",
    "READ_VARIABLE",
    "ASSIGN_VARIABLE",
    "BROADCAST_ARGS",
    "RANDOM_STANDARD_NORMAL",
    "BUCKETIZE",
    "RANDOM_UNIFORM",
    "MULTINOMIAL",
    "GELU",
    "DYNAMIC_UPDATE_SLICE",
    "RELU_0_TO_1",
    "UNSORTED_SEGMENT_PROD",
    "UNSORTED_SEGMENT_MAX",
    "UNSORTED_SEGMENT_SUM",
    "ATAN2",
    "UNSORTED_SEGMENT_MIN",
    "SIGN",
    "BITCAST",
    "BITWISE_XOR",
    "RIGHT_SHIFT",
    "STABLEHLO_LOGISTIC",
    "STABLEHLO_ADD",
    "STABLEHLO_DIVIDE",
    "STABLEHLO_MULTIPLY",
    "STABLEHLO_MAXIMUM",
    "STABLEHLO_RESHAPE",
    "STABLEHLO_CLAMP",
    "STABLEHLO_CONCATENATE",
    "STABLEHLO_BROADCAST_IN_DIM",
    "STABLEHLO_CONVOLUTION",
    "STABLEHLO_SLICE",
    "STABLEHLO_CUSTOM_CALL",
    "STABLEHLO_REDUCE",
    "STABLEHLO_ABS",
    "STABLEHLO_AND",
    "STABLEHLO_COSINE",
    "STABLEHLO_EXPONENTIAL",
    "STABLEHLO_FLOOR",
    "STABLEHLO_LOG",
    "STABLEHLO_MINIMUM",
    "STABLEHLO_NEGATE",
    "STABLEHLO_OR",
    "STABLEHLO_POWER",
    "STABLEHLO_REMAINDER",
    "STABLEHLO_RSQRT",
    "STABLEHLO_SELECT",
    "STABLEHLO_SUBTRACT",
    "STABLEHLO_TANH",
    "STABLEHLO_SCATTER",
    "STABLEHLO_COMPARE",
    "STABLEHLO_CONVERT",
    "STABLEHLO_DYNAMIC_SLICE",
    "STABLEHLO_DYNAMIC_UPDATE_SLICE",
    "STABLEHLO_PAD",
    "STABLEHLO_IOTA",
    "STABLEHLO_DOT_GENERAL",
    "STABLEHLO_REDUCE_WINDOW",
    "STABLEHLO_SORT",
    "STABLEHLO_WHILE",
    "STABLEHLO_GATHER",
    "STABLEHLO_TRANSPOSE",
    "DILATE",
    "STABLEHLO_RNG_BIT_GENERATOR",
    "REDUCE_WINDOW",
    "STABLEHLO_COMPOSITE",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {
  if (::flatbuffers::IsOutRange(e, BuiltinOperator_ADD, BuiltinOperator_STABLEHLO_COMPOSITE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions : uint8_t {
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_UniqueOptions = 80,
  BuiltinOptions_ReverseV2Options = 81,
  BuiltinOptions_AddNOptions = 82,
  BuiltinOptions_GatherNdOptions = 83,
  BuiltinOptions_CosOptions = 84,
  BuiltinOptions_WhereOptions = 85,
  BuiltinOptions_RankOptions = 86,
  BuiltinOptions_ReverseSequenceOptions = 87,
  BuiltinOptions_MatrixDiagOptions = 88,
  BuiltinOptions_QuantizeOptions = 89,
  BuiltinOptions_MatrixSetDiagOptions = 90,
  BuiltinOptions_HardSwishOptions = 91,
  BuiltinOptions_IfOptions = 92,
  BuiltinOptions_WhileOptions = 93,
  BuiltinOptions_DepthToSpaceOptions = 94,
  BuiltinOptions_NonMaxSuppressionV4Options = 95,
  BuiltinOptions_NonMaxSuppressionV5Options = 96,
  BuiltinOptions_ScatterNdOptions = 97,
  BuiltinOptions_SelectV2Options = 98,
  BuiltinOptions_DensifyOptions = 99,
  BuiltinOptions_SegmentSumOptions = 100,
  BuiltinOptions_BatchMatMulOptions = 101,
  BuiltinOptions_CumsumOptions = 102,
  BuiltinOptions_CallOnceOptions = 103,
  BuiltinOptions_BroadcastToOptions = 104,
  BuiltinOptions_Rfft2dOptions = 105,
  BuiltinOptions_Conv3DOptions = 106,
  BuiltinOptions_HashtableOptions = 107,
  BuiltinOptions_HashtableFindOptions = 108,
  BuiltinOptions_HashtableImportOptions = 109,
  BuiltinOptions_HashtableSizeOptions = 110,
  BuiltinOptions_VarHandleOptions = 111,
  BuiltinOptions_ReadVariableOptions = 112,
  BuiltinOptions_AssignVariableOptions = 113,
  BuiltinOptions_RandomOptions = 114,
  BuiltinOptions_BucketizeOptions = 115,
  BuiltinOptions_GeluOptions = 116,
  BuiltinOptions_DynamicUpdateSliceOptions = 117,
  BuiltinOptions_UnsortedSegmentProdOptions = 118,
  BuiltinOptions_UnsortedSegmentMaxOptions = 119,
  BuiltinOptions_UnsortedSegmentMinOptions = 120,
  BuiltinOptions_UnsortedSegmentSumOptions = 121,
  BuiltinOptions_ATan2Options = 122,
  BuiltinOptions_SignOptions = 123,
  BuiltinOptions_BitcastOptions = 124,
  BuiltinOptions_BitwiseXorOptions = 125,
  BuiltinOptions_RightShiftOptions = 126,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_RightShiftOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[127] {
  static const BuiltinOptions values[] = {
    BuiltinOptions_NONE,
    BuiltinOptions_Conv2DOptions,
    BuiltinOptions_DepthwiseConv2DOptions,
    BuiltinOptions_ConcatEmbeddingsOptions,
    BuiltinOptions_LSHProjectionOptions,
    BuiltinOptions_Pool2DOptions,
    BuiltinOptions_SVDFOptions,
    BuiltinOptions_RNNOptions,
    BuiltinOptions_FullyConnectedOptions,
    BuiltinOptions_SoftmaxOptions,
    BuiltinOptions_ConcatenationOptions,
    BuiltinOptions_AddOptions,
    BuiltinOptions_L2NormOptions,
    BuiltinOptions_LocalResponseNormalizationOptions,
    BuiltinOptions_LSTMOptions,
    BuiltinOptions_ResizeBilinearOptions,
    BuiltinOptions_CallOptions,
    BuiltinOptions_ReshapeOptions,
    BuiltinOptions_SkipGramOptions,
    BuiltinOptions_SpaceToDepthOptions,
    BuiltinOptions_EmbeddingLookupSparseOptions,
    BuiltinOptions_MulOptions,
    BuiltinOptions_PadOptions,
    BuiltinOptions_GatherOptions,
    BuiltinOptions_BatchToSpaceNDOptions,
    BuiltinOptions_SpaceToBatchNDOptions,
    BuiltinOptions_TransposeOptions,
    BuiltinOptions_ReducerOptions,
    BuiltinOptions_SubOptions,
    BuiltinOptions_DivOptions,
    BuiltinOptions_SqueezeOptions,
    BuiltinOptions_SequenceRNNOptions,
    BuiltinOptions_StridedSliceOptions,
    BuiltinOptions_ExpOptions,
    BuiltinOptions_TopKV2Options,
    BuiltinOptions_SplitOptions,
    BuiltinOptions_LogSoftmaxOptions,
    BuiltinOptions_CastOptions,
    BuiltinOptions_DequantizeOptions,
    BuiltinOptions_MaximumMinimumOptions,
    BuiltinOptions_ArgMaxOptions,
    BuiltinOptions_LessOptions,
    BuiltinOptions_NegOptions,
    BuiltinOptions_PadV2Options,
    BuiltinOptions_GreaterOptions,
    BuiltinOptions_GreaterEqualOptions,
    BuiltinOptions_LessEqualOptions,
    BuiltinOptions_SelectOptions,
    BuiltinOptions_SliceOptions,
    BuiltinOptions_TransposeConvOptions,
    BuiltinOptions_SparseToDenseOptions,
    BuiltinOptions_TileOptions,
    BuiltinOptions_ExpandDimsOptions,
    BuiltinOptions_EqualOptions,
    BuiltinOptions_NotEqualOptions,
    BuiltinOptions_ShapeOptions,
    BuiltinOptions_PowOptions,
    BuiltinOptions_ArgMinOptions,
    BuiltinOptions_FakeQuantOptions,
    BuiltinOptions_PackOptions,
    BuiltinOptions_LogicalOrOptions,
    BuiltinOptions_OneHotOptions,
    BuiltinOptions_LogicalAndOptions,
    BuiltinOptions_LogicalNotOptions,
    BuiltinOptions_UnpackOptions,
    BuiltinOptions_FloorDivOptions,
    BuiltinOptions_SquareOptions,
    BuiltinOptions_ZerosLikeOptions,
    BuiltinOptions_FillOptions,
    BuiltinOptions_BidirectionalSequenceLSTMOptions,
    BuiltinOptions_BidirectionalSequenceRNNOptions,
    BuiltinOptions_UnidirectionalSequenceLSTMOptions,
    BuiltinOptions_FloorModOptions,
    BuiltinOptions_RangeOptions,
    BuiltinOptions_ResizeNearestNeighborOptions,
    BuiltinOptions_LeakyReluOptions,
    BuiltinOptions_SquaredDifferenceOptions,
    BuiltinOptions_MirrorPadOptions,
    BuiltinOptions_AbsOptions,
    BuiltinOptions_SplitVOptions,
    BuiltinOptions_UniqueOptions,
    BuiltinOptions_ReverseV2Options,
    BuiltinOptions_AddNOptions,
    BuiltinOptions_GatherNdOptions,
    BuiltinOptions_CosOptions,
    BuiltinOptions_WhereOptions,
    BuiltinOptions_RankOptions,
    BuiltinOptions_ReverseSequenceOptions,
    BuiltinOptions_MatrixDiagOptions,
    BuiltinOptions_QuantizeOptions,
    BuiltinOptions_MatrixSetDiagOptions,
    BuiltinOptions_HardSwishOptions,
    BuiltinOptions_IfOptions,
    BuiltinOptions_WhileOptions,
    BuiltinOptions_DepthToSpaceOptions,
    BuiltinOptions_NonMaxSuppressionV4Options,
    BuiltinOptions_NonMaxSuppressionV5Options,
    BuiltinOptions_ScatterNdOptions,
    BuiltinOptions_SelectV2Options,
    BuiltinOptions_DensifyOptions,
    BuiltinOptions_SegmentSumOptions,
    BuiltinOptions_BatchMatMulOptions,
    BuiltinOptions_CumsumOptions,
    BuiltinOptions_CallOnceOptions,
    BuiltinOptions_BroadcastToOptions,
    BuiltinOptions_Rfft2dOptions,
    BuiltinOptions_Conv3DOptions,
    BuiltinOptions_HashtableOptions,
    BuiltinOptions_HashtableFindOptions,
    BuiltinOptions_HashtableImportOptions,
    BuiltinOptions_HashtableSizeOptions,
    BuiltinOptions_VarHandleOptions,
    BuiltinOptions_ReadVariableOptions,
    BuiltinOptions_AssignVariableOptions,
    BuiltinOptions_RandomOptions,
    BuiltinOptions_BucketizeOptions,
    BuiltinOptions_GeluOptions,
    BuiltinOptions_DynamicUpdateSliceOptions,
    BuiltinOptions_UnsortedSegmentProdOptions,
    BuiltinOptions_UnsortedSegmentMaxOptions,
    BuiltinOptions_UnsortedSegmentMinOptions,
    BuiltinOptions_UnsortedSegmentSumOptions,
    BuiltinOptions_ATan2Options,
    BuiltinOptions_SignOptions,
    BuiltinOptions_BitcastOptions,
    BuiltinOptions_BitwiseXorOptions,
    BuiltinOptions_RightShiftOptions
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOptions() {
  static const char * const names[128] = {
    "NONE",
    "Conv2DOptions",
    "DepthwiseConv2DOptions",
    "ConcatEmbeddingsOptions",
    "LSHProjectionOptions",
    "Pool2DOptions",
    "SVDFOptions",
    "RNNOptions",
    "FullyConnectedOptions",
    "SoftmaxOptions",
    "ConcatenationOptions",
    "AddOptions",
    "L2NormOptions",
    "LocalResponseNormalizationOptions",
    "LSTMOptions",
    "ResizeBilinearOptions",
    "CallOptions",
    "ReshapeOptions",
    "SkipGramOptions",
    "SpaceToDepthOptions",
    "EmbeddingLookupSparseOptions",
    "MulOptions",
    "PadOptions",
    "GatherOptions",
    "BatchToSpaceNDOptions",
    "SpaceToBatchNDOptions",
    "TransposeOptions",
    "ReducerOptions",
    "SubOptions",
    "DivOptions",
    "SqueezeOptions",
    "SequenceRNNOptions",
    "StridedSliceOptions",
    "ExpOptions",
    "TopKV2Options",
    "SplitOptions",
    "LogSoftmaxOptions",
    "CastOptions",
    "DequantizeOptions",
    "MaximumMinimumOptions",
    "ArgMaxOptions",
    "LessOptions",
    "NegOptions",
    "PadV2Options",
    "GreaterOptions",
    "GreaterEqualOptions",
    "LessEqualOptions",
    "SelectOptions",
    "SliceOptions",
    "TransposeConvOptions",
    "SparseToDenseOptions",
    "TileOptions",
    "ExpandDimsOptions",
    "EqualOptions",
    "NotEqualOptions",
    "ShapeOptions",
    "PowOptions",
    "ArgMinOptions",
    "FakeQuantOptions",
    "PackOptions",
    "LogicalOrOptions",
    "OneHotOptions",
    "LogicalAndOptions",
    "LogicalNotOptions",
    "UnpackOptions",
    "FloorDivOptions",
    "SquareOptions",
    "ZerosLikeOptions",
    "FillOptions",
    "BidirectionalSequenceLSTMOptions",
    "BidirectionalSequenceRNNOptions",
    "UnidirectionalSequenceLSTMOptions",
    "FloorModOptions",
    "RangeOptions",
    "ResizeNearestNeighborOptions",
    "LeakyReluOptions",
    "SquaredDifferenceOptions",
    "MirrorPadOptions",
    "AbsOptions",
    "SplitVOptions",
    "UniqueOptions",
    "ReverseV2Options",
    "AddNOptions",
    "GatherNdOptions",
    "CosOptions",
    "WhereOptions",
    "RankOptions",
    "ReverseSequenceOptions",
    "MatrixDiagOptions",
    "QuantizeOptions",
    "MatrixSetDiagOptions",
    "HardSwishOptions",
    "IfOptions",
    "WhileOptions",
    "DepthToSpaceOptions",
    "NonMaxSuppressionV4Options",
    "NonMaxSuppressionV5Options",
    "ScatterNdOptions",
    "SelectV2Options",
    "DensifyOptions",
    "SegmentSumOptions",
    "BatchMatMulOptions",
    "CumsumOptions",
    "CallOnceOptions",
    "BroadcastToOptions",
    "Rfft2dOptions",
    "Conv3DOptions",
    "HashtableOptions",
    "HashtableFindOptions",
    "HashtableImportOptions",
    "HashtableSizeOptions",
    "VarHandleOptions",
    "ReadVariableOptions",
    "AssignVariableOptions",
    "RandomOptions",
    "BucketizeOptions",
    "GeluOptions",
    "DynamicUpdateSliceOptions",
    "UnsortedSegmentProdOptions",
    "UnsortedSegmentMaxOptions",
    "UnsortedSegmentMinOptions",
    "UnsortedSegmentSumOptions",
    "ATan2Options",
    "SignOptions",
    "BitcastOptions",
    "BitwiseXorOptions",
    "RightShiftOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {
  if (::flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_RightShiftOptions)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions()[index];
}

template<typename T> struct BuiltinOptionsTraits {
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template<> struct BuiltinOptionsTraits<tflite::Conv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DepthwiseConv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ConcatEmbeddingsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LSHProjectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template<> struct BuiltinOptionsTraits<tflite::Pool2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SVDFOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FullyConnectedOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ConcatenationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template<> struct BuiltinOptionsTraits<tflite::AddOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template<> struct BuiltinOptionsTraits<tflite::L2NormOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LocalResponseNormalizationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ResizeBilinearOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CallOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReshapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SkipGramOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SpaceToDepthOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template<> struct BuiltinOptionsTraits<tflite::EmbeddingLookupSparseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GatherOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BatchToSpaceNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SpaceToBatchNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TransposeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReducerOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SubOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SqueezeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::StridedSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ExpOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TopKV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::SplitOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogSoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DequantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MaximumMinimumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ArgMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LessOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template<> struct BuiltinOptionsTraits<tflite::NegOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PadV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::GreaterOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GreaterEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LessEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SelectOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TransposeConvOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SparseToDenseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ExpandDimsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::EqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::NotEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ShapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PowOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ArgMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FakeQuantOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalOrOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template<> struct BuiltinOptionsTraits<tflite::OneHotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalAndOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalNotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnpackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FloorDivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SquareOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ZerosLikeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FillOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BidirectionalSequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FloorModOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RangeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ResizeNearestNeighborOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LeakyReluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SquaredDifferenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MirrorPadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template<> struct BuiltinOptionsTraits<tflite::AbsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SplitVOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UniqueOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReverseV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::AddNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GatherNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CosOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template<> struct BuiltinOptionsTraits<tflite::WhereOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RankOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReverseSequenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MatrixDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template<> struct BuiltinOptionsTraits<tflite::QuantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MatrixSetDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HardSwishOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template<> struct BuiltinOptionsTraits<tflite::IfOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template<> struct BuiltinOptionsTraits<tflite::WhileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DepthToSpaceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::NonMaxSuppressionV4Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV4Options;
};

template<> struct BuiltinOptionsTraits<tflite::NonMaxSuppressionV5Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV5Options;
};

template<> struct BuiltinOptionsTraits<tflite::ScatterNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SelectV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::DensifyOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SegmentSumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BatchMatMulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CumsumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CumsumOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CallOnceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOnceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BroadcastToOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BroadcastToOptions;
};

template<> struct BuiltinOptionsTraits<tflite::Rfft2dOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Rfft2dOptions;
};

template<> struct BuiltinOptionsTraits<tflite::Conv3DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv3DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HashtableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HashtableFindOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableFindOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HashtableImportOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableImportOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HashtableSizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableSizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::VarHandleOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_VarHandleOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReadVariableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReadVariableOptions;
};

template<> struct BuiltinOptionsTraits<tflite::AssignVariableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AssignVariableOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RandomOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RandomOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BucketizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BucketizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GeluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GeluOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DynamicUpdateSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DynamicUpdateSliceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnsortedSegmentProdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentProdOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnsortedSegmentMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentMaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnsortedSegmentMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentMinOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnsortedSegmentSumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentSumOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ATan2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_ATan2Options;
};

template<> struct BuiltinOptionsTraits<tflite::SignOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SignOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BitcastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BitcastOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BitwiseXorOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BitwiseXorOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RightShiftOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RightShiftOptions;
};

template<typename T> struct BuiltinOptionsUnionTraits {
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template<> struct BuiltinOptionsUnionTraits<tflite::Conv2DOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::DepthwiseConv2DOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ConcatEmbeddingsOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LSHProjectionOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::Pool2DOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SVDFOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::RNNOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::FullyConnectedOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SoftmaxOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ConcatenationOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::AddOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::L2NormOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LocalResponseNormalizationOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LSTMOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ResizeBilinearOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::CallOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ReshapeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SkipGramOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SpaceToDepthOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::EmbeddingLookupSparseOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::MulOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::PadOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::GatherOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::BatchToSpaceNDOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SpaceToBatchNDOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::TransposeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ReducerOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SubOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::DivOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SqueezeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SequenceRNNOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::StridedSliceOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ExpOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::TopKV2OptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SplitOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LogSoftmaxOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::CastOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::DequantizeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::MaximumMinimumOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ArgMaxOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LessOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::NegOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::PadV2OptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template<> struct BuiltinOptionsUnionTraits<tflite::GreaterOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::GreaterEqualOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LessEqualOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SelectOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SliceOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::TransposeConvOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SparseToDenseOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::TileOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ExpandDimsOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::EqualOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::NotEqualOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ShapeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::PowOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ArgMinOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::FakeQuantOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::PackOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LogicalOrOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::OneHotOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LogicalAndOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LogicalNotOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::UnpackOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::FloorDivOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SquareOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ZerosLikeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::FillOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::BidirectionalSequenceLSTMOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::BidirectionalSequenceRNNOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::UnidirectionalSequenceLSTMOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::FloorModOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::RangeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ResizeNearestNeighborOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::LeakyReluOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SquaredDifferenceOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::MirrorPadOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::AbsOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SplitVOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::UniqueOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ReverseV2OptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template<> struct BuiltinOptionsUnionTraits<tflite::AddNOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::GatherNdOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::CosOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::WhereOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::RankOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ReverseSequenceOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::MatrixDiagOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::QuantizeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::MatrixSetDiagOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::HardSwishOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::IfOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::WhileOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::DepthToSpaceOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::NonMaxSuppressionV4OptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV4Options;
};

template<> struct BuiltinOptionsUnionTraits<tflite::NonMaxSuppressionV5OptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV5Options;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ScatterNdOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SelectV2OptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template<> struct BuiltinOptionsUnionTraits<tflite::DensifyOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SegmentSumOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::BatchMatMulOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::CumsumOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_CumsumOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::CallOnceOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOnceOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::BroadcastToOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_BroadcastToOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::Rfft2dOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_Rfft2dOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::Conv3DOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv3DOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::HashtableOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::HashtableFindOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableFindOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::HashtableImportOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableImportOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::HashtableSizeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableSizeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::VarHandleOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_VarHandleOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ReadVariableOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReadVariableOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::AssignVariableOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_AssignVariableOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::RandomOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_RandomOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::BucketizeOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_BucketizeOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::GeluOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_GeluOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::DynamicUpdateSliceOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_DynamicUpdateSliceOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::UnsortedSegmentProdOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentProdOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::UnsortedSegmentMaxOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentMaxOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::UnsortedSegmentMinOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentMinOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::UnsortedSegmentSumOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnsortedSegmentSumOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::ATan2OptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_ATan2Options;
};

template<> struct BuiltinOptionsUnionTraits<tflite::SignOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_SignOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::BitcastOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_BitcastOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::BitwiseXorOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_BitwiseXorOptions;
};

template<> struct BuiltinOptionsUnionTraits<tflite::RightShiftOptionsT> {
  static const BuiltinOptions enum_value = BuiltinOptions_RightShiftOptions;
};

struct BuiltinOptionsUnion {
  BuiltinOptions type;
  void *value;

  BuiltinOptionsUnion() : type(BuiltinOptions_NONE), value(nullptr) {}
  BuiltinOptionsUnion(BuiltinOptionsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BuiltinOptions_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BuiltinOptionsUnion(const BuiltinOptionsUnion &);
  BuiltinOptionsUnion &operator=(const BuiltinOptionsUnion &u)
    { BuiltinOptionsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BuiltinOptionsUnion &operator=(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BuiltinOptionsUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = BuiltinOptionsUnionTraits<RT>::enum_value;
    if (type != BuiltinOptions_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, BuiltinOptions type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::Conv2DOptionsT *AsConv2DOptions() {
    return type == BuiltinOptions_Conv2DOptions ?
      reinterpret_cast<tflite::Conv2DOptionsT *>(value) : nullptr;
  }
  const tflite::Conv2DOptionsT *AsConv2DOptions() const {
    return type == BuiltinOptions_Conv2DOptions ?
      reinterpret_cast<const tflite::Conv2DOptionsT *>(value) : nullptr;
  }
  tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() {
    return type == BuiltinOptions_DepthwiseConv2DOptions ?
      reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value) : nullptr;
  }
  const tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() const {
    return type == BuiltinOptions_DepthwiseConv2DOptions ?
      reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value) : nullptr;
  }
  tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() {
    return type == BuiltinOptions_ConcatEmbeddingsOptions ?
      reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value) : nullptr;
  }
  const tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() const {
    return type == BuiltinOptions_ConcatEmbeddingsOptions ?
      reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value) : nullptr;
  }
  tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() {
    return type == BuiltinOptions_LSHProjectionOptions ?
      reinterpret_cast<tflite::LSHProjectionOptionsT *>(value) : nullptr;
  }
  const tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() const {
    return type == BuiltinOptions_LSHProjectionOptions ?
      reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value) : nullptr;
  }
  tflite::Pool2DOptionsT *AsPool2DOptions() {
    return type == BuiltinOptions_Pool2DOptions ?
      reinterpret_cast<tflite::Pool2DOptionsT *>(value) : nullptr;
  }
  const tflite::Pool2DOptionsT *AsPool2DOptions() const {
    return type == BuiltinOptions_Pool2DOptions ?
      reinterpret_cast<const tflite::Pool2DOptionsT *>(value) : nullptr;
  }
  tflite::SVDFOptionsT *AsSVDFOptions() {
    return type == BuiltinOptions_SVDFOptions ?
      reinterpret_cast<tflite::SVDFOptionsT *>(value) : nullptr;
  }
  const tflite::SVDFOptionsT *AsSVDFOptions() const {
    return type == BuiltinOptions_SVDFOptions ?
      reinterpret_cast<const tflite::SVDFOptionsT *>(value) : nullptr;
  }
  tflite::RNNOptionsT *AsRNNOptions() {
    return type == BuiltinOptions_RNNOptions ?
      reinterpret_cast<tflite::RNNOptionsT *>(value) : nullptr;
  }
  const tflite::RNNOptionsT *AsRNNOptions() const {
    return type == BuiltinOptions_RNNOptions ?
      reinterpret_cast<const tflite::RNNOptionsT *>(value) : nullptr;
  }
  tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() {
    return type == BuiltinOptions_FullyConnectedOptions ?
      reinterpret_cast<tflite::FullyConnectedOptionsT *>(value) : nullptr;
  }
  const tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() const {
    return type == BuiltinOptions_FullyConnectedOptions ?
      reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value) : nullptr;
  }
  tflite::SoftmaxOptionsT *AsSoftmaxOptions() {
    return type == BuiltinOptions_SoftmaxOptions ?
      reinterpret_cast<tflite::SoftmaxOptionsT *>(value) : nullptr;
  }
  const tflite::SoftmaxOptionsT *AsSoftmaxOptions() const {
    return type == BuiltinOptions_SoftmaxOptions ?
      reinterpret_cast<const tflite::SoftmaxOptionsT *>(value) : nullptr;
  }
  tflite::ConcatenationOptionsT *AsConcatenationOptions() {
    return type == BuiltinOptions_ConcatenationOptions ?
      reinterpret_cast<tflite::ConcatenationOptionsT *>(value) : nullptr;
  }
  const tflite::ConcatenationOptionsT *AsConcatenationOptions() const {
    return type == BuiltinOptions_ConcatenationOptions ?
      reinterpret_cast<const tflite::ConcatenationOptionsT *>(value) : nullptr;
  }
  tflite::AddOptionsT *AsAddOptions() {
    return type == BuiltinOptions_AddOptions ?
      reinterpret_cast<tflite::AddOptionsT *>(value) : nullptr;
  }
  const tflite::AddOptionsT *AsAddOptions() const {
    return type == BuiltinOptions_AddOptions ?
      reinterpret_cast<const tflite::AddOptionsT *>(value) : nullptr;
  }
  tflite::L2NormOptionsT *AsL2NormOptions() {
    return type == BuiltinOptions_L2NormOptions ?
      reinterpret_cast<tflite::L2NormOptionsT *>(value) : nullptr;
  }
  const tflite::L2NormOptionsT *AsL2NormOptions() const {
    return type == BuiltinOptions_L2NormOptions ?
      reinterpret_cast<const tflite::L2NormOptionsT *>(value) : nullptr;
  }
  tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() {
    return type == BuiltinOptions_LocalResponseNormalizationOptions ?
      reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value) : nullptr;
  }
  const tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() const {
    return type == BuiltinOptions_LocalResponseNormalizationOptions ?
      reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value) : nullptr;
  }
  tflite::LSTMOptionsT *AsLSTMOptions() {
    return type == BuiltinOptions_LSTMOptions ?
      reinterpret_cast<tflite::LSTMOptionsT *>(value) : nullptr;
  }
  const tflite::LSTMOptionsT *AsLSTMOptions() const {
    return type == BuiltinOptions_LSTMOptions ?
      reinterpret_cast<const tflite::LSTMOptionsT *>(value) : nullptr;
  }
  tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() {
    return type == BuiltinOptions_ResizeBilinearOptions ?
      reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value) : nullptr;
  }
  const tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() const {
    return type == BuiltinOptions_ResizeBilinearOptions ?
      reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value) : nullptr;
  }
  tflite::CallOptionsT *AsCallOptions() {
    return type == BuiltinOptions_CallOptions ?
      reinterpret_cast<tflite::CallOptionsT *>(value) : nullptr;
  }
  const tflite::CallOptionsT *AsCallOptions() const {
    return type == BuiltinOptions_CallOptions ?
      reinterpret_cast<const tflite::CallOptionsT *>(value) : nullptr;
  }
  tflite::ReshapeOptionsT *AsReshapeOptions() {
    return type == BuiltinOptions_ReshapeOptions ?
      reinterpret_cast<tflite::ReshapeOptionsT *>(value) : nullptr;
  }
  const tflite::ReshapeOptionsT *AsReshapeOptions() const {
    return type == BuiltinOptions_ReshapeOptions ?
      reinterpret_cast<const tflite::ReshapeOptionsT *>(value) : nullptr;
  }
  tflite::SkipGramOptionsT *AsSkipGramOptions() {
    return type == BuiltinOptions_SkipGramOptions ?
      reinterpret_cast<tflite::SkipGramOptionsT *>(value) : nullptr;
  }
  const tflite::SkipGramOptionsT *AsSkipGramOptions() const {
    return type == BuiltinOptions_SkipGramOptions ?
      reinterpret_cast<const tflite::SkipGramOptionsT *>(value) : nullptr;
  }
  tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() {
    return type == BuiltinOptions_SpaceToDepthOptions ?
      reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value) : nullptr;
  }
  const tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() const {
    return type == BuiltinOptions_SpaceToDepthOptions ?
      reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value) : nullptr;
  }
  tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions ?
      reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value) : nullptr;
  }
  const tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() const {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions ?
      reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value) : nullptr;
  }
  tflite::MulOptionsT *AsMulOptions() {
    return type == BuiltinOptions_MulOptions ?
      reinterpret_cast<tflite::MulOptionsT *>(value) : nullptr;
  }
  const tflite::MulOptionsT *AsMulOptions() const {
    return type == BuiltinOptions_MulOptions ?
      reinterpret_cast<const tflite::MulOptionsT *>(value) : nullptr;
  }
  tflite::PadOptionsT *AsPadOptions() {
    return type == BuiltinOptions_PadOptions ?
      reinterpret_cast<tflite::PadOptionsT *>(value) : nullptr;
  }
  const tflite::PadOptionsT *AsPadOptions() const {
    return type == BuiltinOptions_PadOptions ?
      reinterpret_cast<const tflite::PadOptionsT *>(value) : nullptr;
  }
  tflite::GatherOptionsT *AsGatherOptions() {
    return type == BuiltinOptions_GatherOptions ?
      reinterpret_cast<tflite::GatherOptionsT *>(value) : nullptr;
  }
  const tflite::GatherOptionsT *AsGatherOptions() const {
    return type == BuiltinOptions_GatherOptions ?
      reinterpret_cast<const tflite::GatherOptionsT *>(value) : nullptr;
  }
  tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() {
    return type == BuiltinOptions_BatchToSpaceNDOptions ?
      reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value) : nullptr;
  }
  const tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() const {
    return type == BuiltinOptions_BatchToSpaceNDOptions ?
      reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value) : nullptr;
  }
  tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() {
    return type == BuiltinOptions_SpaceToBatchNDOptions ?
      reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value) : nullptr;
  }
  const tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() const {
    return type == BuiltinOptions_SpaceToBatchNDOptions ?
      reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value) : nullptr;
  }
  tflite::TransposeOptionsT *AsTransposeOptions() {
    return type == BuiltinOptions_TransposeOptions ?
      reinterpret_cast<tflite::TransposeOptionsT *>(value) : nullptr;
  }
  const tflite::TransposeOptionsT *AsTransposeOptions() const {
    return type == BuiltinOptions_TransposeOptions ?
      reinterpret_cast<const tflite::TransposeOptionsT *>(value) : nullptr;
  }
  tflite::ReducerOptionsT *AsReducerOptions() {
    return type == BuiltinOptions_ReducerOptions ?
      reinterpret_cast<tflite::ReducerOptionsT *>(value) : nullptr;
  }
  const tflite::ReducerOptionsT *AsReducerOptions() const {
    return type == BuiltinOptions_ReducerOptions ?
      reinterpret_cast<const tflite::ReducerOptionsT *>(value) : nullptr;
  }
  tflite::SubOptionsT *AsSubOptions() {
    return type == BuiltinOptions_SubOptions ?
      reinterpret_cast<tflite::SubOptionsT *>(value) : nullptr;
  }
  const tflite::SubOptionsT *AsSubOptions() const {
    return type == BuiltinOptions_SubOptions ?
      reinterpret_cast<const tflite::SubOptionsT *>(value) : nullptr;
  }
  tflite::DivOptionsT *AsDivOptions() {
    return type == BuiltinOptions_DivOptions ?
      reinterpret_cast<tflite::DivOptionsT *>(value) : nullptr;
  }
  const tflite::DivOptionsT *AsDivOptions() const {
    return type == BuiltinOptions_DivOptions ?
      reinterpret_cast<const tflite::DivOptionsT *>(value) : nullptr;
  }
  tflite::SqueezeOptionsT *AsSqueezeOptions() {
    return type == BuiltinOptions_SqueezeOptions ?
      reinterpret_cast<tflite::SqueezeOptionsT *>(value) : nullptr;
  }
  const tflite::SqueezeOptionsT *AsSqueezeOptions() const {
    return type == BuiltinOptions_SqueezeOptions ?
      reinterpret_cast<const tflite::SqueezeOptionsT *>(value) : nullptr;
  }
  tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() {
    return type == BuiltinOptions_SequenceRNNOptions ?
      reinterpret_cast<tflite::SequenceRNNOptionsT *>(value) : nullptr;
  }
  const tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() const {
    return type == BuiltinOptions_SequenceRNNOptions ?
      reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value) : nullptr;
  }
  tflite::StridedSliceOptionsT *AsStridedSliceOptions() {
    return type == BuiltinOptions_StridedSliceOptions ?
      reinterpret_cast<tflite::StridedSliceOptionsT *>(value) : nullptr;
  }
  const tflite::StridedSliceOptionsT *AsStridedSliceOptions() const {
    return type == BuiltinOptions_StridedSliceOptions ?
      reinterpret_cast<const tflite::StridedSliceOptionsT *>(value) : nullptr;
  }
  tflite::ExpOptionsT *AsExpOptions() {
    return type == BuiltinOptions_ExpOptions ?
      reinterpret_cast<tflite::ExpOptionsT *>(value) : nullptr;
  }
  const tflite::ExpOptionsT *AsExpOptions() const {
    return type == BuiltinOptions_ExpOptions ?
      reinterpret_cast<const tflite::ExpOptionsT *>(value) : nullptr;
  }
  tflite::TopKV2OptionsT *AsTopKV2Options() {
    return type == BuiltinOptions_TopKV2Options ?
      reinterpret_cast<tflite::TopKV2OptionsT *>(value) : nullptr;
  }
  const tflite::TopKV2OptionsT *AsTopKV2Options() const {
    return type == BuiltinOptions_TopKV2Options ?
      reinterpret_cast<const tflite::TopKV2OptionsT *>(value) : nullptr;
  }
  tflite::SplitOptionsT *AsSplitOptions() {
    return type == BuiltinOptions_SplitOptions ?
      reinterpret_cast<tflite::SplitOptionsT *>(value) : nullptr;
  }
  const tflite::SplitOptionsT *AsSplitOptions() const {
    return type == BuiltinOptions_SplitOptions ?
      reinterpret_cast<const tflite::SplitOptionsT *>(value) : nullptr;
  }
  tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() {
    return type == BuiltinOptions_LogSoftmaxOptions ?
      reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value) : nullptr;
  }
  const tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() const {
    return type == BuiltinOptions_LogSoftmaxOptions ?
      reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value) : nullptr;
  }
  tflite::CastOptionsT *AsCastOptions() {
    return type == BuiltinOptions_CastOptions ?
      reinterpret_cast<tflite::CastOptionsT *>(value) : nullptr;
  }
  const tflite::CastOptionsT *AsCastOptions() const {
    return type == BuiltinOptions_CastOptions ?
      reinterpret_cast<const tflite::CastOptionsT *>(value) : nullptr;
  }
  tflite::DequantizeOptionsT *AsDequantizeOptions() {
    return type == BuiltinOptions_DequantizeOptions ?
      reinterpret_cast<tflite::DequantizeOptionsT *>(value) : nullptr;
  }
  const tflite::DequantizeOptionsT *AsDequantizeOptions() const {
    return type == BuiltinOptions_DequantizeOptions ?
      reinterpret_cast<const tflite::DequantizeOptionsT *>(value) : nullptr;
  }
  tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() {
    return type == BuiltinOptions_MaximumMinimumOptions ?
      reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value) : nullptr;
  }
  const tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() const {
    return type == BuiltinOptions_MaximumMinimumOptions ?
      reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value) : nullptr;
  }
  tflite::ArgMaxOptionsT *AsArgMaxOptions() {
    return type == BuiltinOptions_ArgMaxOptions ?
      reinterpret_cast<tflite::ArgMaxOptionsT *>(value) : nullptr;
  }
  const tflite::ArgMaxOptionsT *AsArgMaxOptions() const {
    return type == BuiltinOptions_ArgMaxOptions ?
      reinterpret_cast<const tflite::ArgMaxOptionsT *>(value) : nullptr;
  }
  tflite::LessOptionsT *AsLessOptions() {
    return type == BuiltinOptions_LessOptions ?
      reinterpret_cast<tflite::LessOptionsT *>(value) : nullptr;
  }
  const tflite::LessOptionsT *AsLessOptions() const {
    return type == BuiltinOptions_LessOptions ?
      reinterpret_cast<const tflite::LessOptionsT *>(value) : nullptr;
  }
  tflite::NegOptionsT *AsNegOptions() {
    return type == BuiltinOptions_NegOptions ?
      reinterpret_cast<tflite::NegOptionsT *>(value) : nullptr;
  }
  const tflite::NegOptionsT *AsNegOptions() const {
    return type == BuiltinOptions_NegOptions ?
      reinterpret_cast<const tflite::NegOptionsT *>(value) : nullptr;
  }
  tflite::PadV2OptionsT *AsPadV2Options() {
    return type == BuiltinOptions_PadV2Options ?
      reinterpret_cast<tflite::PadV2OptionsT *>(value) : nullptr;
  }
  const tflite::PadV2OptionsT *AsPadV2Options() const {
    return type == BuiltinOptions_PadV2Options ?
      reinterpret_cast<const tflite::PadV2OptionsT *>(value) : nullptr;
  }
  tflite::GreaterOptionsT *AsGreaterOptions() {
    return type == BuiltinOptions_GreaterOptions ?
      reinterpret_cast<tflite::GreaterOptionsT *>(value) : nullptr;
  }
  const tflite::GreaterOptionsT *AsGreaterOptions() const {
    return type == BuiltinOptions_GreaterOptions ?
      reinterpret_cast<const tflite::GreaterOptionsT *>(value) : nullptr;
  }
  tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() {
    return type == BuiltinOptions_GreaterEqualOptions ?
      reinterpret_cast<tflite::GreaterEqualOptionsT *>(value) : nullptr;
  }
  const tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() const {
    return type == BuiltinOptions_GreaterEqualOptions ?
      reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value) : nullptr;
  }
  tflite::LessEqualOptionsT *AsLessEqualOptions() {
    return type == BuiltinOptions_LessEqualOptions ?
      reinterpret_cast<tflite::LessEqualOptionsT *>(value) : nullptr;
  }
  const tflite::LessEqualOptionsT *AsLessEqualOptions() const {
    return type == BuiltinOptions_LessEqualOptions ?
      reinterpret_cast<const tflite::LessEqualOptionsT *>(value) : nullptr;
  }
  tflite::SelectOptionsT *AsSelectOptions() {
    return type == BuiltinOptions_SelectOptions ?
      reinterpret_cast<tflite::SelectOptionsT *>(value) : nullptr;
  }
  const tflite::SelectOptionsT *AsSelectOptions() const {
    return type == BuiltinOptions_SelectOptions ?
      reinterpret_cast<const tflite::SelectOptionsT *>(value) : nullptr;
  }
  tflite::SliceOptionsT *AsSliceOptions() {
    return type == BuiltinOptions_SliceOptions ?
      reinterpret_cast<tflite::SliceOptionsT *>(value) : nullptr;
  }
  const tflite::SliceOptionsT *AsSliceOptions() const {
    return type == BuiltinOptions_SliceOptions ?
      reinterpret_cast<const tflite::SliceOptionsT *>(value) : nullptr;
  }
  tflite::TransposeConvOptionsT *AsTransposeConvOptions() {
    return type == BuiltinOptions_TransposeConvOptions ?
      reinterpret_cast<tflite::TransposeConvOptionsT *>(value) : nullptr;
  }
  const tflite::TransposeConvOptionsT *AsTransposeConvOptions() const {
    return type == BuiltinOptions_TransposeConvOptions ?
      reinterpret_cast<const tflite::TransposeConvOptionsT *>(value) : nullptr;
  }
  tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() {
    return type == BuiltinOptions_SparseToDenseOptions ?
      reinterpret_cast<tflite::SparseToDenseOptionsT *>(value) : nullptr;
  }
  const tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() const {
    return type == BuiltinOptions_SparseToDenseOptions ?
      reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value) : nullptr;
  }
  tflite::TileOptionsT *AsTileOptions() {
    return type == BuiltinOptions_TileOptions ?
      reinterpret_cast<tflite::TileOptionsT *>(value) : nullptr;
  }
  const tflite::TileOptionsT *AsTileOptions() const {
    return type == BuiltinOptions_TileOptions ?
      reinterpret_cast<const tflite::TileOptionsT *>(value) : nullptr;
  }
  tflite::ExpandDimsOptionsT *AsExpandDimsOptions() {
    return type == BuiltinOptions_ExpandDimsOptions ?
      reinterpret_cast<tflite::ExpandDimsOptionsT *>(value) : nullptr;
  }
  const tflite::ExpandDimsOptionsT *AsExpandDimsOptions() const {
    return type == BuiltinOptions_ExpandDimsOptions ?
      reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value) : nullptr;
  }
  tflite::EqualOptionsT *AsEqualOptions() {
    return type == BuiltinOptions_EqualOptions ?
      reinterpret_cast<tflite::EqualOptionsT *>(value) : nullptr;
  }
  const tflite::EqualOptionsT *AsEqualOptions() const {
    return type == BuiltinOptions_EqualOptions ?
      reinterpret_cast<const tflite::EqualOptionsT *>(value) : nullptr;
  }
  tflite::NotEqualOptionsT *AsNotEqualOptions() {
    return type == BuiltinOptions_NotEqualOptions ?
      reinterpret_cast<tflite::NotEqualOptionsT *>(value) : nullptr;
  }
  const tflite::NotEqualOptionsT *AsNotEqualOptions() const {
    return type == BuiltinOptions_NotEqualOptions ?
      reinterpret_cast<const tflite::NotEqualOptionsT *>(value) : nullptr;
  }
  tflite::ShapeOptionsT *AsShapeOptions() {
    return type == BuiltinOptions_ShapeOptions ?
      reinterpret_cast<tflite::ShapeOptionsT *>(value) : nullptr;
  }
  const tflite::ShapeOptionsT *AsShapeOptions() const {
    return type == BuiltinOptions_ShapeOptions ?
      reinterpret_cast<const tflite::ShapeOptionsT *>(value) : nullptr;
  }
  tflite::PowOptionsT *AsPowOptions() {
    return type == BuiltinOptions_PowOptions ?
      reinterpret_cast<tflite::PowOptionsT *>(value) : nullptr;
  }
  const tflite::PowOptionsT *AsPowOptions() const {
    return type == BuiltinOptions_PowOptions ?
      reinterpret_cast<const tflite::PowOptionsT *>(value) : nullptr;
  }
  tflite::ArgMinOptionsT *AsArgMinOptions() {
    return type == BuiltinOptions_ArgMinOptions ?
      reinterpret_cast<tflite::ArgMinOptionsT *>(value) : nullptr;
  }
  const tflite::ArgMinOptionsT *AsArgMinOptions() const {
    return type == BuiltinOptions_ArgMinOptions ?
      reinterpret_cast<const tflite::ArgMinOptionsT *>(value) : nullptr;
  }
  tflite::FakeQuantOptionsT *AsFakeQuantOptions() {
    return type == BuiltinOptions_FakeQuantOptions ?
      reinterpret_cast<tflite::FakeQuantOptionsT *>(value) : nullptr;
  }
  const tflite::FakeQuantOptionsT *AsFakeQuantOptions() const {
    return type == BuiltinOptions_FakeQuantOptions ?
      reinterpret_cast<const tflite::FakeQuantOptionsT *>(value) : nullptr;
  }
  tflite::PackOptionsT *AsPackOptions() {
    return type == BuiltinOptions_PackOptions ?
      reinterpret_cast<tflite::PackOptionsT *>(value) : nullptr;
  }
  const tflite::PackOptionsT *AsPackOptions() const {
    return type == BuiltinOptions_PackOptions ?
      reinterpret_cast<const tflite::PackOptionsT *>(value) : nullptr;
  }
  tflite::LogicalOrOptionsT *AsLogicalOrOptions() {
    return type == BuiltinOptions_LogicalOrOptions ?
      reinterpret_cast<tflite::LogicalOrOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalOrOptionsT *AsLogicalOrOptions() const {
    return type == BuiltinOptions_LogicalOrOptions ?
      reinterpret_cast<const tflite::LogicalOrOptionsT *>(value) : nullptr;
  }
  tflite::OneHotOptionsT *AsOneHotOptions() {
    return type == BuiltinOptions_OneHotOptions ?
      reinterpret_cast<tflite::OneHotOptionsT *>(value) : nullptr;
  }
  const tflite::OneHotOptionsT *AsOneHotOptions() const {
    return type == BuiltinOptions_OneHotOptions ?
      reinterpret_cast<const tflite::OneHotOptionsT *>(value) : nullptr;
  }
  tflite::LogicalAndOptionsT *AsLogicalAndOptions() {
    return type == BuiltinOptions_LogicalAndOptions ?
      reinterpret_cast<tflite::LogicalAndOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalAndOptionsT *AsLogicalAndOptions() const {
    return type == BuiltinOptions_LogicalAndOptions ?
      reinterpret_cast<const tflite::LogicalAndOptionsT *>(value) : nullptr;
  }
  tflite::LogicalNotOptionsT *AsLogicalNotOptions() {
    return type == BuiltinOptions_LogicalNotOptions ?
      reinterpret_cast<tflite::LogicalNotOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalNotOptionsT *AsLogicalNotOptions() const {
    return type == BuiltinOptions_LogicalNotOptions ?
      reinterpret_cast<const tflite::LogicalNotOptionsT *>(value) : nullptr;
  }
  tflite::UnpackOptionsT *AsUnpackOptions() {
    return type == BuiltinOptions_UnpackOptions ?
      reinterpret_cast<tflite::UnpackOptionsT *>(value) : nullptr;
  }
  const tflite::UnpackOptionsT *AsUnpackOptions() const {
    return type == BuiltinOptions_UnpackOptions ?
      reinterpret_cast<const tflite::UnpackOptionsT *>(value) : nullptr;
  }
  tflite::FloorDivOptionsT *AsFloorDivOptions() {
    return type == BuiltinOptions_FloorDivOptions ?
      reinterpret_cast<tflite::FloorDivOptionsT *>(value) : nullptr;
  }
  const tflite::FloorDivOptionsT *AsFloorDivOptions() const {
    return type == BuiltinOptions_FloorDivOptions ?
      reinterpret_cast<const tflite::FloorDivOptionsT *>(value) : nullptr;
  }
  tflite::SquareOptionsT *AsSquareOptions() {
    return type == BuiltinOptions_SquareOptions ?
      reinterpret_cast<tflite::SquareOptionsT *>(value) : nullptr;
  }
  const tflite::SquareOptionsT *AsSquareOptions() const {
    return type == BuiltinOptions_SquareOptions ?
      reinterpret_cast<const tflite::SquareOptionsT *>(value) : nullptr;
  }
  tflite::ZerosLikeOptionsT *AsZerosLikeOptions() {
    return type == BuiltinOptions_ZerosLikeOptions ?
      reinterpret_cast<tflite::ZerosLikeOptionsT *>(value) : nullptr;
  }
  const tflite::ZerosLikeOptionsT *AsZerosLikeOptions() const {
    return type == BuiltinOptions_ZerosLikeOptions ?
      reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value) : nullptr;
  }
  tflite::FillOptionsT *AsFillOptions() {
    return type == BuiltinOptions_FillOptions ?
      reinterpret_cast<tflite::FillOptionsT *>(value) : nullptr;
  }
  const tflite::FillOptionsT *AsFillOptions() const {
    return type == BuiltinOptions_FillOptions ?
      reinterpret_cast<const tflite::FillOptionsT *>(value) : nullptr;
  }
  tflite::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions ?
      reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  const tflite::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() const {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions ?
      reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  tflite::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions ?
      reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(value) : nullptr;
  }
  const tflite::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() const {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions ?
      reinterpret_cast<const tflite::BidirectionalSequenceRNNOptionsT *>(value) : nullptr;
  }
  tflite::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions ?
      reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  const tflite::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() const {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions ?
      reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  tflite::FloorModOptionsT *AsFloorModOptions() {
    return type == BuiltinOptions_FloorModOptions ?
      reinterpret_cast<tflite::FloorModOptionsT *>(value) : nullptr;
  }
  const tflite::FloorModOptionsT *AsFloorModOptions() const {
    return type == BuiltinOptions_FloorModOptions ?
      reinterpret_cast<const tflite::FloorModOptionsT *>(value) : nullptr;
  }
  tflite::RangeOptionsT *AsRangeOptions() {
    return type == BuiltinOptions_RangeOptions ?
      reinterpret_cast<tflite::RangeOptionsT *>(value) : nullptr;
  }
  const tflite::RangeOptionsT *AsRangeOptions() const {
    return type == BuiltinOptions_RangeOptions ?
      reinterpret_cast<const tflite::RangeOptionsT *>(value) : nullptr;
  }
  tflite::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() {
    return type == BuiltinOptions_ResizeNearestNeighborOptions ?
      reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(value) : nullptr;
  }
  const tflite::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() const {
    return type == BuiltinOptions_ResizeNearestNeighborOptions ?
      reinterpret_cast<const tflite::ResizeNearestNeighborOptionsT *>(value) : nullptr;
  }
  tflite::LeakyReluOptionsT *AsLeakyReluOptions() {
    return type == BuiltinOptions_LeakyReluOptions ?
      reinterpret_cast<tflite::LeakyReluOptionsT *>(value) : nullptr;
  }
  const tflite::LeakyReluOptionsT *AsLeakyReluOptions() const {
    return type == BuiltinOptions_LeakyReluOptions ?
      reinterpret_cast<const tflite::LeakyReluOptionsT *>(value) : nullptr;
  }
  tflite::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() {
    return type == BuiltinOptions_SquaredDifferenceOptions ?
      reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(value) : nullptr;
  }
  const tflite::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() const {
    return type == BuiltinOptions_SquaredDifferenceOptions ?
      reinterpret_cast<const tflite::SquaredDifferenceOptionsT *>(value) : nullptr;
  }
  tflite::MirrorPadOptionsT *AsMirrorPadOptions() {
    return type == BuiltinOptions_MirrorPadOptions ?
      reinterpret_cast<tflite::MirrorPadOptionsT *>(value) : nullptr;
  }
  const tflite::MirrorPadOptionsT *AsMirrorPadOptions() const {
    return type == BuiltinOptions_MirrorPadOptions ?
      reinterpret_cast<const tflite::MirrorPadOptionsT *>(value) : nullptr;
  }
  tflite::AbsOptionsT *AsAbsOptions() {
    return type == BuiltinOptions_AbsOptions ?
      reinterpret_cast<tflite::AbsOptionsT *>(value) : nullptr;
  }
  const tflite::AbsOptionsT *AsAbsOptions() const {
    return type == BuiltinOptions_AbsOptions ?
      reinterpret_cast<const tflite::AbsOptionsT *>(value) : nullptr;
  }
  tflite::SplitVOptionsT *AsSplitVOptions() {
    return type == BuiltinOptions_SplitVOptions ?
      reinterpret_cast<tflite::SplitVOptionsT *>(value) : nullptr;
  }
  const tflite::SplitVOptionsT *AsSplitVOptions() const {
    return type == BuiltinOptions_SplitVOptions ?
      reinterpret_cast<const tflite::SplitVOptionsT *>(value) : nullptr;
  }
  tflite::UniqueOptionsT *AsUniqueOptions() {
    return type == BuiltinOptions_UniqueOptions ?
      reinterpret_cast<tflite::UniqueOptionsT *>(value) : nullptr;
  }
  const tflite::UniqueOptionsT *AsUniqueOptions() const {
    return type == BuiltinOptions_UniqueOptions ?
      reinterpret_cast<const tflite::UniqueOptionsT *>(value) : nullptr;
  }
  tflite::ReverseV2OptionsT *AsReverseV2Options() {
    return type == BuiltinOptions_ReverseV2Options ?
      reinterpret_cast<tflite::ReverseV2OptionsT *>(value) : nullptr;
  }
  const tflite::ReverseV2OptionsT *AsReverseV2Options() const {
    return type == BuiltinOptions_ReverseV2Options ?
      reinterpret_cast<const tflite::ReverseV2OptionsT *>(value) : nullptr;
  }
  tflite::AddNOptionsT *AsAddNOptions() {
    return type == BuiltinOptions_AddNOptions ?
      reinterpret_cast<tflite::AddNOptionsT *>(value) : nullptr;
  }
  const tflite::AddNOptionsT *AsAddNOptions() const {
    return type == BuiltinOptions_AddNOptions ?
      reinterpret_cast<const tflite::AddNOptionsT *>(value) : nullptr;
  }
  tflite::GatherNdOptionsT *AsGatherNdOptions() {
    return type == BuiltinOptions_GatherNdOptions ?
      reinterpret_cast<tflite::GatherNdOptionsT *>(value) : nullptr;
  }
  const tflite::GatherNdOptionsT *AsGatherNdOptions() const {
    return type == BuiltinOptions_GatherNdOptions ?
      reinterpret_cast<const tflite::GatherNdOptionsT *>(value) : nullptr;
  }
  tflite::CosOptionsT *AsCosOptions() {
    return type == BuiltinOptions_CosOptions ?
      reinterpret_cast<tflite::CosOptionsT *>(value) : nullptr;
  }
  const tflite::CosOptionsT *AsCosOptions() const {
    return type == BuiltinOptions_CosOptions ?
      reinterpret_cast<const tflite::CosOptionsT *>(value) : nullptr;
  }
  tflite::WhereOptionsT *AsWhereOptions() {
    return type == BuiltinOptions_WhereOptions ?
      reinterpret_cast<tflite::WhereOptionsT *>(value) : nullptr;
  }
  const tflite::WhereOptionsT *AsWhereOptions() const {
    return type == BuiltinOptions_WhereOptions ?
      reinterpret_cast<const tflite::WhereOptionsT *>(value) : nullptr;
  }
  tflite::RankOptionsT *AsRankOptions() {
    return type == BuiltinOptions_RankOptions ?
      reinterpret_cast<tflite::RankOptionsT *>(value) : nullptr;
  }
  const tflite::RankOptionsT *AsRankOptions() const {
    return type == BuiltinOptions_RankOptions ?
      reinterpret_cast<const tflite::RankOptionsT *>(value) : nullptr;
  }
  tflite::ReverseSequenceOptionsT *AsReverseSequenceOptions() {
    return type == BuiltinOptions_ReverseSequenceOptions ?
      reinterpret_cast<tflite::ReverseSequenceOptionsT *>(value) : nullptr;
  }
  const tflite::ReverseSequenceOptionsT *AsReverseSequenceOptions() const {
    return type == BuiltinOptions_ReverseSequenceOptions ?
      reinterpret_cast<const tflite::ReverseSequenceOptionsT *>(value) : nullptr;
  }
  tflite::MatrixDiagOptionsT *AsMatrixDiagOptions() {
    return type == BuiltinOptions_MatrixDiagOptions ?
      reinterpret_cast<tflite::MatrixDiagOptionsT *>(value) : nullptr;
  }
  const tflite::MatrixDiagOptionsT *AsMatrixDiagOptions() const {
    return type == BuiltinOptions_MatrixDiagOptions ?
      reinterpret_cast<const tflite::MatrixDiagOptionsT *>(value) : nullptr;
  }
  tflite::QuantizeOptionsT *AsQuantizeOptions() {
    return type == BuiltinOptions_QuantizeOptions ?
      reinterpret_cast<tflite::QuantizeOptionsT *>(value) : nullptr;
  }
  const tflite::QuantizeOptionsT *AsQuantizeOptions() const {
    return type == BuiltinOptions_QuantizeOptions ?
      reinterpret_cast<const tflite::QuantizeOptionsT *>(value) : nullptr;
  }
  tflite::MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() {
    return type == BuiltinOptions_MatrixSetDiagOptions ?
      reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(value) : nullptr;
  }
  const tflite::MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() const {
    return type == BuiltinOptions_MatrixSetDiagOptions ?
      reinterpret_cast<const tflite::MatrixSetDiagOptionsT *>(value) : nullptr;
  }
  tflite::HardSwishOptionsT *AsHardSwishOptions() {
    return type == BuiltinOptions_HardSwishOptions ?
      reinterpret_cast<tflite::HardSwishOptionsT *>(value) : nullptr;
  }
  const tflite::HardSwishOptionsT *AsHardSwishOptions() const {
    return type == BuiltinOptions_HardSwishOptions ?
      reinterpret_cast<const tflite::HardSwishOptionsT *>(value) : nullptr;
  }
  tflite::IfOptionsT *AsIfOptions() {
    return type == BuiltinOptions_IfOptions ?
      reinterpret_cast<tflite::IfOptionsT *>(value) : nullptr;
  }
  const tflite::IfOptionsT *AsIfOptions() const {
    return type == BuiltinOptions_IfOptions ?
      reinterpret_cast<const tflite::IfOptionsT *>(value) : nullptr;
  }
  tflite::WhileOptionsT *AsWhileOptions() {
    return type == BuiltinOptions_WhileOptions ?
      reinterpret_cast<tflite::WhileOptionsT *>(value) : nullptr;
  }
  const tflite::WhileOptionsT *AsWhileOptions() const {
    return type == BuiltinOptions_WhileOptions ?
      reinterpret_cast<const tflite::WhileOptionsT *>(value) : nullptr;
  }
  tflite::DepthToSpaceOptionsT *AsDepthToSpaceOptions() {
    return type == BuiltinOptions_DepthToSpaceOptions ?
      reinterpret_cast<tflite::DepthToSpaceOptionsT *>(value) : nullptr;
  }
  const tflite::DepthToSpaceOptionsT *AsDepthToSpaceOptions() const {
    return type == BuiltinOptions_DepthToSpaceOptions ?
      reinterpret_cast<const tflite::DepthToSpaceOptionsT *>(value) : nullptr;
  }
  tflite::NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() {
    return type == BuiltinOptions_NonMaxSuppressionV4Options ?
      reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(value) : nullptr;
  }
  const tflite::NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() const {
    return type == BuiltinOptions_NonMaxSuppressionV4Options ?
      reinterpret_cast<const tflite::NonMaxSuppressionV4OptionsT *>(value) : nullptr;
  }
  tflite::NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() {
    return type == BuiltinOptions_NonMaxSuppressionV5Options ?
      reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(value) : nullptr;
  }
  const tflite::NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() const {
    return type == BuiltinOptions_NonMaxSuppressionV5Options ?
      reinterpret_cast<const tflite::NonMaxSuppressionV5OptionsT *>(value) : nullptr;
  }
  tflite::ScatterNdOptionsT *AsScatterNdOptions() {
    return type == BuiltinOptions_ScatterNdOptions ?
      reinterpret_cast<tflite::ScatterNdOptionsT *>(value) : nullptr;
  }
  const tflite::ScatterNdOptionsT *AsScatterNdOptions() const {
    return type == BuiltinOptions_ScatterNdOptions ?
      reinterpret_cast<const tflite::ScatterNdOptionsT *>(value) : nullptr;
  }
  tflite::SelectV2OptionsT *AsSelectV2Options() {
    return type == BuiltinOptions_SelectV2Options ?
      reinterpret_cast<tflite::SelectV2OptionsT *>(value) : nullptr;
  }
  const tflite::SelectV2OptionsT *AsSelectV2Options() const {
    return type == BuiltinOptions_SelectV2Options ?
      reinterpret_cast<const tflite::SelectV2OptionsT *>(value) : nullptr;
  }
  tflite::DensifyOptionsT *AsDensifyOptions() {
    return type == BuiltinOptions_DensifyOptions ?
      reinterpret_cast<tflite::DensifyOptionsT *>(value) : nullptr;
  }
  const tflite::DensifyOptionsT *AsDensifyOptions() const {
    return type == BuiltinOptions_DensifyOptions ?
      reinterpret_cast<const tflite::DensifyOptionsT *>(value) : nullptr;
  }
  tflite::SegmentSumOptionsT *AsSegmentSumOptions() {
    return type == BuiltinOptions_SegmentSumOptions ?
      reinterpret_cast<tflite::SegmentSumOptionsT *>(value) : nullptr;
  }
  const tflite::SegmentSumOptionsT *AsSegmentSumOptions() const {
    return type == BuiltinOptions_SegmentSumOptions ?
      reinterpret_cast<const tflite::SegmentSumOptionsT *>(value) : nullptr;
  }
  tflite::BatchMatMulOptionsT *AsBatchMatMulOptions() {
    return type == BuiltinOptions_BatchMatMulOptions ?
      reinterpret_cast<tflite::BatchMatMulOptionsT *>(value) : nullptr;
  }
  const tflite::BatchMatMulOptionsT *AsBatchMatMulOptions() const {
    return type == BuiltinOptions_BatchMatMulOptions ?
      reinterpret_cast<const tflite::BatchMatMulOptionsT *>(value) : nullptr;
  }
  tflite::CumsumOptionsT *AsCumsumOptions() {
    return type == BuiltinOptions_CumsumOptions ?
      reinterpret_cast<tflite::CumsumOptionsT *>(value) : nullptr;
  }
  const tflite::CumsumOptionsT *AsCumsumOptions() const {
    return type == BuiltinOptions_CumsumOptions ?
      reinterpret_cast<const tflite::CumsumOptionsT *>(value) : nullptr;
  }
  tflite::CallOnceOptionsT *AsCallOnceOptions() {
    return type == BuiltinOptions_CallOnceOptions ?
      reinterpret_cast<tflite::CallOnceOptionsT *>(value) : nullptr;
  }
  const tflite::CallOnceOptionsT *AsCallOnceOptions() const {
    return type == BuiltinOptions_CallOnceOptions ?
      reinterpret_cast<const tflite::CallOnceOptionsT *>(value) : nullptr;
  }
  tflite::BroadcastToOptionsT *AsBroadcastToOptions() {
    return type == BuiltinOptions_BroadcastToOptions ?
      reinterpret_cast<tflite::BroadcastToOptionsT *>(value) : nullptr;
  }
  const tflite::BroadcastToOptionsT *AsBroadcastToOptions() const {
    return type == BuiltinOptions_BroadcastToOptions ?
      reinterpret_cast<const tflite::BroadcastToOptionsT *>(value) : nullptr;
  }
  tflite::Rfft2dOptionsT *AsRfft2dOptions() {
    return type == BuiltinOptions_Rfft2dOptions ?
      reinterpret_cast<tflite::Rfft2dOptionsT *>(value) : nullptr;
  }
  const tflite::Rfft2dOptionsT *AsRfft2dOptions() const {
    return type == BuiltinOptions_Rfft2dOptions ?
      reinterpret_cast<const tflite::Rfft2dOptionsT *>(value) : nullptr;
  }
  tflite::Conv3DOptionsT *AsConv3DOptions() {
    return type == BuiltinOptions_Conv3DOptions ?
      reinterpret_cast<tflite::Conv3DOptionsT *>(value) : nullptr;
  }
  const tflite::Conv3DOptionsT *AsConv3DOptions() const {
    return type == BuiltinOptions_Conv3DOptions ?
      reinterpret_cast<const tflite::Conv3DOptionsT *>(value) : nullptr;
  }
  tflite::HashtableOptionsT *AsHashtableOptions() {
    return type == BuiltinOptions_HashtableOptions ?
      reinterpret_cast<tflite::HashtableOptionsT *>(value) : nullptr;
  }
  const tflite::HashtableOptionsT *AsHashtableOptions() const {
    return type == BuiltinOptions_HashtableOptions ?
      reinterpret_cast<const tflite::HashtableOptionsT *>(value) : nullptr;
  }
  tflite::HashtableFindOptionsT *AsHashtableFindOptions() {
    return type == BuiltinOptions_HashtableFindOptions ?
      reinterpret_cast<tflite::HashtableFindOptionsT *>(value) : nullptr;
  }
  const tflite::HashtableFindOptionsT *AsHashtableFindOptions() const {
    return type == BuiltinOptions_HashtableFindOptions ?
      reinterpret_cast<const tflite::HashtableFindOptionsT *>(value) : nullptr;
  }
  tflite::HashtableImportOptionsT *AsHashtableImportOptions() {
    return type == BuiltinOptions_HashtableImportOptions ?
      reinterpret_cast<tflite::HashtableImportOptionsT *>(value) : nullptr;
  }
  const tflite::HashtableImportOptionsT *AsHashtableImportOptions() const {
    return type == BuiltinOptions_HashtableImportOptions ?
      reinterpret_cast<const tflite::HashtableImportOptionsT *>(value) : nullptr;
  }
  tflite::HashtableSizeOptionsT *AsHashtableSizeOptions() {
    return type == BuiltinOptions_HashtableSizeOptions ?
      reinterpret_cast<tflite::HashtableSizeOptionsT *>(value) : nullptr;
  }
  const tflite::HashtableSizeOptionsT *AsHashtableSizeOptions() const {
    return type == BuiltinOptions_HashtableSizeOptions ?
      reinterpret_cast<const tflite::HashtableSizeOptionsT *>(value) : nullptr;
  }
  tflite::VarHandleOptionsT *AsVarHandleOptions() {
    return type == BuiltinOptions_VarHandleOptions ?
      reinterpret_cast<tflite::VarHandleOptionsT *>(value) : nullptr;
  }
  const tflite::VarHandleOptionsT *AsVarHandleOptions() const {
    return type == BuiltinOptions_VarHandleOptions ?
      reinterpret_cast<const tflite::VarHandleOptionsT *>(value) : nullptr;
  }
  tflite::ReadVariableOptionsT *AsReadVariableOptions() {
    return type == BuiltinOptions_ReadVariableOptions ?
      reinterpret_cast<tflite::ReadVariableOptionsT *>(value) : nullptr;
  }
  const tflite::ReadVariableOptionsT *AsReadVariableOptions() const {
    return type == BuiltinOptions_ReadVariableOptions ?
      reinterpret_cast<const tflite::ReadVariableOptionsT *>(value) : nullptr;
  }
  tflite::AssignVariableOptionsT *AsAssignVariableOptions() {
    return type == BuiltinOptions_AssignVariableOptions ?
      reinterpret_cast<tflite::AssignVariableOptionsT *>(value) : nullptr;
  }
  const tflite::AssignVariableOptionsT *AsAssignVariableOptions() const {
    return type == BuiltinOptions_AssignVariableOptions ?
      reinterpret_cast<const tflite::AssignVariableOptionsT *>(value) : nullptr;
  }
  tflite::RandomOptionsT *AsRandomOptions() {
    return type == BuiltinOptions_RandomOptions ?
      reinterpret_cast<tflite::RandomOptionsT *>(value) : nullptr;
  }
  const tflite::RandomOptionsT *AsRandomOptions() const {
    return type == BuiltinOptions_RandomOptions ?
      reinterpret_cast<const tflite::RandomOptionsT *>(value) : nullptr;
  }
  tflite::BucketizeOptionsT *AsBucketizeOptions() {
    return type == BuiltinOptions_BucketizeOptions ?
      reinterpret_cast<tflite::BucketizeOptionsT *>(value) : nullptr;
  }
  const tflite::BucketizeOptionsT *AsBucketizeOptions() const {
    return type == BuiltinOptions_BucketizeOptions ?
      reinterpret_cast<const tflite::BucketizeOptionsT *>(value) : nullptr;
  }
  tflite::GeluOptionsT *AsGeluOptions() {
    return type == BuiltinOptions_GeluOptions ?
      reinterpret_cast<tflite::GeluOptionsT *>(value) : nullptr;
  }
  const tflite::GeluOptionsT *AsGeluOptions() const {
    return type == BuiltinOptions_GeluOptions ?
      reinterpret_cast<const tflite::GeluOptionsT *>(value) : nullptr;
  }
  tflite::DynamicUpdateSliceOptionsT *AsDynamicUpdateSliceOptions() {
    return type == BuiltinOptions_DynamicUpdateSliceOptions ?
      reinterpret_cast<tflite::DynamicUpdateSliceOptionsT *>(value) : nullptr;
  }
  const tflite::DynamicUpdateSliceOptionsT *AsDynamicUpdateSliceOptions() const {
    return type == BuiltinOptions_DynamicUpdateSliceOptions ?
      reinterpret_cast<const tflite::DynamicUpdateSliceOptionsT *>(value) : nullptr;
  }
  tflite::UnsortedSegmentProdOptionsT *AsUnsortedSegmentProdOptions() {
    return type == BuiltinOptions_UnsortedSegmentProdOptions ?
      reinterpret_cast<tflite::UnsortedSegmentProdOptionsT *>(value) : nullptr;
  }
  const tflite::UnsortedSegmentProdOptionsT *AsUnsortedSegmentProdOptions() const {
    return type == BuiltinOptions_UnsortedSegmentProdOptions ?
      reinterpret_cast<const tflite::UnsortedSegmentProdOptionsT *>(value) : nullptr;
  }
  tflite::UnsortedSegmentMaxOptionsT *AsUnsortedSegmentMaxOptions() {
    return type == BuiltinOptions_UnsortedSegmentMaxOptions ?
      reinterpret_cast<tflite::UnsortedSegmentMaxOptionsT *>(value) : nullptr;
  }
  const tflite::UnsortedSegmentMaxOptionsT *AsUnsortedSegmentMaxOptions() const {
    return type == BuiltinOptions_UnsortedSegmentMaxOptions ?
      reinterpret_cast<const tflite::UnsortedSegmentMaxOptionsT *>(value) : nullptr;
  }
  tflite::UnsortedSegmentMinOptionsT *AsUnsortedSegmentMinOptions() {
    return type == BuiltinOptions_UnsortedSegmentMinOptions ?
      reinterpret_cast<tflite::UnsortedSegmentMinOptionsT *>(value) : nullptr;
  }
  const tflite::UnsortedSegmentMinOptionsT *AsUnsortedSegmentMinOptions() const {
    return type == BuiltinOptions_UnsortedSegmentMinOptions ?
      reinterpret_cast<const tflite::UnsortedSegmentMinOptionsT *>(value) : nullptr;
  }
  tflite::UnsortedSegmentSumOptionsT *AsUnsortedSegmentSumOptions() {
    return type == BuiltinOptions_UnsortedSegmentSumOptions ?
      reinterpret_cast<tflite::UnsortedSegmentSumOptionsT *>(value) : nullptr;
  }
  const tflite::UnsortedSegmentSumOptionsT *AsUnsortedSegmentSumOptions() const {
    return type == BuiltinOptions_UnsortedSegmentSumOptions ?
      reinterpret_cast<const tflite::UnsortedSegmentSumOptionsT *>(value) : nullptr;
  }
  tflite::ATan2OptionsT *AsATan2Options() {
    return type == BuiltinOptions_ATan2Options ?
      reinterpret_cast<tflite::ATan2OptionsT *>(value) : nullptr;
  }
  const tflite::ATan2OptionsT *AsATan2Options() const {
    return type == BuiltinOptions_ATan2Options ?
      reinterpret_cast<const tflite::ATan2OptionsT *>(value) : nullptr;
  }
  tflite::SignOptionsT *AsSignOptions() {
    return type == BuiltinOptions_SignOptions ?
      reinterpret_cast<tflite::SignOptionsT *>(value) : nullptr;
  }
  const tflite::SignOptionsT *AsSignOptions() const {
    return type == BuiltinOptions_SignOptions ?
      reinterpret_cast<const tflite::SignOptionsT *>(value) : nullptr;
  }
  tflite::BitcastOptionsT *AsBitcastOptions() {
    return type == BuiltinOptions_BitcastOptions ?
      reinterpret_cast<tflite::BitcastOptionsT *>(value) : nullptr;
  }
  const tflite::BitcastOptionsT *AsBitcastOptions() const {
    return type == BuiltinOptions_BitcastOptions ?
      reinterpret_cast<const tflite::BitcastOptionsT *>(value) : nullptr;
  }
  tflite::BitwiseXorOptionsT *AsBitwiseXorOptions() {
    return type == BuiltinOptions_BitwiseXorOptions ?
      reinterpret_cast<tflite::BitwiseXorOptionsT *>(value) : nullptr;
  }
  const tflite::BitwiseXorOptionsT *AsBitwiseXorOptions() const {
    return type == BuiltinOptions_BitwiseXorOptions ?
      reinterpret_cast<const tflite::BitwiseXorOptionsT *>(value) : nullptr;
  }
  tflite::RightShiftOptionsT *AsRightShiftOptions() {
    return type == BuiltinOptions_RightShiftOptions ?
      reinterpret_cast<tflite::RightShiftOptionsT *>(value) : nullptr;
  }
  const tflite::RightShiftOptionsT *AsRightShiftOptions() const {
    return type == BuiltinOptions_RightShiftOptions ?
      reinterpret_cast<const tflite::RightShiftOptionsT *>(value) : nullptr;
  }
};

bool VerifyBuiltinOptions(::flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum BuiltinOptions2 : uint8_t {
  BuiltinOptions2_NONE = 0,
  BuiltinOptions2_StablehloConcatenateOptions = 1,
  BuiltinOptions2_StablehloBroadcastInDimOptions = 2,
  BuiltinOptions2_StablehloSliceOptions = 3,
  BuiltinOptions2_StablehloConvolutionOptions = 4,
  BuiltinOptions2_StablehloCustomCallOptions = 5,
  BuiltinOptions2_StablehloReduceOptions = 6,
  BuiltinOptions2_StablehloScatterOptions = 7,
  BuiltinOptions2_StablehloCompareOptions = 8,
  BuiltinOptions2_StablehloDynamicSliceOptions = 9,
  BuiltinOptions2_StablehloPadOptions = 10,
  BuiltinOptions2_StablehloIotaOptions = 11,
  BuiltinOptions2_StablehloDotGeneralOptions = 12,
  BuiltinOptions2_StablehloReduceWindowOptions = 13,
  BuiltinOptions2_StablehloSortOptions = 14,
  BuiltinOptions2_StablehloWhileOptions = 15,
  BuiltinOptions2_StablehloGatherOptions = 16,
  BuiltinOptions2_StablehloTransposeOptions = 17,
  BuiltinOptions2_DilateOptions = 18,
  BuiltinOptions2_StablehloRngBitGeneratorOptions = 19,
  BuiltinOptions2_ReduceWindowOptions = 20,
  BuiltinOptions2_StableHLOCompositeOptions = 21,
  BuiltinOptions2_MIN = BuiltinOptions2_NONE,
  BuiltinOptions2_MAX = BuiltinOptions2_StableHLOCompositeOptions
};

inline const BuiltinOptions2 (&EnumValuesBuiltinOptions2())[22] {
  static const BuiltinOptions2 values[] = {
    BuiltinOptions2_NONE,
    BuiltinOptions2_StablehloConcatenateOptions,
    BuiltinOptions2_StablehloBroadcastInDimOptions,
    BuiltinOptions2_StablehloSliceOptions,
    BuiltinOptions2_StablehloConvolutionOptions,
    BuiltinOptions2_StablehloCustomCallOptions,
    BuiltinOptions2_StablehloReduceOptions,
    BuiltinOptions2_StablehloScatterOptions,
    BuiltinOptions2_StablehloCompareOptions,
    BuiltinOptions2_StablehloDynamicSliceOptions,
    BuiltinOptions2_StablehloPadOptions,
    BuiltinOptions2_StablehloIotaOptions,
    BuiltinOptions2_StablehloDotGeneralOptions,
    BuiltinOptions2_StablehloReduceWindowOptions,
    BuiltinOptions2_StablehloSortOptions,
    BuiltinOptions2_StablehloWhileOptions,
    BuiltinOptions2_StablehloGatherOptions,
    BuiltinOptions2_StablehloTransposeOptions,
    BuiltinOptions2_DilateOptions,
    BuiltinOptions2_StablehloRngBitGeneratorOptions,
    BuiltinOptions2_ReduceWindowOptions,
    BuiltinOptions2_StableHLOCompositeOptions
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOptions2() {
  static const char * const names[23] = {
    "NONE",
    "StablehloConcatenateOptions",
    "StablehloBroadcastInDimOptions",
    "StablehloSliceOptions",
    "StablehloConvolutionOptions",
    "StablehloCustomCallOptions",
    "StablehloReduceOptions",
    "StablehloScatterOptions",
    "StablehloCompareOptions",
    "StablehloDynamicSliceOptions",
    "StablehloPadOptions",
    "StablehloIotaOptions",
    "StablehloDotGeneralOptions",
    "StablehloReduceWindowOptions",
    "StablehloSortOptions",
    "StablehloWhileOptions",
    "StablehloGatherOptions",
    "StablehloTransposeOptions",
    "DilateOptions",
    "StablehloRngBitGeneratorOptions",
    "ReduceWindowOptions",
    "StableHLOCompositeOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOptions2(BuiltinOptions2 e) {
  if (::flatbuffers::IsOutRange(e, BuiltinOptions2_NONE, BuiltinOptions2_StableHLOCompositeOptions)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions2()[index];
}

template<typename T> struct BuiltinOptions2Traits {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_NONE;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloConcatenateOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloConcatenateOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloBroadcastInDimOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloBroadcastInDimOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloSliceOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloSliceOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloConvolutionOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloConvolutionOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloCustomCallOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCustomCallOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloReduceOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloReduceOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloScatterOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloScatterOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloCompareOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCompareOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloDynamicSliceOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloDynamicSliceOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloPadOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloPadOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloIotaOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloIotaOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloDotGeneralOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloDotGeneralOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloReduceWindowOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloReduceWindowOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloSortOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloSortOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloWhileOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloWhileOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloGatherOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloGatherOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloTransposeOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloTransposeOptions;
};

template<> struct BuiltinOptions2Traits<tflite::DilateOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_DilateOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StablehloRngBitGeneratorOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloRngBitGeneratorOptions;
};

template<> struct BuiltinOptions2Traits<tflite::ReduceWindowOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_ReduceWindowOptions;
};

template<> struct BuiltinOptions2Traits<tflite::StableHLOCompositeOptions> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StableHLOCompositeOptions;
};

template<typename T> struct BuiltinOptions2UnionTraits {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_NONE;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloConcatenateOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloConcatenateOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloBroadcastInDimOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloBroadcastInDimOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloSliceOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloSliceOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloConvolutionOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloConvolutionOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloCustomCallOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCustomCallOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloReduceOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloReduceOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloScatterOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloScatterOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloCompareOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloCompareOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloDynamicSliceOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloDynamicSliceOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloPadOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloPadOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloIotaOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloIotaOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloDotGeneralOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloDotGeneralOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloReduceWindowOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloReduceWindowOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloSortOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloSortOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloWhileOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloWhileOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloGatherOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloGatherOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloTransposeOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloTransposeOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::DilateOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_DilateOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StablehloRngBitGeneratorOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StablehloRngBitGeneratorOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::ReduceWindowOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_ReduceWindowOptions;
};

template<> struct BuiltinOptions2UnionTraits<tflite::StableHLOCompositeOptionsT> {
  static const BuiltinOptions2 enum_value = BuiltinOptions2_StableHLOCompositeOptions;
};

struct BuiltinOptions2Union {
  BuiltinOptions2 type;
  void *value;

  BuiltinOptions2Union() : type(BuiltinOptions2_NONE), value(nullptr) {}
  BuiltinOptions2Union(BuiltinOptions2Union&& u) FLATBUFFERS_NOEXCEPT :
    type(BuiltinOptions2_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BuiltinOptions2Union(const BuiltinOptions2Union &);
  BuiltinOptions2Union &operator=(const BuiltinOptions2Union &u)
    { BuiltinOptions2Union t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BuiltinOptions2Union &operator=(BuiltinOptions2Union &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BuiltinOptions2Union() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = BuiltinOptions2UnionTraits<RT>::enum_value;
    if (type != BuiltinOptions2_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, BuiltinOptions2 type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::StablehloConcatenateOptionsT *AsStablehloConcatenateOptions() {
    return type == BuiltinOptions2_StablehloConcatenateOptions ?
      reinterpret_cast<tflite::StablehloConcatenateOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloConcatenateOptionsT *AsStablehloConcatenateOptions() const {
    return type == BuiltinOptions2_StablehloConcatenateOptions ?
      reinterpret_cast<const tflite::StablehloConcatenateOptionsT *>(value) : nullptr;
  }
  tflite::StablehloBroadcastInDimOptionsT *AsStablehloBroadcastInDimOptions() {
    return type == BuiltinOptions2_StablehloBroadcastInDimOptions ?
      reinterpret_cast<tflite::StablehloBroadcastInDimOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloBroadcastInDimOptionsT *AsStablehloBroadcastInDimOptions() const {
    return type == BuiltinOptions2_StablehloBroadcastInDimOptions ?
      reinterpret_cast<const tflite::StablehloBroadcastInDimOptionsT *>(value) : nullptr;
  }
  tflite::StablehloSliceOptionsT *AsStablehloSliceOptions() {
    return type == BuiltinOptions2_StablehloSliceOptions ?
      reinterpret_cast<tflite::StablehloSliceOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloSliceOptionsT *AsStablehloSliceOptions() const {
    return type == BuiltinOptions2_StablehloSliceOptions ?
      reinterpret_cast<const tflite::StablehloSliceOptionsT *>(value) : nullptr;
  }
  tflite::StablehloConvolutionOptionsT *AsStablehloConvolutionOptions() {
    return type == BuiltinOptions2_StablehloConvolutionOptions ?
      reinterpret_cast<tflite::StablehloConvolutionOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloConvolutionOptionsT *AsStablehloConvolutionOptions() const {
    return type == BuiltinOptions2_StablehloConvolutionOptions ?
      reinterpret_cast<const tflite::StablehloConvolutionOptionsT *>(value) : nullptr;
  }
  tflite::StablehloCustomCallOptionsT *AsStablehloCustomCallOptions() {
    return type == BuiltinOptions2_StablehloCustomCallOptions ?
      reinterpret_cast<tflite::StablehloCustomCallOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloCustomCallOptionsT *AsStablehloCustomCallOptions() const {
    return type == BuiltinOptions2_StablehloCustomCallOptions ?
      reinterpret_cast<const tflite::StablehloCustomCallOptionsT *>(value) : nullptr;
  }
  tflite::StablehloReduceOptionsT *AsStablehloReduceOptions() {
    return type == BuiltinOptions2_StablehloReduceOptions ?
      reinterpret_cast<tflite::StablehloReduceOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloReduceOptionsT *AsStablehloReduceOptions() const {
    return type == BuiltinOptions2_StablehloReduceOptions ?
      reinterpret_cast<const tflite::StablehloReduceOptionsT *>(value) : nullptr;
  }
  tflite::StablehloScatterOptionsT *AsStablehloScatterOptions() {
    return type == BuiltinOptions2_StablehloScatterOptions ?
      reinterpret_cast<tflite::StablehloScatterOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloScatterOptionsT *AsStablehloScatterOptions() const {
    return type == BuiltinOptions2_StablehloScatterOptions ?
      reinterpret_cast<const tflite::StablehloScatterOptionsT *>(value) : nullptr;
  }
  tflite::StablehloCompareOptionsT *AsStablehloCompareOptions() {
    return type == BuiltinOptions2_StablehloCompareOptions ?
      reinterpret_cast<tflite::StablehloCompareOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloCompareOptionsT *AsStablehloCompareOptions() const {
    return type == BuiltinOptions2_StablehloCompareOptions ?
      reinterpret_cast<const tflite::StablehloCompareOptionsT *>(value) : nullptr;
  }
  tflite::StablehloDynamicSliceOptionsT *AsStablehloDynamicSliceOptions() {
    return type == BuiltinOptions2_StablehloDynamicSliceOptions ?
      reinterpret_cast<tflite::StablehloDynamicSliceOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloDynamicSliceOptionsT *AsStablehloDynamicSliceOptions() const {
    return type == BuiltinOptions2_StablehloDynamicSliceOptions ?
      reinterpret_cast<const tflite::StablehloDynamicSliceOptionsT *>(value) : nullptr;
  }
  tflite::StablehloPadOptionsT *AsStablehloPadOptions() {
    return type == BuiltinOptions2_StablehloPadOptions ?
      reinterpret_cast<tflite::StablehloPadOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloPadOptionsT *AsStablehloPadOptions() const {
    return type == BuiltinOptions2_StablehloPadOptions ?
      reinterpret_cast<const tflite::StablehloPadOptionsT *>(value) : nullptr;
  }
  tflite::StablehloIotaOptionsT *AsStablehloIotaOptions() {
    return type == BuiltinOptions2_StablehloIotaOptions ?
      reinterpret_cast<tflite::StablehloIotaOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloIotaOptionsT *AsStablehloIotaOptions() const {
    return type == BuiltinOptions2_StablehloIotaOptions ?
      reinterpret_cast<const tflite::StablehloIotaOptionsT *>(value) : nullptr;
  }
  tflite::StablehloDotGeneralOptionsT *AsStablehloDotGeneralOptions() {
    return type == BuiltinOptions2_StablehloDotGeneralOptions ?
      reinterpret_cast<tflite::StablehloDotGeneralOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloDotGeneralOptionsT *AsStablehloDotGeneralOptions() const {
    return type == BuiltinOptions2_StablehloDotGeneralOptions ?
      reinterpret_cast<const tflite::StablehloDotGeneralOptionsT *>(value) : nullptr;
  }
  tflite::StablehloReduceWindowOptionsT *AsStablehloReduceWindowOptions() {
    return type == BuiltinOptions2_StablehloReduceWindowOptions ?
      reinterpret_cast<tflite::StablehloReduceWindowOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloReduceWindowOptionsT *AsStablehloReduceWindowOptions() const {
    return type == BuiltinOptions2_StablehloReduceWindowOptions ?
      reinterpret_cast<const tflite::StablehloReduceWindowOptionsT *>(value) : nullptr;
  }
  tflite::StablehloSortOptionsT *AsStablehloSortOptions() {
    return type == BuiltinOptions2_StablehloSortOptions ?
      reinterpret_cast<tflite::StablehloSortOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloSortOptionsT *AsStablehloSortOptions() const {
    return type == BuiltinOptions2_StablehloSortOptions ?
      reinterpret_cast<const tflite::StablehloSortOptionsT *>(value) : nullptr;
  }
  tflite::StablehloWhileOptionsT *AsStablehloWhileOptions() {
    return type == BuiltinOptions2_StablehloWhileOptions ?
      reinterpret_cast<tflite::StablehloWhileOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloWhileOptionsT *AsStablehloWhileOptions() const {
    return type == BuiltinOptions2_StablehloWhileOptions ?
      reinterpret_cast<const tflite::StablehloWhileOptionsT *>(value) : nullptr;
  }
  tflite::StablehloGatherOptionsT *AsStablehloGatherOptions() {
    return type == BuiltinOptions2_StablehloGatherOptions ?
      reinterpret_cast<tflite::StablehloGatherOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloGatherOptionsT *AsStablehloGatherOptions() const {
    return type == BuiltinOptions2_StablehloGatherOptions ?
      reinterpret_cast<const tflite::StablehloGatherOptionsT *>(value) : nullptr;
  }
  tflite::StablehloTransposeOptionsT *AsStablehloTransposeOptions() {
    return type == BuiltinOptions2_StablehloTransposeOptions ?
      reinterpret_cast<tflite::StablehloTransposeOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloTransposeOptionsT *AsStablehloTransposeOptions() const {
    return type == BuiltinOptions2_StablehloTransposeOptions ?
      reinterpret_cast<const tflite::StablehloTransposeOptionsT *>(value) : nullptr;
  }
  tflite::DilateOptionsT *AsDilateOptions() {
    return type == BuiltinOptions2_DilateOptions ?
      reinterpret_cast<tflite::DilateOptionsT *>(value) : nullptr;
  }
  const tflite::DilateOptionsT *AsDilateOptions() const {
    return type == BuiltinOptions2_DilateOptions ?
      reinterpret_cast<const tflite::DilateOptionsT *>(value) : nullptr;
  }
  tflite::StablehloRngBitGeneratorOptionsT *AsStablehloRngBitGeneratorOptions() {
    return type == BuiltinOptions2_StablehloRngBitGeneratorOptions ?
      reinterpret_cast<tflite::StablehloRngBitGeneratorOptionsT *>(value) : nullptr;
  }
  const tflite::StablehloRngBitGeneratorOptionsT *AsStablehloRngBitGeneratorOptions() const {
    return type == BuiltinOptions2_StablehloRngBitGeneratorOptions ?
      reinterpret_cast<const tflite::StablehloRngBitGeneratorOptionsT *>(value) : nullptr;
  }
  tflite::ReduceWindowOptionsT *AsReduceWindowOptions() {
    return type == BuiltinOptions2_ReduceWindowOptions ?
      reinterpret_cast<tflite::ReduceWindowOptionsT *>(value) : nullptr;
  }
  const tflite::ReduceWindowOptionsT *AsReduceWindowOptions() const {
    return type == BuiltinOptions2_ReduceWindowOptions ?
      reinterpret_cast<const tflite::ReduceWindowOptionsT *>(value) : nullptr;
  }
  tflite::StableHLOCompositeOptionsT *AsStableHLOCompositeOptions() {
    return type == BuiltinOptions2_StableHLOCompositeOptions ?
      reinterpret_cast<tflite::StableHLOCompositeOptionsT *>(value) : nullptr;
  }
  const tflite::StableHLOCompositeOptionsT *AsStableHLOCompositeOptions() const {
    return type == BuiltinOptions2_StableHLOCompositeOptions ?
      reinterpret_cast<const tflite::StableHLOCompositeOptionsT *>(value) : nullptr;
  }
};

bool VerifyBuiltinOptions2(::flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions2 type);
bool VerifyBuiltinOptions2Vector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum StablehloPrecisionConfig : uint32_t {
  StablehloPrecisionConfig_DEFAULT = 0,
  StablehloPrecisionConfig_HIGH = 1,
  StablehloPrecisionConfig_HIGHEST = 2,
  StablehloPrecisionConfig_MIN = StablehloPrecisionConfig_DEFAULT,
  StablehloPrecisionConfig_MAX = StablehloPrecisionConfig_HIGHEST
};

inline const StablehloPrecisionConfig (&EnumValuesStablehloPrecisionConfig())[3] {
  static const StablehloPrecisionConfig values[] = {
    StablehloPrecisionConfig_DEFAULT,
    StablehloPrecisionConfig_HIGH,
    StablehloPrecisionConfig_HIGHEST
  };
  return values;
}

inline const char * const *EnumNamesStablehloPrecisionConfig() {
  static const char * const names[4] = {
    "DEFAULT",
    "HIGH",
    "HIGHEST",
    nullptr
  };
  return names;
}

inline const char *EnumNameStablehloPrecisionConfig(StablehloPrecisionConfig e) {
  if (::flatbuffers::IsOutRange(e, StablehloPrecisionConfig_DEFAULT, StablehloPrecisionConfig_HIGHEST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStablehloPrecisionConfig()[index];
}

enum StablehloComparisonDirection : uint32_t {
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ = 0,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_NE = 1,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GE = 2,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GT = 3,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LE = 4,
  StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT = 5,
  StablehloComparisonDirection_MIN = StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
  StablehloComparisonDirection_MAX = StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT
};

inline const StablehloComparisonDirection (&EnumValuesStablehloComparisonDirection())[6] {
  static const StablehloComparisonDirection values[] = {
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_NE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_GT,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LE,
    StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT
  };
  return values;
}

inline const char * const *EnumNamesStablehloComparisonDirection() {
  static const char * const names[7] = {
    "STABLEHLO_COMPARISON_DIRECTION_EQ",
    "STABLEHLO_COMPARISON_DIRECTION_NE",
    "STABLEHLO_COMPARISON_DIRECTION_GE",
    "STABLEHLO_COMPARISON_DIRECTION_GT",
    "STABLEHLO_COMPARISON_DIRECTION_LE",
    "STABLEHLO_COMPARISON_DIRECTION_LT",
    nullptr
  };
  return names;
}

inline const char *EnumNameStablehloComparisonDirection(StablehloComparisonDirection e) {
  if (::flatbuffers::IsOutRange(e, StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ, StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_LT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStablehloComparisonDirection()[index];
}

enum StablehloComparisonType : uint32_t {
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE = 0,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT = 1,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER = 2,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_SIGNED = 3,
  StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED = 4,
  StablehloComparisonType_MIN = StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE,
  StablehloComparisonType_MAX = StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED
};

inline const StablehloComparisonType (&EnumValuesStablehloComparisonType())[5] {
  static const StablehloComparisonType values[] = {
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_SIGNED,
    StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED
  };
  return values;
}

inline const char * const *EnumNamesStablehloComparisonType() {
  static const char * const names[6] = {
    "STABLEHLO_COMPARISON_TYPE_NOTYPE",
    "STABLEHLO_COMPARISON_TYPE_FLOAT",
    "STABLEHLO_COMPARISON_TYPE_FLOAT_TOTAL_ORDER",
    "STABLEHLO_COMPARISON_TYPE_SIGNED",
    "STABLEHLO_COMPARISON_TYPE_UNSIGNED",
    nullptr
  };
  return names;
}

inline const char *EnumNameStablehloComparisonType(StablehloComparisonType e) {
  if (::flatbuffers::IsOutRange(e, StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE, StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_UNSIGNED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStablehloComparisonType()[index];
}

enum RngAlgorithm : int8_t {
  RngAlgorithm_DEFAULT = 0,
  RngAlgorithm_PHILOX = 1,
  RngAlgorithm_THREEFRY = 2,
  RngAlgorithm_MIN = RngAlgorithm_DEFAULT,
  RngAlgorithm_MAX = RngAlgorithm_THREEFRY
};

inline const RngAlgorithm (&EnumValuesRngAlgorithm())[3] {
  static const RngAlgorithm values[] = {
    RngAlgorithm_DEFAULT,
    RngAlgorithm_PHILOX,
    RngAlgorithm_THREEFRY
  };
  return values;
}

inline const char * const *EnumNamesRngAlgorithm() {
  static const char * const names[4] = {
    "DEFAULT",
    "PHILOX",
    "THREEFRY",
    nullptr
  };
  return names;
}

inline const char *EnumNameRngAlgorithm(RngAlgorithm e) {
  if (::flatbuffers::IsOutRange(e, RngAlgorithm_DEFAULT, RngAlgorithm_THREEFRY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRngAlgorithm()[index];
}

enum Padding : int8_t {
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2] {
  static const Padding values[] = {
    Padding_SAME,
    Padding_VALID
  };
  return values;
}

inline const char * const *EnumNamesPadding() {
  static const char * const names[3] = {
    "SAME",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadding(Padding e) {
  if (::flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType : int8_t {
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
  static const ActivationFunctionType values[] = {
    ActivationFunctionType_NONE,
    ActivationFunctionType_RELU,
    ActivationFunctionType_RELU_N1_TO_1,
    ActivationFunctionType_RELU6,
    ActivationFunctionType_TANH,
    ActivationFunctionType_SIGN_BIT
  };
  return values;
}

inline const char * const *EnumNamesActivationFunctionType() {
  static const char * const names[7] = {
    "NONE",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "TANH",
    "SIGN_BIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {
  if (::flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType : int8_t {
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
  static const LSHProjectionType values[] = {
    LSHProjectionType_UNKNOWN,
    LSHProjectionType_SPARSE,
    LSHProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLSHProjectionType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {
  if (::flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat : int8_t {
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_MIN = FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX = FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
  static const FullyConnectedOptionsWeightsFormat values[] = {
    FullyConnectedOptionsWeightsFormat_DEFAULT,
    FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
  };
  return values;
}

inline const char * const *EnumNamesFullyConnectedOptionsWeightsFormat() {
  static const char * const names[3] = {
    "DEFAULT",
    "SHUFFLED4x16INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {
  if (::flatbuffers::IsOutRange(e, FullyConnectedOptionsWeightsFormat_DEFAULT, FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum LSTMKernelType : int8_t {
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
  static const LSTMKernelType values[] = {
    LSTMKernelType_FULL,
    LSTMKernelType_BASIC
  };
  return values;
}

inline const char * const *EnumNamesLSTMKernelType() {
  static const char * const names[3] = {
    "FULL",
    "BASIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {
  if (::flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType : int8_t {
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
  static const CombinerType values[] = {
    CombinerType_SUM,
    CombinerType_MEAN,
    CombinerType_SQRTN
  };
  return values;
}

inline const char * const *EnumNamesCombinerType() {
  static const char * const names[4] = {
    "SUM",
    "MEAN",
    "SQRTN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCombinerType(CombinerType e) {
  if (::flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCombinerType()[index];
}

enum MirrorPadMode : int8_t {
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2] {
  static const MirrorPadMode values[] = {
    MirrorPadMode_REFLECT,
    MirrorPadMode_SYMMETRIC
  };
  return values;
}

inline const char * const *EnumNamesMirrorPadMode() {
  static const char * const names[3] = {
    "REFLECT",
    "SYMMETRIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e) {
  if (::flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum ReduceWindowFunction : int32_t {
  ReduceWindowFunction_UNSUPPORTED = 0,
  ReduceWindowFunction_ADD = 1,
  ReduceWindowFunction_MUL = 2,
  ReduceWindowFunction_MINIMUM = 3,
  ReduceWindowFunction_MAXIMUM = 4,
  ReduceWindowFunction_ALL = 5,
  ReduceWindowFunction_ANY = 6,
  ReduceWindowFunction_MIN = ReduceWindowFunction_UNSUPPORTED,
  ReduceWindowFunction_MAX = ReduceWindowFunction_ANY
};

inline const ReduceWindowFunction (&EnumValuesReduceWindowFunction())[7] {
  static const ReduceWindowFunction values[] = {
    ReduceWindowFunction_UNSUPPORTED,
    ReduceWindowFunction_ADD,
    ReduceWindowFunction_MUL,
    ReduceWindowFunction_MINIMUM,
    ReduceWindowFunction_MAXIMUM,
    ReduceWindowFunction_ALL,
    ReduceWindowFunction_ANY
  };
  return values;
}

inline const char * const *EnumNamesReduceWindowFunction() {
  static const char * const names[8] = {
    "UNSUPPORTED",
    "ADD",
    "MUL",
    "MINIMUM",
    "MAXIMUM",
    "ALL",
    "ANY",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceWindowFunction(ReduceWindowFunction e) {
  if (::flatbuffers::IsOutRange(e, ReduceWindowFunction_UNSUPPORTED, ReduceWindowFunction_ANY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceWindowFunction()[index];
}

enum CustomOptionsFormat : int8_t {
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
  static const CustomOptionsFormat values[] = {
    CustomOptionsFormat_FLEXBUFFERS
  };
  return values;
}

inline const char * const *EnumNamesCustomOptionsFormat() {
  static const char * const names[2] = {
    "FLEXBUFFERS",
    nullptr
  };
  return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
  if (::flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS, CustomOptionsFormat_FLEXBUFFERS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

struct CustomQuantizationT : public ::flatbuffers::NativeTable {
  typedef CustomQuantization TableType;
  std::vector<uint8_t> custom{};
};

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CustomQuantizationT NativeTableType;
  typedef CustomQuantizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUSTOM = 4
  };
  const ::flatbuffers::Vector<uint8_t> *custom() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) &&
           verifier.EndTable();
  }
  CustomQuantizationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomQuantizationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CustomQuantization> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomQuantizationBuilder {
  typedef CustomQuantization Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_custom(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
  }
  explicit CustomQuantizationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CustomQuantization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *custom = nullptr) {
  if (custom) { _fbb.ForceVectorAlignment(custom->size(), sizeof(uint8_t), 16); }
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return tflite::CreateCustomQuantization(
      _fbb,
      custom__);
}

::flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(::flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizationParametersT : public ::flatbuffers::NativeTable {
  typedef QuantizationParameters TableType;
  std::vector<float> min{};
  std::vector<float> max{};
  std::vector<float> scale{};
  std::vector<int64_t> zero_point{};
  tflite::QuantizationDetailsUnion details{};
  int32_t quantized_dimension = 0;
};

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizationParametersT NativeTableType;
  typedef QuantizationParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SCALE = 8,
    VT_ZERO_POINT = 10,
    VT_DETAILS_TYPE = 12,
    VT_DETAILS = 14,
    VT_QUANTIZED_DIMENSION = 16
  };
  const ::flatbuffers::Vector<float> *min() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MIN);
  }
  const ::flatbuffers::Vector<float> *max() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MAX);
  }
  const ::flatbuffers::Vector<float> *scale() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const ::flatbuffers::Vector<int64_t> *zero_point() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
  }
  tflite::QuantizationDetails details_type() const {
    return static_cast<tflite::QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  const void *details() const {
    return GetPointer<const void *>(VT_DETAILS);
  }
  template<typename T> const T *details_as() const;
  const tflite::CustomQuantization *details_as_CustomQuantization() const {
    return details_type() == tflite::QuantizationDetails_CustomQuantization ? static_cast<const tflite::CustomQuantization *>(details()) : nullptr;
  }
  int32_t quantized_dimension() const {
    return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_ZERO_POINT) &&
           verifier.VerifyVector(zero_point()) &&
           VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE, 1) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION, 4) &&
           verifier.EndTable();
  }
  QuantizationParametersT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizationParametersT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<QuantizationParameters> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::CustomQuantization *QuantizationParameters::details_as<tflite::CustomQuantization>() const {
  return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder {
  typedef QuantizationParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(::flatbuffers::Offset<::flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
  }
  void add_max(::flatbuffers::Offset<::flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
  }
  void add_scale(::flatbuffers::Offset<::flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
  }
  void add_zero_point(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_point) {
    fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  void add_details_type(tflite::QuantizationDetails details_type) {
    fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE, static_cast<uint8_t>(details_type), 0);
  }
  void add_details(::flatbuffers::Offset<void> details) {
    fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
  }
  void add_quantized_dimension(int32_t quantized_dimension) {
    fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension, 0);
  }
  explicit QuantizationParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizationParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> min = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> max = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> scale = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_point = 0,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,
    ::flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_quantized_dimension(quantized_dimension);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *min = nullptr,
    const std::vector<float> *max = nullptr,
    const std::vector<float> *scale = nullptr,
    const std::vector<int64_t> *zero_point = nullptr,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,
    ::flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto zero_point__ = zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0;
  return tflite::CreateQuantizationParameters(
      _fbb,
      min__,
      max__,
      scale__,
      zero_point__,
      details_type,
      details,
      quantized_dimension);
}

::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int32VectorT : public ::flatbuffers::NativeTable {
  typedef Int32Vector TableType;
  std::vector<int32_t> values{};
};

struct Int32Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int32VectorT NativeTableType;
  typedef Int32VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<int32_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Int32VectorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int32VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int32Vector> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int32VectorBuilder {
  typedef Int32Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values) {
    fbb_.AddOffset(Int32Vector::VT_VALUES, values);
  }
  explicit Int32VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int32Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int32Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int32Vector> CreateInt32Vector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values = 0) {
  Int32VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Int32Vector> CreateInt32VectorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
  return tflite::CreateInt32Vector(
      _fbb,
      values__);
}

::flatbuffers::Offset<Int32Vector> CreateInt32Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint16VectorT : public ::flatbuffers::NativeTable {
  typedef Uint16Vector TableType;
  std::vector<uint16_t> values{};
};

struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Uint16VectorT NativeTableType;
  typedef Uint16VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<uint16_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Uint16VectorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Uint16VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Uint16Vector> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint16VectorBuilder {
  typedef Uint16Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> values) {
    fbb_.AddOffset(Uint16Vector::VT_VALUES, values);
  }
  explicit Uint16VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Uint16Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Uint16Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Uint16Vector> CreateUint16Vector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> values = 0) {
  Uint16VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Uint16Vector> CreateUint16VectorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *values = nullptr) {
  if (values) { _fbb.ForceVectorAlignment(values->size(), sizeof(uint16_t), 4); }
  auto values__ = values ? _fbb.CreateVector<uint16_t>(*values) : 0;
  return tflite::CreateUint16Vector(
      _fbb,
      values__);
}

::flatbuffers::Offset<Uint16Vector> CreateUint16Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint8VectorT : public ::flatbuffers::NativeTable {
  typedef Uint8Vector TableType;
  std::vector<uint8_t> values{};
};

struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Uint8VectorT NativeTableType;
  typedef Uint8VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<uint8_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Uint8VectorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Uint8VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Uint8Vector> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint8VectorBuilder {
  typedef Uint8Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values) {
    fbb_.AddOffset(Uint8Vector::VT_VALUES, values);
  }
  explicit Uint8VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Uint8Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Uint8Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Uint8Vector> CreateUint8Vector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values = 0) {
  Uint8VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Uint8Vector> CreateUint8VectorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *values = nullptr) {
  if (values) { _fbb.ForceVectorAlignment(values->size(), sizeof(uint8_t), 4); }
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  return tflite::CreateUint8Vector(
      _fbb,
      values__);
}

::flatbuffers::Offset<Uint8Vector> CreateUint8Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DimensionMetadataT : public ::flatbuffers::NativeTable {
  typedef DimensionMetadata TableType;
  tflite::DimensionType format = tflite::DimensionType_DENSE;
  int32_t dense_size = 0;
  tflite::SparseIndexVectorUnion array_segments{};
  tflite::SparseIndexVectorUnion array_indices{};
};

struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DimensionMetadataT NativeTableType;
  typedef DimensionMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_DENSE_SIZE = 6,
    VT_ARRAY_SEGMENTS_TYPE = 8,
    VT_ARRAY_SEGMENTS = 10,
    VT_ARRAY_INDICES_TYPE = 12,
    VT_ARRAY_INDICES = 14
  };
  tflite::DimensionType format() const {
    return static_cast<tflite::DimensionType>(GetField<int8_t>(VT_FORMAT, 0));
  }
  int32_t dense_size() const {
    return GetField<int32_t>(VT_DENSE_SIZE, 0);
  }
  tflite::SparseIndexVector array_segments_type() const {
    return static_cast<tflite::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_SEGMENTS_TYPE, 0));
  }
  const void *array_segments() const {
    return GetPointer<const void *>(VT_ARRAY_SEGMENTS);
  }
  template<typename T> const T *array_segments_as() const;
  const tflite::Int32Vector *array_segments_as_Int32Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Int32Vector ? static_cast<const tflite::Int32Vector *>(array_segments()) : nullptr;
  }
  const tflite::Uint16Vector *array_segments_as_Uint16Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Uint16Vector ? static_cast<const tflite::Uint16Vector *>(array_segments()) : nullptr;
  }
  const tflite::Uint8Vector *array_segments_as_Uint8Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Uint8Vector ? static_cast<const tflite::Uint8Vector *>(array_segments()) : nullptr;
  }
  tflite::SparseIndexVector array_indices_type() const {
    return static_cast<tflite::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_INDICES_TYPE, 0));
  }
  const void *array_indices() const {
    return GetPointer<const void *>(VT_ARRAY_INDICES);
  }
  template<typename T> const T *array_indices_as() const;
  const tflite::Int32Vector *array_indices_as_Int32Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Int32Vector ? static_cast<const tflite::Int32Vector *>(array_indices()) : nullptr;
  }
  const tflite::Uint16Vector *array_indices_as_Uint16Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Uint16Vector ? static_cast<const tflite::Uint16Vector *>(array_indices()) : nullptr;
  }
  const tflite::Uint8Vector *array_indices_as_Uint8Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Uint8Vector ? static_cast<const tflite::Uint8Vector *>(array_indices()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FORMAT, 1) &&
           VerifyField<int32_t>(verifier, VT_DENSE_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_SEGMENTS_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARRAY_SEGMENTS) &&
           VerifySparseIndexVector(verifier, array_segments(), array_segments_type()) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_INDICES_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARRAY_INDICES) &&
           VerifySparseIndexVector(verifier, array_indices(), array_indices_type()) &&
           verifier.EndTable();
  }
  DimensionMetadataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DimensionMetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DimensionMetadata> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::Int32Vector *DimensionMetadata::array_segments_as<tflite::Int32Vector>() const {
  return array_segments_as_Int32Vector();
}

template<> inline const tflite::Uint16Vector *DimensionMetadata::array_segments_as<tflite::Uint16Vector>() const {
  return array_segments_as_Uint16Vector();
}

template<> inline const tflite::Uint8Vector *DimensionMetadata::array_segments_as<tflite::Uint8Vector>() const {
  return array_segments_as_Uint8Vector();
}

template<> inline const tflite::Int32Vector *DimensionMetadata::array_indices_as<tflite::Int32Vector>() const {
  return array_indices_as_Int32Vector();
}

template<> inline const tflite::Uint16Vector *DimensionMetadata::array_indices_as<tflite::Uint16Vector>() const {
  return array_indices_as_Uint16Vector();
}

template<> inline const tflite::Uint8Vector *DimensionMetadata::array_indices_as<tflite::Uint8Vector>() const {
  return array_indices_as_Uint8Vector();
}

struct DimensionMetadataBuilder {
  typedef DimensionMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_format(tflite::DimensionType format) {
    fbb_.AddElement<int8_t>(DimensionMetadata::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  void add_dense_size(int32_t dense_size) {
    fbb_.AddElement<int32_t>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
  }
  void add_array_segments_type(tflite::SparseIndexVector array_segments_type) {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE, static_cast<uint8_t>(array_segments_type), 0);
  }
  void add_array_segments(::flatbuffers::Offset<void> array_segments) {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);
  }
  void add_array_indices_type(tflite::SparseIndexVector array_indices_type) {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_INDICES_TYPE, static_cast<uint8_t>(array_indices_type), 0);
  }
  void add_array_indices(::flatbuffers::Offset<void> array_indices) {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_INDICES, array_indices);
  }
  explicit DimensionMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DimensionMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DimensionMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::DimensionType format = tflite::DimensionType_DENSE,
    int32_t dense_size = 0,
    tflite::SparseIndexVector array_segments_type = tflite::SparseIndexVector_NONE,
    ::flatbuffers::Offset<void> array_segments = 0,
    tflite::SparseIndexVector array_indices_type = tflite::SparseIndexVector_NONE,
    ::flatbuffers::Offset<void> array_indices = 0) {
  DimensionMetadataBuilder builder_(_fbb);
  builder_.add_array_indices(array_indices);
  builder_.add_array_segments(array_segments);
  builder_.add_dense_size(dense_size);
  builder_.add_array_indices_type(array_indices_type);
  builder_.add_array_segments_type(array_segments_type);
  builder_.add_format(format);
  return builder_.Finish();
}

::flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparsityParametersT : public ::flatbuffers::NativeTable {
  typedef SparsityParameters TableType;
  std::vector<int32_t> traversal_order{};
  std::vector<int32_t> block_map{};
  std::vector<std::unique_ptr<tflite::DimensionMetadataT>> dim_metadata{};
  SparsityParametersT() = default;
  SparsityParametersT(const SparsityParametersT &o);
  SparsityParametersT(SparsityParametersT&&) FLATBUFFERS_NOEXCEPT = default;
  SparsityParametersT &operator=(SparsityParametersT o) FLATBUFFERS_NOEXCEPT;
};

struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SparsityParametersT NativeTableType;
  typedef SparsityParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRAVERSAL_ORDER = 4,
    VT_BLOCK_MAP = 6,
    VT_DIM_METADATA = 8
  };
  const ::flatbuffers::Vector<int32_t> *traversal_order() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TRAVERSAL_ORDER);
  }
  const ::flatbuffers::Vector<int32_t> *block_map() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_BLOCK_MAP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::DimensionMetadata>> *>(VT_DIM_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAVERSAL_ORDER) &&
           verifier.VerifyVector(traversal_order()) &&
           VerifyOffset(verifier, VT_BLOCK_MAP) &&
           verifier.VerifyVector(block_map()) &&
           VerifyOffset(verifier, VT_DIM_METADATA) &&
           verifier.VerifyVector(dim_metadata()) &&
           verifier.VerifyVectorOfTables(dim_metadata()) &&
           verifier.EndTable();
  }
  SparsityParametersT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparsityParametersT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SparsityParameters> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparsityParametersBuilder {
  typedef SparsityParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_traversal_order(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> traversal_order) {
    fbb_.AddOffset(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);
  }
  void add_block_map(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> block_map) {
    fbb_.AddOffset(SparsityParameters::VT_BLOCK_MAP, block_map);
  }
  void add_dim_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata) {
    fbb_.AddOffset(SparsityParameters::VT_DIM_METADATA, dim_metadata);
  }
  explicit SparsityParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparsityParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparsityParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> traversal_order = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> block_map = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata = 0) {
  SparsityParametersBuilder builder_(_fbb);
  builder_.add_dim_metadata(dim_metadata);
  builder_.add_block_map(block_map);
  builder_.add_traversal_order(traversal_order);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *traversal_order = nullptr,
    const std::vector<int32_t> *block_map = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata = nullptr) {
  auto traversal_order__ = traversal_order ? _fbb.CreateVector<int32_t>(*traversal_order) : 0;
  auto block_map__ = block_map ? _fbb.CreateVector<int32_t>(*block_map) : 0;
  auto dim_metadata__ = dim_metadata ? _fbb.CreateVector<::flatbuffers::Offset<tflite::DimensionMetadata>>(*dim_metadata) : 0;
  return tflite::CreateSparsityParameters(
      _fbb,
      traversal_order__,
      block_map__,
      dim_metadata__);
}

::flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VariantSubTypeT : public ::flatbuffers::NativeTable {
  typedef VariantSubType TableType;
  std::vector<int32_t> shape{};
  tflite::TensorType type = tflite::TensorType_FLOAT32;
  bool has_rank = false;
};

struct VariantSubType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VariantSubTypeT NativeTableType;
  typedef VariantSubTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_HAS_RANK = 8
  };
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  tflite::TensorType type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool has_rank() const {
    return GetField<uint8_t>(VT_HAS_RANK, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_HAS_RANK, 1) &&
           verifier.EndTable();
  }
  VariantSubTypeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VariantSubTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VariantSubType> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VariantSubTypeBuilder {
  typedef VariantSubType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(VariantSubType::VT_SHAPE, shape);
  }
  void add_type(tflite::TensorType type) {
    fbb_.AddElement<int8_t>(VariantSubType::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_has_rank(bool has_rank) {
    fbb_.AddElement<uint8_t>(VariantSubType::VT_HAS_RANK, static_cast<uint8_t>(has_rank), 0);
  }
  explicit VariantSubTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VariantSubType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VariantSubType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VariantSubType> CreateVariantSubType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    tflite::TensorType type = tflite::TensorType_FLOAT32,
    bool has_rank = false) {
  VariantSubTypeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_has_rank(has_rank);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VariantSubType> CreateVariantSubTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    tflite::TensorType type = tflite::TensorType_FLOAT32,
    bool has_rank = false) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return tflite::CreateVariantSubType(
      _fbb,
      shape__,
      type,
      has_rank);
}

::flatbuffers::Offset<VariantSubType> CreateVariantSubType(::flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public ::flatbuffers::NativeTable {
  typedef Tensor TableType;
  std::vector<int32_t> shape{};
  tflite::TensorType type = tflite::TensorType_FLOAT32;
  uint32_t buffer = 0;
  std::string name{};
  std::unique_ptr<tflite::QuantizationParametersT> quantization{};
  bool is_variable = false;
  std::unique_ptr<tflite::SparsityParametersT> sparsity{};
  std::vector<int32_t> shape_signature{};
  bool has_rank = false;
  std::vector<std::unique_ptr<tflite::VariantSubTypeT>> variant_tensors{};
  TensorT() = default;
  TensorT(const TensorT &o);
  TensorT(TensorT&&) FLATBUFFERS_NOEXCEPT = default;
  TensorT &operator=(TensorT o) FLATBUFFERS_NOEXCEPT;
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorT NativeTableType;
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER = 8,
    VT_NAME = 10,
    VT_QUANTIZATION = 12,
    VT_IS_VARIABLE = 14,
    VT_SPARSITY = 16,
    VT_SHAPE_SIGNATURE = 18,
    VT_HAS_RANK = 20,
    VT_VARIANT_TENSORS = 22
  };
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  tflite::TensorType type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(VT_BUFFER, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const tflite::QuantizationParameters *quantization() const {
    return GetPointer<const tflite::QuantizationParameters *>(VT_QUANTIZATION);
  }
  bool is_variable() const {
    return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0;
  }
  const tflite::SparsityParameters *sparsity() const {
    return GetPointer<const tflite::SparsityParameters *>(VT_SPARSITY);
  }
  const ::flatbuffers::Vector<int32_t> *shape_signature() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE_SIGNATURE);
  }
  bool has_rank() const {
    return GetField<uint8_t>(VT_HAS_RANK, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::VariantSubType>> *variant_tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::VariantSubType>> *>(VT_VARIANT_TENSORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_QUANTIZATION) &&
           verifier.VerifyTable(quantization()) &&
           VerifyField<uint8_t>(verifier, VT_IS_VARIABLE, 1) &&
           VerifyOffset(verifier, VT_SPARSITY) &&
           verifier.VerifyTable(sparsity()) &&
           VerifyOffset(verifier, VT_SHAPE_SIGNATURE) &&
           verifier.VerifyVector(shape_signature()) &&
           VerifyField<uint8_t>(verifier, VT_HAS_RANK, 1) &&
           VerifyOffset(verifier, VT_VARIANT_TENSORS) &&
           verifier.VerifyVector(variant_tensors()) &&
           verifier.VerifyVectorOfTables(variant_tensors()) &&
           verifier.EndTable();
  }
  TensorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Tensor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(tflite::TensorType type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_quantization(::flatbuffers::Offset<tflite::QuantizationParameters> quantization) {
    fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
  }
  void add_is_variable(bool is_variable) {
    fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
  }
  void add_sparsity(::flatbuffers::Offset<tflite::SparsityParameters> sparsity) {
    fbb_.AddOffset(Tensor::VT_SPARSITY, sparsity);
  }
  void add_shape_signature(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape_signature) {
    fbb_.AddOffset(Tensor::VT_SHAPE_SIGNATURE, shape_signature);
  }
  void add_has_rank(bool has_rank) {
    fbb_.AddElement<uint8_t>(Tensor::VT_HAS_RANK, static_cast<uint8_t>(has_rank), 0);
  }
  void add_variant_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::VariantSubType>>> variant_tensors) {
    fbb_.AddOffset(Tensor::VT_VARIANT_TENSORS, variant_tensors);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    tflite::TensorType type = tflite::TensorType_FLOAT32,
    uint32_t buffer = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
    bool is_variable = false,
    ::flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape_signature = 0,
    bool has_rank = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::VariantSubType>>> variant_tensors = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_variant_tensors(variant_tensors);
  builder_.add_shape_signature(shape_signature);
  builder_.add_sparsity(sparsity);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_has_rank(has_rank);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    tflite::TensorType type = tflite::TensorType_FLOAT32,
    uint32_t buffer = 0,
    const char *name = nullptr,
    ::flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
    bool is_variable = false,
    ::flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,
    const std::vector<int32_t> *shape_signature = nullptr,
    bool has_rank = false,
    const std::vector<::flatbuffers::Offset<tflite::VariantSubType>> *variant_tensors = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape_signature__ = shape_signature ? _fbb.CreateVector<int32_t>(*shape_signature) : 0;
  auto variant_tensors__ = variant_tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::VariantSubType>>(*variant_tensors) : 0;
  return tflite::CreateTensor(
      _fbb,
      shape__,
      type,
      buffer,
      name__,
      quantization,
      is_variable,
      sparsity,
      shape_signature__,
      has_rank,
      variant_tensors__);
}

::flatbuffers::Offset<Tensor> CreateTensor(::flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloGatherOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloGatherOptions TableType;
  std::vector<int64_t> offset_dims{};
  std::vector<int64_t> collapsed_slice_dims{};
  std::vector<int64_t> start_index_map{};
  int64_t index_vector_dim = 0;
  std::vector<int64_t> slice_sizes{};
  bool indices_are_sorted = false;
};

struct StablehloGatherOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloGatherOptionsT NativeTableType;
  typedef StablehloGatherOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET_DIMS = 4,
    VT_COLLAPSED_SLICE_DIMS = 6,
    VT_START_INDEX_MAP = 8,
    VT_INDEX_VECTOR_DIM = 10,
    VT_SLICE_SIZES = 12,
    VT_INDICES_ARE_SORTED = 14
  };
  const ::flatbuffers::Vector<int64_t> *offset_dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_OFFSET_DIMS);
  }
  const ::flatbuffers::Vector<int64_t> *collapsed_slice_dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_COLLAPSED_SLICE_DIMS);
  }
  const ::flatbuffers::Vector<int64_t> *start_index_map() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_START_INDEX_MAP);
  }
  int64_t index_vector_dim() const {
    return GetField<int64_t>(VT_INDEX_VECTOR_DIM, 0);
  }
  const ::flatbuffers::Vector<int64_t> *slice_sizes() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SLICE_SIZES);
  }
  bool indices_are_sorted() const {
    return GetField<uint8_t>(VT_INDICES_ARE_SORTED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OFFSET_DIMS) &&
           verifier.VerifyVector(offset_dims()) &&
           VerifyOffset(verifier, VT_COLLAPSED_SLICE_DIMS) &&
           verifier.VerifyVector(collapsed_slice_dims()) &&
           VerifyOffset(verifier, VT_START_INDEX_MAP) &&
           verifier.VerifyVector(start_index_map()) &&
           VerifyField<int64_t>(verifier, VT_INDEX_VECTOR_DIM, 8) &&
           VerifyOffset(verifier, VT_SLICE_SIZES) &&
           verifier.VerifyVector(slice_sizes()) &&
           VerifyField<uint8_t>(verifier, VT_INDICES_ARE_SORTED, 1) &&
           verifier.EndTable();
  }
  StablehloGatherOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloGatherOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloGatherOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloGatherOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloGatherOptionsBuilder {
  typedef StablehloGatherOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_offset_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> offset_dims) {
    fbb_.AddOffset(StablehloGatherOptions::VT_OFFSET_DIMS, offset_dims);
  }
  void add_collapsed_slice_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> collapsed_slice_dims) {
    fbb_.AddOffset(StablehloGatherOptions::VT_COLLAPSED_SLICE_DIMS, collapsed_slice_dims);
  }
  void add_start_index_map(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> start_index_map) {
    fbb_.AddOffset(StablehloGatherOptions::VT_START_INDEX_MAP, start_index_map);
  }
  void add_index_vector_dim(int64_t index_vector_dim) {
    fbb_.AddElement<int64_t>(StablehloGatherOptions::VT_INDEX_VECTOR_DIM, index_vector_dim, 0);
  }
  void add_slice_sizes(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> slice_sizes) {
    fbb_.AddOffset(StablehloGatherOptions::VT_SLICE_SIZES, slice_sizes);
  }
  void add_indices_are_sorted(bool indices_are_sorted) {
    fbb_.AddElement<uint8_t>(StablehloGatherOptions::VT_INDICES_ARE_SORTED, static_cast<uint8_t>(indices_are_sorted), 0);
  }
  explicit StablehloGatherOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloGatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloGatherOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> offset_dims = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> collapsed_slice_dims = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> start_index_map = 0,
    int64_t index_vector_dim = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> slice_sizes = 0,
    bool indices_are_sorted = false) {
  StablehloGatherOptionsBuilder builder_(_fbb);
  builder_.add_index_vector_dim(index_vector_dim);
  builder_.add_slice_sizes(slice_sizes);
  builder_.add_start_index_map(start_index_map);
  builder_.add_collapsed_slice_dims(collapsed_slice_dims);
  builder_.add_offset_dims(offset_dims);
  builder_.add_indices_are_sorted(indices_are_sorted);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *offset_dims = nullptr,
    const std::vector<int64_t> *collapsed_slice_dims = nullptr,
    const std::vector<int64_t> *start_index_map = nullptr,
    int64_t index_vector_dim = 0,
    const std::vector<int64_t> *slice_sizes = nullptr,
    bool indices_are_sorted = false) {
  auto offset_dims__ = offset_dims ? _fbb.CreateVector<int64_t>(*offset_dims) : 0;
  auto collapsed_slice_dims__ = collapsed_slice_dims ? _fbb.CreateVector<int64_t>(*collapsed_slice_dims) : 0;
  auto start_index_map__ = start_index_map ? _fbb.CreateVector<int64_t>(*start_index_map) : 0;
  auto slice_sizes__ = slice_sizes ? _fbb.CreateVector<int64_t>(*slice_sizes) : 0;
  return tflite::CreateStablehloGatherOptions(
      _fbb,
      offset_dims__,
      collapsed_slice_dims__,
      start_index_map__,
      index_vector_dim,
      slice_sizes__,
      indices_are_sorted);
}

::flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloGatherOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloTransposeOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloTransposeOptions TableType;
  std::vector<int64_t> permutation{};
};

struct StablehloTransposeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloTransposeOptionsT NativeTableType;
  typedef StablehloTransposeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERMUTATION = 4
  };
  const ::flatbuffers::Vector<int64_t> *permutation() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_PERMUTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERMUTATION) &&
           verifier.VerifyVector(permutation()) &&
           verifier.EndTable();
  }
  StablehloTransposeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloTransposeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloTransposeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloTransposeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloTransposeOptionsBuilder {
  typedef StablehloTransposeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_permutation(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> permutation) {
    fbb_.AddOffset(StablehloTransposeOptions::VT_PERMUTATION, permutation);
  }
  explicit StablehloTransposeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloTransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloTransposeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloTransposeOptions> CreateStablehloTransposeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> permutation = 0) {
  StablehloTransposeOptionsBuilder builder_(_fbb);
  builder_.add_permutation(permutation);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloTransposeOptions> CreateStablehloTransposeOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *permutation = nullptr) {
  auto permutation__ = permutation ? _fbb.CreateVector<int64_t>(*permutation) : 0;
  return tflite::CreateStablehloTransposeOptions(
      _fbb,
      permutation__);
}

::flatbuffers::Offset<StablehloTransposeOptions> CreateStablehloTransposeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloTransposeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloDotGeneralOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloDotGeneralOptions TableType;
  std::vector<int64_t> lhs_batching_dimensions{};
  std::vector<int64_t> rhs_batching_dimensions{};
  std::vector<int64_t> lhs_contracting_dimensions{};
  std::vector<int64_t> rhs_contracting_dimensions{};
  std::vector<tflite::StablehloPrecisionConfig> precision_config{};
};

struct StablehloDotGeneralOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloDotGeneralOptionsT NativeTableType;
  typedef StablehloDotGeneralOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LHS_BATCHING_DIMENSIONS = 4,
    VT_RHS_BATCHING_DIMENSIONS = 6,
    VT_LHS_CONTRACTING_DIMENSIONS = 8,
    VT_RHS_CONTRACTING_DIMENSIONS = 10,
    VT_PRECISION_CONFIG = 12
  };
  const ::flatbuffers::Vector<int64_t> *lhs_batching_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_LHS_BATCHING_DIMENSIONS);
  }
  const ::flatbuffers::Vector<int64_t> *rhs_batching_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_RHS_BATCHING_DIMENSIONS);
  }
  const ::flatbuffers::Vector<int64_t> *lhs_contracting_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_LHS_CONTRACTING_DIMENSIONS);
  }
  const ::flatbuffers::Vector<int64_t> *rhs_contracting_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_RHS_CONTRACTING_DIMENSIONS);
  }
  const ::flatbuffers::Vector<uint32_t> *precision_config() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_PRECISION_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LHS_BATCHING_DIMENSIONS) &&
           verifier.VerifyVector(lhs_batching_dimensions()) &&
           VerifyOffset(verifier, VT_RHS_BATCHING_DIMENSIONS) &&
           verifier.VerifyVector(rhs_batching_dimensions()) &&
           VerifyOffset(verifier, VT_LHS_CONTRACTING_DIMENSIONS) &&
           verifier.VerifyVector(lhs_contracting_dimensions()) &&
           VerifyOffset(verifier, VT_RHS_CONTRACTING_DIMENSIONS) &&
           verifier.VerifyVector(rhs_contracting_dimensions()) &&
           VerifyOffset(verifier, VT_PRECISION_CONFIG) &&
           verifier.VerifyVector(precision_config()) &&
           verifier.EndTable();
  }
  StablehloDotGeneralOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloDotGeneralOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloDotGeneralOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloDotGeneralOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloDotGeneralOptionsBuilder {
  typedef StablehloDotGeneralOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lhs_batching_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_batching_dimensions) {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_LHS_BATCHING_DIMENSIONS, lhs_batching_dimensions);
  }
  void add_rhs_batching_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_batching_dimensions) {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_RHS_BATCHING_DIMENSIONS, rhs_batching_dimensions);
  }
  void add_lhs_contracting_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_contracting_dimensions) {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_LHS_CONTRACTING_DIMENSIONS, lhs_contracting_dimensions);
  }
  void add_rhs_contracting_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_contracting_dimensions) {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_RHS_CONTRACTING_DIMENSIONS, rhs_contracting_dimensions);
  }
  void add_precision_config(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> precision_config) {
    fbb_.AddOffset(StablehloDotGeneralOptions::VT_PRECISION_CONFIG, precision_config);
  }
  explicit StablehloDotGeneralOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloDotGeneralOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloDotGeneralOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_batching_dimensions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_batching_dimensions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_contracting_dimensions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_contracting_dimensions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> precision_config = 0) {
  StablehloDotGeneralOptionsBuilder builder_(_fbb);
  builder_.add_precision_config(precision_config);
  builder_.add_rhs_contracting_dimensions(rhs_contracting_dimensions);
  builder_.add_lhs_contracting_dimensions(lhs_contracting_dimensions);
  builder_.add_rhs_batching_dimensions(rhs_batching_dimensions);
  builder_.add_lhs_batching_dimensions(lhs_batching_dimensions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *lhs_batching_dimensions = nullptr,
    const std::vector<int64_t> *rhs_batching_dimensions = nullptr,
    const std::vector<int64_t> *lhs_contracting_dimensions = nullptr,
    const std::vector<int64_t> *rhs_contracting_dimensions = nullptr,
    const std::vector<uint32_t> *precision_config = nullptr) {
  auto lhs_batching_dimensions__ = lhs_batching_dimensions ? _fbb.CreateVector<int64_t>(*lhs_batching_dimensions) : 0;
  auto rhs_batching_dimensions__ = rhs_batching_dimensions ? _fbb.CreateVector<int64_t>(*rhs_batching_dimensions) : 0;
  auto lhs_contracting_dimensions__ = lhs_contracting_dimensions ? _fbb.CreateVector<int64_t>(*lhs_contracting_dimensions) : 0;
  auto rhs_contracting_dimensions__ = rhs_contracting_dimensions ? _fbb.CreateVector<int64_t>(*rhs_contracting_dimensions) : 0;
  auto precision_config__ = precision_config ? _fbb.CreateVector<uint32_t>(*precision_config) : 0;
  return tflite::CreateStablehloDotGeneralOptions(
      _fbb,
      lhs_batching_dimensions__,
      rhs_batching_dimensions__,
      lhs_contracting_dimensions__,
      rhs_contracting_dimensions__,
      precision_config__);
}

::flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloDotGeneralOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloReduceWindowOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloReduceWindowOptions TableType;
  std::vector<int64_t> window_dimensions{};
  std::vector<int64_t> window_strides{};
  std::vector<int64_t> base_dilations{};
  std::vector<int64_t> window_dilations{};
  std::vector<int64_t> padding{};
  int32_t body_subgraph_index = 0;
};

struct StablehloReduceWindowOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloReduceWindowOptionsT NativeTableType;
  typedef StablehloReduceWindowOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WINDOW_DIMENSIONS = 4,
    VT_WINDOW_STRIDES = 6,
    VT_BASE_DILATIONS = 8,
    VT_WINDOW_DILATIONS = 10,
    VT_PADDING = 12,
    VT_BODY_SUBGRAPH_INDEX = 14
  };
  const ::flatbuffers::Vector<int64_t> *window_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_WINDOW_DIMENSIONS);
  }
  const ::flatbuffers::Vector<int64_t> *window_strides() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_WINDOW_STRIDES);
  }
  const ::flatbuffers::Vector<int64_t> *base_dilations() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_BASE_DILATIONS);
  }
  const ::flatbuffers::Vector<int64_t> *window_dilations() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_WINDOW_DILATIONS);
  }
  const ::flatbuffers::Vector<int64_t> *padding() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_PADDING);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WINDOW_DIMENSIONS) &&
           verifier.VerifyVector(window_dimensions()) &&
           VerifyOffset(verifier, VT_WINDOW_STRIDES) &&
           verifier.VerifyVector(window_strides()) &&
           VerifyOffset(verifier, VT_BASE_DILATIONS) &&
           verifier.VerifyVector(base_dilations()) &&
           VerifyOffset(verifier, VT_WINDOW_DILATIONS) &&
           verifier.VerifyVector(window_dilations()) &&
           VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyVector(padding()) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  StablehloReduceWindowOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloReduceWindowOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloReduceWindowOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceWindowOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloReduceWindowOptionsBuilder {
  typedef StablehloReduceWindowOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_window_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_dimensions) {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_WINDOW_DIMENSIONS, window_dimensions);
  }
  void add_window_strides(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_strides) {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_WINDOW_STRIDES, window_strides);
  }
  void add_base_dilations(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> base_dilations) {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_BASE_DILATIONS, base_dilations);
  }
  void add_window_dilations(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_dilations) {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_WINDOW_DILATIONS, window_dilations);
  }
  void add_padding(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding) {
    fbb_.AddOffset(StablehloReduceWindowOptions::VT_PADDING, padding);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(StablehloReduceWindowOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit StablehloReduceWindowOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloReduceWindowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloReduceWindowOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_dimensions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_strides = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> base_dilations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_dilations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding = 0,
    int32_t body_subgraph_index = 0) {
  StablehloReduceWindowOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_padding(padding);
  builder_.add_window_dilations(window_dilations);
  builder_.add_base_dilations(base_dilations);
  builder_.add_window_strides(window_strides);
  builder_.add_window_dimensions(window_dimensions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *window_dimensions = nullptr,
    const std::vector<int64_t> *window_strides = nullptr,
    const std::vector<int64_t> *base_dilations = nullptr,
    const std::vector<int64_t> *window_dilations = nullptr,
    const std::vector<int64_t> *padding = nullptr,
    int32_t body_subgraph_index = 0) {
  auto window_dimensions__ = window_dimensions ? _fbb.CreateVector<int64_t>(*window_dimensions) : 0;
  auto window_strides__ = window_strides ? _fbb.CreateVector<int64_t>(*window_strides) : 0;
  auto base_dilations__ = base_dilations ? _fbb.CreateVector<int64_t>(*base_dilations) : 0;
  auto window_dilations__ = window_dilations ? _fbb.CreateVector<int64_t>(*window_dilations) : 0;
  auto padding__ = padding ? _fbb.CreateVector<int64_t>(*padding) : 0;
  return tflite::CreateStablehloReduceWindowOptions(
      _fbb,
      window_dimensions__,
      window_strides__,
      base_dilations__,
      window_dilations__,
      padding__,
      body_subgraph_index);
}

::flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceWindowOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloWhileOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloWhileOptions TableType;
  int32_t cond_subgraph_index = 0;
  int32_t body_subgraph_index = 0;
};

struct StablehloWhileOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloWhileOptionsT NativeTableType;
  typedef StablehloWhileOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND_SUBGRAPH_INDEX = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  int32_t cond_subgraph_index() const {
    return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  StablehloWhileOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloWhileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloWhileOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloWhileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloWhileOptionsBuilder {
  typedef StablehloWhileOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index) {
    fbb_.AddElement<int32_t>(StablehloWhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(StablehloWhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit StablehloWhileOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloWhileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloWhileOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloWhileOptions> CreateStablehloWhileOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cond_subgraph_index = 0,
    int32_t body_subgraph_index = 0) {
  StablehloWhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

::flatbuffers::Offset<StablehloWhileOptions> CreateStablehloWhileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloWhileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloSortOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloSortOptions TableType;
  int64_t dimension = 0;
  bool is_stable = false;
  int32_t comparator_subgraph_index = 0;
};

struct StablehloSortOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloSortOptionsT NativeTableType;
  typedef StablehloSortOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMENSION = 4,
    VT_IS_STABLE = 6,
    VT_COMPARATOR_SUBGRAPH_INDEX = 8
  };
  int64_t dimension() const {
    return GetField<int64_t>(VT_DIMENSION, 0);
  }
  bool is_stable() const {
    return GetField<uint8_t>(VT_IS_STABLE, 0) != 0;
  }
  int32_t comparator_subgraph_index() const {
    return GetField<int32_t>(VT_COMPARATOR_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DIMENSION, 8) &&
           VerifyField<uint8_t>(verifier, VT_IS_STABLE, 1) &&
           VerifyField<int32_t>(verifier, VT_COMPARATOR_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  StablehloSortOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloSortOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloSortOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloSortOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloSortOptionsBuilder {
  typedef StablehloSortOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dimension(int64_t dimension) {
    fbb_.AddElement<int64_t>(StablehloSortOptions::VT_DIMENSION, dimension, 0);
  }
  void add_is_stable(bool is_stable) {
    fbb_.AddElement<uint8_t>(StablehloSortOptions::VT_IS_STABLE, static_cast<uint8_t>(is_stable), 0);
  }
  void add_comparator_subgraph_index(int32_t comparator_subgraph_index) {
    fbb_.AddElement<int32_t>(StablehloSortOptions::VT_COMPARATOR_SUBGRAPH_INDEX, comparator_subgraph_index, 0);
  }
  explicit StablehloSortOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloSortOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloSortOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloSortOptions> CreateStablehloSortOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dimension = 0,
    bool is_stable = false,
    int32_t comparator_subgraph_index = 0) {
  StablehloSortOptionsBuilder builder_(_fbb);
  builder_.add_dimension(dimension);
  builder_.add_comparator_subgraph_index(comparator_subgraph_index);
  builder_.add_is_stable(is_stable);
  return builder_.Finish();
}

::flatbuffers::Offset<StablehloSortOptions> CreateStablehloSortOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloSortOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloConcatenateOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloConcatenateOptions TableType;
  int64_t dimension = 0;
};

struct StablehloConcatenateOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloConcatenateOptionsT NativeTableType;
  typedef StablehloConcatenateOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMENSION = 4
  };
  int64_t dimension() const {
    return GetField<int64_t>(VT_DIMENSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DIMENSION, 8) &&
           verifier.EndTable();
  }
  StablehloConcatenateOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloConcatenateOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloConcatenateOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloConcatenateOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloConcatenateOptionsBuilder {
  typedef StablehloConcatenateOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dimension(int64_t dimension) {
    fbb_.AddElement<int64_t>(StablehloConcatenateOptions::VT_DIMENSION, dimension, 0);
  }
  explicit StablehloConcatenateOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloConcatenateOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloConcatenateOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloConcatenateOptions> CreateStablehloConcatenateOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dimension = 0) {
  StablehloConcatenateOptionsBuilder builder_(_fbb);
  builder_.add_dimension(dimension);
  return builder_.Finish();
}

::flatbuffers::Offset<StablehloConcatenateOptions> CreateStablehloConcatenateOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloConcatenateOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloBroadcastInDimOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloBroadcastInDimOptions TableType;
  std::vector<int64_t> broadcast_dimensions{};
};

struct StablehloBroadcastInDimOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloBroadcastInDimOptionsT NativeTableType;
  typedef StablehloBroadcastInDimOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BROADCAST_DIMENSIONS = 4
  };
  const ::flatbuffers::Vector<int64_t> *broadcast_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_BROADCAST_DIMENSIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BROADCAST_DIMENSIONS) &&
           verifier.VerifyVector(broadcast_dimensions()) &&
           verifier.EndTable();
  }
  StablehloBroadcastInDimOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloBroadcastInDimOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloBroadcastInDimOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloBroadcastInDimOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloBroadcastInDimOptionsBuilder {
  typedef StablehloBroadcastInDimOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_broadcast_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> broadcast_dimensions) {
    fbb_.AddOffset(StablehloBroadcastInDimOptions::VT_BROADCAST_DIMENSIONS, broadcast_dimensions);
  }
  explicit StablehloBroadcastInDimOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloBroadcastInDimOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloBroadcastInDimOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> broadcast_dimensions = 0) {
  StablehloBroadcastInDimOptionsBuilder builder_(_fbb);
  builder_.add_broadcast_dimensions(broadcast_dimensions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *broadcast_dimensions = nullptr) {
  auto broadcast_dimensions__ = broadcast_dimensions ? _fbb.CreateVector<int64_t>(*broadcast_dimensions) : 0;
  return tflite::CreateStablehloBroadcastInDimOptions(
      _fbb,
      broadcast_dimensions__);
}

::flatbuffers::Offset<StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloBroadcastInDimOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloCompareOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloCompareOptions TableType;
  tflite::StablehloComparisonDirection comparison_direction = tflite::StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ;
  tflite::StablehloComparisonType compare_type = tflite::StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE;
};

struct StablehloCompareOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloCompareOptionsT NativeTableType;
  typedef StablehloCompareOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPARISON_DIRECTION = 4,
    VT_COMPARE_TYPE = 6
  };
  tflite::StablehloComparisonDirection comparison_direction() const {
    return static_cast<tflite::StablehloComparisonDirection>(GetField<uint32_t>(VT_COMPARISON_DIRECTION, 0));
  }
  tflite::StablehloComparisonType compare_type() const {
    return static_cast<tflite::StablehloComparisonType>(GetField<uint32_t>(VT_COMPARE_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COMPARISON_DIRECTION, 4) &&
           VerifyField<uint32_t>(verifier, VT_COMPARE_TYPE, 4) &&
           verifier.EndTable();
  }
  StablehloCompareOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloCompareOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloCompareOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloCompareOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloCompareOptionsBuilder {
  typedef StablehloCompareOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_comparison_direction(tflite::StablehloComparisonDirection comparison_direction) {
    fbb_.AddElement<uint32_t>(StablehloCompareOptions::VT_COMPARISON_DIRECTION, static_cast<uint32_t>(comparison_direction), 0);
  }
  void add_compare_type(tflite::StablehloComparisonType compare_type) {
    fbb_.AddElement<uint32_t>(StablehloCompareOptions::VT_COMPARE_TYPE, static_cast<uint32_t>(compare_type), 0);
  }
  explicit StablehloCompareOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloCompareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloCompareOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloCompareOptions> CreateStablehloCompareOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::StablehloComparisonDirection comparison_direction = tflite::StablehloComparisonDirection_STABLEHLO_COMPARISON_DIRECTION_EQ,
    tflite::StablehloComparisonType compare_type = tflite::StablehloComparisonType_STABLEHLO_COMPARISON_TYPE_NOTYPE) {
  StablehloCompareOptionsBuilder builder_(_fbb);
  builder_.add_compare_type(compare_type);
  builder_.add_comparison_direction(comparison_direction);
  return builder_.Finish();
}

::flatbuffers::Offset<StablehloCompareOptions> CreateStablehloCompareOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloCompareOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloDynamicSliceOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloDynamicSliceOptions TableType;
  std::vector<int64_t> slice_sizes{};
};

struct StablehloDynamicSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloDynamicSliceOptionsT NativeTableType;
  typedef StablehloDynamicSliceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLICE_SIZES = 4
  };
  const ::flatbuffers::Vector<int64_t> *slice_sizes() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SLICE_SIZES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SLICE_SIZES) &&
           verifier.VerifyVector(slice_sizes()) &&
           verifier.EndTable();
  }
  StablehloDynamicSliceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloDynamicSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloDynamicSliceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloDynamicSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloDynamicSliceOptionsBuilder {
  typedef StablehloDynamicSliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_slice_sizes(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> slice_sizes) {
    fbb_.AddOffset(StablehloDynamicSliceOptions::VT_SLICE_SIZES, slice_sizes);
  }
  explicit StablehloDynamicSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloDynamicSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloDynamicSliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> slice_sizes = 0) {
  StablehloDynamicSliceOptionsBuilder builder_(_fbb);
  builder_.add_slice_sizes(slice_sizes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *slice_sizes = nullptr) {
  auto slice_sizes__ = slice_sizes ? _fbb.CreateVector<int64_t>(*slice_sizes) : 0;
  return tflite::CreateStablehloDynamicSliceOptions(
      _fbb,
      slice_sizes__);
}

::flatbuffers::Offset<StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloDynamicSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloPadOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloPadOptions TableType;
  std::vector<int64_t> edge_padding_low{};
  std::vector<int64_t> edge_padding_high{};
  std::vector<int64_t> interior_padding{};
};

struct StablehloPadOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloPadOptionsT NativeTableType;
  typedef StablehloPadOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EDGE_PADDING_LOW = 4,
    VT_EDGE_PADDING_HIGH = 6,
    VT_INTERIOR_PADDING = 8
  };
  const ::flatbuffers::Vector<int64_t> *edge_padding_low() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EDGE_PADDING_LOW);
  }
  const ::flatbuffers::Vector<int64_t> *edge_padding_high() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EDGE_PADDING_HIGH);
  }
  const ::flatbuffers::Vector<int64_t> *interior_padding() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INTERIOR_PADDING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EDGE_PADDING_LOW) &&
           verifier.VerifyVector(edge_padding_low()) &&
           VerifyOffset(verifier, VT_EDGE_PADDING_HIGH) &&
           verifier.VerifyVector(edge_padding_high()) &&
           VerifyOffset(verifier, VT_INTERIOR_PADDING) &&
           verifier.VerifyVector(interior_padding()) &&
           verifier.EndTable();
  }
  StablehloPadOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloPadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloPadOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloPadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloPadOptionsBuilder {
  typedef StablehloPadOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_edge_padding_low(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> edge_padding_low) {
    fbb_.AddOffset(StablehloPadOptions::VT_EDGE_PADDING_LOW, edge_padding_low);
  }
  void add_edge_padding_high(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> edge_padding_high) {
    fbb_.AddOffset(StablehloPadOptions::VT_EDGE_PADDING_HIGH, edge_padding_high);
  }
  void add_interior_padding(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> interior_padding) {
    fbb_.AddOffset(StablehloPadOptions::VT_INTERIOR_PADDING, interior_padding);
  }
  explicit StablehloPadOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloPadOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloPadOptions> CreateStablehloPadOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> edge_padding_low = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> edge_padding_high = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> interior_padding = 0) {
  StablehloPadOptionsBuilder builder_(_fbb);
  builder_.add_interior_padding(interior_padding);
  builder_.add_edge_padding_high(edge_padding_high);
  builder_.add_edge_padding_low(edge_padding_low);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloPadOptions> CreateStablehloPadOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *edge_padding_low = nullptr,
    const std::vector<int64_t> *edge_padding_high = nullptr,
    const std::vector<int64_t> *interior_padding = nullptr) {
  auto edge_padding_low__ = edge_padding_low ? _fbb.CreateVector<int64_t>(*edge_padding_low) : 0;
  auto edge_padding_high__ = edge_padding_high ? _fbb.CreateVector<int64_t>(*edge_padding_high) : 0;
  auto interior_padding__ = interior_padding ? _fbb.CreateVector<int64_t>(*interior_padding) : 0;
  return tflite::CreateStablehloPadOptions(
      _fbb,
      edge_padding_low__,
      edge_padding_high__,
      interior_padding__);
}

::flatbuffers::Offset<StablehloPadOptions> CreateStablehloPadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloPadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloIotaOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloIotaOptions TableType;
  int64_t iota_dimension = 0;
};

struct StablehloIotaOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloIotaOptionsT NativeTableType;
  typedef StablehloIotaOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IOTA_DIMENSION = 4
  };
  int64_t iota_dimension() const {
    return GetField<int64_t>(VT_IOTA_DIMENSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_IOTA_DIMENSION, 8) &&
           verifier.EndTable();
  }
  StablehloIotaOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloIotaOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloIotaOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloIotaOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloIotaOptionsBuilder {
  typedef StablehloIotaOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_iota_dimension(int64_t iota_dimension) {
    fbb_.AddElement<int64_t>(StablehloIotaOptions::VT_IOTA_DIMENSION, iota_dimension, 0);
  }
  explicit StablehloIotaOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloIotaOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloIotaOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloIotaOptions> CreateStablehloIotaOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t iota_dimension = 0) {
  StablehloIotaOptionsBuilder builder_(_fbb);
  builder_.add_iota_dimension(iota_dimension);
  return builder_.Finish();
}

::flatbuffers::Offset<StablehloIotaOptions> CreateStablehloIotaOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloIotaOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloCustomCallOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloCustomCallOptions TableType;
  std::string call_target_name{};
  bool has_side_effect = false;
  std::string backend_config{};
  int32_t api_version = 0;
  std::vector<int32_t> called_computations{};
  std::vector<uint8_t> custom_attributes{};
};

struct StablehloCustomCallOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloCustomCallOptionsT NativeTableType;
  typedef StablehloCustomCallOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALL_TARGET_NAME = 4,
    VT_HAS_SIDE_EFFECT = 6,
    VT_BACKEND_CONFIG = 8,
    VT_API_VERSION = 10,
    VT_CALLED_COMPUTATIONS = 12,
    VT_CUSTOM_ATTRIBUTES = 14
  };
  const ::flatbuffers::String *call_target_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALL_TARGET_NAME);
  }
  bool has_side_effect() const {
    return GetField<uint8_t>(VT_HAS_SIDE_EFFECT, 0) != 0;
  }
  const ::flatbuffers::String *backend_config() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BACKEND_CONFIG);
  }
  int32_t api_version() const {
    return GetField<int32_t>(VT_API_VERSION, 0);
  }
  const ::flatbuffers::Vector<int32_t> *called_computations() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_CALLED_COMPUTATIONS);
  }
  const ::flatbuffers::Vector<uint8_t> *custom_attributes() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_ATTRIBUTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALL_TARGET_NAME) &&
           verifier.VerifyString(call_target_name()) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SIDE_EFFECT, 1) &&
           VerifyOffset(verifier, VT_BACKEND_CONFIG) &&
           verifier.VerifyString(backend_config()) &&
           VerifyField<int32_t>(verifier, VT_API_VERSION, 4) &&
           VerifyOffset(verifier, VT_CALLED_COMPUTATIONS) &&
           verifier.VerifyVector(called_computations()) &&
           VerifyOffset(verifier, VT_CUSTOM_ATTRIBUTES) &&
           verifier.VerifyVector(custom_attributes()) &&
           verifier.EndTable();
  }
  StablehloCustomCallOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloCustomCallOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloCustomCallOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloCustomCallOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloCustomCallOptionsBuilder {
  typedef StablehloCustomCallOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_call_target_name(::flatbuffers::Offset<::flatbuffers::String> call_target_name) {
    fbb_.AddOffset(StablehloCustomCallOptions::VT_CALL_TARGET_NAME, call_target_name);
  }
  void add_has_side_effect(bool has_side_effect) {
    fbb_.AddElement<uint8_t>(StablehloCustomCallOptions::VT_HAS_SIDE_EFFECT, static_cast<uint8_t>(has_side_effect), 0);
  }
  void add_backend_config(::flatbuffers::Offset<::flatbuffers::String> backend_config) {
    fbb_.AddOffset(StablehloCustomCallOptions::VT_BACKEND_CONFIG, backend_config);
  }
  void add_api_version(int32_t api_version) {
    fbb_.AddElement<int32_t>(StablehloCustomCallOptions::VT_API_VERSION, api_version, 0);
  }
  void add_called_computations(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> called_computations) {
    fbb_.AddOffset(StablehloCustomCallOptions::VT_CALLED_COMPUTATIONS, called_computations);
  }
  void add_custom_attributes(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_attributes) {
    fbb_.AddOffset(StablehloCustomCallOptions::VT_CUSTOM_ATTRIBUTES, custom_attributes);
  }
  explicit StablehloCustomCallOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloCustomCallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloCustomCallOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> call_target_name = 0,
    bool has_side_effect = false,
    ::flatbuffers::Offset<::flatbuffers::String> backend_config = 0,
    int32_t api_version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> called_computations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_attributes = 0) {
  StablehloCustomCallOptionsBuilder builder_(_fbb);
  builder_.add_custom_attributes(custom_attributes);
  builder_.add_called_computations(called_computations);
  builder_.add_api_version(api_version);
  builder_.add_backend_config(backend_config);
  builder_.add_call_target_name(call_target_name);
  builder_.add_has_side_effect(has_side_effect);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *call_target_name = nullptr,
    bool has_side_effect = false,
    const char *backend_config = nullptr,
    int32_t api_version = 0,
    const std::vector<int32_t> *called_computations = nullptr,
    const std::vector<uint8_t> *custom_attributes = nullptr) {
  auto call_target_name__ = call_target_name ? _fbb.CreateString(call_target_name) : 0;
  auto backend_config__ = backend_config ? _fbb.CreateString(backend_config) : 0;
  auto called_computations__ = called_computations ? _fbb.CreateVector<int32_t>(*called_computations) : 0;
  auto custom_attributes__ = custom_attributes ? _fbb.CreateVector<uint8_t>(*custom_attributes) : 0;
  return tflite::CreateStablehloCustomCallOptions(
      _fbb,
      call_target_name__,
      has_side_effect,
      backend_config__,
      api_version,
      called_computations__,
      custom_attributes__);
}

::flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloCustomCallOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloReduceOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloReduceOptions TableType;
  std::vector<int64_t> dimensions{};
  int32_t body_subgraph_index = 0;
};

struct StablehloReduceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloReduceOptionsT NativeTableType;
  typedef StablehloReduceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMENSIONS = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  const ::flatbuffers::Vector<int64_t> *dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMENSIONS);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMENSIONS) &&
           verifier.VerifyVector(dimensions()) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  StablehloReduceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloReduceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloReduceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloReduceOptionsBuilder {
  typedef StablehloReduceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dimensions) {
    fbb_.AddOffset(StablehloReduceOptions::VT_DIMENSIONS, dimensions);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(StablehloReduceOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit StablehloReduceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloReduceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloReduceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloReduceOptions> CreateStablehloReduceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dimensions = 0,
    int32_t body_subgraph_index = 0) {
  StablehloReduceOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_dimensions(dimensions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloReduceOptions> CreateStablehloReduceOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dimensions = nullptr,
    int32_t body_subgraph_index = 0) {
  auto dimensions__ = dimensions ? _fbb.CreateVector<int64_t>(*dimensions) : 0;
  return tflite::CreateStablehloReduceOptions(
      _fbb,
      dimensions__,
      body_subgraph_index);
}

::flatbuffers::Offset<StablehloReduceOptions> CreateStablehloReduceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloSliceOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloSliceOptions TableType;
  std::vector<int64_t> start_indices{};
  std::vector<int64_t> limit_indices{};
  std::vector<int64_t> strides{};
};

struct StablehloSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloSliceOptionsT NativeTableType;
  typedef StablehloSliceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_INDICES = 4,
    VT_LIMIT_INDICES = 6,
    VT_STRIDES = 8
  };
  const ::flatbuffers::Vector<int64_t> *start_indices() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_START_INDICES);
  }
  const ::flatbuffers::Vector<int64_t> *limit_indices() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_LIMIT_INDICES);
  }
  const ::flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_START_INDICES) &&
           verifier.VerifyVector(start_indices()) &&
           VerifyOffset(verifier, VT_LIMIT_INDICES) &&
           verifier.VerifyVector(limit_indices()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
  StablehloSliceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloSliceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloSliceOptionsBuilder {
  typedef StablehloSliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_indices(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> start_indices) {
    fbb_.AddOffset(StablehloSliceOptions::VT_START_INDICES, start_indices);
  }
  void add_limit_indices(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> limit_indices) {
    fbb_.AddOffset(StablehloSliceOptions::VT_LIMIT_INDICES, limit_indices);
  }
  void add_strides(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(StablehloSliceOptions::VT_STRIDES, strides);
  }
  explicit StablehloSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloSliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloSliceOptions> CreateStablehloSliceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> start_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> limit_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> strides = 0) {
  StablehloSliceOptionsBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_limit_indices(limit_indices);
  builder_.add_start_indices(start_indices);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloSliceOptions> CreateStablehloSliceOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *start_indices = nullptr,
    const std::vector<int64_t> *limit_indices = nullptr,
    const std::vector<int64_t> *strides = nullptr) {
  auto start_indices__ = start_indices ? _fbb.CreateVector<int64_t>(*start_indices) : 0;
  auto limit_indices__ = limit_indices ? _fbb.CreateVector<int64_t>(*limit_indices) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  return tflite::CreateStablehloSliceOptions(
      _fbb,
      start_indices__,
      limit_indices__,
      strides__);
}

::flatbuffers::Offset<StablehloSliceOptions> CreateStablehloSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloConvolutionOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloConvolutionOptions TableType;
  std::vector<int64_t> window_strides{};
  std::vector<int64_t> padding{};
  std::vector<int64_t> lhs_dilation{};
  std::vector<int64_t> rhs_dilation{};
  std::vector<bool> window_reversal{};
  int64_t input_batch_dimension = 0;
  int64_t input_feature_dimension = 0;
  std::vector<int64_t> input_spatial_dimensions{};
  int64_t kernel_input_feature_dimension = 0;
  int64_t kernel_output_feature_dimension = 0;
  std::vector<int64_t> kernel_spatial_dimensions{};
  int64_t output_batch_dimension = 0;
  int64_t output_feature_dimension = 0;
  std::vector<int64_t> output_spatial_dimensions{};
  int64_t feature_group_count = 0;
  int64_t batch_group_count = 0;
  std::vector<tflite::StablehloPrecisionConfig> precision_config{};
};

struct StablehloConvolutionOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloConvolutionOptionsT NativeTableType;
  typedef StablehloConvolutionOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WINDOW_STRIDES = 4,
    VT_PADDING = 6,
    VT_LHS_DILATION = 8,
    VT_RHS_DILATION = 10,
    VT_WINDOW_REVERSAL = 12,
    VT_INPUT_BATCH_DIMENSION = 14,
    VT_INPUT_FEATURE_DIMENSION = 16,
    VT_INPUT_SPATIAL_DIMENSIONS = 18,
    VT_KERNEL_INPUT_FEATURE_DIMENSION = 20,
    VT_KERNEL_OUTPUT_FEATURE_DIMENSION = 22,
    VT_KERNEL_SPATIAL_DIMENSIONS = 24,
    VT_OUTPUT_BATCH_DIMENSION = 26,
    VT_OUTPUT_FEATURE_DIMENSION = 28,
    VT_OUTPUT_SPATIAL_DIMENSIONS = 30,
    VT_FEATURE_GROUP_COUNT = 32,
    VT_BATCH_GROUP_COUNT = 34,
    VT_PRECISION_CONFIG = 36
  };
  const ::flatbuffers::Vector<int64_t> *window_strides() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_WINDOW_STRIDES);
  }
  const ::flatbuffers::Vector<int64_t> *padding() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_PADDING);
  }
  const ::flatbuffers::Vector<int64_t> *lhs_dilation() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_LHS_DILATION);
  }
  const ::flatbuffers::Vector<int64_t> *rhs_dilation() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_RHS_DILATION);
  }
  const ::flatbuffers::Vector<uint8_t> *window_reversal() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_WINDOW_REVERSAL);
  }
  int64_t input_batch_dimension() const {
    return GetField<int64_t>(VT_INPUT_BATCH_DIMENSION, 0);
  }
  int64_t input_feature_dimension() const {
    return GetField<int64_t>(VT_INPUT_FEATURE_DIMENSION, 0);
  }
  const ::flatbuffers::Vector<int64_t> *input_spatial_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INPUT_SPATIAL_DIMENSIONS);
  }
  int64_t kernel_input_feature_dimension() const {
    return GetField<int64_t>(VT_KERNEL_INPUT_FEATURE_DIMENSION, 0);
  }
  int64_t kernel_output_feature_dimension() const {
    return GetField<int64_t>(VT_KERNEL_OUTPUT_FEATURE_DIMENSION, 0);
  }
  const ::flatbuffers::Vector<int64_t> *kernel_spatial_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_KERNEL_SPATIAL_DIMENSIONS);
  }
  int64_t output_batch_dimension() const {
    return GetField<int64_t>(VT_OUTPUT_BATCH_DIMENSION, 0);
  }
  int64_t output_feature_dimension() const {
    return GetField<int64_t>(VT_OUTPUT_FEATURE_DIMENSION, 0);
  }
  const ::flatbuffers::Vector<int64_t> *output_spatial_dimensions() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_OUTPUT_SPATIAL_DIMENSIONS);
  }
  int64_t feature_group_count() const {
    return GetField<int64_t>(VT_FEATURE_GROUP_COUNT, 0);
  }
  int64_t batch_group_count() const {
    return GetField<int64_t>(VT_BATCH_GROUP_COUNT, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *precision_config() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_PRECISION_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WINDOW_STRIDES) &&
           verifier.VerifyVector(window_strides()) &&
           VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyVector(padding()) &&
           VerifyOffset(verifier, VT_LHS_DILATION) &&
           verifier.VerifyVector(lhs_dilation()) &&
           VerifyOffset(verifier, VT_RHS_DILATION) &&
           verifier.VerifyVector(rhs_dilation()) &&
           VerifyOffset(verifier, VT_WINDOW_REVERSAL) &&
           verifier.VerifyVector(window_reversal()) &&
           VerifyField<int64_t>(verifier, VT_INPUT_BATCH_DIMENSION, 8) &&
           VerifyField<int64_t>(verifier, VT_INPUT_FEATURE_DIMENSION, 8) &&
           VerifyOffset(verifier, VT_INPUT_SPATIAL_DIMENSIONS) &&
           verifier.VerifyVector(input_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, VT_KERNEL_INPUT_FEATURE_DIMENSION, 8) &&
           VerifyField<int64_t>(verifier, VT_KERNEL_OUTPUT_FEATURE_DIMENSION, 8) &&
           VerifyOffset(verifier, VT_KERNEL_SPATIAL_DIMENSIONS) &&
           verifier.VerifyVector(kernel_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_BATCH_DIMENSION, 8) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_FEATURE_DIMENSION, 8) &&
           VerifyOffset(verifier, VT_OUTPUT_SPATIAL_DIMENSIONS) &&
           verifier.VerifyVector(output_spatial_dimensions()) &&
           VerifyField<int64_t>(verifier, VT_FEATURE_GROUP_COUNT, 8) &&
           VerifyField<int64_t>(verifier, VT_BATCH_GROUP_COUNT, 8) &&
           VerifyOffset(verifier, VT_PRECISION_CONFIG) &&
           verifier.VerifyVector(precision_config()) &&
           verifier.EndTable();
  }
  StablehloConvolutionOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloConvolutionOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloConvolutionOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloConvolutionOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloConvolutionOptionsBuilder {
  typedef StablehloConvolutionOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_window_strides(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_strides) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_WINDOW_STRIDES, window_strides);
  }
  void add_padding(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_PADDING, padding);
  }
  void add_lhs_dilation(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_dilation) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_LHS_DILATION, lhs_dilation);
  }
  void add_rhs_dilation(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_dilation) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_RHS_DILATION, rhs_dilation);
  }
  void add_window_reversal(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> window_reversal) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_WINDOW_REVERSAL, window_reversal);
  }
  void add_input_batch_dimension(int64_t input_batch_dimension) {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_INPUT_BATCH_DIMENSION, input_batch_dimension, 0);
  }
  void add_input_feature_dimension(int64_t input_feature_dimension) {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_INPUT_FEATURE_DIMENSION, input_feature_dimension, 0);
  }
  void add_input_spatial_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> input_spatial_dimensions) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_INPUT_SPATIAL_DIMENSIONS, input_spatial_dimensions);
  }
  void add_kernel_input_feature_dimension(int64_t kernel_input_feature_dimension) {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_KERNEL_INPUT_FEATURE_DIMENSION, kernel_input_feature_dimension, 0);
  }
  void add_kernel_output_feature_dimension(int64_t kernel_output_feature_dimension) {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_KERNEL_OUTPUT_FEATURE_DIMENSION, kernel_output_feature_dimension, 0);
  }
  void add_kernel_spatial_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> kernel_spatial_dimensions) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_KERNEL_SPATIAL_DIMENSIONS, kernel_spatial_dimensions);
  }
  void add_output_batch_dimension(int64_t output_batch_dimension) {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_OUTPUT_BATCH_DIMENSION, output_batch_dimension, 0);
  }
  void add_output_feature_dimension(int64_t output_feature_dimension) {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_OUTPUT_FEATURE_DIMENSION, output_feature_dimension, 0);
  }
  void add_output_spatial_dimensions(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> output_spatial_dimensions) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_OUTPUT_SPATIAL_DIMENSIONS, output_spatial_dimensions);
  }
  void add_feature_group_count(int64_t feature_group_count) {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_FEATURE_GROUP_COUNT, feature_group_count, 0);
  }
  void add_batch_group_count(int64_t batch_group_count) {
    fbb_.AddElement<int64_t>(StablehloConvolutionOptions::VT_BATCH_GROUP_COUNT, batch_group_count, 0);
  }
  void add_precision_config(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> precision_config) {
    fbb_.AddOffset(StablehloConvolutionOptions::VT_PRECISION_CONFIG, precision_config);
  }
  explicit StablehloConvolutionOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloConvolutionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloConvolutionOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> window_strides = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> lhs_dilation = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> rhs_dilation = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> window_reversal = 0,
    int64_t input_batch_dimension = 0,
    int64_t input_feature_dimension = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> input_spatial_dimensions = 0,
    int64_t kernel_input_feature_dimension = 0,
    int64_t kernel_output_feature_dimension = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> kernel_spatial_dimensions = 0,
    int64_t output_batch_dimension = 0,
    int64_t output_feature_dimension = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> output_spatial_dimensions = 0,
    int64_t feature_group_count = 0,
    int64_t batch_group_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> precision_config = 0) {
  StablehloConvolutionOptionsBuilder builder_(_fbb);
  builder_.add_batch_group_count(batch_group_count);
  builder_.add_feature_group_count(feature_group_count);
  builder_.add_output_feature_dimension(output_feature_dimension);
  builder_.add_output_batch_dimension(output_batch_dimension);
  builder_.add_kernel_output_feature_dimension(kernel_output_feature_dimension);
  builder_.add_kernel_input_feature_dimension(kernel_input_feature_dimension);
  builder_.add_input_feature_dimension(input_feature_dimension);
  builder_.add_input_batch_dimension(input_batch_dimension);
  builder_.add_precision_config(precision_config);
  builder_.add_output_spatial_dimensions(output_spatial_dimensions);
  builder_.add_kernel_spatial_dimensions(kernel_spatial_dimensions);
  builder_.add_input_spatial_dimensions(input_spatial_dimensions);
  builder_.add_window_reversal(window_reversal);
  builder_.add_rhs_dilation(rhs_dilation);
  builder_.add_lhs_dilation(lhs_dilation);
  builder_.add_padding(padding);
  builder_.add_window_strides(window_strides);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *window_strides = nullptr,
    const std::vector<int64_t> *padding = nullptr,
    const std::vector<int64_t> *lhs_dilation = nullptr,
    const std::vector<int64_t> *rhs_dilation = nullptr,
    const std::vector<uint8_t> *window_reversal = nullptr,
    int64_t input_batch_dimension = 0,
    int64_t input_feature_dimension = 0,
    const std::vector<int64_t> *input_spatial_dimensions = nullptr,
    int64_t kernel_input_feature_dimension = 0,
    int64_t kernel_output_feature_dimension = 0,
    const std::vector<int64_t> *kernel_spatial_dimensions = nullptr,
    int64_t output_batch_dimension = 0,
    int64_t output_feature_dimension = 0,
    const std::vector<int64_t> *output_spatial_dimensions = nullptr,
    int64_t feature_group_count = 0,
    int64_t batch_group_count = 0,
    const std::vector<uint32_t> *precision_config = nullptr) {
  auto window_strides__ = window_strides ? _fbb.CreateVector<int64_t>(*window_strides) : 0;
  auto padding__ = padding ? _fbb.CreateVector<int64_t>(*padding) : 0;
  auto lhs_dilation__ = lhs_dilation ? _fbb.CreateVector<int64_t>(*lhs_dilation) : 0;
  auto rhs_dilation__ = rhs_dilation ? _fbb.CreateVector<int64_t>(*rhs_dilation) : 0;
  auto window_reversal__ = window_reversal ? _fbb.CreateVector<uint8_t>(*window_reversal) : 0;
  auto input_spatial_dimensions__ = input_spatial_dimensions ? _fbb.CreateVector<int64_t>(*input_spatial_dimensions) : 0;
  auto kernel_spatial_dimensions__ = kernel_spatial_dimensions ? _fbb.CreateVector<int64_t>(*kernel_spatial_dimensions) : 0;
  auto output_spatial_dimensions__ = output_spatial_dimensions ? _fbb.CreateVector<int64_t>(*output_spatial_dimensions) : 0;
  auto precision_config__ = precision_config ? _fbb.CreateVector<uint32_t>(*precision_config) : 0;
  return tflite::CreateStablehloConvolutionOptions(
      _fbb,
      window_strides__,
      padding__,
      lhs_dilation__,
      rhs_dilation__,
      window_reversal__,
      input_batch_dimension,
      input_feature_dimension,
      input_spatial_dimensions__,
      kernel_input_feature_dimension,
      kernel_output_feature_dimension,
      kernel_spatial_dimensions__,
      output_batch_dimension,
      output_feature_dimension,
      output_spatial_dimensions__,
      feature_group_count,
      batch_group_count,
      precision_config__);
}

::flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloConvolutionOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloScatterOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloScatterOptions TableType;
  bool indices_are_sorted = false;
  std::vector<int64_t> update_window_dims{};
  std::vector<int64_t> inserted_window_dims{};
  std::vector<int64_t> scatter_dims_to_operand_dims{};
  int64_t index_vector_dim = 0;
  bool unique_indices = false;
  int32_t update_computation_subgraph_index = 0;
};

struct StablehloScatterOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloScatterOptionsT NativeTableType;
  typedef StablehloScatterOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICES_ARE_SORTED = 4,
    VT_UPDATE_WINDOW_DIMS = 6,
    VT_INSERTED_WINDOW_DIMS = 8,
    VT_SCATTER_DIMS_TO_OPERAND_DIMS = 10,
    VT_INDEX_VECTOR_DIM = 12,
    VT_UNIQUE_INDICES = 14,
    VT_UPDATE_COMPUTATION_SUBGRAPH_INDEX = 16
  };
  bool indices_are_sorted() const {
    return GetField<uint8_t>(VT_INDICES_ARE_SORTED, 0) != 0;
  }
  const ::flatbuffers::Vector<int64_t> *update_window_dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_UPDATE_WINDOW_DIMS);
  }
  const ::flatbuffers::Vector<int64_t> *inserted_window_dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INSERTED_WINDOW_DIMS);
  }
  const ::flatbuffers::Vector<int64_t> *scatter_dims_to_operand_dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SCATTER_DIMS_TO_OPERAND_DIMS);
  }
  int64_t index_vector_dim() const {
    return GetField<int64_t>(VT_INDEX_VECTOR_DIM, 0);
  }
  bool unique_indices() const {
    return GetField<uint8_t>(VT_UNIQUE_INDICES, 0) != 0;
  }
  int32_t update_computation_subgraph_index() const {
    return GetField<int32_t>(VT_UPDATE_COMPUTATION_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INDICES_ARE_SORTED, 1) &&
           VerifyOffset(verifier, VT_UPDATE_WINDOW_DIMS) &&
           verifier.VerifyVector(update_window_dims()) &&
           VerifyOffset(verifier, VT_INSERTED_WINDOW_DIMS) &&
           verifier.VerifyVector(inserted_window_dims()) &&
           VerifyOffset(verifier, VT_SCATTER_DIMS_TO_OPERAND_DIMS) &&
           verifier.VerifyVector(scatter_dims_to_operand_dims()) &&
           VerifyField<int64_t>(verifier, VT_INDEX_VECTOR_DIM, 8) &&
           VerifyField<uint8_t>(verifier, VT_UNIQUE_INDICES, 1) &&
           VerifyField<int32_t>(verifier, VT_UPDATE_COMPUTATION_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  StablehloScatterOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloScatterOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloScatterOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloScatterOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloScatterOptionsBuilder {
  typedef StablehloScatterOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_indices_are_sorted(bool indices_are_sorted) {
    fbb_.AddElement<uint8_t>(StablehloScatterOptions::VT_INDICES_ARE_SORTED, static_cast<uint8_t>(indices_are_sorted), 0);
  }
  void add_update_window_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> update_window_dims) {
    fbb_.AddOffset(StablehloScatterOptions::VT_UPDATE_WINDOW_DIMS, update_window_dims);
  }
  void add_inserted_window_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> inserted_window_dims) {
    fbb_.AddOffset(StablehloScatterOptions::VT_INSERTED_WINDOW_DIMS, inserted_window_dims);
  }
  void add_scatter_dims_to_operand_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> scatter_dims_to_operand_dims) {
    fbb_.AddOffset(StablehloScatterOptions::VT_SCATTER_DIMS_TO_OPERAND_DIMS, scatter_dims_to_operand_dims);
  }
  void add_index_vector_dim(int64_t index_vector_dim) {
    fbb_.AddElement<int64_t>(StablehloScatterOptions::VT_INDEX_VECTOR_DIM, index_vector_dim, 0);
  }
  void add_unique_indices(bool unique_indices) {
    fbb_.AddElement<uint8_t>(StablehloScatterOptions::VT_UNIQUE_INDICES, static_cast<uint8_t>(unique_indices), 0);
  }
  void add_update_computation_subgraph_index(int32_t update_computation_subgraph_index) {
    fbb_.AddElement<int32_t>(StablehloScatterOptions::VT_UPDATE_COMPUTATION_SUBGRAPH_INDEX, update_computation_subgraph_index, 0);
  }
  explicit StablehloScatterOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloScatterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloScatterOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool indices_are_sorted = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> update_window_dims = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> inserted_window_dims = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> scatter_dims_to_operand_dims = 0,
    int64_t index_vector_dim = 0,
    bool unique_indices = false,
    int32_t update_computation_subgraph_index = 0) {
  StablehloScatterOptionsBuilder builder_(_fbb);
  builder_.add_index_vector_dim(index_vector_dim);
  builder_.add_update_computation_subgraph_index(update_computation_subgraph_index);
  builder_.add_scatter_dims_to_operand_dims(scatter_dims_to_operand_dims);
  builder_.add_inserted_window_dims(inserted_window_dims);
  builder_.add_update_window_dims(update_window_dims);
  builder_.add_unique_indices(unique_indices);
  builder_.add_indices_are_sorted(indices_are_sorted);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool indices_are_sorted = false,
    const std::vector<int64_t> *update_window_dims = nullptr,
    const std::vector<int64_t> *inserted_window_dims = nullptr,
    const std::vector<int64_t> *scatter_dims_to_operand_dims = nullptr,
    int64_t index_vector_dim = 0,
    bool unique_indices = false,
    int32_t update_computation_subgraph_index = 0) {
  auto update_window_dims__ = update_window_dims ? _fbb.CreateVector<int64_t>(*update_window_dims) : 0;
  auto inserted_window_dims__ = inserted_window_dims ? _fbb.CreateVector<int64_t>(*inserted_window_dims) : 0;
  auto scatter_dims_to_operand_dims__ = scatter_dims_to_operand_dims ? _fbb.CreateVector<int64_t>(*scatter_dims_to_operand_dims) : 0;
  return tflite::CreateStablehloScatterOptions(
      _fbb,
      indices_are_sorted,
      update_window_dims__,
      inserted_window_dims__,
      scatter_dims_to_operand_dims__,
      index_vector_dim,
      unique_indices,
      update_computation_subgraph_index);
}

::flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloScatterOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StablehloRngBitGeneratorOptionsT : public ::flatbuffers::NativeTable {
  typedef StablehloRngBitGeneratorOptions TableType;
  tflite::RngAlgorithm algorithm = tflite::RngAlgorithm_DEFAULT;
};

struct StablehloRngBitGeneratorOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StablehloRngBitGeneratorOptionsT NativeTableType;
  typedef StablehloRngBitGeneratorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALGORITHM = 4
  };
  tflite::RngAlgorithm algorithm() const {
    return static_cast<tflite::RngAlgorithm>(GetField<int8_t>(VT_ALGORITHM, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ALGORITHM, 1) &&
           verifier.EndTable();
  }
  StablehloRngBitGeneratorOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StablehloRngBitGeneratorOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StablehloRngBitGeneratorOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloRngBitGeneratorOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StablehloRngBitGeneratorOptionsBuilder {
  typedef StablehloRngBitGeneratorOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_algorithm(tflite::RngAlgorithm algorithm) {
    fbb_.AddElement<int8_t>(StablehloRngBitGeneratorOptions::VT_ALGORITHM, static_cast<int8_t>(algorithm), 0);
  }
  explicit StablehloRngBitGeneratorOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StablehloRngBitGeneratorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StablehloRngBitGeneratorOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StablehloRngBitGeneratorOptions> CreateStablehloRngBitGeneratorOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::RngAlgorithm algorithm = tflite::RngAlgorithm_DEFAULT) {
  StablehloRngBitGeneratorOptionsBuilder builder_(_fbb);
  builder_.add_algorithm(algorithm);
  return builder_.Finish();
}

::flatbuffers::Offset<StablehloRngBitGeneratorOptions> CreateStablehloRngBitGeneratorOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloRngBitGeneratorOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionsT : public ::flatbuffers::NativeTable {
  typedef Conv2DOptions TableType;
  tflite::Padding padding = tflite::Padding_SAME;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  int32_t dilation_w_factor = 1;
  int32_t dilation_h_factor = 1;
  tflite::TensorType quantized_bias_type = tflite::TensorType_FLOAT32;
};

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Conv2DOptionsT NativeTableType;
  typedef Conv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_DILATION_W_FACTOR = 12,
    VT_DILATION_H_FACTOR = 14,
    VT_QUANTIZED_BIAS_TYPE = 16
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  tflite::TensorType quantized_bias_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_QUANTIZED_BIAS_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) &&
           VerifyField<int8_t>(verifier, VT_QUANTIZED_BIAS_TYPE, 1) &&
           verifier.EndTable();
  }
  Conv2DOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Conv2DOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionsBuilder {
  typedef Conv2DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  void add_quantized_bias_type(tflite::TensorType quantized_bias_type) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_QUANTIZED_BIAS_TYPE, static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit Conv2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1,
    tflite::TensorType quantized_bias_type = tflite::TensorType_FLOAT32) {
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv3DOptionsT : public ::flatbuffers::NativeTable {
  typedef Conv3DOptions TableType;
  tflite::Padding padding = tflite::Padding_SAME;
  int32_t stride_d = 0;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  int32_t dilation_d_factor = 1;
  int32_t dilation_w_factor = 1;
  int32_t dilation_h_factor = 1;
};

struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Conv3DOptionsT NativeTableType;
  typedef Conv3DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_D = 6,
    VT_STRIDE_W = 8,
    VT_STRIDE_H = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_D_FACTOR = 14,
    VT_DILATION_W_FACTOR = 16,
    VT_DILATION_H_FACTOR = 18
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_d() const {
    return GetField<int32_t>(VT_STRIDE_D, 0);
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_d_factor() const {
    return GetField<int32_t>(VT_DILATION_D_FACTOR, 1);
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_D, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int32_t>(verifier, VT_DILATION_D_FACTOR, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) &&
           verifier.EndTable();
  }
  Conv3DOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv3DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Conv3DOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv3DOptionsBuilder {
  typedef Conv3DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_d(int32_t stride_d) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_D, stride_d, 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_d_factor(int32_t dilation_d_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_D_FACTOR, dilation_d_factor, 1);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv3DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv3DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv3DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_d = 0,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_d_factor = 1,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  Conv3DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_dilation_d_factor(dilation_d_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_stride_d(stride_d);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

::flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionsT : public ::flatbuffers::NativeTable {
  typedef Pool2DOptions TableType;
  tflite::Padding padding = tflite::Padding_SAME;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  int32_t filter_width = 0;
  int32_t filter_height = 0;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
};

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Pool2DOptionsT NativeTableType;
  typedef Pool2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FILTER_WIDTH = 10,
    VT_FILTER_HEIGHT = 12,
    VT_FUSED_ACTIVATION_FUNCTION = 14
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t filter_width() const {
    return GetField<int32_t>(VT_FILTER_WIDTH, 0);
  }
  int32_t filter_height() const {
    return GetField<int32_t>(VT_FILTER_HEIGHT, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int32_t>(verifier, VT_FILTER_WIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           verifier.EndTable();
  }
  Pool2DOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pool2DOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionsBuilder {
  typedef Pool2DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit Pool2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pool2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t filter_width = 0,
    int32_t filter_height = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

::flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthwiseConv2DOptionsT : public ::flatbuffers::NativeTable {
  typedef DepthwiseConv2DOptions TableType;
  tflite::Padding padding = tflite::Padding_SAME;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  int32_t depth_multiplier = 0;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  int32_t dilation_w_factor = 1;
  int32_t dilation_h_factor = 1;
};

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepthwiseConv2DOptionsT NativeTableType;
  typedef DepthwiseConv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_W_FACTOR = 14,
    VT_DILATION_H_FACTOR = 16
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) &&
           verifier.EndTable();
  }
  DepthwiseConv2DOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthwiseConv2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DepthwiseConv2DOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthwiseConv2DOptionsBuilder {
  typedef DepthwiseConv2DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit DepthwiseConv2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t depth_multiplier = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

::flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatEmbeddingsOptionsT : public ::flatbuffers::NativeTable {
  typedef ConcatEmbeddingsOptions TableType;
  int32_t num_channels = 0;
  std::vector<int32_t> num_columns_per_channel{};
  std::vector<int32_t> embedding_dim_per_channel{};
};

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConcatEmbeddingsOptionsT NativeTableType;
  typedef ConcatEmbeddingsOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_CHANNELS = 4,
    VT_NUM_COLUMNS_PER_CHANNEL = 6,
    VT_EMBEDDING_DIM_PER_CHANNEL = 8
  };
  int32_t num_channels() const {
    return GetField<int32_t>(VT_NUM_CHANNELS, 0);
  }
  const ::flatbuffers::Vector<int32_t> *num_columns_per_channel() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
  }
  const ::flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
           verifier.VerifyVector(embedding_dim_per_channel()) &&
           verifier.EndTable();
  }
  ConcatEmbeddingsOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatEmbeddingsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ConcatEmbeddingsOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatEmbeddingsOptionsBuilder {
  typedef ConcatEmbeddingsOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels) {
    fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  void add_num_columns_per_channel(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> num_columns_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    const std::vector<int32_t> *num_columns_per_channel = nullptr,
    const std::vector<int32_t> *embedding_dim_per_channel = nullptr) {
  auto num_columns_per_channel__ = num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0;
  auto embedding_dim_per_channel__ = embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0;
  return tflite::CreateConcatEmbeddingsOptions(
      _fbb,
      num_channels,
      num_columns_per_channel__,
      embedding_dim_per_channel__);
}

::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSHProjectionOptionsT : public ::flatbuffers::NativeTable {
  typedef LSHProjectionOptions TableType;
  tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN;
};

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LSHProjectionOptionsT NativeTableType;
  typedef LSHProjectionOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  tflite::LSHProjectionType type() const {
    return static_cast<tflite::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
  LSHProjectionOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSHProjectionOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LSHProjectionOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSHProjectionOptionsBuilder {
  typedef LSHProjectionOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(tflite::LSHProjectionType type) {
    fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LSHProjectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN) {
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

::flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SVDFOptionsT : public ::flatbuffers::NativeTable {
  typedef SVDFOptions TableType;
  int32_t rank = 0;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  bool asymmetric_quantize_inputs = false;
};

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SVDFOptionsT NativeTableType;
  typedef SVDFOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANK = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           verifier.EndTable();
  }
  SVDFOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SVDFOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SVDFOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SVDFOptionsBuilder {
  typedef SVDFOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SVDFOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SVDFOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNOptionsT : public ::flatbuffers::NativeTable {
  typedef RNNOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  bool asymmetric_quantize_inputs = false;
};

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RNNOptionsT NativeTableType;
  typedef RNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           verifier.EndTable();
  }
  RNNOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RNNOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNOptionsBuilder {
  typedef RNNOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit RNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<RNNOptions> CreateRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SequenceRNNOptionsT : public ::flatbuffers::NativeTable {
  typedef SequenceRNNOptions TableType;
  bool time_major = false;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  bool asymmetric_quantize_inputs = false;
};

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SequenceRNNOptionsT NativeTableType;
  typedef SequenceRNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           verifier.EndTable();
  }
  SequenceRNNOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SequenceRNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SequenceRNNOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceRNNOptionsBuilder {
  typedef SequenceRNNOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SequenceRNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

::flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceRNNOptionsT : public ::flatbuffers::NativeTable {
  typedef BidirectionalSequenceRNNOptions TableType;
  bool time_major = false;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  bool merge_outputs = false;
  bool asymmetric_quantize_inputs = false;
};

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BidirectionalSequenceRNNOptionsT NativeTableType;
  typedef BidirectionalSequenceRNNOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_MERGE_OUTPUTS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           verifier.EndTable();
  }
  BidirectionalSequenceRNNOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceRNNOptionsBuilder {
  typedef BidirectionalSequenceRNNOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool merge_outputs = false,
    bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

::flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullyConnectedOptionsT : public ::flatbuffers::NativeTable {
  typedef FullyConnectedOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  tflite::FullyConnectedOptionsWeightsFormat weights_format = tflite::FullyConnectedOptionsWeightsFormat_DEFAULT;
  bool keep_num_dims = false;
  bool asymmetric_quantize_inputs = false;
  tflite::TensorType quantized_bias_type = tflite::TensorType_FLOAT32;
};

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FullyConnectedOptionsT NativeTableType;
  typedef FullyConnectedOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_WEIGHTS_FORMAT = 6,
    VT_KEEP_NUM_DIMS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10,
    VT_QUANTIZED_BIAS_TYPE = 12
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  tflite::FullyConnectedOptionsWeightsFormat weights_format() const {
    return static_cast<tflite::FullyConnectedOptionsWeightsFormat>(GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
  }
  bool keep_num_dims() const {
    return GetField<uint8_t>(VT_KEEP_NUM_DIMS, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  tflite::TensorType quantized_bias_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_QUANTIZED_BIAS_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT, 1) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_NUM_DIMS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           VerifyField<int8_t>(verifier, VT_QUANTIZED_BIAS_TYPE, 1) &&
           verifier.EndTable();
  }
  FullyConnectedOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FullyConnectedOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FullyConnectedOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullyConnectedOptionsBuilder {
  typedef FullyConnectedOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(tflite::FullyConnectedOptionsWeightsFormat weights_format) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, static_cast<int8_t>(weights_format), 0);
  }
  void add_keep_num_dims(bool keep_num_dims) {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, static_cast<uint8_t>(keep_num_dims), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  void add_quantized_bias_type(tflite::TensorType quantized_bias_type) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_QUANTIZED_BIAS_TYPE, static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit FullyConnectedOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FullyConnectedOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    tflite::FullyConnectedOptionsWeightsFormat weights_format = tflite::FullyConnectedOptionsWeightsFormat_DEFAULT,
    bool keep_num_dims = false,
    bool asymmetric_quantize_inputs = false,
    tflite::TensorType quantized_bias_type = tflite::TensorType_FLOAT32) {
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_keep_num_dims(keep_num_dims);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionsT : public ::flatbuffers::NativeTable {
  typedef SoftmaxOptions TableType;
  float beta = 0.0f;
};

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SoftmaxOptionsT NativeTableType;
  typedef SoftmaxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
  SoftmaxOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SoftmaxOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionsBuilder {
  typedef SoftmaxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);
  }
  explicit SoftmaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

::flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatenationOptionsT : public ::flatbuffers::NativeTable {
  typedef ConcatenationOptions TableType;
  int32_t axis = 0;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
};

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConcatenationOptionsT NativeTableType;
  typedef ConcatenationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           verifier.EndTable();
  }
  ConcatenationOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatenationOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ConcatenationOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatenationOptionsBuilder {
  typedef ConcatenationOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConcatenationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionsT : public ::flatbuffers::NativeTable {
  typedef AddOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  bool pot_scale_int16 = true;
};

struct AddOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddOptionsT NativeTableType;
  typedef AddOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16, 1) &&
           verifier.EndTable();
  }
  AddOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AddOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionsBuilder {
  typedef AddOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(AddOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);
  }
  explicit AddOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddOptions> CreateAddOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool pot_scale_int16 = true) {
  AddOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<AddOptions> CreateAddOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionsT : public ::flatbuffers::NativeTable {
  typedef MulOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
};

struct MulOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MulOptionsT NativeTableType;
  typedef MulOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           verifier.EndTable();
  }
  MulOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MulOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionsBuilder {
  typedef MulOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit MulOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MulOptions> CreateMulOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  MulOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<MulOptions> CreateMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormOptionsT : public ::flatbuffers::NativeTable {
  typedef L2NormOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
};

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef L2NormOptionsT NativeTableType;
  typedef L2NormOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           verifier.EndTable();
  }
  L2NormOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(L2NormOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<L2NormOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormOptionsBuilder {
  typedef L2NormOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<L2NormOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(::flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocalResponseNormalizationOptionsT : public ::flatbuffers::NativeTable {
  typedef LocalResponseNormalizationOptions TableType;
  int32_t radius = 0;
  float bias = 0.0f;
  float alpha = 0.0f;
  float beta = 0.0f;
};

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LocalResponseNormalizationOptionsT NativeTableType;
  typedef LocalResponseNormalizationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
  LocalResponseNormalizationOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LocalResponseNormalizationOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LocalResponseNormalizationOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocalResponseNormalizationOptionsBuilder {
  typedef LocalResponseNormalizationOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  return builder_.Finish();
}

::flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMOptionsT : public ::flatbuffers::NativeTable {
  typedef LSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  float cell_clip = 0.0f;
  float proj_clip = 0.0f;
  tflite::LSTMKernelType kernel_type = tflite::LSTMKernelType_FULL;
  bool asymmetric_quantize_inputs = false;
};

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LSTMOptionsT NativeTableType;
  typedef LSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_KERNEL_TYPE = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  tflite::LSTMKernelType kernel_type() const {
    return static_cast<tflite::LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP, 4) &&
           VerifyField<int8_t>(verifier, VT_KERNEL_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           verifier.EndTable();
  }
  LSTMOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LSTMOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMOptionsBuilder {
  typedef LSTMOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_kernel_type(tflite::LSTMKernelType kernel_type) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit LSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    tflite::LSTMKernelType kernel_type = tflite::LSTMKernelType_FULL,
    bool asymmetric_quantize_inputs = false) {
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnidirectionalSequenceLSTMOptionsT : public ::flatbuffers::NativeTable {
  typedef UnidirectionalSequenceLSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  float cell_clip = 0.0f;
  float proj_clip = 0.0f;
  bool time_major = false;
  bool asymmetric_quantize_inputs = false;
  bool diagonal_recurrent_tensors = false;
};

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnidirectionalSequenceLSTMOptionsT NativeTableType;
  typedef UnidirectionalSequenceLSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_TIME_MAJOR = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12,
    VT_DIAGONAL_RECURRENT_TENSORS = 14
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool diagonal_recurrent_tensors() const {
    return GetField<uint8_t>(VT_DIAGONAL_RECURRENT_TENSORS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP, 4) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_DIAGONAL_RECURRENT_TENSORS, 1) &&
           verifier.EndTable();
  }
  UnidirectionalSequenceLSTMOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnidirectionalSequenceLSTMOptionsBuilder {
  typedef UnidirectionalSequenceLSTMOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  void add_diagonal_recurrent_tensors(bool diagonal_recurrent_tensors) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_DIAGONAL_RECURRENT_TENSORS, static_cast<uint8_t>(diagonal_recurrent_tensors), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool time_major = false,
    bool asymmetric_quantize_inputs = false,
    bool diagonal_recurrent_tensors = false) {
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_diagonal_recurrent_tensors(diagonal_recurrent_tensors);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceLSTMOptionsT : public ::flatbuffers::NativeTable {
  typedef BidirectionalSequenceLSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  float cell_clip = 0.0f;
  float proj_clip = 0.0f;
  bool merge_outputs = false;
  bool time_major = true;
  bool asymmetric_quantize_inputs = false;
};

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BidirectionalSequenceLSTMOptionsT NativeTableType;
  typedef BidirectionalSequenceLSTMOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_MERGE_OUTPUTS = 10,
    VT_TIME_MAJOR = 12,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 14
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 1) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP, 4) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           verifier.EndTable();
  }
  BidirectionalSequenceLSTMOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceLSTMOptionsBuilder {
  typedef BidirectionalSequenceLSTMOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 1);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool merge_outputs = false,
    bool time_major = true,
    bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeBilinearOptionsT : public ::flatbuffers::NativeTable {
  typedef ResizeBilinearOptions TableType;
  bool align_corners = false;
  bool half_pixel_centers = false;
};

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResizeBilinearOptionsT NativeTableType;
  typedef ResizeBilinearOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGN_CORNERS = 8,
    VT_HALF_PIXEL_CENTERS = 10
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS, 1) &&
           verifier.EndTable();
  }
  ResizeBilinearOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeBilinearOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ResizeBilinearOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBilinearOptionsBuilder {
  typedef ResizeBilinearOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeBilinearOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResizeBilinearOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false,
    bool half_pixel_centers = false) {
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

::flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeNearestNeighborOptionsT : public ::flatbuffers::NativeTable {
  typedef ResizeNearestNeighborOptions TableType;
  bool align_corners = false;
  bool half_pixel_centers = false;
};

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResizeNearestNeighborOptionsT NativeTableType;
  typedef ResizeNearestNeighborOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGN_CORNERS = 4,
    VT_HALF_PIXEL_CENTERS = 6
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS, 1) &&
           verifier.EndTable();
  }
  ResizeNearestNeighborOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeNearestNeighborOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ResizeNearestNeighborOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeNearestNeighborOptionsBuilder {
  typedef ResizeNearestNeighborOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false,
    bool half_pixel_centers = false) {
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

::flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOptionsT : public ::flatbuffers::NativeTable {
  typedef CallOptions TableType;
  uint32_t subgraph = 0;
};

struct CallOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallOptionsT NativeTableType;
  typedef CallOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPH = 4
  };
  uint32_t subgraph() const {
    return GetField<uint32_t>(VT_SUBGRAPH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH, 4) &&
           verifier.EndTable();
  }
  CallOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CallOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOptionsBuilder {
  typedef CallOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph) {
    fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  explicit CallOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallOptions> CreateCallOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t subgraph = 0) {
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

::flatbuffers::Offset<CallOptions> CreateCallOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadOptionsT : public ::flatbuffers::NativeTable {
  typedef PadOptions TableType;
};

struct PadOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PadOptionsT NativeTableType;
  typedef PadOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PadOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PadOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadOptionsBuilder {
  typedef PadOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PadOptions> CreatePadOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<PadOptions> CreatePadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadV2OptionsT : public ::flatbuffers::NativeTable {
  typedef PadV2Options TableType;
};

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PadV2OptionsT NativeTableType;
  typedef PadV2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PadV2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PadV2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadV2OptionsBuilder {
  typedef PadV2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PadV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PadV2Options> CreatePadV2Options(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<PadV2Options> CreatePadV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionsT : public ::flatbuffers::NativeTable {
  typedef ReshapeOptions TableType;
  std::vector<int32_t> new_shape{};
};

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReshapeOptionsT NativeTableType;
  typedef ReshapeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_SHAPE = 4
  };
  const ::flatbuffers::Vector<int32_t> *new_shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) &&
           verifier.EndTable();
  }
  ReshapeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReshapeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionsBuilder {
  typedef ReshapeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_new_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape) {
    fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReshapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape = 0) {
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *new_shape = nullptr) {
  auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
  return tflite::CreateReshapeOptions(
      _fbb,
      new_shape__);
}

::flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDOptionsT : public ::flatbuffers::NativeTable {
  typedef SpaceToBatchNDOptions TableType;
};

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpaceToBatchNDOptionsT NativeTableType;
  typedef SpaceToBatchNDOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SpaceToBatchNDOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchNDOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SpaceToBatchNDOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDOptionsBuilder {
  typedef SpaceToBatchNDOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDOptionsT : public ::flatbuffers::NativeTable {
  typedef BatchToSpaceNDOptions TableType;
};

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchToSpaceNDOptionsT NativeTableType;
  typedef BatchToSpaceNDOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BatchToSpaceNDOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceNDOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BatchToSpaceNDOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDOptionsBuilder {
  typedef BatchToSpaceNDOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramOptionsT : public ::flatbuffers::NativeTable {
  typedef SkipGramOptions TableType;
  int32_t ngram_size = 0;
  int32_t max_skip_size = 0;
  bool include_all_ngrams = false;
};

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SkipGramOptionsT NativeTableType;
  typedef SkipGramOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NGRAM_SIZE = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_INCLUDE_ALL_NGRAMS = 8
  };
  int32_t ngram_size() const {
    return GetField<int32_t>(VT_NGRAM_SIZE, 0);
  }
  int32_t max_skip_size() const {
    return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0);
  }
  bool include_all_ngrams() const {
    return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NGRAM_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS, 1) &&
           verifier.EndTable();
  }
  SkipGramOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkipGramOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SkipGramOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramOptionsBuilder {
  typedef SkipGramOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_include_all_ngrams(bool include_all_ngrams) {
    fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SkipGramOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ngram_size = 0,
    int32_t max_skip_size = 0,
    bool include_all_ngrams = false) {
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

::flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthOptionsT : public ::flatbuffers::NativeTable {
  typedef SpaceToDepthOptions TableType;
  int32_t block_size = 0;
};

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpaceToDepthOptionsT NativeTableType;
  typedef SpaceToDepthOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const {
    return GetField<int32_t>(VT_BLOCK_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE, 4) &&
           verifier.EndTable();
  }
  SpaceToDepthOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToDepthOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SpaceToDepthOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthOptionsBuilder {
  typedef SpaceToDepthOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpaceToDepthOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

::flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthToSpaceOptionsT : public ::flatbuffers::NativeTable {
  typedef DepthToSpaceOptions TableType;
  int32_t block_size = 0;
};

struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepthToSpaceOptionsT NativeTableType;
  typedef DepthToSpaceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const {
    return GetField<int32_t>(VT_BLOCK_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE, 4) &&
           verifier.EndTable();
  }
  DepthToSpaceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthToSpaceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DepthToSpaceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthToSpaceOptionsBuilder {
  typedef DepthToSpaceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit DepthToSpaceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepthToSpaceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepthToSpaceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  DepthToSpaceOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

::flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubOptionsT : public ::flatbuffers::NativeTable {
  typedef SubOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  bool pot_scale_int16 = true;
};

struct SubOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubOptionsT NativeTableType;
  typedef SubOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16, 1) &&
           verifier.EndTable();
  }
  SubOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SubOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubOptionsBuilder {
  typedef SubOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(SubOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);
  }
  explicit SubOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubOptions> CreateSubOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool pot_scale_int16 = true) {
  SubOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<SubOptions> CreateSubOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionsT : public ::flatbuffers::NativeTable {
  typedef DivOptions TableType;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
};

struct DivOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DivOptionsT NativeTableType;
  typedef DivOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           verifier.EndTable();
  }
  DivOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DivOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionsBuilder {
  typedef DivOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit DivOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DivOptions> CreateDivOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  DivOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

::flatbuffers::Offset<DivOptions> CreateDivOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2OptionsT : public ::flatbuffers::NativeTable {
  typedef TopKV2Options TableType;
};

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TopKV2OptionsT NativeTableType;
  typedef TopKV2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TopKV2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TopKV2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2OptionsBuilder {
  typedef TopKV2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TopKV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupSparseOptionsT : public ::flatbuffers::NativeTable {
  typedef EmbeddingLookupSparseOptions TableType;
  tflite::CombinerType combiner = tflite::CombinerType_SUM;
};

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmbeddingLookupSparseOptionsT NativeTableType;
  typedef EmbeddingLookupSparseOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMBINER = 4
  };
  tflite::CombinerType combiner() const {
    return static_cast<tflite::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMBINER, 1) &&
           verifier.EndTable();
  }
  EmbeddingLookupSparseOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingLookupSparseOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EmbeddingLookupSparseOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupSparseOptionsBuilder {
  typedef EmbeddingLookupSparseOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_combiner(tflite::CombinerType combiner) {
    fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER, static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::CombinerType combiner = tflite::CombinerType_SUM) {
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

::flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(::flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherOptionsT : public ::flatbuffers::NativeTable {
  typedef GatherOptions TableType;
  int32_t axis = 0;
  int32_t batch_dims = 0;
};

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GatherOptionsT NativeTableType;
  typedef GatherOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_BATCH_DIMS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t batch_dims() const {
    return GetField<int32_t>(VT_BATCH_DIMS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIMS, 4) &&
           verifier.EndTable();
  }
  GatherOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GatherOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherOptionsBuilder {
  typedef GatherOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);
  }
  void add_batch_dims(int32_t batch_dims) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);
  }
  explicit GatherOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GatherOptions> CreateGatherOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t batch_dims = 0) {
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_batch_dims(batch_dims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

::flatbuffers::Offset<GatherOptions> CreateGatherOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeOptionsT : public ::flatbuffers::NativeTable {
  typedef TransposeOptions TableType;
};

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransposeOptionsT NativeTableType;
  typedef TransposeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TransposeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TransposeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeOptionsBuilder {
  typedef TransposeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionsT : public ::flatbuffers::NativeTable {
  typedef ExpOptions TableType;
};

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpOptionsT NativeTableType;
  typedef ExpOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ExpOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionsBuilder {
  typedef ExpOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpOptions> CreateExpOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<ExpOptions> CreateExpOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CosOptionsT : public ::flatbuffers::NativeTable {
  typedef CosOptions TableType;
};

struct CosOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CosOptionsT NativeTableType;
  typedef CosOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CosOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CosOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CosOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CosOptionsBuilder {
  typedef CosOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CosOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CosOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CosOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CosOptions> CreateCosOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CosOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<CosOptions> CreateCosOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReducerOptionsT : public ::flatbuffers::NativeTable {
  typedef ReducerOptions TableType;
  bool keep_dims = false;
};

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReducerOptionsT NativeTableType;
  typedef ReducerOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4
  };
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS, 1) &&
           verifier.EndTable();
  }
  ReducerOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReducerOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReducerOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReducerOptionsBuilder {
  typedef ReducerOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReducerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReducerOptions> CreateReducerOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool keep_dims = false) {
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

::flatbuffers::Offset<ReducerOptions> CreateReducerOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeOptionsT : public ::flatbuffers::NativeTable {
  typedef SqueezeOptions TableType;
  std::vector<int32_t> squeeze_dims{};
};

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SqueezeOptionsT NativeTableType;
  typedef SqueezeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SQUEEZE_DIMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *squeeze_dims() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) &&
           verifier.EndTable();
  }
  SqueezeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SqueezeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeOptionsBuilder {
  typedef SqueezeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_squeeze_dims(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> squeeze_dims) {
    fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SqueezeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *squeeze_dims = nullptr) {
  auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
  return tflite::CreateSqueezeOptions(
      _fbb,
      squeeze_dims__);
}

::flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitOptionsT : public ::flatbuffers::NativeTable {
  typedef SplitOptions TableType;
  int32_t num_splits = 0;
};

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SplitOptionsT NativeTableType;
  typedef SplitOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS, 4) &&
           verifier.EndTable();
  }
  SplitOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SplitOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitOptionsBuilder {
  typedef SplitOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SplitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SplitOptions> CreateSplitOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

::flatbuffers::Offset<SplitOptions> CreateSplitOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitVOptionsT : public ::flatbuffers::NativeTable {
  typedef SplitVOptions TableType;
  int32_t num_splits = 0;
};

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SplitVOptionsT NativeTableType;
  typedef SplitVOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS, 4) &&
           verifier.EndTable();
  }
  SplitVOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitVOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SplitVOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitVOptionsBuilder {
  typedef SplitVOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SplitVOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

::flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceOptionsT : public ::flatbuffers::NativeTable {
  typedef StridedSliceOptions TableType;
  int32_t begin_mask = 0;
  int32_t end_mask = 0;
  int32_t ellipsis_mask = 0;
  int32_t new_axis_mask = 0;
  int32_t shrink_axis_mask = 0;
  bool offset = false;
};

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StridedSliceOptionsT NativeTableType;
  typedef StridedSliceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12,
    VT_OFFSET = 14
  };
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t ellipsis_mask() const {
    return GetField<int32_t>(VT_ELLIPSIS_MASK, 0);
  }
  int32_t new_axis_mask() const {
    return GetField<int32_t>(VT_NEW_AXIS_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool offset() const {
    return GetField<uint8_t>(VT_OFFSET, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_END_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK, 4) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK, 4) &&
           VerifyField<uint8_t>(verifier, VT_OFFSET, 1) &&
           verifier.EndTable();
  }
  StridedSliceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StridedSliceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceOptionsBuilder {
  typedef StridedSliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  void add_offset(bool offset) {
    fbb_.AddElement<uint8_t>(StridedSliceOptions::VT_OFFSET, static_cast<uint8_t>(offset), 0);
  }
  explicit StridedSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StridedSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t ellipsis_mask = 0,
    int32_t new_axis_mask = 0,
    int32_t shrink_axis_mask = 0,
    bool offset = false) {
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  builder_.add_offset(offset);
  return builder_.Finish();
}

::flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSoftmaxOptionsT : public ::flatbuffers::NativeTable {
  typedef LogSoftmaxOptions TableType;
};

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogSoftmaxOptionsT NativeTableType;
  typedef LogSoftmaxOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogSoftmaxOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogSoftmaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LogSoftmaxOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSoftmaxOptionsBuilder {
  typedef LogSoftmaxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogSoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastOptionsT : public ::flatbuffers::NativeTable {
  typedef CastOptions TableType;
  tflite::TensorType in_data_type = tflite::TensorType_FLOAT32;
  tflite::TensorType out_data_type = tflite::TensorType_FLOAT32;
};

struct CastOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CastOptionsT NativeTableType;
  typedef CastOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_DATA_TYPE = 4,
    VT_OUT_DATA_TYPE = 6
  };
  tflite::TensorType in_data_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
  }
  tflite::TensorType out_data_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE, 1) &&
           verifier.EndTable();
  }
  CastOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CastOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastOptionsBuilder {
  typedef CastOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_in_data_type(tflite::TensorType in_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(tflite::TensorType out_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CastOptions> CreateCastOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType in_data_type = tflite::TensorType_FLOAT32,
    tflite::TensorType out_data_type = tflite::TensorType_FLOAT32) {
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

::flatbuffers::Offset<CastOptions> CreateCastOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DequantizeOptionsT : public ::flatbuffers::NativeTable {
  typedef DequantizeOptions TableType;
};

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DequantizeOptionsT NativeTableType;
  typedef DequantizeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DequantizeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DequantizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DequantizeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DequantizeOptionsBuilder {
  typedef DequantizeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DequantizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DequantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  DequantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumMinimumOptionsT : public ::flatbuffers::NativeTable {
  typedef MaximumMinimumOptions TableType;
};

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaximumMinimumOptionsT NativeTableType;
  typedef MaximumMinimumOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaximumMinimumOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumMinimumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MaximumMinimumOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumMinimumOptionsBuilder {
  typedef MaximumMinimumOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MaximumMinimumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaximumMinimumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumMinimumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileOptionsT : public ::flatbuffers::NativeTable {
  typedef TileOptions TableType;
};

struct TileOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TileOptionsT NativeTableType;
  typedef TileOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TileOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TileOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileOptionsBuilder {
  typedef TileOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TileOptions> CreateTileOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<TileOptions> CreateTileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionsT : public ::flatbuffers::NativeTable {
  typedef ArgMaxOptions TableType;
  tflite::TensorType output_type = tflite::TensorType_FLOAT32;
};

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgMaxOptionsT NativeTableType;
  typedef ArgMaxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TYPE = 4
  };
  tflite::TensorType output_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE, 1) &&
           verifier.EndTable();
  }
  ArgMaxOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ArgMaxOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionsBuilder {
  typedef ArgMaxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_output_type(tflite::TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

::flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinOptionsT : public ::flatbuffers::NativeTable {
  typedef ArgMinOptions TableType;
  tflite::TensorType output_type = tflite::TensorType_FLOAT32;
};

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgMinOptionsT NativeTableType;
  typedef ArgMinOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TYPE = 4
  };
  tflite::TensorType output_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE, 1) &&
           verifier.EndTable();
  }
  ArgMinOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMinOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ArgMinOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinOptionsBuilder {
  typedef ArgMinOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_output_type(tflite::TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

::flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterOptionsT : public ::flatbuffers::NativeTable {
  typedef GreaterOptions TableType;
};

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GreaterOptionsT NativeTableType;
  typedef GreaterOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GreaterOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterOptionsBuilder {
  typedef GreaterOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GreaterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionsT : public ::flatbuffers::NativeTable {
  typedef GreaterEqualOptions TableType;
};

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GreaterEqualOptionsT NativeTableType;
  typedef GreaterEqualOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterEqualOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GreaterEqualOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionsBuilder {
  typedef GreaterEqualOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GreaterEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessOptionsT : public ::flatbuffers::NativeTable {
  typedef LessOptions TableType;
};

struct LessOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LessOptionsT NativeTableType;
  typedef LessOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LessOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessOptionsBuilder {
  typedef LessOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LessOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LessOptions> CreateLessOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<LessOptions> CreateLessOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionsT : public ::flatbuffers::NativeTable {
  typedef LessEqualOptions TableType;
};

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LessEqualOptionsT NativeTableType;
  typedef LessEqualOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessEqualOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LessEqualOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionsBuilder {
  typedef LessEqualOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LessEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegOptionsT : public ::flatbuffers::NativeTable {
  typedef NegOptions TableType;
};

struct NegOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NegOptionsT NativeTableType;
  typedef NegOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NegOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NegOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegOptionsBuilder {
  typedef NegOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NegOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NegOptions> CreateNegOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<NegOptions> CreateNegOptions(::flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectOptionsT : public ::flatbuffers::NativeTable {
  typedef SelectOptions TableType;
};

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SelectOptionsT NativeTableType;
  typedef SelectOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SelectOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectOptionsBuilder {
  typedef SelectOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SelectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SelectOptions> CreateSelectOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SelectOptions> CreateSelectOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionsT : public ::flatbuffers::NativeTable {
  typedef SliceOptions TableType;
};

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SliceOptionsT NativeTableType;
  typedef SliceOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SliceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SliceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionsBuilder {
  typedef SliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SliceOptions> CreateSliceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SliceOptions> CreateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeConvOptionsT : public ::flatbuffers::NativeTable {
  typedef TransposeConvOptions TableType;
  tflite::Padding padding = tflite::Padding_SAME;
  int32_t stride_w = 0;
  int32_t stride_h = 0;
  tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;
  tflite::TensorType quantized_bias_type = tflite::TensorType_FLOAT32;
};

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransposeConvOptionsT NativeTableType;
  typedef TransposeConvOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_QUANTIZED_BIAS_TYPE = 12
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  tflite::TensorType quantized_bias_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_QUANTIZED_BIAS_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING, 1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H, 4) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&
           VerifyField<int8_t>(verifier, VT_QUANTIZED_BIAS_TYPE, 1) &&
           verifier.EndTable();
  }
  TransposeConvOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeConvOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TransposeConvOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeConvOptionsBuilder {
  typedef TransposeConvOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_quantized_bias_type(tflite::TensorType quantized_bias_type) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_QUANTIZED_BIAS_TYPE, static_cast<int8_t>(quantized_bias_type), 0);
  }
  explicit TransposeConvOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransposeConvOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    tflite::TensorType quantized_bias_type = tflite::TensorType_FLOAT32) {
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_quantized_bias_type(quantized_bias_type);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

::flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsOptionsT : public ::flatbuffers::NativeTable {
  typedef ExpandDimsOptions TableType;
};

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpandDimsOptionsT NativeTableType;
  typedef ExpandDimsOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpandDimsOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ExpandDimsOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsOptionsBuilder {
  typedef ExpandDimsOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpandDimsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseOptionsT : public ::flatbuffers::NativeTable {
  typedef SparseToDenseOptions TableType;
  bool validate_indices = false;
};

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SparseToDenseOptionsT NativeTableType;
  typedef SparseToDenseOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALIDATE_INDICES = 4
  };
  bool validate_indices() const {
    return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES, 1) &&
           verifier.EndTable();
  }
  SparseToDenseOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseToDenseOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SparseToDenseOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseOptionsBuilder {
  typedef SparseToDenseOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices) {
    fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES, static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparseToDenseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool validate_indices = false) {
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

::flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualOptionsT : public ::flatbuffers::NativeTable {
  typedef EqualOptions TableType;
};

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EqualOptionsT NativeTableType;
  typedef EqualOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EqualOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EqualOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualOptionsBuilder {
  typedef EqualOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EqualOptions> CreateEqualOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<EqualOptions> CreateEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionsT : public ::flatbuffers::NativeTable {
  typedef NotEqualOptions TableType;
};

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotEqualOptionsT NativeTableType;
  typedef NotEqualOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NotEqualOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NotEqualOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionsBuilder {
  typedef NotEqualOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeOptionsT : public ::flatbuffers::NativeTable {
  typedef ShapeOptions TableType;
  tflite::TensorType out_type = tflite::TensorType_FLOAT32;
};

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShapeOptionsT NativeTableType;
  typedef ShapeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT_TYPE = 4
  };
  tflite::TensorType out_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUT_TYPE, 1) &&
           verifier.EndTable();
  }
  ShapeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShapeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ShapeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeOptionsBuilder {
  typedef ShapeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_out_type(tflite::TensorType out_type) {
    fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShapeOptions> CreateShapeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType out_type = tflite::TensorType_FLOAT32) {
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

::flatbuffers::Offset<ShapeOptions> CreateShapeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankOptionsT : public ::flatbuffers::NativeTable {
  typedef RankOptions TableType;
};

struct RankOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RankOptionsT NativeTableType;
  typedef RankOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RankOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RankOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankOptionsBuilder {
  typedef RankOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RankOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RankOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RankOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RankOptions> CreateRankOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RankOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<RankOptions> CreateRankOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionsT : public ::flatbuffers::NativeTable {
  typedef PowOptions TableType;
};

struct PowOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PowOptionsT NativeTableType;
  typedef PowOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PowOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PowOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionsBuilder {
  typedef PowOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PowOptions> CreatePowOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<PowOptions> CreatePowOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantOptionsT : public ::flatbuffers::NativeTable {
  typedef FakeQuantOptions TableType;
  float min = 0.0f;
  float max = 0.0f;
  int32_t num_bits = 0;
  bool narrow_range = false;
};

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FakeQuantOptionsT NativeTableType;
  typedef FakeQuantOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_NUM_BITS = 8,
    VT_NARROW_RANGE = 10
  };
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  int32_t num_bits() const {
    return GetField<int32_t>(VT_NUM_BITS, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_BITS, 4) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE, 1) &&
           verifier.EndTable();
  }
  FakeQuantOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FakeQuantOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantOptionsBuilder {
  typedef FakeQuantOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f);
  }
  void add_num_bits(int32_t num_bits) {
    fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FakeQuantOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f,
    int32_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

::flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackOptionsT : public ::flatbuffers::NativeTable {
  typedef PackOptions TableType;
  int32_t values_count = 0;
  int32_t axis = 0;
};

struct PackOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PackOptionsT NativeTableType;
  typedef PackOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES_COUNT = 4,
    VT_AXIS = 6
  };
  int32_t values_count() const {
    return GetField<int32_t>(VT_VALUES_COUNT, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUES_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
  PackOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PackOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackOptionsBuilder {
  typedef PackOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count) {
    fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);
  }
  explicit PackOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PackOptions> CreatePackOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t values_count = 0,
    int32_t axis = 0) {
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

::flatbuffers::Offset<PackOptions> CreatePackOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrOptionsT : public ::flatbuffers::NativeTable {
  typedef LogicalOrOptions TableType;
};

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogicalOrOptionsT NativeTableType;
  typedef LogicalOrOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalOrOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalOrOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LogicalOrOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrOptionsBuilder {
  typedef LogicalOrOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogicalOrOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotOptionsT : public ::flatbuffers::NativeTable {
  typedef OneHotOptions TableType;
  int32_t axis = 0;
};

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OneHotOptionsT NativeTableType;
  typedef OneHotOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
  OneHotOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OneHotOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotOptionsBuilder {
  typedef OneHotOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);
  }
  explicit OneHotOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OneHotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

::flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(::flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsOptionsT : public ::flatbuffers::NativeTable {
  typedef AbsOptions TableType;
};

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AbsOptionsT NativeTableType;
  typedef AbsOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AbsOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsOptionsBuilder {
  typedef AbsOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AbsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AbsOptions> CreateAbsOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<AbsOptions> CreateAbsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSwishOptionsT : public ::flatbuffers::NativeTable {
  typedef HardSwishOptions TableType;
};

struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HardSwishOptionsT NativeTableType;
  typedef HardSwishOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HardSwishOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HardSwishOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HardSwishOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSwishOptionsBuilder {
  typedef HardSwishOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HardSwishOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HardSwishOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HardSwishOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HardSwishOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndOptionsT : public ::flatbuffers::NativeTable {
  typedef LogicalAndOptions TableType;
};

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogicalAndOptionsT NativeTableType;
  typedef LogicalAndOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalAndOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalAndOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LogicalAndOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndOptionsBuilder {
  typedef LogicalAndOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogicalAndOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotOptionsT : public ::flatbuffers::NativeTable {
  typedef LogicalNotOptions TableType;
};

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogicalNotOptionsT NativeTableType;
  typedef LogicalNotOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalNotOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalNotOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LogicalNotOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotOptionsBuilder {
  typedef LogicalNotOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogicalNotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnpackOptionsT : public ::flatbuffers::NativeTable {
  typedef UnpackOptions TableType;
  int32_t num = 0;
  int32_t axis = 0;
};

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnpackOptionsT NativeTableType;
  typedef UnpackOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
  UnpackOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnpackOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UnpackOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnpackOptionsBuilder {
  typedef UnpackOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);
  }
  explicit UnpackOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnpackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

::flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivOptionsT : public ::flatbuffers::NativeTable {
  typedef FloorDivOptions TableType;
};

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloorDivOptionsT NativeTableType;
  typedef FloorDivOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorDivOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorDivOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FloorDivOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivOptionsBuilder {
  typedef FloorDivOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloorDivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareOptionsT : public ::flatbuffers::NativeTable {
  typedef SquareOptions TableType;
};

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SquareOptionsT NativeTableType;
  typedef SquareOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquareOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquareOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SquareOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareOptionsBuilder {
  typedef SquareOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SquareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SquareOptions> CreateSquareOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SquareOptions> CreateSquareOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeOptionsT : public ::flatbuffers::NativeTable {
  typedef ZerosLikeOptions TableType;
};

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ZerosLikeOptionsT NativeTableType;
  typedef ZerosLikeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ZerosLikeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZerosLikeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ZerosLikeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeOptionsBuilder {
  typedef ZerosLikeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZerosLikeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillOptionsT : public ::flatbuffers::NativeTable {
  typedef FillOptions TableType;
};

struct FillOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FillOptionsT NativeTableType;
  typedef FillOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FillOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FillOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillOptionsBuilder {
  typedef FillOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FillOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FillOptions> CreateFillOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<FillOptions> CreateFillOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorModOptionsT : public ::flatbuffers::NativeTable {
  typedef FloorModOptions TableType;
};

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloorModOptionsT NativeTableType;
  typedef FloorModOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorModOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorModOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FloorModOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorModOptionsBuilder {
  typedef FloorModOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloorModOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeOptionsT : public ::flatbuffers::NativeTable {
  typedef RangeOptions TableType;
};

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeOptionsT NativeTableType;
  typedef RangeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RangeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RangeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeOptionsBuilder {
  typedef RangeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RangeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RangeOptions> CreateRangeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<RangeOptions> CreateRangeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluOptionsT : public ::flatbuffers::NativeTable {
  typedef LeakyReluOptions TableType;
  float alpha = 0.0f;
};

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeakyReluOptionsT NativeTableType;
  typedef LeakyReluOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
  LeakyReluOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LeakyReluOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluOptionsBuilder {
  typedef LeakyReluOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f);
  }
  explicit LeakyReluOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeakyReluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

::flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquaredDifferenceOptionsT : public ::flatbuffers::NativeTable {
  typedef SquaredDifferenceOptions TableType;
};

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SquaredDifferenceOptionsT NativeTableType;
  typedef SquaredDifferenceOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquaredDifferenceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquaredDifferenceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SquaredDifferenceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquaredDifferenceOptionsBuilder {
  typedef SquaredDifferenceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SquaredDifferenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MirrorPadOptionsT : public ::flatbuffers::NativeTable {
  typedef MirrorPadOptions TableType;
  tflite::MirrorPadMode mode = tflite::MirrorPadMode_REFLECT;
};

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MirrorPadOptionsT NativeTableType;
  typedef MirrorPadOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  tflite::MirrorPadMode mode() const {
    return static_cast<tflite::MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           verifier.EndTable();
  }
  MirrorPadOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MirrorPadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MirrorPadOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MirrorPadOptionsBuilder {
  typedef MirrorPadOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(tflite::MirrorPadMode mode) {
    fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MirrorPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::MirrorPadMode mode = tflite::MirrorPadMode_REFLECT) {
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

::flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueOptionsT : public ::flatbuffers::NativeTable {
  typedef UniqueOptions TableType;
  tflite::TensorType idx_out_type = tflite::TensorType_INT32;
};

struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueOptionsT NativeTableType;
  typedef UniqueOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX_OUT_TYPE = 4
  };
  tflite::TensorType idx_out_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IDX_OUT_TYPE, 2));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE, 1) &&
           verifier.EndTable();
  }
  UniqueOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueOptionsBuilder {
  typedef UniqueOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idx_out_type(tflite::TensorType idx_out_type) {
    fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE, static_cast<int8_t>(idx_out_type), 2);
  }
  explicit UniqueOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType idx_out_type = tflite::TensorType_INT32) {
  UniqueOptionsBuilder builder_(_fbb);
  builder_.add_idx_out_type(idx_out_type);
  return builder_.Finish();
}

::flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseV2OptionsT : public ::flatbuffers::NativeTable {
  typedef ReverseV2Options TableType;
};

struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReverseV2OptionsT NativeTableType;
  typedef ReverseV2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReverseV2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReverseV2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseV2OptionsBuilder {
  typedef ReverseV2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ReverseV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReverseV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReverseV2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ReverseV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddNOptionsT : public ::flatbuffers::NativeTable {
  typedef AddNOptions TableType;
};

struct AddNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddNOptionsT NativeTableType;
  typedef AddNOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddNOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AddNOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddNOptionsBuilder {
  typedef AddNOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit AddNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddNOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddNOptions> CreateAddNOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  AddNOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<AddNOptions> CreateAddNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherNdOptionsT : public ::flatbuffers::NativeTable {
  typedef GatherNdOptions TableType;
};

struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GatherNdOptionsT NativeTableType;
  typedef GatherNdOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GatherNdOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherNdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GatherNdOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherNdOptionsBuilder {
  typedef GatherNdOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GatherNdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GatherNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GatherNdOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GatherNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhereOptionsT : public ::flatbuffers::NativeTable {
  typedef WhereOptions TableType;
};

struct WhereOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhereOptionsT NativeTableType;
  typedef WhereOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  WhereOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhereOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WhereOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhereOptionsBuilder {
  typedef WhereOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit WhereOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhereOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhereOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhereOptions> CreateWhereOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  WhereOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<WhereOptions> CreateWhereOptions(::flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseSequenceOptionsT : public ::flatbuffers::NativeTable {
  typedef ReverseSequenceOptions TableType;
  int32_t seq_dim = 0;
  int32_t batch_dim = 0;
};

struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReverseSequenceOptionsT NativeTableType;
  typedef ReverseSequenceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int32_t seq_dim() const {
    return GetField<int32_t>(VT_SEQ_DIM, 0);
  }
  int32_t batch_dim() const {
    return GetField<int32_t>(VT_BATCH_DIM, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQ_DIM, 4) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIM, 4) &&
           verifier.EndTable();
  }
  ReverseSequenceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseSequenceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReverseSequenceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseSequenceOptionsBuilder {
  typedef ReverseSequenceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seq_dim(int32_t seq_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int32_t batch_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
  }
  explicit ReverseSequenceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReverseSequenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReverseSequenceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seq_dim = 0,
    int32_t batch_dim = 0) {
  ReverseSequenceOptionsBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

::flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixDiagOptionsT : public ::flatbuffers::NativeTable {
  typedef MatrixDiagOptions TableType;
};

struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatrixDiagOptionsT NativeTableType;
  typedef MatrixDiagOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MatrixDiagOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixDiagOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MatrixDiagOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixDiagOptionsBuilder {
  typedef MatrixDiagOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MatrixDiagOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MatrixDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MatrixDiagOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  MatrixDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizeOptionsT : public ::flatbuffers::NativeTable {
  typedef QuantizeOptions TableType;
};

struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizeOptionsT NativeTableType;
  typedef QuantizeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  QuantizeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<QuantizeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizeOptionsBuilder {
  typedef QuantizeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit QuantizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  QuantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixSetDiagOptionsT : public ::flatbuffers::NativeTable {
  typedef MatrixSetDiagOptions TableType;
};

struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatrixSetDiagOptionsT NativeTableType;
  typedef MatrixSetDiagOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MatrixSetDiagOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixSetDiagOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MatrixSetDiagOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixSetDiagOptionsBuilder {
  typedef MatrixSetDiagOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MatrixSetDiagOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MatrixSetDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MatrixSetDiagOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  MatrixSetDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IfOptionsT : public ::flatbuffers::NativeTable {
  typedef IfOptions TableType;
  int32_t then_subgraph_index = 0;
  int32_t else_subgraph_index = 0;
};

struct IfOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IfOptionsT NativeTableType;
  typedef IfOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THEN_SUBGRAPH_INDEX = 4,
    VT_ELSE_SUBGRAPH_INDEX = 6
  };
  int32_t then_subgraph_index() const {
    return GetField<int32_t>(VT_THEN_SUBGRAPH_INDEX, 0);
  }
  int32_t else_subgraph_index() const {
    return GetField<int32_t>(VT_ELSE_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_THEN_SUBGRAPH_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_ELSE_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  IfOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IfOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IfOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IfOptionsBuilder {
  typedef IfOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_then_subgraph_index(int32_t then_subgraph_index) {
    fbb_.AddElement<int32_t>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
  }
  void add_else_subgraph_index(int32_t else_subgraph_index) {
    fbb_.AddElement<int32_t>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
  }
  explicit IfOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IfOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IfOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IfOptions> CreateIfOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t then_subgraph_index = 0,
    int32_t else_subgraph_index = 0) {
  IfOptionsBuilder builder_(_fbb);
  builder_.add_else_subgraph_index(else_subgraph_index);
  builder_.add_then_subgraph_index(then_subgraph_index);
  return builder_.Finish();
}

::flatbuffers::Offset<IfOptions> CreateIfOptions(::flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOnceOptionsT : public ::flatbuffers::NativeTable {
  typedef CallOnceOptions TableType;
  int32_t init_subgraph_index = 0;
};

struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallOnceOptionsT NativeTableType;
  typedef CallOnceOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INIT_SUBGRAPH_INDEX = 4
  };
  int32_t init_subgraph_index() const {
    return GetField<int32_t>(VT_INIT_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INIT_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  CallOnceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOnceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CallOnceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOnceOptionsBuilder {
  typedef CallOnceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_init_subgraph_index(int32_t init_subgraph_index) {
    fbb_.AddElement<int32_t>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, init_subgraph_index, 0);
  }
  explicit CallOnceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallOnceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallOnceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t init_subgraph_index = 0) {
  CallOnceOptionsBuilder builder_(_fbb);
  builder_.add_init_subgraph_index(init_subgraph_index);
  return builder_.Finish();
}

::flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhileOptionsT : public ::flatbuffers::NativeTable {
  typedef WhileOptions TableType;
  int32_t cond_subgraph_index = 0;
  int32_t body_subgraph_index = 0;
};

struct WhileOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhileOptionsT NativeTableType;
  typedef WhileOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND_SUBGRAPH_INDEX = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  int32_t cond_subgraph_index() const {
    return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  WhileOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WhileOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhileOptionsBuilder {
  typedef WhileOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index) {
    fbb_.AddElement<int32_t>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit WhileOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhileOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhileOptions> CreateWhileOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cond_subgraph_index = 0,
    int32_t body_subgraph_index = 0) {
  WhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

::flatbuffers::Offset<WhileOptions> CreateWhileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV4OptionsT : public ::flatbuffers::NativeTable {
  typedef NonMaxSuppressionV4Options TableType;
};

struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NonMaxSuppressionV4OptionsT NativeTableType;
  typedef NonMaxSuppressionV4OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonMaxSuppressionV4OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV4OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NonMaxSuppressionV4Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV4OptionsBuilder {
  typedef NonMaxSuppressionV4Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV4OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NonMaxSuppressionV4Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NonMaxSuppressionV4Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV4OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV5OptionsT : public ::flatbuffers::NativeTable {
  typedef NonMaxSuppressionV5Options TableType;
};

struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NonMaxSuppressionV5OptionsT NativeTableType;
  typedef NonMaxSuppressionV5OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonMaxSuppressionV5OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV5OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NonMaxSuppressionV5Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV5OptionsBuilder {
  typedef NonMaxSuppressionV5Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV5OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NonMaxSuppressionV5Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NonMaxSuppressionV5Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV5OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNdOptionsT : public ::flatbuffers::NativeTable {
  typedef ScatterNdOptions TableType;
};

struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScatterNdOptionsT NativeTableType;
  typedef ScatterNdOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ScatterNdOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterNdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ScatterNdOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNdOptionsBuilder {
  typedef ScatterNdOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ScatterNdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScatterNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScatterNdOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectV2OptionsT : public ::flatbuffers::NativeTable {
  typedef SelectV2Options TableType;
};

struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SelectV2OptionsT NativeTableType;
  typedef SelectV2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectV2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SelectV2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectV2OptionsBuilder {
  typedef SelectV2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SelectV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SelectV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SelectV2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SelectV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DensifyOptionsT : public ::flatbuffers::NativeTable {
  typedef DensifyOptions TableType;
};

struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DensifyOptionsT NativeTableType;
  typedef DensifyOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DensifyOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DensifyOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DensifyOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DensifyOptionsBuilder {
  typedef DensifyOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DensifyOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DensifyOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DensifyOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  DensifyOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SegmentSumOptionsT : public ::flatbuffers::NativeTable {
  typedef SegmentSumOptions TableType;
};

struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SegmentSumOptionsT NativeTableType;
  typedef SegmentSumOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SegmentSumOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SegmentSumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SegmentSumOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SegmentSumOptionsBuilder {
  typedef SegmentSumOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SegmentSumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SegmentSumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SegmentSumOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchMatMulOptionsT : public ::flatbuffers::NativeTable {
  typedef BatchMatMulOptions TableType;
  bool adj_x = false;
  bool adj_y = false;
  bool asymmetric_quantize_inputs = false;
};

struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchMatMulOptionsT NativeTableType;
  typedef BatchMatMulOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADJ_X = 4,
    VT_ADJ_Y = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool adj_x() const {
    return GetField<uint8_t>(VT_ADJ_X, 0) != 0;
  }
  bool adj_y() const {
    return GetField<uint8_t>(VT_ADJ_Y, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADJ_X, 1) &&
           VerifyField<uint8_t>(verifier, VT_ADJ_Y, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&
           verifier.EndTable();
  }
  BatchMatMulOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchMatMulOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BatchMatMulOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchMatMulOptionsBuilder {
  typedef BatchMatMulOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_adj_x(bool adj_x) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_X, static_cast<uint8_t>(adj_x), 0);
  }
  void add_adj_y(bool adj_y) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_Y, static_cast<uint8_t>(adj_y), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BatchMatMulOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchMatMulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchMatMulOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool adj_x = false,
    bool adj_y = false,
    bool asymmetric_quantize_inputs = false) {
  BatchMatMulOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_adj_y(adj_y);
  builder_.add_adj_x(adj_x);
  return builder_.Finish();
}

::flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CumsumOptionsT : public ::flatbuffers::NativeTable {
  typedef CumsumOptions TableType;
  bool exclusive = false;
  bool reverse = false;
};

struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CumsumOptionsT NativeTableType;
  typedef CumsumOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
  }
  bool reverse() const {
    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE, 1) &&
           verifier.EndTable();
  }
  CumsumOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CumsumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CumsumOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CumsumOptionsBuilder {
  typedef CumsumOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumsumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CumsumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CumsumOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumsumOptionsBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

::flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastToOptionsT : public ::flatbuffers::NativeTable {
  typedef BroadcastToOptions TableType;
};

struct BroadcastToOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BroadcastToOptionsT NativeTableType;
  typedef BroadcastToOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BroadcastToOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastToOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BroadcastToOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastToOptionsBuilder {
  typedef BroadcastToOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BroadcastToOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BroadcastToOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BroadcastToOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BroadcastToOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Rfft2dOptionsT : public ::flatbuffers::NativeTable {
  typedef Rfft2dOptions TableType;
};

struct Rfft2dOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Rfft2dOptionsT NativeTableType;
  typedef Rfft2dOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Rfft2dOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Rfft2dOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Rfft2dOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Rfft2dOptionsBuilder {
  typedef Rfft2dOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit Rfft2dOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rfft2dOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rfft2dOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  Rfft2dOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableOptionsT : public ::flatbuffers::NativeTable {
  typedef HashtableOptions TableType;
  int32_t table_id = 0;
  tflite::TensorType key_dtype = tflite::TensorType_FLOAT32;
  tflite::TensorType value_dtype = tflite::TensorType_FLOAT32;
};

struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HashtableOptionsT NativeTableType;
  typedef HashtableOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLE_ID = 4,
    VT_KEY_DTYPE = 6,
    VT_VALUE_DTYPE = 8
  };
  int32_t table_id() const {
    return GetField<int32_t>(VT_TABLE_ID, 0);
  }
  tflite::TensorType key_dtype() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_KEY_DTYPE, 0));
  }
  tflite::TensorType value_dtype() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_VALUE_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TABLE_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_KEY_DTYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_VALUE_DTYPE, 1) &&
           verifier.EndTable();
  }
  HashtableOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HashtableOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableOptionsBuilder {
  typedef HashtableOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_table_id(int32_t table_id) {
    fbb_.AddElement<int32_t>(HashtableOptions::VT_TABLE_ID, table_id, 0);
  }
  void add_key_dtype(tflite::TensorType key_dtype) {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_KEY_DTYPE, static_cast<int8_t>(key_dtype), 0);
  }
  void add_value_dtype(tflite::TensorType value_dtype) {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_VALUE_DTYPE, static_cast<int8_t>(value_dtype), 0);
  }
  explicit HashtableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HashtableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HashtableOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t table_id = 0,
    tflite::TensorType key_dtype = tflite::TensorType_FLOAT32,
    tflite::TensorType value_dtype = tflite::TensorType_FLOAT32) {
  HashtableOptionsBuilder builder_(_fbb);
  builder_.add_table_id(table_id);
  builder_.add_value_dtype(value_dtype);
  builder_.add_key_dtype(key_dtype);
  return builder_.Finish();
}

::flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableFindOptionsT : public ::flatbuffers::NativeTable {
  typedef HashtableFindOptions TableType;
};

struct HashtableFindOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HashtableFindOptionsT NativeTableType;
  typedef HashtableFindOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableFindOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableFindOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HashtableFindOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableFindOptionsBuilder {
  typedef HashtableFindOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HashtableFindOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HashtableFindOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HashtableFindOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableFindOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableImportOptionsT : public ::flatbuffers::NativeTable {
  typedef HashtableImportOptions TableType;
};

struct HashtableImportOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HashtableImportOptionsT NativeTableType;
  typedef HashtableImportOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableImportOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableImportOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HashtableImportOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableImportOptionsBuilder {
  typedef HashtableImportOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HashtableImportOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HashtableImportOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HashtableImportOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableImportOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableSizeOptionsT : public ::flatbuffers::NativeTable {
  typedef HashtableSizeOptions TableType;
};

struct HashtableSizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HashtableSizeOptionsT NativeTableType;
  typedef HashtableSizeOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableSizeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableSizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HashtableSizeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableSizeOptionsBuilder {
  typedef HashtableSizeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HashtableSizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HashtableSizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HashtableSizeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableSizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VarHandleOptionsT : public ::flatbuffers::NativeTable {
  typedef VarHandleOptions TableType;
  std::string container{};
  std::string shared_name{};
};

struct VarHandleOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VarHandleOptionsT NativeTableType;
  typedef VarHandleOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTAINER = 4,
    VT_SHARED_NAME = 6
  };
  const ::flatbuffers::String *container() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTAINER);
  }
  const ::flatbuffers::String *shared_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHARED_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTAINER) &&
           verifier.VerifyString(container()) &&
           VerifyOffset(verifier, VT_SHARED_NAME) &&
           verifier.VerifyString(shared_name()) &&
           verifier.EndTable();
  }
  VarHandleOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarHandleOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VarHandleOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarHandleOptionsBuilder {
  typedef VarHandleOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_container(::flatbuffers::Offset<::flatbuffers::String> container) {
    fbb_.AddOffset(VarHandleOptions::VT_CONTAINER, container);
  }
  void add_shared_name(::flatbuffers::Offset<::flatbuffers::String> shared_name) {
    fbb_.AddOffset(VarHandleOptions::VT_SHARED_NAME, shared_name);
  }
  explicit VarHandleOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VarHandleOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VarHandleOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> container = 0,
    ::flatbuffers::Offset<::flatbuffers::String> shared_name = 0) {
  VarHandleOptionsBuilder builder_(_fbb);
  builder_.add_shared_name(shared_name);
  builder_.add_container(container);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *container = nullptr,
    const char *shared_name = nullptr) {
  auto container__ = container ? _fbb.CreateString(container) : 0;
  auto shared_name__ = shared_name ? _fbb.CreateString(shared_name) : 0;
  return tflite::CreateVarHandleOptions(
      _fbb,
      container__,
      shared_name__);
}

::flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(::flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadVariableOptionsT : public ::flatbuffers::NativeTable {
  typedef ReadVariableOptions TableType;
};

struct ReadVariableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadVariableOptionsT NativeTableType;
  typedef ReadVariableOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReadVariableOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadVariableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadVariableOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadVariableOptionsBuilder {
  typedef ReadVariableOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ReadVariableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadVariableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadVariableOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ReadVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssignVariableOptionsT : public ::flatbuffers::NativeTable {
  typedef AssignVariableOptions TableType;
};

struct AssignVariableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AssignVariableOptionsT NativeTableType;
  typedef AssignVariableOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AssignVariableOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssignVariableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AssignVariableOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssignVariableOptionsBuilder {
  typedef AssignVariableOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit AssignVariableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AssignVariableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AssignVariableOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  AssignVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomOptionsT : public ::flatbuffers::NativeTable {
  typedef RandomOptions TableType;
  int64_t seed = 0;
  int64_t seed2 = 0;
};

struct RandomOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RandomOptionsT NativeTableType;
  typedef RandomOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int64_t seed() const {
    return GetField<int64_t>(VT_SEED, 0);
  }
  int64_t seed2() const {
    return GetField<int64_t>(VT_SEED2, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEED, 8) &&
           VerifyField<int64_t>(verifier, VT_SEED2, 8) &&
           verifier.EndTable();
  }
  RandomOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RandomOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomOptionsBuilder {
  typedef RandomOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) {
    fbb_.AddElement<int64_t>(RandomOptions::VT_SEED, seed, 0);
  }
  void add_seed2(int64_t seed2) {
    fbb_.AddElement<int64_t>(RandomOptions::VT_SEED2, seed2, 0);
  }
  explicit RandomOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RandomOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RandomOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RandomOptions> CreateRandomOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seed = 0,
    int64_t seed2 = 0) {
  RandomOptionsBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

::flatbuffers::Offset<RandomOptions> CreateRandomOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BucketizeOptionsT : public ::flatbuffers::NativeTable {
  typedef BucketizeOptions TableType;
  std::vector<float> boundaries{};
};

struct BucketizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BucketizeOptionsT NativeTableType;
  typedef BucketizeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOUNDARIES = 4
  };
  const ::flatbuffers::Vector<float> *boundaries() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BOUNDARIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BOUNDARIES) &&
           verifier.VerifyVector(boundaries()) &&
           verifier.EndTable();
  }
  BucketizeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BucketizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BucketizeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BucketizeOptionsBuilder {
  typedef BucketizeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_boundaries(::flatbuffers::Offset<::flatbuffers::Vector<float>> boundaries) {
    fbb_.AddOffset(BucketizeOptions::VT_BOUNDARIES, boundaries);
  }
  explicit BucketizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BucketizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BucketizeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> boundaries = 0) {
  BucketizeOptionsBuilder builder_(_fbb);
  builder_.add_boundaries(boundaries);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *boundaries = nullptr) {
  auto boundaries__ = boundaries ? _fbb.CreateVector<float>(*boundaries) : 0;
  return tflite::CreateBucketizeOptions(
      _fbb,
      boundaries__);
}

::flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeluOptionsT : public ::flatbuffers::NativeTable {
  typedef GeluOptions TableType;
  bool approximate = false;
};

struct GeluOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeluOptionsT NativeTableType;
  typedef GeluOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPROXIMATE = 4
  };
  bool approximate() const {
    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_APPROXIMATE, 1) &&
           verifier.EndTable();
  }
  GeluOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeluOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeluOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeluOptionsBuilder {
  typedef GeluOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(GeluOptions::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
  }
  explicit GeluOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeluOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GeluOptions> CreateGeluOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool approximate = false) {
  GeluOptionsBuilder builder_(_fbb);
  builder_.add_approximate(approximate);
  return builder_.Finish();
}

::flatbuffers::Offset<GeluOptions> CreateGeluOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DynamicUpdateSliceOptionsT : public ::flatbuffers::NativeTable {
  typedef DynamicUpdateSliceOptions TableType;
};

struct DynamicUpdateSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DynamicUpdateSliceOptionsT NativeTableType;
  typedef DynamicUpdateSliceOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DynamicUpdateSliceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DynamicUpdateSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DynamicUpdateSliceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DynamicUpdateSliceOptionsBuilder {
  typedef DynamicUpdateSliceOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DynamicUpdateSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DynamicUpdateSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DynamicUpdateSliceOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  DynamicUpdateSliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentProdOptionsT : public ::flatbuffers::NativeTable {
  typedef UnsortedSegmentProdOptions TableType;
};

struct UnsortedSegmentProdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnsortedSegmentProdOptionsT NativeTableType;
  typedef UnsortedSegmentProdOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentProdOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentProdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UnsortedSegmentProdOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentProdOptionsBuilder {
  typedef UnsortedSegmentProdOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentProdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsortedSegmentProdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsortedSegmentProdOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentProdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentMaxOptionsT : public ::flatbuffers::NativeTable {
  typedef UnsortedSegmentMaxOptions TableType;
};

struct UnsortedSegmentMaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnsortedSegmentMaxOptionsT NativeTableType;
  typedef UnsortedSegmentMaxOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentMaxOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentMaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UnsortedSegmentMaxOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentMaxOptionsBuilder {
  typedef UnsortedSegmentMaxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentMaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsortedSegmentMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsortedSegmentMaxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentMaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentSumOptionsT : public ::flatbuffers::NativeTable {
  typedef UnsortedSegmentSumOptions TableType;
};

struct UnsortedSegmentSumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnsortedSegmentSumOptionsT NativeTableType;
  typedef UnsortedSegmentSumOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentSumOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentSumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UnsortedSegmentSumOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentSumOptionsBuilder {
  typedef UnsortedSegmentSumOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentSumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsortedSegmentSumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsortedSegmentSumOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ATan2OptionsT : public ::flatbuffers::NativeTable {
  typedef ATan2Options TableType;
};

struct ATan2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ATan2OptionsT NativeTableType;
  typedef ATan2OptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ATan2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ATan2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ATan2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ATan2OptionsBuilder {
  typedef ATan2Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ATan2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ATan2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ATan2Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ATan2Options> CreateATan2Options(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ATan2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<ATan2Options> CreateATan2Options(::flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentMinOptionsT : public ::flatbuffers::NativeTable {
  typedef UnsortedSegmentMinOptions TableType;
};

struct UnsortedSegmentMinOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnsortedSegmentMinOptionsT NativeTableType;
  typedef UnsortedSegmentMinOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentMinOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentMinOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UnsortedSegmentMinOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentMinOptionsBuilder {
  typedef UnsortedSegmentMinOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentMinOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsortedSegmentMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsortedSegmentMinOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentMinOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignOptionsT : public ::flatbuffers::NativeTable {
  typedef SignOptions TableType;
};

struct SignOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SignOptionsT NativeTableType;
  typedef SignOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SignOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SignOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignOptionsBuilder {
  typedef SignOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SignOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SignOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SignOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SignOptions> CreateSignOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SignOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<SignOptions> CreateSignOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BitcastOptionsT : public ::flatbuffers::NativeTable {
  typedef BitcastOptions TableType;
};

struct BitcastOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BitcastOptionsT NativeTableType;
  typedef BitcastOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BitcastOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BitcastOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BitcastOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BitcastOptionsBuilder {
  typedef BitcastOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BitcastOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BitcastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BitcastOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BitcastOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BitwiseXorOptionsT : public ::flatbuffers::NativeTable {
  typedef BitwiseXorOptions TableType;
};

struct BitwiseXorOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BitwiseXorOptionsT NativeTableType;
  typedef BitwiseXorOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BitwiseXorOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BitwiseXorOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BitwiseXorOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BitwiseXorOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BitwiseXorOptionsBuilder {
  typedef BitwiseXorOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BitwiseXorOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BitwiseXorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BitwiseXorOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BitwiseXorOptions> CreateBitwiseXorOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BitwiseXorOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<BitwiseXorOptions> CreateBitwiseXorOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BitwiseXorOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RightShiftOptionsT : public ::flatbuffers::NativeTable {
  typedef RightShiftOptions TableType;
};

struct RightShiftOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RightShiftOptionsT NativeTableType;
  typedef RightShiftOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RightShiftOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RightShiftOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RightShiftOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RightShiftOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RightShiftOptionsBuilder {
  typedef RightShiftOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RightShiftOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RightShiftOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RightShiftOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RightShiftOptions> CreateRightShiftOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RightShiftOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<RightShiftOptions> CreateRightShiftOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RightShiftOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DilateOptionsT : public ::flatbuffers::NativeTable {
  typedef DilateOptions TableType;
};

struct DilateOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DilateOptionsT NativeTableType;
  typedef DilateOptionsBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DilateOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DilateOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DilateOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DilateOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DilateOptionsBuilder {
  typedef DilateOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DilateOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DilateOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DilateOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DilateOptions> CreateDilateOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  DilateOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<DilateOptions> CreateDilateOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DilateOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceWindowOptionsT : public ::flatbuffers::NativeTable {
  typedef ReduceWindowOptions TableType;
  tflite::ReduceWindowFunction reduce_function = tflite::ReduceWindowFunction_UNSUPPORTED;
};

struct ReduceWindowOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReduceWindowOptionsT NativeTableType;
  typedef ReduceWindowOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCE_FUNCTION = 4
  };
  tflite::ReduceWindowFunction reduce_function() const {
    return static_cast<tflite::ReduceWindowFunction>(GetField<int32_t>(VT_REDUCE_FUNCTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REDUCE_FUNCTION, 4) &&
           verifier.EndTable();
  }
  ReduceWindowOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceWindowOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReduceWindowOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReduceWindowOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceWindowOptionsBuilder {
  typedef ReduceWindowOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reduce_function(tflite::ReduceWindowFunction reduce_function) {
    fbb_.AddElement<int32_t>(ReduceWindowOptions::VT_REDUCE_FUNCTION, static_cast<int32_t>(reduce_function), 0);
  }
  explicit ReduceWindowOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReduceWindowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReduceWindowOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReduceWindowOptions> CreateReduceWindowOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ReduceWindowFunction reduce_function = tflite::ReduceWindowFunction_UNSUPPORTED) {
  ReduceWindowOptionsBuilder builder_(_fbb);
  builder_.add_reduce_function(reduce_function);
  return builder_.Finish();
}

::flatbuffers::Offset<ReduceWindowOptions> CreateReduceWindowOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReduceWindowOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorCodeT : public ::flatbuffers::NativeTable {
  typedef OperatorCode TableType;
  int8_t deprecated_builtin_code = 0;
  std::string custom_code{};
  int32_t version = 1;
  tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD;
};

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorCodeT NativeTableType;
  typedef OperatorCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPRECATED_BUILTIN_CODE = 4,
    VT_CUSTOM_CODE = 6,
    VT_VERSION = 8,
    VT_BUILTIN_CODE = 10
  };
  int8_t deprecated_builtin_code() const {
    return GetField<int8_t>(VT_DEPRECATED_BUILTIN_CODE, 0);
  }
  const ::flatbuffers::String *custom_code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOM_CODE);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 1);
  }
  tflite::BuiltinOperator builtin_code() const {
    return static_cast<tflite::BuiltinOperator>(GetField<int32_t>(VT_BUILTIN_CODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DEPRECATED_BUILTIN_CODE, 1) &&
           VerifyOffset(verifier, VT_CUSTOM_CODE) &&
           verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<int32_t>(verifier, VT_BUILTIN_CODE, 4) &&
           verifier.EndTable();
  }
  OperatorCodeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorCodeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OperatorCode> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorCodeBuilder {
  typedef OperatorCode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_deprecated_builtin_code(int8_t deprecated_builtin_code) {
    fbb_.AddElement<int8_t>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, deprecated_builtin_code, 0);
  }
  void add_custom_code(::flatbuffers::Offset<::flatbuffers::String> custom_code) {
    fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
  }
  void add_builtin_code(tflite::BuiltinOperator builtin_code) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int32_t>(builtin_code), 0);
  }
  explicit OperatorCodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OperatorCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t deprecated_builtin_code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> custom_code = 0,
    int32_t version = 1,
    tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD) {
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_builtin_code(builtin_code);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_deprecated_builtin_code(deprecated_builtin_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t deprecated_builtin_code = 0,
    const char *custom_code = nullptr,
    int32_t version = 1,
    tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD) {
  auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
  return tflite::CreateOperatorCode(
      _fbb,
      deprecated_builtin_code,
      custom_code__,
      version,
      builtin_code);
}

::flatbuffers::Offset<OperatorCode> CreateOperatorCode(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StableHLOCompositeOptionsT : public ::flatbuffers::NativeTable {
  typedef StableHLOCompositeOptions TableType;
  std::string name{};
  int32_t decomposition_subgraph_index = 0;
  std::vector<uint8_t> composite_attributes{};
  tflite::CustomOptionsFormat composite_attributes_format = tflite::CustomOptionsFormat_FLEXBUFFERS;
  int32_t version = 0;
};

struct StableHLOCompositeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StableHLOCompositeOptionsT NativeTableType;
  typedef StableHLOCompositeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DECOMPOSITION_SUBGRAPH_INDEX = 6,
    VT_COMPOSITE_ATTRIBUTES = 8,
    VT_COMPOSITE_ATTRIBUTES_FORMAT = 10,
    VT_VERSION = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t decomposition_subgraph_index() const {
    return GetField<int32_t>(VT_DECOMPOSITION_SUBGRAPH_INDEX, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *composite_attributes() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_COMPOSITE_ATTRIBUTES);
  }
  tflite::CustomOptionsFormat composite_attributes_format() const {
    return static_cast<tflite::CustomOptionsFormat>(GetField<int8_t>(VT_COMPOSITE_ATTRIBUTES_FORMAT, 0));
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_DECOMPOSITION_SUBGRAPH_INDEX, 4) &&
           VerifyOffset(verifier, VT_COMPOSITE_ATTRIBUTES) &&
           verifier.VerifyVector(composite_attributes()) &&
           VerifyField<int8_t>(verifier, VT_COMPOSITE_ATTRIBUTES_FORMAT, 1) &&
           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
           verifier.EndTable();
  }
  StableHLOCompositeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StableHLOCompositeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StableHLOCompositeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StableHLOCompositeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StableHLOCompositeOptionsBuilder {
  typedef StableHLOCompositeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(StableHLOCompositeOptions::VT_NAME, name);
  }
  void add_decomposition_subgraph_index(int32_t decomposition_subgraph_index) {
    fbb_.AddElement<int32_t>(StableHLOCompositeOptions::VT_DECOMPOSITION_SUBGRAPH_INDEX, decomposition_subgraph_index, 0);
  }
  void add_composite_attributes(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> composite_attributes) {
    fbb_.AddOffset(StableHLOCompositeOptions::VT_COMPOSITE_ATTRIBUTES, composite_attributes);
  }
  void add_composite_attributes_format(tflite::CustomOptionsFormat composite_attributes_format) {
    fbb_.AddElement<int8_t>(StableHLOCompositeOptions::VT_COMPOSITE_ATTRIBUTES_FORMAT, static_cast<int8_t>(composite_attributes_format), 0);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(StableHLOCompositeOptions::VT_VERSION, version, 0);
  }
  explicit StableHLOCompositeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StableHLOCompositeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StableHLOCompositeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StableHLOCompositeOptions> CreateStableHLOCompositeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t decomposition_subgraph_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> composite_attributes = 0,
    tflite::CustomOptionsFormat composite_attributes_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    int32_t version = 0) {
  StableHLOCompositeOptionsBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_composite_attributes(composite_attributes);
  builder_.add_decomposition_subgraph_index(decomposition_subgraph_index);
  builder_.add_name(name);
  builder_.add_composite_attributes_format(composite_attributes_format);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StableHLOCompositeOptions> CreateStableHLOCompositeOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t decomposition_subgraph_index = 0,
    const std::vector<uint8_t> *composite_attributes = nullptr,
    tflite::CustomOptionsFormat composite_attributes_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    int32_t version = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto composite_attributes__ = composite_attributes ? _fbb.CreateVector<uint8_t>(*composite_attributes) : 0;
  return tflite::CreateStableHLOCompositeOptions(
      _fbb,
      name__,
      decomposition_subgraph_index,
      composite_attributes__,
      composite_attributes_format,
      version);
}

::flatbuffers::Offset<StableHLOCompositeOptions> CreateStableHLOCompositeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StableHLOCompositeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorT : public ::flatbuffers::NativeTable {
  typedef Operator TableType;
  uint32_t opcode_index = 0;
  std::vector<int32_t> inputs{};
  std::vector<int32_t> outputs{};
  tflite::BuiltinOptionsUnion builtin_options{};
  std::vector<uint8_t> custom_options{};
  tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS;
  std::vector<bool> mutating_variable_inputs{};
  std::vector<int32_t> intermediates{};
  uint64_t large_custom_options_offset = 0;
  uint64_t large_custom_options_size = 0;
  tflite::BuiltinOptions2Union builtin_options_2{};
};

struct Operator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorT NativeTableType;
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPCODE_INDEX = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_BUILTIN_OPTIONS_TYPE = 10,
    VT_BUILTIN_OPTIONS = 12,
    VT_CUSTOM_OPTIONS = 14,
    VT_CUSTOM_OPTIONS_FORMAT = 16,
    VT_MUTATING_VARIABLE_INPUTS = 18,
    VT_INTERMEDIATES = 20,
    VT_LARGE_CUSTOM_OPTIONS_OFFSET = 22,
    VT_LARGE_CUSTOM_OPTIONS_SIZE = 24,
    VT_BUILTIN_OPTIONS_2_TYPE = 26,
    VT_BUILTIN_OPTIONS_2 = 28
  };
  uint32_t opcode_index() const {
    return GetField<uint32_t>(VT_OPCODE_INDEX, 0);
  }
  const ::flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  tflite::BuiltinOptions builtin_options_type() const {
    return static_cast<tflite::BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
  }
  const void *builtin_options() const {
    return GetPointer<const void *>(VT_BUILTIN_OPTIONS);
  }
  template<typename T> const T *builtin_options_as() const;
  const tflite::Conv2DOptions *builtin_options_as_Conv2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Conv2DOptions ? static_cast<const tflite::Conv2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DepthwiseConv2DOptions ? static_cast<const tflite::DepthwiseConv2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ConcatEmbeddingsOptions ? static_cast<const tflite::ConcatEmbeddingsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LSHProjectionOptions ? static_cast<const tflite::LSHProjectionOptions *>(builtin_options()) : nullptr;
  }
  const tflite::Pool2DOptions *builtin_options_as_Pool2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Pool2DOptions ? static_cast<const tflite::Pool2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SVDFOptions *builtin_options_as_SVDFOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SVDFOptions ? static_cast<const tflite::SVDFOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RNNOptions *builtin_options_as_RNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RNNOptions ? static_cast<const tflite::RNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FullyConnectedOptions ? static_cast<const tflite::FullyConnectedOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SoftmaxOptions *builtin_options_as_SoftmaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SoftmaxOptions ? static_cast<const tflite::SoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ConcatenationOptions *builtin_options_as_ConcatenationOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ConcatenationOptions ? static_cast<const tflite::ConcatenationOptions *>(builtin_options()) : nullptr;
  }
  const tflite::AddOptions *builtin_options_as_AddOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AddOptions ? static_cast<const tflite::AddOptions *>(builtin_options()) : nullptr;
  }
  const tflite::L2NormOptions *builtin_options_as_L2NormOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_L2NormOptions ? static_cast<const tflite::L2NormOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LocalResponseNormalizationOptions *builtin_options_as_LocalResponseNormalizationOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LocalResponseNormalizationOptions ? static_cast<const tflite::LocalResponseNormalizationOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LSTMOptions *builtin_options_as_LSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LSTMOptions ? static_cast<const tflite::LSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ResizeBilinearOptions ? static_cast<const tflite::ResizeBilinearOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CallOptions *builtin_options_as_CallOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CallOptions ? static_cast<const tflite::CallOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReshapeOptions *builtin_options_as_ReshapeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReshapeOptions ? static_cast<const tflite::ReshapeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SkipGramOptions *builtin_options_as_SkipGramOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SkipGramOptions ? static_cast<const tflite::SkipGramOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SpaceToDepthOptions ? static_cast<const tflite::SpaceToDepthOptions *>(builtin_options()) : nullptr;
  }
  const tflite::EmbeddingLookupSparseOptions *builtin_options_as_EmbeddingLookupSparseOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_EmbeddingLookupSparseOptions ? static_cast<const tflite::EmbeddingLookupSparseOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MulOptions *builtin_options_as_MulOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MulOptions ? static_cast<const tflite::MulOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PadOptions *builtin_options_as_PadOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PadOptions ? static_cast<const tflite::PadOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GatherOptions *builtin_options_as_GatherOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GatherOptions ? static_cast<const tflite::GatherOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BatchToSpaceNDOptions ? static_cast<const tflite::BatchToSpaceNDOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SpaceToBatchNDOptions ? static_cast<const tflite::SpaceToBatchNDOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TransposeOptions *builtin_options_as_TransposeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TransposeOptions ? static_cast<const tflite::TransposeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReducerOptions *builtin_options_as_ReducerOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReducerOptions ? static_cast<const tflite::ReducerOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SubOptions *builtin_options_as_SubOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SubOptions ? static_cast<const tflite::SubOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DivOptions *builtin_options_as_DivOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DivOptions ? static_cast<const tflite::DivOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SqueezeOptions *builtin_options_as_SqueezeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SqueezeOptions ? static_cast<const tflite::SqueezeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SequenceRNNOptions ? static_cast<const tflite::SequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::StridedSliceOptions *builtin_options_as_StridedSliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_StridedSliceOptions ? static_cast<const tflite::StridedSliceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ExpOptions *builtin_options_as_ExpOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ExpOptions ? static_cast<const tflite::ExpOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TopKV2Options *builtin_options_as_TopKV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_TopKV2Options ? static_cast<const tflite::TopKV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::SplitOptions *builtin_options_as_SplitOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SplitOptions ? static_cast<const tflite::SplitOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogSoftmaxOptions ? static_cast<const tflite::LogSoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CastOptions *builtin_options_as_CastOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CastOptions ? static_cast<const tflite::CastOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DequantizeOptions *builtin_options_as_DequantizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DequantizeOptions ? static_cast<const tflite::DequantizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MaximumMinimumOptions ? static_cast<const tflite::MaximumMinimumOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ArgMaxOptions *builtin_options_as_ArgMaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ArgMaxOptions ? static_cast<const tflite::ArgMaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LessOptions *builtin_options_as_LessOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LessOptions ? static_cast<const tflite::LessOptions *>(builtin_options()) : nullptr;
  }
  const tflite::NegOptions *builtin_options_as_NegOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_NegOptions ? static_cast<const tflite::NegOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PadV2Options *builtin_options_as_PadV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_PadV2Options ? static_cast<const tflite::PadV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::GreaterOptions *builtin_options_as_GreaterOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GreaterOptions ? static_cast<const tflite::GreaterOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GreaterEqualOptions ? static_cast<const tflite::GreaterEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LessEqualOptions *builtin_options_as_LessEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LessEqualOptions ? static_cast<const tflite::LessEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SelectOptions *builtin_options_as_SelectOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SelectOptions ? static_cast<const tflite::SelectOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SliceOptions *builtin_options_as_SliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SliceOptions ? static_cast<const tflite::SliceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TransposeConvOptions *builtin_options_as_TransposeConvOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TransposeConvOptions ? static_cast<const tflite::TransposeConvOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SparseToDenseOptions ? static_cast<const tflite::SparseToDenseOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TileOptions *builtin_options_as_TileOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TileOptions ? static_cast<const tflite::TileOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ExpandDimsOptions ? static_cast<const tflite::ExpandDimsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::EqualOptions *builtin_options_as_EqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_EqualOptions ? static_cast<const tflite::EqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::NotEqualOptions *builtin_options_as_NotEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_NotEqualOptions ? static_cast<const tflite::NotEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ShapeOptions *builtin_options_as_ShapeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ShapeOptions ? static_cast<const tflite::ShapeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PowOptions *builtin_options_as_PowOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PowOptions ? static_cast<const tflite::PowOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ArgMinOptions *builtin_options_as_ArgMinOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ArgMinOptions ? static_cast<const tflite::ArgMinOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FakeQuantOptions *builtin_options_as_FakeQuantOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FakeQuantOptions ? static_cast<const tflite::FakeQuantOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PackOptions *builtin_options_as_PackOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PackOptions ? static_cast<const tflite::PackOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalOrOptions *builtin_options_as_LogicalOrOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalOrOptions ? static_cast<const tflite::LogicalOrOptions *>(builtin_options()) : nullptr;
  }
  const tflite::OneHotOptions *builtin_options_as_OneHotOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_OneHotOptions ? static_cast<const tflite::OneHotOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalAndOptions *builtin_options_as_LogicalAndOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalAndOptions ? static_cast<const tflite::LogicalAndOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalNotOptions *builtin_options_as_LogicalNotOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalNotOptions ? static_cast<const tflite::LogicalNotOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnpackOptions *builtin_options_as_UnpackOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnpackOptions ? static_cast<const tflite::UnpackOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FloorDivOptions *builtin_options_as_FloorDivOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FloorDivOptions ? static_cast<const tflite::FloorDivOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SquareOptions *builtin_options_as_SquareOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SquareOptions ? static_cast<const tflite::SquareOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ZerosLikeOptions ? static_cast<const tflite::ZerosLikeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FillOptions *builtin_options_as_FillOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FillOptions ? static_cast<const tflite::FillOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BidirectionalSequenceLSTMOptions *builtin_options_as_BidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BidirectionalSequenceLSTMOptions ? static_cast<const tflite::BidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BidirectionalSequenceRNNOptions *builtin_options_as_BidirectionalSequenceRNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BidirectionalSequenceRNNOptions ? static_cast<const tflite::BidirectionalSequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnidirectionalSequenceLSTMOptions *builtin_options_as_UnidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnidirectionalSequenceLSTMOptions ? static_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FloorModOptions *builtin_options_as_FloorModOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FloorModOptions ? static_cast<const tflite::FloorModOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RangeOptions *builtin_options_as_RangeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RangeOptions ? static_cast<const tflite::RangeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ResizeNearestNeighborOptions *builtin_options_as_ResizeNearestNeighborOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ResizeNearestNeighborOptions ? static_cast<const tflite::ResizeNearestNeighborOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LeakyReluOptions *builtin_options_as_LeakyReluOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LeakyReluOptions ? static_cast<const tflite::LeakyReluOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SquaredDifferenceOptions ? static_cast<const tflite::SquaredDifferenceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MirrorPadOptions *builtin_options_as_MirrorPadOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MirrorPadOptions ? static_cast<const tflite::MirrorPadOptions *>(builtin_options()) : nullptr;
  }
  const tflite::AbsOptions *builtin_options_as_AbsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AbsOptions ? static_cast<const tflite::AbsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SplitVOptions *builtin_options_as_SplitVOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SplitVOptions ? static_cast<const tflite::SplitVOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UniqueOptions *builtin_options_as_UniqueOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UniqueOptions ? static_cast<const tflite::UniqueOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReverseV2Options *builtin_options_as_ReverseV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReverseV2Options ? static_cast<const tflite::ReverseV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::AddNOptions *builtin_options_as_AddNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AddNOptions ? static_cast<const tflite::AddNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GatherNdOptions *builtin_options_as_GatherNdOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GatherNdOptions ? static_cast<const tflite::GatherNdOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CosOptions *builtin_options_as_CosOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CosOptions ? static_cast<const tflite::CosOptions *>(builtin_options()) : nullptr;
  }
  const tflite::WhereOptions *builtin_options_as_WhereOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_WhereOptions ? static_cast<const tflite::WhereOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RankOptions *builtin_options_as_RankOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RankOptions ? static_cast<const tflite::RankOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReverseSequenceOptions *builtin_options_as_ReverseSequenceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReverseSequenceOptions ? static_cast<const tflite::ReverseSequenceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MatrixDiagOptions *builtin_options_as_MatrixDiagOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MatrixDiagOptions ? static_cast<const tflite::MatrixDiagOptions *>(builtin_options()) : nullptr;
  }
  const tflite::QuantizeOptions *builtin_options_as_QuantizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_QuantizeOptions ? static_cast<const tflite::QuantizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MatrixSetDiagOptions *builtin_options_as_MatrixSetDiagOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MatrixSetDiagOptions ? static_cast<const tflite::MatrixSetDiagOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HardSwishOptions *builtin_options_as_HardSwishOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HardSwishOptions ? static_cast<const tflite::HardSwishOptions *>(builtin_options()) : nullptr;
  }
  const tflite::IfOptions *builtin_options_as_IfOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_IfOptions ? static_cast<const tflite::IfOptions *>(builtin_options()) : nullptr;
  }
  const tflite::WhileOptions *builtin_options_as_WhileOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_WhileOptions ? static_cast<const tflite::WhileOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DepthToSpaceOptions *builtin_options_as_DepthToSpaceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DepthToSpaceOptions ? static_cast<const tflite::DepthToSpaceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::NonMaxSuppressionV4Options *builtin_options_as_NonMaxSuppressionV4Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_NonMaxSuppressionV4Options ? static_cast<const tflite::NonMaxSuppressionV4Options *>(builtin_options()) : nullptr;
  }
  const tflite::NonMaxSuppressionV5Options *builtin_options_as_NonMaxSuppressionV5Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_NonMaxSuppressionV5Options ? static_cast<const tflite::NonMaxSuppressionV5Options *>(builtin_options()) : nullptr;
  }
  const tflite::ScatterNdOptions *builtin_options_as_ScatterNdOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ScatterNdOptions ? static_cast<const tflite::ScatterNdOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SelectV2Options *builtin_options_as_SelectV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_SelectV2Options ? static_cast<const tflite::SelectV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::DensifyOptions *builtin_options_as_DensifyOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DensifyOptions ? static_cast<const tflite::DensifyOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SegmentSumOptions *builtin_options_as_SegmentSumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SegmentSumOptions ? static_cast<const tflite::SegmentSumOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BatchMatMulOptions *builtin_options_as_BatchMatMulOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BatchMatMulOptions ? static_cast<const tflite::BatchMatMulOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CumsumOptions *builtin_options_as_CumsumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CumsumOptions ? static_cast<const tflite::CumsumOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CallOnceOptions *builtin_options_as_CallOnceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CallOnceOptions ? static_cast<const tflite::CallOnceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BroadcastToOptions *builtin_options_as_BroadcastToOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BroadcastToOptions ? static_cast<const tflite::BroadcastToOptions *>(builtin_options()) : nullptr;
  }
  const tflite::Rfft2dOptions *builtin_options_as_Rfft2dOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Rfft2dOptions ? static_cast<const tflite::Rfft2dOptions *>(builtin_options()) : nullptr;
  }
  const tflite::Conv3DOptions *builtin_options_as_Conv3DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Conv3DOptions ? static_cast<const tflite::Conv3DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HashtableOptions *builtin_options_as_HashtableOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableOptions ? static_cast<const tflite::HashtableOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HashtableFindOptions *builtin_options_as_HashtableFindOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableFindOptions ? static_cast<const tflite::HashtableFindOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HashtableImportOptions *builtin_options_as_HashtableImportOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableImportOptions ? static_cast<const tflite::HashtableImportOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HashtableSizeOptions *builtin_options_as_HashtableSizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableSizeOptions ? static_cast<const tflite::HashtableSizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::VarHandleOptions *builtin_options_as_VarHandleOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_VarHandleOptions ? static_cast<const tflite::VarHandleOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReadVariableOptions *builtin_options_as_ReadVariableOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReadVariableOptions ? static_cast<const tflite::ReadVariableOptions *>(builtin_options()) : nullptr;
  }
  const tflite::AssignVariableOptions *builtin_options_as_AssignVariableOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AssignVariableOptions ? static_cast<const tflite::AssignVariableOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RandomOptions *builtin_options_as_RandomOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RandomOptions ? static_cast<const tflite::RandomOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BucketizeOptions *builtin_options_as_BucketizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BucketizeOptions ? static_cast<const tflite::BucketizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GeluOptions *builtin_options_as_GeluOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GeluOptions ? static_cast<const tflite::GeluOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DynamicUpdateSliceOptions *builtin_options_as_DynamicUpdateSliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DynamicUpdateSliceOptions ? static_cast<const tflite::DynamicUpdateSliceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnsortedSegmentProdOptions *builtin_options_as_UnsortedSegmentProdOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnsortedSegmentProdOptions ? static_cast<const tflite::UnsortedSegmentProdOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnsortedSegmentMaxOptions *builtin_options_as_UnsortedSegmentMaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnsortedSegmentMaxOptions ? static_cast<const tflite::UnsortedSegmentMaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnsortedSegmentMinOptions *builtin_options_as_UnsortedSegmentMinOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnsortedSegmentMinOptions ? static_cast<const tflite::UnsortedSegmentMinOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnsortedSegmentSumOptions *builtin_options_as_UnsortedSegmentSumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnsortedSegmentSumOptions ? static_cast<const tflite::UnsortedSegmentSumOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ATan2Options *builtin_options_as_ATan2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_ATan2Options ? static_cast<const tflite::ATan2Options *>(builtin_options()) : nullptr;
  }
  const tflite::SignOptions *builtin_options_as_SignOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SignOptions ? static_cast<const tflite::SignOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BitcastOptions *builtin_options_as_BitcastOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BitcastOptions ? static_cast<const tflite::BitcastOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BitwiseXorOptions *builtin_options_as_BitwiseXorOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BitwiseXorOptions ? static_cast<const tflite::BitwiseXorOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RightShiftOptions *builtin_options_as_RightShiftOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RightShiftOptions ? static_cast<const tflite::RightShiftOptions *>(builtin_options()) : nullptr;
  }
  const ::flatbuffers::Vector<uint8_t> *custom_options() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
  }
  tflite::CustomOptionsFormat custom_options_format() const {
    return static_cast<tflite::CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *intermediates() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INTERMEDIATES);
  }
  uint64_t large_custom_options_offset() const {
    return GetField<uint64_t>(VT_LARGE_CUSTOM_OPTIONS_OFFSET, 0);
  }
  uint64_t large_custom_options_size() const {
    return GetField<uint64_t>(VT_LARGE_CUSTOM_OPTIONS_SIZE, 0);
  }
  tflite::BuiltinOptions2 builtin_options_2_type() const {
    return static_cast<tflite::BuiltinOptions2>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_2_TYPE, 0));
  }
  const void *builtin_options_2() const {
    return GetPointer<const void *>(VT_BUILTIN_OPTIONS_2);
  }
  template<typename T> const T *builtin_options_2_as() const;
  const tflite::StablehloConcatenateOptions *builtin_options_2_as_StablehloConcatenateOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloConcatenateOptions ? static_cast<const tflite::StablehloConcatenateOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloBroadcastInDimOptions *builtin_options_2_as_StablehloBroadcastInDimOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloBroadcastInDimOptions ? static_cast<const tflite::StablehloBroadcastInDimOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloSliceOptions *builtin_options_2_as_StablehloSliceOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloSliceOptions ? static_cast<const tflite::StablehloSliceOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloConvolutionOptions *builtin_options_2_as_StablehloConvolutionOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloConvolutionOptions ? static_cast<const tflite::StablehloConvolutionOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloCustomCallOptions *builtin_options_2_as_StablehloCustomCallOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloCustomCallOptions ? static_cast<const tflite::StablehloCustomCallOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloReduceOptions *builtin_options_2_as_StablehloReduceOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloReduceOptions ? static_cast<const tflite::StablehloReduceOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloScatterOptions *builtin_options_2_as_StablehloScatterOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloScatterOptions ? static_cast<const tflite::StablehloScatterOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloCompareOptions *builtin_options_2_as_StablehloCompareOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloCompareOptions ? static_cast<const tflite::StablehloCompareOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloDynamicSliceOptions *builtin_options_2_as_StablehloDynamicSliceOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloDynamicSliceOptions ? static_cast<const tflite::StablehloDynamicSliceOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloPadOptions *builtin_options_2_as_StablehloPadOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloPadOptions ? static_cast<const tflite::StablehloPadOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloIotaOptions *builtin_options_2_as_StablehloIotaOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloIotaOptions ? static_cast<const tflite::StablehloIotaOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloDotGeneralOptions *builtin_options_2_as_StablehloDotGeneralOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloDotGeneralOptions ? static_cast<const tflite::StablehloDotGeneralOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloReduceWindowOptions *builtin_options_2_as_StablehloReduceWindowOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloReduceWindowOptions ? static_cast<const tflite::StablehloReduceWindowOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloSortOptions *builtin_options_2_as_StablehloSortOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloSortOptions ? static_cast<const tflite::StablehloSortOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloWhileOptions *builtin_options_2_as_StablehloWhileOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloWhileOptions ? static_cast<const tflite::StablehloWhileOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloGatherOptions *builtin_options_2_as_StablehloGatherOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloGatherOptions ? static_cast<const tflite::StablehloGatherOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloTransposeOptions *builtin_options_2_as_StablehloTransposeOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloTransposeOptions ? static_cast<const tflite::StablehloTransposeOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::DilateOptions *builtin_options_2_as_DilateOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_DilateOptions ? static_cast<const tflite::DilateOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StablehloRngBitGeneratorOptions *builtin_options_2_as_StablehloRngBitGeneratorOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StablehloRngBitGeneratorOptions ? static_cast<const tflite::StablehloRngBitGeneratorOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::ReduceWindowOptions *builtin_options_2_as_ReduceWindowOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_ReduceWindowOptions ? static_cast<const tflite::ReduceWindowOptions *>(builtin_options_2()) : nullptr;
  }
  const tflite::StableHLOCompositeOptions *builtin_options_2_as_StableHLOCompositeOptions() const {
    return builtin_options_2_type() == tflite::BuiltinOptions2_StableHLOCompositeOptions ? static_cast<const tflite::StableHLOCompositeOptions *>(builtin_options_2()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX, 4) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE, 1) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
           VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
           VerifyOffset(verifier, VT_CUSTOM_OPTIONS) &&
           verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT, 1) &&
           VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           VerifyOffset(verifier, VT_INTERMEDIATES) &&
           verifier.VerifyVector(intermediates()) &&
           VerifyField<uint64_t>(verifier, VT_LARGE_CUSTOM_OPTIONS_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_LARGE_CUSTOM_OPTIONS_SIZE, 8) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_2_TYPE, 1) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS_2) &&
           VerifyBuiltinOptions2(verifier, builtin_options_2(), builtin_options_2_type()) &&
           verifier.EndTable();
  }
  OperatorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Operator> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::Conv2DOptions *Operator::builtin_options_as<tflite::Conv2DOptions>() const {
  return builtin_options_as_Conv2DOptions();
}

template<> inline const tflite::DepthwiseConv2DOptions *Operator::builtin_options_as<tflite::DepthwiseConv2DOptions>() const {
  return builtin_options_as_DepthwiseConv2DOptions();
}

template<> inline const tflite::ConcatEmbeddingsOptions *Operator::builtin_options_as<tflite::ConcatEmbeddingsOptions>() const {
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template<> inline const tflite::LSHProjectionOptions *Operator::builtin_options_as<tflite::LSHProjectionOptions>() const {
  return builtin_options_as_LSHProjectionOptions();
}

template<> inline const tflite::Pool2DOptions *Operator::builtin_options_as<tflite::Pool2DOptions>() const {
  return builtin_options_as_Pool2DOptions();
}

template<> inline const tflite::SVDFOptions *Operator::builtin_options_as<tflite::SVDFOptions>() const {
  return builtin_options_as_SVDFOptions();
}

template<> inline const tflite::RNNOptions *Operator::builtin_options_as<tflite::RNNOptions>() const {
  return builtin_options_as_RNNOptions();
}

template<> inline const tflite::FullyConnectedOptions *Operator::builtin_options_as<tflite::FullyConnectedOptions>() const {
  return builtin_options_as_FullyConnectedOptions();
}

template<> inline const tflite::SoftmaxOptions *Operator::builtin_options_as<tflite::SoftmaxOptions>() const {
  return builtin_options_as_SoftmaxOptions();
}

template<> inline const tflite::ConcatenationOptions *Operator::builtin_options_as<tflite::ConcatenationOptions>() const {
  return builtin_options_as_ConcatenationOptions();
}

template<> inline const tflite::AddOptions *Operator::builtin_options_as<tflite::AddOptions>() const {
  return builtin_options_as_AddOptions();
}

template<> inline const tflite::L2NormOptions *Operator::builtin_options_as<tflite::L2NormOptions>() const {
  return builtin_options_as_L2NormOptions();
}

template<> inline const tflite::LocalResponseNormalizationOptions *Operator::builtin_options_as<tflite::LocalResponseNormalizationOptions>() const {
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template<> inline const tflite::LSTMOptions *Operator::builtin_options_as<tflite::LSTMOptions>() const {
  return builtin_options_as_LSTMOptions();
}

template<> inline const tflite::ResizeBilinearOptions *Operator::builtin_options_as<tflite::ResizeBilinearOptions>() const {
  return builtin_options_as_ResizeBilinearOptions();
}

template<> inline const tflite::CallOptions *Operator::builtin_options_as<tflite::CallOptions>() const {
  return builtin_options_as_CallOptions();
}

template<> inline const tflite::ReshapeOptions *Operator::builtin_options_as<tflite::ReshapeOptions>() const {
  return builtin_options_as_ReshapeOptions();
}

template<> inline const tflite::SkipGramOptions *Operator::builtin_options_as<tflite::SkipGramOptions>() const {
  return builtin_options_as_SkipGramOptions();
}

template<> inline const tflite::SpaceToDepthOptions *Operator::builtin_options_as<tflite::SpaceToDepthOptions>() const {
  return builtin_options_as_SpaceToDepthOptions();
}

template<> inline const tflite::EmbeddingLookupSparseOptions *Operator::builtin_options_as<tflite::EmbeddingLookupSparseOptions>() const {
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template<> inline const tflite::MulOptions *Operator::builtin_options_as<tflite::MulOptions>() const {
  return builtin_options_as_MulOptions();
}

template<> inline const tflite::PadOptions *Operator::builtin_options_as<tflite::PadOptions>() const {
  return builtin_options_as_PadOptions();
}

template<> inline const tflite::GatherOptions *Operator::builtin_options_as<tflite::GatherOptions>() const {
  return builtin_options_as_GatherOptions();
}

template<> inline const tflite::BatchToSpaceNDOptions *Operator::builtin_options_as<tflite::BatchToSpaceNDOptions>() const {
  return builtin_options_as_BatchToSpaceNDOptions();
}

template<> inline const tflite::SpaceToBatchNDOptions *Operator::builtin_options_as<tflite::SpaceToBatchNDOptions>() const {
  return builtin_options_as_SpaceToBatchNDOptions();
}

template<> inline const tflite::TransposeOptions *Operator::builtin_options_as<tflite::TransposeOptions>() const {
  return builtin_options_as_TransposeOptions();
}

template<> inline const tflite::ReducerOptions *Operator::builtin_options_as<tflite::ReducerOptions>() const {
  return builtin_options_as_ReducerOptions();
}

template<> inline const tflite::SubOptions *Operator::builtin_options_as<tflite::SubOptions>() const {
  return builtin_options_as_SubOptions();
}

template<> inline const tflite::DivOptions *Operator::builtin_options_as<tflite::DivOptions>() const {
  return builtin_options_as_DivOptions();
}

template<> inline const tflite::SqueezeOptions *Operator::builtin_options_as<tflite::SqueezeOptions>() const {
  return builtin_options_as_SqueezeOptions();
}

template<> inline const tflite::SequenceRNNOptions *Operator::builtin_options_as<tflite::SequenceRNNOptions>() const {
  return builtin_options_as_SequenceRNNOptions();
}

template<> inline const tflite::StridedSliceOptions *Operator::builtin_options_as<tflite::StridedSliceOptions>() const {
  return builtin_options_as_StridedSliceOptions();
}

template<> inline const tflite::ExpOptions *Operator::builtin_options_as<tflite::ExpOptions>() const {
  return builtin_options_as_ExpOptions();
}

template<> inline const tflite::TopKV2Options *Operator::builtin_options_as<tflite::TopKV2Options>() const {
  return builtin_options_as_TopKV2Options();
}

template<> inline const tflite::SplitOptions *Operator::builtin_options_as<tflite::SplitOptions>() const {
  return builtin_options_as_SplitOptions();
}

template<> inline const tflite::LogSoftmaxOptions *Operator::builtin_options_as<tflite::LogSoftmaxOptions>() const {
  return builtin_options_as_LogSoftmaxOptions();
}

template<> inline const tflite::CastOptions *Operator::builtin_options_as<tflite::CastOptions>() const {
  return builtin_options_as_CastOptions();
}

template<> inline const tflite::DequantizeOptions *Operator::builtin_options_as<tflite::DequantizeOptions>() const {
  return builtin_options_as_DequantizeOptions();
}

template<> inline const tflite::MaximumMinimumOptions *Operator::builtin_options_as<tflite::MaximumMinimumOptions>() const {
  return builtin_options_as_MaximumMinimumOptions();
}

template<> inline const tflite::ArgMaxOptions *Operator::builtin_options_as<tflite::ArgMaxOptions>() const {
  return builtin_options_as_ArgMaxOptions();
}

template<> inline const tflite::LessOptions *Operator::builtin_options_as<tflite::LessOptions>() const {
  return builtin_options_as_LessOptions();
}

template<> inline const tflite::NegOptions *Operator::builtin_options_as<tflite::NegOptions>() const {
  return builtin_options_as_NegOptions();
}

template<> inline const tflite::PadV2Options *Operator::builtin_options_as<tflite::PadV2Options>() const {
  return builtin_options_as_PadV2Options();
}

template<> inline const tflite::GreaterOptions *Operator::builtin_options_as<tflite::GreaterOptions>() const {
  return builtin_options_as_GreaterOptions();
}

template<> inline const tflite::GreaterEqualOptions *Operator::builtin_options_as<tflite::GreaterEqualOptions>() const {
  return builtin_options_as_GreaterEqualOptions();
}

template<> inline const tflite::LessEqualOptions *Operator::builtin_options_as<tflite::LessEqualOptions>() const {
  return builtin_options_as_LessEqualOptions();
}

template<> inline const tflite::SelectOptions *Operator::builtin_options_as<tflite::SelectOptions>() const {
  return builtin_options_as_SelectOptions();
}

template<> inline const tflite::SliceOptions *Operator::builtin_options_as<tflite::SliceOptions>() const {
  return builtin_options_as_SliceOptions();
}

template<> inline const tflite::TransposeConvOptions *Operator::builtin_options_as<tflite::TransposeConvOptions>() const {
  return builtin_options_as_TransposeConvOptions();
}

template<> inline const tflite::SparseToDenseOptions *Operator::builtin_options_as<tflite::SparseToDenseOptions>() const {
  return builtin_options_as_SparseToDenseOptions();
}

template<> inline const tflite::TileOptions *Operator::builtin_options_as<tflite::TileOptions>() const {
  return builtin_options_as_TileOptions();
}

template<> inline const tflite::ExpandDimsOptions *Operator::builtin_options_as<tflite::ExpandDimsOptions>() const {
  return builtin_options_as_ExpandDimsOptions();
}

template<> inline const tflite::EqualOptions *Operator::builtin_options_as<tflite::EqualOptions>() const {
  return builtin_options_as_EqualOptions();
}

template<> inline const tflite::NotEqualOptions *Operator::builtin_options_as<tflite::NotEqualOptions>() const {
  return builtin_options_as_NotEqualOptions();
}

template<> inline const tflite::ShapeOptions *Operator::builtin_options_as<tflite::ShapeOptions>() const {
  return builtin_options_as_ShapeOptions();
}

template<> inline const tflite::PowOptions *Operator::builtin_options_as<tflite::PowOptions>() const {
  return builtin_options_as_PowOptions();
}

template<> inline const tflite::ArgMinOptions *Operator::builtin_options_as<tflite::ArgMinOptions>() const {
  return builtin_options_as_ArgMinOptions();
}

template<> inline const tflite::FakeQuantOptions *Operator::builtin_options_as<tflite::FakeQuantOptions>() const {
  return builtin_options_as_FakeQuantOptions();
}

template<> inline const tflite::PackOptions *Operator::builtin_options_as<tflite::PackOptions>() const {
  return builtin_options_as_PackOptions();
}

template<> inline const tflite::LogicalOrOptions *Operator::builtin_options_as<tflite::LogicalOrOptions>() const {
  return builtin_options_as_LogicalOrOptions();
}

template<> inline const tflite::OneHotOptions *Operator::builtin_options_as<tflite::OneHotOptions>() const {
  return builtin_options_as_OneHotOptions();
}

template<> inline const tflite::LogicalAndOptions *Operator::builtin_options_as<tflite::LogicalAndOptions>() const {
  return builtin_options_as_LogicalAndOptions();
}

template<> inline const tflite::LogicalNotOptions *Operator::builtin_options_as<tflite::LogicalNotOptions>() const {
  return builtin_options_as_LogicalNotOptions();
}

template<> inline const tflite::UnpackOptions *Operator::builtin_options_as<tflite::UnpackOptions>() const {
  return builtin_options_as_UnpackOptions();
}

template<> inline const tflite::FloorDivOptions *Operator::builtin_options_as<tflite::FloorDivOptions>() const {
  return builtin_options_as_FloorDivOptions();
}

template<> inline const tflite::SquareOptions *Operator::builtin_options_as<tflite::SquareOptions>() const {
  return builtin_options_as_SquareOptions();
}

template<> inline const tflite::ZerosLikeOptions *Operator::builtin_options_as<tflite::ZerosLikeOptions>() const {
  return builtin_options_as_ZerosLikeOptions();
}

template<> inline const tflite::FillOptions *Operator::builtin_options_as<tflite::FillOptions>() const {
  return builtin_options_as_FillOptions();
}

template<> inline const tflite::BidirectionalSequenceLSTMOptions *Operator::builtin_options_as<tflite::BidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template<> inline const tflite::BidirectionalSequenceRNNOptions *Operator::builtin_options_as<tflite::BidirectionalSequenceRNNOptions>() const {
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template<> inline const tflite::UnidirectionalSequenceLSTMOptions *Operator::builtin_options_as<tflite::UnidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template<> inline const tflite::FloorModOptions *Operator::builtin_options_as<tflite::FloorModOptions>() const {
  return builtin_options_as_FloorModOptions();
}

template<> inline const tflite::RangeOptions *Operator::builtin_options_as<tflite::RangeOptions>() const {
  return builtin_options_as_RangeOptions();
}

template<> inline const tflite::ResizeNearestNeighborOptions *Operator::builtin_options_as<tflite::ResizeNearestNeighborOptions>() const {
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template<> inline const tflite::LeakyReluOptions *Operator::builtin_options_as<tflite::LeakyReluOptions>() const {
  return builtin_options_as_LeakyReluOptions();
}

template<> inline const tflite::SquaredDifferenceOptions *Operator::builtin_options_as<tflite::SquaredDifferenceOptions>() const {
  return builtin_options_as_SquaredDifferenceOptions();
}

template<> inline const tflite::MirrorPadOptions *Operator::builtin_options_as<tflite::MirrorPadOptions>() const {
  return builtin_options_as_MirrorPadOptions();
}

template<> inline const tflite::AbsOptions *Operator::builtin_options_as<tflite::AbsOptions>() const {
  return builtin_options_as_AbsOptions();
}

template<> inline const tflite::SplitVOptions *Operator::builtin_options_as<tflite::SplitVOptions>() const {
  return builtin_options_as_SplitVOptions();
}

template<> inline const tflite::UniqueOptions *Operator::builtin_options_as<tflite::UniqueOptions>() const {
  return builtin_options_as_UniqueOptions();
}

template<> inline const tflite::ReverseV2Options *Operator::builtin_options_as<tflite::ReverseV2Options>() const {
  return builtin_options_as_ReverseV2Options();
}

template<> inline const tflite::AddNOptions *Operator::builtin_options_as<tflite::AddNOptions>() const {
  return builtin_options_as_AddNOptions();
}

template<> inline const tflite::GatherNdOptions *Operator::builtin_options_as<tflite::GatherNdOptions>() const {
  return builtin_options_as_GatherNdOptions();
}

template<> inline const tflite::CosOptions *Operator::builtin_options_as<tflite::CosOptions>() const {
  return builtin_options_as_CosOptions();
}

template<> inline const tflite::WhereOptions *Operator::builtin_options_as<tflite::WhereOptions>() const {
  return builtin_options_as_WhereOptions();
}

template<> inline const tflite::RankOptions *Operator::builtin_options_as<tflite::RankOptions>() const {
  return builtin_options_as_RankOptions();
}

template<> inline const tflite::ReverseSequenceOptions *Operator::builtin_options_as<tflite::ReverseSequenceOptions>() const {
  return builtin_options_as_ReverseSequenceOptions();
}

template<> inline const tflite::MatrixDiagOptions *Operator::builtin_options_as<tflite::MatrixDiagOptions>() const {
  return builtin_options_as_MatrixDiagOptions();
}

template<> inline const tflite::QuantizeOptions *Operator::builtin_options_as<tflite::QuantizeOptions>() const {
  return builtin_options_as_QuantizeOptions();
}

template<> inline const tflite::MatrixSetDiagOptions *Operator::builtin_options_as<tflite::MatrixSetDiagOptions>() const {
  return builtin_options_as_MatrixSetDiagOptions();
}

template<> inline const tflite::HardSwishOptions *Operator::builtin_options_as<tflite::HardSwishOptions>() const {
  return builtin_options_as_HardSwishOptions();
}

template<> inline const tflite::IfOptions *Operator::builtin_options_as<tflite::IfOptions>() const {
  return builtin_options_as_IfOptions();
}

template<> inline const tflite::WhileOptions *Operator::builtin_options_as<tflite::WhileOptions>() const {
  return builtin_options_as_WhileOptions();
}

template<> inline const tflite::DepthToSpaceOptions *Operator::builtin_options_as<tflite::DepthToSpaceOptions>() const {
  return builtin_options_as_DepthToSpaceOptions();
}

template<> inline const tflite::NonMaxSuppressionV4Options *Operator::builtin_options_as<tflite::NonMaxSuppressionV4Options>() const {
  return builtin_options_as_NonMaxSuppressionV4Options();
}

template<> inline const tflite::NonMaxSuppressionV5Options *Operator::builtin_options_as<tflite::NonMaxSuppressionV5Options>() const {
  return builtin_options_as_NonMaxSuppressionV5Options();
}

template<> inline const tflite::ScatterNdOptions *Operator::builtin_options_as<tflite::ScatterNdOptions>() const {
  return builtin_options_as_ScatterNdOptions();
}

template<> inline const tflite::SelectV2Options *Operator::builtin_options_as<tflite::SelectV2Options>() const {
  return builtin_options_as_SelectV2Options();
}

template<> inline const tflite::DensifyOptions *Operator::builtin_options_as<tflite::DensifyOptions>() const {
  return builtin_options_as_DensifyOptions();
}

template<> inline const tflite::SegmentSumOptions *Operator::builtin_options_as<tflite::SegmentSumOptions>() const {
  return builtin_options_as_SegmentSumOptions();
}

template<> inline const tflite::BatchMatMulOptions *Operator::builtin_options_as<tflite::BatchMatMulOptions>() const {
  return builtin_options_as_BatchMatMulOptions();
}

template<> inline const tflite::CumsumOptions *Operator::builtin_options_as<tflite::CumsumOptions>() const {
  return builtin_options_as_CumsumOptions();
}

template<> inline const tflite::CallOnceOptions *Operator::builtin_options_as<tflite::CallOnceOptions>() const {
  return builtin_options_as_CallOnceOptions();
}

template<> inline const tflite::BroadcastToOptions *Operator::builtin_options_as<tflite::BroadcastToOptions>() const {
  return builtin_options_as_BroadcastToOptions();
}

template<> inline const tflite::Rfft2dOptions *Operator::builtin_options_as<tflite::Rfft2dOptions>() const {
  return builtin_options_as_Rfft2dOptions();
}

template<> inline const tflite::Conv3DOptions *Operator::builtin_options_as<tflite::Conv3DOptions>() const {
  return builtin_options_as_Conv3DOptions();
}

template<> inline const tflite::HashtableOptions *Operator::builtin_options_as<tflite::HashtableOptions>() const {
  return builtin_options_as_HashtableOptions();
}

template<> inline const tflite::HashtableFindOptions *Operator::builtin_options_as<tflite::HashtableFindOptions>() const {
  return builtin_options_as_HashtableFindOptions();
}

template<> inline const tflite::HashtableImportOptions *Operator::builtin_options_as<tflite::HashtableImportOptions>() const {
  return builtin_options_as_HashtableImportOptions();
}

template<> inline const tflite::HashtableSizeOptions *Operator::builtin_options_as<tflite::HashtableSizeOptions>() const {
  return builtin_options_as_HashtableSizeOptions();
}

template<> inline const tflite::VarHandleOptions *Operator::builtin_options_as<tflite::VarHandleOptions>() const {
  return builtin_options_as_VarHandleOptions();
}

template<> inline const tflite::ReadVariableOptions *Operator::builtin_options_as<tflite::ReadVariableOptions>() const {
  return builtin_options_as_ReadVariableOptions();
}

template<> inline const tflite::AssignVariableOptions *Operator::builtin_options_as<tflite::AssignVariableOptions>() const {
  return builtin_options_as_AssignVariableOptions();
}

template<> inline const tflite::RandomOptions *Operator::builtin_options_as<tflite::RandomOptions>() const {
  return builtin_options_as_RandomOptions();
}

template<> inline const tflite::BucketizeOptions *Operator::builtin_options_as<tflite::BucketizeOptions>() const {
  return builtin_options_as_BucketizeOptions();
}

template<> inline const tflite::GeluOptions *Operator::builtin_options_as<tflite::GeluOptions>() const {
  return builtin_options_as_GeluOptions();
}

template<> inline const tflite::DynamicUpdateSliceOptions *Operator::builtin_options_as<tflite::DynamicUpdateSliceOptions>() const {
  return builtin_options_as_DynamicUpdateSliceOptions();
}

template<> inline const tflite::UnsortedSegmentProdOptions *Operator::builtin_options_as<tflite::UnsortedSegmentProdOptions>() const {
  return builtin_options_as_UnsortedSegmentProdOptions();
}

template<> inline const tflite::UnsortedSegmentMaxOptions *Operator::builtin_options_as<tflite::UnsortedSegmentMaxOptions>() const {
  return builtin_options_as_UnsortedSegmentMaxOptions();
}

template<> inline const tflite::UnsortedSegmentMinOptions *Operator::builtin_options_as<tflite::UnsortedSegmentMinOptions>() const {
  return builtin_options_as_UnsortedSegmentMinOptions();
}

template<> inline const tflite::UnsortedSegmentSumOptions *Operator::builtin_options_as<tflite::UnsortedSegmentSumOptions>() const {
  return builtin_options_as_UnsortedSegmentSumOptions();
}

template<> inline const tflite::ATan2Options *Operator::builtin_options_as<tflite::ATan2Options>() const {
  return builtin_options_as_ATan2Options();
}

template<> inline const tflite::SignOptions *Operator::builtin_options_as<tflite::SignOptions>() const {
  return builtin_options_as_SignOptions();
}

template<> inline const tflite::BitcastOptions *Operator::builtin_options_as<tflite::BitcastOptions>() const {
  return builtin_options_as_BitcastOptions();
}

template<> inline const tflite::BitwiseXorOptions *Operator::builtin_options_as<tflite::BitwiseXorOptions>() const {
  return builtin_options_as_BitwiseXorOptions();
}

template<> inline const tflite::RightShiftOptions *Operator::builtin_options_as<tflite::RightShiftOptions>() const {
  return builtin_options_as_RightShiftOptions();
}

template<> inline const tflite::StablehloConcatenateOptions *Operator::builtin_options_2_as<tflite::StablehloConcatenateOptions>() const {
  return builtin_options_2_as_StablehloConcatenateOptions();
}

template<> inline const tflite::StablehloBroadcastInDimOptions *Operator::builtin_options_2_as<tflite::StablehloBroadcastInDimOptions>() const {
  return builtin_options_2_as_StablehloBroadcastInDimOptions();
}

template<> inline const tflite::StablehloSliceOptions *Operator::builtin_options_2_as<tflite::StablehloSliceOptions>() const {
  return builtin_options_2_as_StablehloSliceOptions();
}

template<> inline const tflite::StablehloConvolutionOptions *Operator::builtin_options_2_as<tflite::StablehloConvolutionOptions>() const {
  return builtin_options_2_as_StablehloConvolutionOptions();
}

template<> inline const tflite::StablehloCustomCallOptions *Operator::builtin_options_2_as<tflite::StablehloCustomCallOptions>() const {
  return builtin_options_2_as_StablehloCustomCallOptions();
}

template<> inline const tflite::StablehloReduceOptions *Operator::builtin_options_2_as<tflite::StablehloReduceOptions>() const {
  return builtin_options_2_as_StablehloReduceOptions();
}

template<> inline const tflite::StablehloScatterOptions *Operator::builtin_options_2_as<tflite::StablehloScatterOptions>() const {
  return builtin_options_2_as_StablehloScatterOptions();
}

template<> inline const tflite::StablehloCompareOptions *Operator::builtin_options_2_as<tflite::StablehloCompareOptions>() const {
  return builtin_options_2_as_StablehloCompareOptions();
}

template<> inline const tflite::StablehloDynamicSliceOptions *Operator::builtin_options_2_as<tflite::StablehloDynamicSliceOptions>() const {
  return builtin_options_2_as_StablehloDynamicSliceOptions();
}

template<> inline const tflite::StablehloPadOptions *Operator::builtin_options_2_as<tflite::StablehloPadOptions>() const {
  return builtin_options_2_as_StablehloPadOptions();
}

template<> inline const tflite::StablehloIotaOptions *Operator::builtin_options_2_as<tflite::StablehloIotaOptions>() const {
  return builtin_options_2_as_StablehloIotaOptions();
}

template<> inline const tflite::StablehloDotGeneralOptions *Operator::builtin_options_2_as<tflite::StablehloDotGeneralOptions>() const {
  return builtin_options_2_as_StablehloDotGeneralOptions();
}

template<> inline const tflite::StablehloReduceWindowOptions *Operator::builtin_options_2_as<tflite::StablehloReduceWindowOptions>() const {
  return builtin_options_2_as_StablehloReduceWindowOptions();
}

template<> inline const tflite::StablehloSortOptions *Operator::builtin_options_2_as<tflite::StablehloSortOptions>() const {
  return builtin_options_2_as_StablehloSortOptions();
}

template<> inline const tflite::StablehloWhileOptions *Operator::builtin_options_2_as<tflite::StablehloWhileOptions>() const {
  return builtin_options_2_as_StablehloWhileOptions();
}

template<> inline const tflite::StablehloGatherOptions *Operator::builtin_options_2_as<tflite::StablehloGatherOptions>() const {
  return builtin_options_2_as_StablehloGatherOptions();
}

template<> inline const tflite::StablehloTransposeOptions *Operator::builtin_options_2_as<tflite::StablehloTransposeOptions>() const {
  return builtin_options_2_as_StablehloTransposeOptions();
}

template<> inline const tflite::DilateOptions *Operator::builtin_options_2_as<tflite::DilateOptions>() const {
  return builtin_options_2_as_DilateOptions();
}

template<> inline const tflite::StablehloRngBitGeneratorOptions *Operator::builtin_options_2_as<tflite::StablehloRngBitGeneratorOptions>() const {
  return builtin_options_2_as_StablehloRngBitGeneratorOptions();
}

template<> inline const tflite::ReduceWindowOptions *Operator::builtin_options_2_as<tflite::ReduceWindowOptions>() const {
  return builtin_options_2_as_ReduceWindowOptions();
}

template<> inline const tflite::StableHLOCompositeOptions *Operator::builtin_options_2_as<tflite::StableHLOCompositeOptions>() const {
  return builtin_options_2_as_StableHLOCompositeOptions();
}

struct OperatorBuilder {
  typedef Operator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index) {
    fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_builtin_options_type(tflite::BuiltinOptions builtin_options_type) {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE, static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(::flatbuffers::Offset<void> builtin_options) {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  void add_custom_options(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_options) {
    fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  void add_custom_options_format(tflite::CustomOptionsFormat custom_options_format) {
    fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {
    fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  void add_intermediates(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> intermediates) {
    fbb_.AddOffset(Operator::VT_INTERMEDIATES, intermediates);
  }
  void add_large_custom_options_offset(uint64_t large_custom_options_offset) {
    fbb_.AddElement<uint64_t>(Operator::VT_LARGE_CUSTOM_OPTIONS_OFFSET, large_custom_options_offset, 0);
  }
  void add_large_custom_options_size(uint64_t large_custom_options_size) {
    fbb_.AddElement<uint64_t>(Operator::VT_LARGE_CUSTOM_OPTIONS_SIZE, large_custom_options_size, 0);
  }
  void add_builtin_options_2_type(tflite::BuiltinOptions2 builtin_options_2_type) {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_2_TYPE, static_cast<uint8_t>(builtin_options_2_type), 0);
  }
  void add_builtin_options_2(::flatbuffers::Offset<void> builtin_options_2) {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS_2, builtin_options_2);
  }
  explicit OperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Operator> CreateOperator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    ::flatbuffers::Offset<void> builtin_options = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_options = 0,
    tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> intermediates = 0,
    uint64_t large_custom_options_offset = 0,
    uint64_t large_custom_options_size = 0,
    tflite::BuiltinOptions2 builtin_options_2_type = tflite::BuiltinOptions2_NONE,
    ::flatbuffers::Offset<void> builtin_options_2 = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_large_custom_options_size(large_custom_options_size);
  builder_.add_large_custom_options_offset(large_custom_options_offset);
  builder_.add_builtin_options_2(builtin_options_2);
  builder_.add_intermediates(intermediates);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_builtin_options_2_type(builtin_options_2_type);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Operator> CreateOperatorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    ::flatbuffers::Offset<void> builtin_options = 0,
    const std::vector<uint8_t> *custom_options = nullptr,
    tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    const std::vector<uint8_t> *mutating_variable_inputs = nullptr,
    const std::vector<int32_t> *intermediates = nullptr,
    uint64_t large_custom_options_offset = 0,
    uint64_t large_custom_options_size = 0,
    tflite::BuiltinOptions2 builtin_options_2_type = tflite::BuiltinOptions2_NONE,
    ::flatbuffers::Offset<void> builtin_options_2 = 0) {
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto custom_options__ = custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
  auto mutating_variable_inputs__ = mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0;
  auto intermediates__ = intermediates ? _fbb.CreateVector<int32_t>(*intermediates) : 0;
  return tflite::CreateOperator(
      _fbb,
      opcode_index,
      inputs__,
      outputs__,
      builtin_options_type,
      builtin_options,
      custom_options__,
      custom_options_format,
      mutating_variable_inputs__,
      intermediates__,
      large_custom_options_offset,
      large_custom_options_size,
      builtin_options_2_type,
      builtin_options_2);
}

::flatbuffers::Offset<Operator> CreateOperator(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public ::flatbuffers::NativeTable {
  typedef SubGraph TableType;
  std::vector<std::unique_ptr<tflite::TensorT>> tensors{};
  std::vector<int32_t> inputs{};
  std::vector<int32_t> outputs{};
  std::vector<std::unique_ptr<tflite::OperatorT>> operators{};
  std::string name{};
  SubGraphT() = default;
  SubGraphT(const SubGraphT &o);
  SubGraphT(SubGraphT&&) FLATBUFFERS_NOEXCEPT = default;
  SubGraphT &operator=(SubGraphT o) FLATBUFFERS_NOEXCEPT;
};

struct SubGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubGraphT NativeTableType;
  typedef SubGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Tensor>> *tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Tensor>> *>(VT_TENSORS);
  }
  const ::flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Operator>> *operators() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Operator>> *>(VT_OPERATORS);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  SubGraphT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SubGraph> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder {
  typedef SubGraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Tensor>>> tensors) {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Operator>>> operators) {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  explicit SubGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubGraph> CreateSubGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Tensor>>> tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Operator>>> operators = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::Tensor>> *tensors = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::Operator>> *operators = nullptr,
    const char *name = nullptr) {
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Tensor>>(*tensors) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto operators__ = operators ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Operator>>(*operators) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateSubGraph(
      _fbb,
      tensors__,
      inputs__,
      outputs__,
      operators__,
      name__);
}

::flatbuffers::Offset<SubGraph> CreateSubGraph(::flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferT : public ::flatbuffers::NativeTable {
  typedef Buffer TableType;
  std::vector<uint8_t> data{};
  uint64_t offset = 0;
  uint64_t size = 0;
};

struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferT NativeTableType;
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_OFFSET = 6,
    VT_SIZE = 8
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
  BufferT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Buffer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder {
  typedef Buffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(Buffer::VT_OFFSET, offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Buffer::VT_SIZE, size, 0);
  }
  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Buffer> CreateBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    uint64_t offset = 0,
    uint64_t size = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Buffer> CreateBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr,
    uint64_t offset = 0,
    uint64_t size = 0) {
  if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16); }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return tflite::CreateBuffer(
      _fbb,
      data__,
      offset,
      size);
}

::flatbuffers::Offset<Buffer> CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public ::flatbuffers::NativeTable {
  typedef Metadata TableType;
  std::string name{};
  uint32_t buffer = 0;
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataT NativeTableType;
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BUFFER = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(VT_BUFFER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER, 4) &&
           verifier.EndTable();
  }
  MetadataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Metadata> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
  typedef Metadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Metadata::VT_NAME, name);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Metadata::VT_BUFFER, buffer, 0);
  }
  explicit MetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Metadata> CreateMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t buffer = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Metadata> CreateMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t buffer = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateMetadata(
      _fbb,
      name__,
      buffer);
}

::flatbuffers::Offset<Metadata> CreateMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorMapT : public ::flatbuffers::NativeTable {
  typedef TensorMap TableType;
  std::string name{};
  uint32_t tensor_index = 0;
};

struct TensorMap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorMapT NativeTableType;
  typedef TensorMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TENSOR_INDEX = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t tensor_index() const {
    return GetField<uint32_t>(VT_TENSOR_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_TENSOR_INDEX, 4) &&
           verifier.EndTable();
  }
  TensorMapT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorMapT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TensorMap> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorMapBuilder {
  typedef TensorMap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TensorMap::VT_NAME, name);
  }
  void add_tensor_index(uint32_t tensor_index) {
    fbb_.AddElement<uint32_t>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);
  }
  explicit TensorMapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorMap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorMap> CreateTensorMap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t tensor_index = 0) {
  TensorMapBuilder builder_(_fbb);
  builder_.add_tensor_index(tensor_index);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorMap> CreateTensorMapDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t tensor_index = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateTensorMap(
      _fbb,
      name__,
      tensor_index);
}

::flatbuffers::Offset<TensorMap> CreateTensorMap(::flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignatureDefT : public ::flatbuffers::NativeTable {
  typedef SignatureDef TableType;
  std::vector<std::unique_ptr<tflite::TensorMapT>> inputs{};
  std::vector<std::unique_ptr<tflite::TensorMapT>> outputs{};
  std::string signature_key{};
  uint32_t subgraph_index = 0;
  SignatureDefT() = default;
  SignatureDefT(const SignatureDefT &o);
  SignatureDefT(SignatureDefT&&) FLATBUFFERS_NOEXCEPT = default;
  SignatureDefT &operator=(SignatureDefT o) FLATBUFFERS_NOEXCEPT;
};

struct SignatureDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SignatureDefT NativeTableType;
  typedef SignatureDefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_OUTPUTS = 6,
    VT_SIGNATURE_KEY = 8,
    VT_SUBGRAPH_INDEX = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::String *signature_key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE_KEY);
  }
  uint32_t subgraph_index() const {
    return GetField<uint32_t>(VT_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_SIGNATURE_KEY) &&
           verifier.VerifyString(signature_key()) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  SignatureDefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignatureDefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SignatureDef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignatureDefBuilder {
  typedef SignatureDef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>>> inputs) {
    fbb_.AddOffset(SignatureDef::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>>> outputs) {
    fbb_.AddOffset(SignatureDef::VT_OUTPUTS, outputs);
  }
  void add_signature_key(::flatbuffers::Offset<::flatbuffers::String> signature_key) {
    fbb_.AddOffset(SignatureDef::VT_SIGNATURE_KEY, signature_key);
  }
  void add_subgraph_index(uint32_t subgraph_index) {
    fbb_.AddElement<uint32_t>(SignatureDef::VT_SUBGRAPH_INDEX, subgraph_index, 0);
  }
  explicit SignatureDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SignatureDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SignatureDef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SignatureDef> CreateSignatureDef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signature_key = 0,
    uint32_t subgraph_index = 0) {
  SignatureDefBuilder builder_(_fbb);
  builder_.add_subgraph_index(subgraph_index);
  builder_.add_signature_key(signature_key);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::TensorMap>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::TensorMap>> *outputs = nullptr,
    const char *signature_key = nullptr,
    uint32_t subgraph_index = 0) {
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMap>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMap>>(*outputs) : 0;
  auto signature_key__ = signature_key ? _fbb.CreateString(signature_key) : 0;
  return tflite::CreateSignatureDef(
      _fbb,
      inputs__,
      outputs__,
      signature_key__,
      subgraph_index);
}

::flatbuffers::Offset<SignatureDef> CreateSignatureDef(::flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public ::flatbuffers::NativeTable {
  typedef Model TableType;
  uint32_t version = 0;
  std::vector<std::unique_ptr<tflite::OperatorCodeT>> operator_codes{};
  std::vector<std::unique_ptr<tflite::SubGraphT>> subgraphs{};
  std::string description{};
  std::vector<std::unique_ptr<tflite::BufferT>> buffers{};
  std::vector<int32_t> metadata_buffer{};
  std::vector<std::unique_ptr<tflite::MetadataT>> metadata{};
  std::vector<std::unique_ptr<tflite::SignatureDefT>> signature_defs{};
  ModelT() = default;
  ModelT(const ModelT &o);
  ModelT(ModelT&&) FLATBUFFERS_NOEXCEPT = default;
  ModelT &operator=(ModelT o) FLATBUFFERS_NOEXCEPT;
};

struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelT NativeTableType;
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_OPERATOR_CODES = 6,
    VT_SUBGRAPHS = 8,
    VT_DESCRIPTION = 10,
    VT_BUFFERS = 12,
    VT_METADATA_BUFFER = 14,
    VT_METADATA = 16,
    VT_SIGNATURE_DEFS = 18
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::OperatorCode>> *operator_codes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::OperatorCode>> *>(VT_OPERATOR_CODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraph>> *subgraphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraph>> *>(VT_SUBGRAPHS);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Buffer>> *buffers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Buffer>> *>(VT_BUFFERS);
  }
  const ::flatbuffers::Vector<int32_t> *metadata_buffer() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Metadata>> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Metadata>> *>(VT_METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SignatureDef>> *signature_defs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SignatureDef>> *>(VT_SIGNATURE_DEFS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_OPERATOR_CODES) &&
           verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_METADATA_BUFFER) &&
           verifier.VerifyVector(metadata_buffer()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           VerifyOffset(verifier, VT_SIGNATURE_DEFS) &&
           verifier.VerifyVector(signature_defs()) &&
           verifier.VerifyVectorOfTables(signature_defs()) &&
           verifier.EndTable();
  }
  ModelT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Model> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
  typedef Model Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
  }
  void add_operator_codes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::OperatorCode>>> operator_codes) {
    fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
  }
  void add_subgraphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraph>>> subgraphs) {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Model::VT_DESCRIPTION, description);
  }
  void add_buffers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Buffer>>> buffers) {
    fbb_.AddOffset(Model::VT_BUFFERS, buffers);
  }
  void add_metadata_buffer(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> metadata_buffer) {
    fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Metadata>>> metadata) {
    fbb_.AddOffset(Model::VT_METADATA, metadata);
  }
  void add_signature_defs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SignatureDef>>> signature_defs) {
    fbb_.AddOffset(Model::VT_SIGNATURE_DEFS, signature_defs);
  }
  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Model> CreateModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::OperatorCode>>> operator_codes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraph>>> subgraphs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Buffer>>> buffers = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> metadata_buffer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Metadata>>> metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SignatureDef>>> signature_defs = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_signature_defs(signature_defs);
  builder_.add_metadata(metadata);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Model> CreateModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<::flatbuffers::Offset<tflite::OperatorCode>> *operator_codes = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::SubGraph>> *subgraphs = nullptr,
    const char *description = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::Buffer>> *buffers = nullptr,
    const std::vector<int32_t> *metadata_buffer = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::Metadata>> *metadata = nullptr,
    const std::vector<::flatbuffers::Offset<tflite::SignatureDef>> *signature_defs = nullptr) {
  auto operator_codes__ = operator_codes ? _fbb.CreateVector<::flatbuffers::Offset<tflite::OperatorCode>>(*operator_codes) : 0;
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SubGraph>>(*subgraphs) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Buffer>>(*buffers) : 0;
  auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Metadata>>(*metadata) : 0;
  auto signature_defs__ = signature_defs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SignatureDef>>(*signature_defs) : 0;
  return tflite::CreateModel(
      _fbb,
      version,
      operator_codes__,
      subgraphs__,
      description__,
      buffers__,
      metadata_buffer__,
      metadata__,
      signature_defs__);
}

::flatbuffers::Offset<Model> CreateModel(::flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CustomQuantizationT *CustomQuantization::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomQuantizationT>(new CustomQuantizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomQuantization::UnPackTo(CustomQuantizationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = custom(); if (_e) { _o->custom.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->custom.begin()); } }
}

inline ::flatbuffers::Offset<CustomQuantization> CustomQuantization::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomQuantization(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(::flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CustomQuantizationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->custom.size(), sizeof(uint8_t), 16);
  auto _custom = _o->custom.size() ? _fbb.CreateVector(_o->custom) : 0;
  return tflite::CreateCustomQuantization(
      _fbb,
      _custom);
}

inline QuantizationParametersT *QuantizationParameters::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuantizationParametersT>(new QuantizationParametersT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantizationParameters::UnPackTo(QuantizationParametersT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min(); if (_e) { _o->min.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min[_i] = _e->Get(_i); } } else { _o->min.resize(0); } }
  { auto _e = max(); if (_e) { _o->max.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max[_i] = _e->Get(_i); } } else { _o->max.resize(0); } }
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } else { _o->scale.resize(0); } }
  { auto _e = zero_point(); if (_e) { _o->zero_point.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->zero_point[_i] = _e->Get(_i); } } else { _o->zero_point.resize(0); } }
  { auto _e = details_type(); _o->details.type = _e; }
  { auto _e = details(); if (_e) _o->details.value = tflite::QuantizationDetailsUnion::UnPack(_e, details_type(), _resolver); }
  { auto _e = quantized_dimension(); _o->quantized_dimension = _e; }
}

inline ::flatbuffers::Offset<QuantizationParameters> QuantizationParameters::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizationParameters(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const QuantizationParametersT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min = _o->min.size() ? _fbb.CreateVector(_o->min) : 0;
  auto _max = _o->max.size() ? _fbb.CreateVector(_o->max) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _zero_point = _o->zero_point.size() ? _fbb.CreateVector(_o->zero_point) : 0;
  auto _details_type = _o->details.type;
  auto _details = _o->details.Pack(_fbb);
  auto _quantized_dimension = _o->quantized_dimension;
  return tflite::CreateQuantizationParameters(
      _fbb,
      _min,
      _max,
      _scale,
      _zero_point,
      _details_type,
      _details,
      _quantized_dimension);
}

inline Int32VectorT *Int32Vector::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int32VectorT>(new Int32VectorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int32Vector::UnPackTo(Int32VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<Int32Vector> Int32Vector::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt32Vector(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int32Vector> CreateInt32Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int32VectorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateInt32Vector(
      _fbb,
      _values);
}

inline Uint16VectorT *Uint16Vector::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Uint16VectorT>(new Uint16VectorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Uint16Vector::UnPackTo(Uint16VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<Uint16Vector> Uint16Vector::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUint16Vector(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Uint16Vector> CreateUint16Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Uint16VectorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint16_t), 4);
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateUint16Vector(
      _fbb,
      _values);
}

inline Uint8VectorT *Uint8Vector::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Uint8VectorT>(new Uint8VectorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Uint8Vector::UnPackTo(Uint8VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->values.begin()); } }
}

inline ::flatbuffers::Offset<Uint8Vector> Uint8Vector::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUint8Vector(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Uint8Vector> CreateUint8Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Uint8VectorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint8_t), 4);
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateUint8Vector(
      _fbb,
      _values);
}

inline DimensionMetadataT *DimensionMetadata::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DimensionMetadataT>(new DimensionMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DimensionMetadata::UnPackTo(DimensionMetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = dense_size(); _o->dense_size = _e; }
  { auto _e = array_segments_type(); _o->array_segments.type = _e; }
  { auto _e = array_segments(); if (_e) _o->array_segments.value = tflite::SparseIndexVectorUnion::UnPack(_e, array_segments_type(), _resolver); }
  { auto _e = array_indices_type(); _o->array_indices.type = _e; }
  { auto _e = array_indices(); if (_e) _o->array_indices.value = tflite::SparseIndexVectorUnion::UnPack(_e, array_indices_type(), _resolver); }
}

inline ::flatbuffers::Offset<DimensionMetadata> DimensionMetadata::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDimensionMetadata(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DimensionMetadataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _dense_size = _o->dense_size;
  auto _array_segments_type = _o->array_segments.type;
  auto _array_segments = _o->array_segments.Pack(_fbb);
  auto _array_indices_type = _o->array_indices.type;
  auto _array_indices = _o->array_indices.Pack(_fbb);
  return tflite::CreateDimensionMetadata(
      _fbb,
      _format,
      _dense_size,
      _array_segments_type,
      _array_segments,
      _array_indices_type,
      _array_indices);
}

inline SparsityParametersT::SparsityParametersT(const SparsityParametersT &o)
      : traversal_order(o.traversal_order),
        block_map(o.block_map) {
  dim_metadata.reserve(o.dim_metadata.size());
  for (const auto &dim_metadata_ : o.dim_metadata) { dim_metadata.emplace_back((dim_metadata_) ? new tflite::DimensionMetadataT(*dim_metadata_) : nullptr); }
}

inline SparsityParametersT &SparsityParametersT::operator=(SparsityParametersT o) FLATBUFFERS_NOEXCEPT {
  std::swap(traversal_order, o.traversal_order);
  std::swap(block_map, o.block_map);
  std::swap(dim_metadata, o.dim_metadata);
  return *this;
}

inline SparsityParametersT *SparsityParameters::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SparsityParametersT>(new SparsityParametersT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparsityParameters::UnPackTo(SparsityParametersT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = traversal_order(); if (_e) { _o->traversal_order.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->traversal_order[_i] = _e->Get(_i); } } else { _o->traversal_order.resize(0); } }
  { auto _e = block_map(); if (_e) { _o->block_map.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_map[_i] = _e->Get(_i); } } else { _o->block_map.resize(0); } }
  { auto _e = dim_metadata(); if (_e) { _o->dim_metadata.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->dim_metadata[_i]) { _e->Get(_i)->UnPackTo(_o->dim_metadata[_i].get(), _resolver); } else { _o->dim_metadata[_i] = std::unique_ptr<tflite::DimensionMetadataT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->dim_metadata.resize(0); } }
}

inline ::flatbuffers::Offset<SparsityParameters> SparsityParameters::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparsityParameters(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SparsityParametersT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _traversal_order = _o->traversal_order.size() ? _fbb.CreateVector(_o->traversal_order) : 0;
  auto _block_map = _o->block_map.size() ? _fbb.CreateVector(_o->block_map) : 0;
  auto _dim_metadata = _o->dim_metadata.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::DimensionMetadata>> (_o->dim_metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateDimensionMetadata(*__va->__fbb, __va->__o->dim_metadata[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::CreateSparsityParameters(
      _fbb,
      _traversal_order,
      _block_map,
      _dim_metadata);
}

inline VariantSubTypeT *VariantSubType::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VariantSubTypeT>(new VariantSubTypeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VariantSubType::UnPackTo(VariantSubTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } else { _o->shape.resize(0); } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = has_rank(); _o->has_rank = _e; }
}

inline ::flatbuffers::Offset<VariantSubType> VariantSubType::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVariantSubType(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VariantSubType> CreateVariantSubType(::flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VariantSubTypeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _type = _o->type;
  auto _has_rank = _o->has_rank;
  return tflite::CreateVariantSubType(
      _fbb,
      _shape,
      _type,
      _has_rank);
}

inline TensorT::TensorT(const TensorT &o)
      : shape(o.shape),
        type(o.type),
        buffer(o.buffer),
        name(o.name),
        quantization((o.quantization) ? new tflite::QuantizationParametersT(*o.quantization) : nullptr),
        is_variable(o.is_variable),
        sparsity((o.sparsity) ? new tflite::SparsityParametersT(*o.sparsity) : nullptr),
        shape_signature(o.shape_signature),
        has_rank(o.has_rank) {
  variant_tensors.reserve(o.variant_tensors.size());
  for (const auto &variant_tensors_ : o.variant_tensors) { variant_tensors.emplace_back((variant_tensors_) ? new tflite::VariantSubTypeT(*variant_tensors_) : nullptr); }
}

inline TensorT &TensorT::operator=(TensorT o) FLATBUFFERS_NOEXCEPT {
  std::swap(shape, o.shape);
  std::swap(type, o.type);
  std::swap(buffer, o.buffer);
  std::swap(name, o.name);
  std::swap(quantization, o.quantization);
  std::swap(is_variable, o.is_variable);
  std::swap(sparsity, o.sparsity);
  std::swap(shape_signature, o.shape_signature);
  std::swap(has_rank, o.has_rank);
  std::swap(variant_tensors, o.variant_tensors);
  return *this;
}

inline TensorT *Tensor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorT>(new TensorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tensor::UnPackTo(TensorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } else { _o->shape.resize(0); } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = buffer(); _o->buffer = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = quantization(); if (_e) { if(_o->quantization) { _e->UnPackTo(_o->quantization.get(), _resolver); } else { _o->quantization = std::unique_ptr<tflite::QuantizationParametersT>(_e->UnPack(_resolver)); } } else if (_o->quantization) { _o->quantization.reset(); } }
  { auto _e = is_variable(); _o->is_variable = _e; }
  { auto _e = sparsity(); if (_e) { if(_o->sparsity) { _e->UnPackTo(_o->sparsity.get(), _resolver); } else { _o->sparsity = std::unique_ptr<tflite::SparsityParametersT>(_e->UnPack(_resolver)); } } else if (_o->sparsity) { _o->sparsity.reset(); } }
  { auto _e = shape_signature(); if (_e) { _o->shape_signature.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape_signature[_i] = _e->Get(_i); } } else { _o->shape_signature.resize(0); } }
  { auto _e = has_rank(); _o->has_rank = _e; }
  { auto _e = variant_tensors(); if (_e) { _o->variant_tensors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->variant_tensors[_i]) { _e->Get(_i)->UnPackTo(_o->variant_tensors[_i].get(), _resolver); } else { _o->variant_tensors[_i] = std::unique_ptr<tflite::VariantSubTypeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->variant_tensors.resize(0); } }
}

inline ::flatbuffers::Offset<Tensor> Tensor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Tensor> CreateTensor(::flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _type = _o->type;
  auto _buffer = _o->buffer;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _quantization = _o->quantization ? CreateQuantizationParameters(_fbb, _o->quantization.get(), _rehasher) : 0;
  auto _is_variable = _o->is_variable;
  auto _sparsity = _o->sparsity ? CreateSparsityParameters(_fbb, _o->sparsity.get(), _rehasher) : 0;
  auto _shape_signature = _o->shape_signature.size() ? _fbb.CreateVector(_o->shape_signature) : 0;
  auto _has_rank = _o->has_rank;
  auto _variant_tensors = _o->variant_tensors.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::VariantSubType>> (_o->variant_tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateVariantSubType(*__va->__fbb, __va->__o->variant_tensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::CreateTensor(
      _fbb,
      _shape,
      _type,
      _buffer,
      _name,
      _quantization,
      _is_variable,
      _sparsity,
      _shape_signature,
      _has_rank,
      _variant_tensors);
}

inline StablehloGatherOptionsT *StablehloGatherOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloGatherOptionsT>(new StablehloGatherOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloGatherOptions::UnPackTo(StablehloGatherOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = offset_dims(); if (_e) { _o->offset_dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->offset_dims[_i] = _e->Get(_i); } } else { _o->offset_dims.resize(0); } }
  { auto _e = collapsed_slice_dims(); if (_e) { _o->collapsed_slice_dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->collapsed_slice_dims[_i] = _e->Get(_i); } } else { _o->collapsed_slice_dims.resize(0); } }
  { auto _e = start_index_map(); if (_e) { _o->start_index_map.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->start_index_map[_i] = _e->Get(_i); } } else { _o->start_index_map.resize(0); } }
  { auto _e = index_vector_dim(); _o->index_vector_dim = _e; }
  { auto _e = slice_sizes(); if (_e) { _o->slice_sizes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slice_sizes[_i] = _e->Get(_i); } } else { _o->slice_sizes.resize(0); } }
  { auto _e = indices_are_sorted(); _o->indices_are_sorted = _e; }
}

inline ::flatbuffers::Offset<StablehloGatherOptions> StablehloGatherOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloGatherOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloGatherOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloGatherOptions> CreateStablehloGatherOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloGatherOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloGatherOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _offset_dims = _o->offset_dims.size() ? _fbb.CreateVector(_o->offset_dims) : 0;
  auto _collapsed_slice_dims = _o->collapsed_slice_dims.size() ? _fbb.CreateVector(_o->collapsed_slice_dims) : 0;
  auto _start_index_map = _o->start_index_map.size() ? _fbb.CreateVector(_o->start_index_map) : 0;
  auto _index_vector_dim = _o->index_vector_dim;
  auto _slice_sizes = _o->slice_sizes.size() ? _fbb.CreateVector(_o->slice_sizes) : 0;
  auto _indices_are_sorted = _o->indices_are_sorted;
  return tflite::CreateStablehloGatherOptions(
      _fbb,
      _offset_dims,
      _collapsed_slice_dims,
      _start_index_map,
      _index_vector_dim,
      _slice_sizes,
      _indices_are_sorted);
}

inline StablehloTransposeOptionsT *StablehloTransposeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloTransposeOptionsT>(new StablehloTransposeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloTransposeOptions::UnPackTo(StablehloTransposeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = permutation(); if (_e) { _o->permutation.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->permutation[_i] = _e->Get(_i); } } else { _o->permutation.resize(0); } }
}

inline ::flatbuffers::Offset<StablehloTransposeOptions> StablehloTransposeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloTransposeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloTransposeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloTransposeOptions> CreateStablehloTransposeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloTransposeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloTransposeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _permutation = _o->permutation.size() ? _fbb.CreateVector(_o->permutation) : 0;
  return tflite::CreateStablehloTransposeOptions(
      _fbb,
      _permutation);
}

inline StablehloDotGeneralOptionsT *StablehloDotGeneralOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloDotGeneralOptionsT>(new StablehloDotGeneralOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloDotGeneralOptions::UnPackTo(StablehloDotGeneralOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lhs_batching_dimensions(); if (_e) { _o->lhs_batching_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs_batching_dimensions[_i] = _e->Get(_i); } } else { _o->lhs_batching_dimensions.resize(0); } }
  { auto _e = rhs_batching_dimensions(); if (_e) { _o->rhs_batching_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rhs_batching_dimensions[_i] = _e->Get(_i); } } else { _o->rhs_batching_dimensions.resize(0); } }
  { auto _e = lhs_contracting_dimensions(); if (_e) { _o->lhs_contracting_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs_contracting_dimensions[_i] = _e->Get(_i); } } else { _o->lhs_contracting_dimensions.resize(0); } }
  { auto _e = rhs_contracting_dimensions(); if (_e) { _o->rhs_contracting_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rhs_contracting_dimensions[_i] = _e->Get(_i); } } else { _o->rhs_contracting_dimensions.resize(0); } }
  { auto _e = precision_config(); if (_e) { _o->precision_config.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->precision_config[_i] = static_cast<tflite::StablehloPrecisionConfig>(_e->Get(_i)); } } else { _o->precision_config.resize(0); } }
}

inline ::flatbuffers::Offset<StablehloDotGeneralOptions> StablehloDotGeneralOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloDotGeneralOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloDotGeneralOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloDotGeneralOptions> CreateStablehloDotGeneralOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloDotGeneralOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloDotGeneralOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lhs_batching_dimensions = _o->lhs_batching_dimensions.size() ? _fbb.CreateVector(_o->lhs_batching_dimensions) : 0;
  auto _rhs_batching_dimensions = _o->rhs_batching_dimensions.size() ? _fbb.CreateVector(_o->rhs_batching_dimensions) : 0;
  auto _lhs_contracting_dimensions = _o->lhs_contracting_dimensions.size() ? _fbb.CreateVector(_o->lhs_contracting_dimensions) : 0;
  auto _rhs_contracting_dimensions = _o->rhs_contracting_dimensions.size() ? _fbb.CreateVector(_o->rhs_contracting_dimensions) : 0;
  auto _precision_config = _o->precision_config.size() ? _fbb.CreateVectorScalarCast<uint32_t>(::flatbuffers::data(_o->precision_config), _o->precision_config.size()) : 0;
  return tflite::CreateStablehloDotGeneralOptions(
      _fbb,
      _lhs_batching_dimensions,
      _rhs_batching_dimensions,
      _lhs_contracting_dimensions,
      _rhs_contracting_dimensions,
      _precision_config);
}

inline StablehloReduceWindowOptionsT *StablehloReduceWindowOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloReduceWindowOptionsT>(new StablehloReduceWindowOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloReduceWindowOptions::UnPackTo(StablehloReduceWindowOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = window_dimensions(); if (_e) { _o->window_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_dimensions[_i] = _e->Get(_i); } } else { _o->window_dimensions.resize(0); } }
  { auto _e = window_strides(); if (_e) { _o->window_strides.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_strides[_i] = _e->Get(_i); } } else { _o->window_strides.resize(0); } }
  { auto _e = base_dilations(); if (_e) { _o->base_dilations.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->base_dilations[_i] = _e->Get(_i); } } else { _o->base_dilations.resize(0); } }
  { auto _e = window_dilations(); if (_e) { _o->window_dilations.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_dilations[_i] = _e->Get(_i); } } else { _o->window_dilations.resize(0); } }
  { auto _e = padding(); if (_e) { _o->padding.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->padding[_i] = _e->Get(_i); } } else { _o->padding.resize(0); } }
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; }
}

inline ::flatbuffers::Offset<StablehloReduceWindowOptions> StablehloReduceWindowOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceWindowOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloReduceWindowOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloReduceWindowOptions> CreateStablehloReduceWindowOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceWindowOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloReduceWindowOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _window_dimensions = _o->window_dimensions.size() ? _fbb.CreateVector(_o->window_dimensions) : 0;
  auto _window_strides = _o->window_strides.size() ? _fbb.CreateVector(_o->window_strides) : 0;
  auto _base_dilations = _o->base_dilations.size() ? _fbb.CreateVector(_o->base_dilations) : 0;
  auto _window_dilations = _o->window_dilations.size() ? _fbb.CreateVector(_o->window_dilations) : 0;
  auto _padding = _o->padding.size() ? _fbb.CreateVector(_o->padding) : 0;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateStablehloReduceWindowOptions(
      _fbb,
      _window_dimensions,
      _window_strides,
      _base_dilations,
      _window_dilations,
      _padding,
      _body_subgraph_index);
}

inline StablehloWhileOptionsT *StablehloWhileOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloWhileOptionsT>(new StablehloWhileOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloWhileOptions::UnPackTo(StablehloWhileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cond_subgraph_index(); _o->cond_subgraph_index = _e; }
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; }
}

inline ::flatbuffers::Offset<StablehloWhileOptions> StablehloWhileOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloWhileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloWhileOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloWhileOptions> CreateStablehloWhileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloWhileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloWhileOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cond_subgraph_index = _o->cond_subgraph_index;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateStablehloWhileOptions(
      _fbb,
      _cond_subgraph_index,
      _body_subgraph_index);
}

inline StablehloSortOptionsT *StablehloSortOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloSortOptionsT>(new StablehloSortOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloSortOptions::UnPackTo(StablehloSortOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dimension(); _o->dimension = _e; }
  { auto _e = is_stable(); _o->is_stable = _e; }
  { auto _e = comparator_subgraph_index(); _o->comparator_subgraph_index = _e; }
}

inline ::flatbuffers::Offset<StablehloSortOptions> StablehloSortOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloSortOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloSortOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloSortOptions> CreateStablehloSortOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloSortOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloSortOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dimension = _o->dimension;
  auto _is_stable = _o->is_stable;
  auto _comparator_subgraph_index = _o->comparator_subgraph_index;
  return tflite::CreateStablehloSortOptions(
      _fbb,
      _dimension,
      _is_stable,
      _comparator_subgraph_index);
}

inline StablehloConcatenateOptionsT *StablehloConcatenateOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloConcatenateOptionsT>(new StablehloConcatenateOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloConcatenateOptions::UnPackTo(StablehloConcatenateOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dimension(); _o->dimension = _e; }
}

inline ::flatbuffers::Offset<StablehloConcatenateOptions> StablehloConcatenateOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloConcatenateOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloConcatenateOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloConcatenateOptions> CreateStablehloConcatenateOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloConcatenateOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloConcatenateOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dimension = _o->dimension;
  return tflite::CreateStablehloConcatenateOptions(
      _fbb,
      _dimension);
}

inline StablehloBroadcastInDimOptionsT *StablehloBroadcastInDimOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloBroadcastInDimOptionsT>(new StablehloBroadcastInDimOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloBroadcastInDimOptions::UnPackTo(StablehloBroadcastInDimOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = broadcast_dimensions(); if (_e) { _o->broadcast_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->broadcast_dimensions[_i] = _e->Get(_i); } } else { _o->broadcast_dimensions.resize(0); } }
}

inline ::flatbuffers::Offset<StablehloBroadcastInDimOptions> StablehloBroadcastInDimOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloBroadcastInDimOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloBroadcastInDimOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloBroadcastInDimOptions> CreateStablehloBroadcastInDimOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloBroadcastInDimOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloBroadcastInDimOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _broadcast_dimensions = _o->broadcast_dimensions.size() ? _fbb.CreateVector(_o->broadcast_dimensions) : 0;
  return tflite::CreateStablehloBroadcastInDimOptions(
      _fbb,
      _broadcast_dimensions);
}

inline StablehloCompareOptionsT *StablehloCompareOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloCompareOptionsT>(new StablehloCompareOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloCompareOptions::UnPackTo(StablehloCompareOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = comparison_direction(); _o->comparison_direction = _e; }
  { auto _e = compare_type(); _o->compare_type = _e; }
}

inline ::flatbuffers::Offset<StablehloCompareOptions> StablehloCompareOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloCompareOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloCompareOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloCompareOptions> CreateStablehloCompareOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloCompareOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloCompareOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _comparison_direction = _o->comparison_direction;
  auto _compare_type = _o->compare_type;
  return tflite::CreateStablehloCompareOptions(
      _fbb,
      _comparison_direction,
      _compare_type);
}

inline StablehloDynamicSliceOptionsT *StablehloDynamicSliceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloDynamicSliceOptionsT>(new StablehloDynamicSliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloDynamicSliceOptions::UnPackTo(StablehloDynamicSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slice_sizes(); if (_e) { _o->slice_sizes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slice_sizes[_i] = _e->Get(_i); } } else { _o->slice_sizes.resize(0); } }
}

inline ::flatbuffers::Offset<StablehloDynamicSliceOptions> StablehloDynamicSliceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloDynamicSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloDynamicSliceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloDynamicSliceOptions> CreateStablehloDynamicSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloDynamicSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloDynamicSliceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slice_sizes = _o->slice_sizes.size() ? _fbb.CreateVector(_o->slice_sizes) : 0;
  return tflite::CreateStablehloDynamicSliceOptions(
      _fbb,
      _slice_sizes);
}

inline StablehloPadOptionsT *StablehloPadOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloPadOptionsT>(new StablehloPadOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloPadOptions::UnPackTo(StablehloPadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = edge_padding_low(); if (_e) { _o->edge_padding_low.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->edge_padding_low[_i] = _e->Get(_i); } } else { _o->edge_padding_low.resize(0); } }
  { auto _e = edge_padding_high(); if (_e) { _o->edge_padding_high.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->edge_padding_high[_i] = _e->Get(_i); } } else { _o->edge_padding_high.resize(0); } }
  { auto _e = interior_padding(); if (_e) { _o->interior_padding.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->interior_padding[_i] = _e->Get(_i); } } else { _o->interior_padding.resize(0); } }
}

inline ::flatbuffers::Offset<StablehloPadOptions> StablehloPadOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloPadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloPadOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloPadOptions> CreateStablehloPadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloPadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloPadOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _edge_padding_low = _o->edge_padding_low.size() ? _fbb.CreateVector(_o->edge_padding_low) : 0;
  auto _edge_padding_high = _o->edge_padding_high.size() ? _fbb.CreateVector(_o->edge_padding_high) : 0;
  auto _interior_padding = _o->interior_padding.size() ? _fbb.CreateVector(_o->interior_padding) : 0;
  return tflite::CreateStablehloPadOptions(
      _fbb,
      _edge_padding_low,
      _edge_padding_high,
      _interior_padding);
}

inline StablehloIotaOptionsT *StablehloIotaOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloIotaOptionsT>(new StablehloIotaOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloIotaOptions::UnPackTo(StablehloIotaOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = iota_dimension(); _o->iota_dimension = _e; }
}

inline ::flatbuffers::Offset<StablehloIotaOptions> StablehloIotaOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloIotaOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloIotaOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloIotaOptions> CreateStablehloIotaOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloIotaOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloIotaOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _iota_dimension = _o->iota_dimension;
  return tflite::CreateStablehloIotaOptions(
      _fbb,
      _iota_dimension);
}

inline StablehloCustomCallOptionsT *StablehloCustomCallOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloCustomCallOptionsT>(new StablehloCustomCallOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloCustomCallOptions::UnPackTo(StablehloCustomCallOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = call_target_name(); if (_e) _o->call_target_name = _e->str(); }
  { auto _e = has_side_effect(); _o->has_side_effect = _e; }
  { auto _e = backend_config(); if (_e) _o->backend_config = _e->str(); }
  { auto _e = api_version(); _o->api_version = _e; }
  { auto _e = called_computations(); if (_e) { _o->called_computations.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->called_computations[_i] = _e->Get(_i); } } else { _o->called_computations.resize(0); } }
  { auto _e = custom_attributes(); if (_e) { _o->custom_attributes.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->custom_attributes.begin()); } }
}

inline ::flatbuffers::Offset<StablehloCustomCallOptions> StablehloCustomCallOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloCustomCallOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloCustomCallOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloCustomCallOptions> CreateStablehloCustomCallOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloCustomCallOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloCustomCallOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _call_target_name = _o->call_target_name.empty() ? 0 : _fbb.CreateString(_o->call_target_name);
  auto _has_side_effect = _o->has_side_effect;
  auto _backend_config = _o->backend_config.empty() ? 0 : _fbb.CreateString(_o->backend_config);
  auto _api_version = _o->api_version;
  auto _called_computations = _o->called_computations.size() ? _fbb.CreateVector(_o->called_computations) : 0;
  auto _custom_attributes = _o->custom_attributes.size() ? _fbb.CreateVector(_o->custom_attributes) : 0;
  return tflite::CreateStablehloCustomCallOptions(
      _fbb,
      _call_target_name,
      _has_side_effect,
      _backend_config,
      _api_version,
      _called_computations,
      _custom_attributes);
}

inline StablehloReduceOptionsT *StablehloReduceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloReduceOptionsT>(new StablehloReduceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloReduceOptions::UnPackTo(StablehloReduceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dimensions(); if (_e) { _o->dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dimensions[_i] = _e->Get(_i); } } else { _o->dimensions.resize(0); } }
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; }
}

inline ::flatbuffers::Offset<StablehloReduceOptions> StablehloReduceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloReduceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloReduceOptions> CreateStablehloReduceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloReduceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloReduceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dimensions = _o->dimensions.size() ? _fbb.CreateVector(_o->dimensions) : 0;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateStablehloReduceOptions(
      _fbb,
      _dimensions,
      _body_subgraph_index);
}

inline StablehloSliceOptionsT *StablehloSliceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloSliceOptionsT>(new StablehloSliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloSliceOptions::UnPackTo(StablehloSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_indices(); if (_e) { _o->start_indices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->start_indices[_i] = _e->Get(_i); } } else { _o->start_indices.resize(0); } }
  { auto _e = limit_indices(); if (_e) { _o->limit_indices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->limit_indices[_i] = _e->Get(_i); } } else { _o->limit_indices.resize(0); } }
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } else { _o->strides.resize(0); } }
}

inline ::flatbuffers::Offset<StablehloSliceOptions> StablehloSliceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloSliceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloSliceOptions> CreateStablehloSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloSliceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_indices = _o->start_indices.size() ? _fbb.CreateVector(_o->start_indices) : 0;
  auto _limit_indices = _o->limit_indices.size() ? _fbb.CreateVector(_o->limit_indices) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  return tflite::CreateStablehloSliceOptions(
      _fbb,
      _start_indices,
      _limit_indices,
      _strides);
}

inline StablehloConvolutionOptionsT *StablehloConvolutionOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloConvolutionOptionsT>(new StablehloConvolutionOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloConvolutionOptions::UnPackTo(StablehloConvolutionOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = window_strides(); if (_e) { _o->window_strides.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_strides[_i] = _e->Get(_i); } } else { _o->window_strides.resize(0); } }
  { auto _e = padding(); if (_e) { _o->padding.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->padding[_i] = _e->Get(_i); } } else { _o->padding.resize(0); } }
  { auto _e = lhs_dilation(); if (_e) { _o->lhs_dilation.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lhs_dilation[_i] = _e->Get(_i); } } else { _o->lhs_dilation.resize(0); } }
  { auto _e = rhs_dilation(); if (_e) { _o->rhs_dilation.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rhs_dilation[_i] = _e->Get(_i); } } else { _o->rhs_dilation.resize(0); } }
  { auto _e = window_reversal(); if (_e) { _o->window_reversal.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->window_reversal[_i] = _e->Get(_i) != 0; } } else { _o->window_reversal.resize(0); } }
  { auto _e = input_batch_dimension(); _o->input_batch_dimension = _e; }
  { auto _e = input_feature_dimension(); _o->input_feature_dimension = _e; }
  { auto _e = input_spatial_dimensions(); if (_e) { _o->input_spatial_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_spatial_dimensions[_i] = _e->Get(_i); } } else { _o->input_spatial_dimensions.resize(0); } }
  { auto _e = kernel_input_feature_dimension(); _o->kernel_input_feature_dimension = _e; }
  { auto _e = kernel_output_feature_dimension(); _o->kernel_output_feature_dimension = _e; }
  { auto _e = kernel_spatial_dimensions(); if (_e) { _o->kernel_spatial_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_spatial_dimensions[_i] = _e->Get(_i); } } else { _o->kernel_spatial_dimensions.resize(0); } }
  { auto _e = output_batch_dimension(); _o->output_batch_dimension = _e; }
  { auto _e = output_feature_dimension(); _o->output_feature_dimension = _e; }
  { auto _e = output_spatial_dimensions(); if (_e) { _o->output_spatial_dimensions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_spatial_dimensions[_i] = _e->Get(_i); } } else { _o->output_spatial_dimensions.resize(0); } }
  { auto _e = feature_group_count(); _o->feature_group_count = _e; }
  { auto _e = batch_group_count(); _o->batch_group_count = _e; }
  { auto _e = precision_config(); if (_e) { _o->precision_config.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->precision_config[_i] = static_cast<tflite::StablehloPrecisionConfig>(_e->Get(_i)); } } else { _o->precision_config.resize(0); } }
}

inline ::flatbuffers::Offset<StablehloConvolutionOptions> StablehloConvolutionOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloConvolutionOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloConvolutionOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloConvolutionOptions> CreateStablehloConvolutionOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloConvolutionOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloConvolutionOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _window_strides = _o->window_strides.size() ? _fbb.CreateVector(_o->window_strides) : 0;
  auto _padding = _o->padding.size() ? _fbb.CreateVector(_o->padding) : 0;
  auto _lhs_dilation = _o->lhs_dilation.size() ? _fbb.CreateVector(_o->lhs_dilation) : 0;
  auto _rhs_dilation = _o->rhs_dilation.size() ? _fbb.CreateVector(_o->rhs_dilation) : 0;
  auto _window_reversal = _o->window_reversal.size() ? _fbb.CreateVector(_o->window_reversal) : 0;
  auto _input_batch_dimension = _o->input_batch_dimension;
  auto _input_feature_dimension = _o->input_feature_dimension;
  auto _input_spatial_dimensions = _o->input_spatial_dimensions.size() ? _fbb.CreateVector(_o->input_spatial_dimensions) : 0;
  auto _kernel_input_feature_dimension = _o->kernel_input_feature_dimension;
  auto _kernel_output_feature_dimension = _o->kernel_output_feature_dimension;
  auto _kernel_spatial_dimensions = _o->kernel_spatial_dimensions.size() ? _fbb.CreateVector(_o->kernel_spatial_dimensions) : 0;
  auto _output_batch_dimension = _o->output_batch_dimension;
  auto _output_feature_dimension = _o->output_feature_dimension;
  auto _output_spatial_dimensions = _o->output_spatial_dimensions.size() ? _fbb.CreateVector(_o->output_spatial_dimensions) : 0;
  auto _feature_group_count = _o->feature_group_count;
  auto _batch_group_count = _o->batch_group_count;
  auto _precision_config = _o->precision_config.size() ? _fbb.CreateVectorScalarCast<uint32_t>(::flatbuffers::data(_o->precision_config), _o->precision_config.size()) : 0;
  return tflite::CreateStablehloConvolutionOptions(
      _fbb,
      _window_strides,
      _padding,
      _lhs_dilation,
      _rhs_dilation,
      _window_reversal,
      _input_batch_dimension,
      _input_feature_dimension,
      _input_spatial_dimensions,
      _kernel_input_feature_dimension,
      _kernel_output_feature_dimension,
      _kernel_spatial_dimensions,
      _output_batch_dimension,
      _output_feature_dimension,
      _output_spatial_dimensions,
      _feature_group_count,
      _batch_group_count,
      _precision_config);
}

inline StablehloScatterOptionsT *StablehloScatterOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloScatterOptionsT>(new StablehloScatterOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloScatterOptions::UnPackTo(StablehloScatterOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = indices_are_sorted(); _o->indices_are_sorted = _e; }
  { auto _e = update_window_dims(); if (_e) { _o->update_window_dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->update_window_dims[_i] = _e->Get(_i); } } else { _o->update_window_dims.resize(0); } }
  { auto _e = inserted_window_dims(); if (_e) { _o->inserted_window_dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inserted_window_dims[_i] = _e->Get(_i); } } else { _o->inserted_window_dims.resize(0); } }
  { auto _e = scatter_dims_to_operand_dims(); if (_e) { _o->scatter_dims_to_operand_dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scatter_dims_to_operand_dims[_i] = _e->Get(_i); } } else { _o->scatter_dims_to_operand_dims.resize(0); } }
  { auto _e = index_vector_dim(); _o->index_vector_dim = _e; }
  { auto _e = unique_indices(); _o->unique_indices = _e; }
  { auto _e = update_computation_subgraph_index(); _o->update_computation_subgraph_index = _e; }
}

inline ::flatbuffers::Offset<StablehloScatterOptions> StablehloScatterOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloScatterOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloScatterOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloScatterOptions> CreateStablehloScatterOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloScatterOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloScatterOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _indices_are_sorted = _o->indices_are_sorted;
  auto _update_window_dims = _o->update_window_dims.size() ? _fbb.CreateVector(_o->update_window_dims) : 0;
  auto _inserted_window_dims = _o->inserted_window_dims.size() ? _fbb.CreateVector(_o->inserted_window_dims) : 0;
  auto _scatter_dims_to_operand_dims = _o->scatter_dims_to_operand_dims.size() ? _fbb.CreateVector(_o->scatter_dims_to_operand_dims) : 0;
  auto _index_vector_dim = _o->index_vector_dim;
  auto _unique_indices = _o->unique_indices;
  auto _update_computation_subgraph_index = _o->update_computation_subgraph_index;
  return tflite::CreateStablehloScatterOptions(
      _fbb,
      _indices_are_sorted,
      _update_window_dims,
      _inserted_window_dims,
      _scatter_dims_to_operand_dims,
      _index_vector_dim,
      _unique_indices,
      _update_computation_subgraph_index);
}

inline StablehloRngBitGeneratorOptionsT *StablehloRngBitGeneratorOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StablehloRngBitGeneratorOptionsT>(new StablehloRngBitGeneratorOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StablehloRngBitGeneratorOptions::UnPackTo(StablehloRngBitGeneratorOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = algorithm(); _o->algorithm = _e; }
}

inline ::flatbuffers::Offset<StablehloRngBitGeneratorOptions> StablehloRngBitGeneratorOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloRngBitGeneratorOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStablehloRngBitGeneratorOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StablehloRngBitGeneratorOptions> CreateStablehloRngBitGeneratorOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StablehloRngBitGeneratorOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StablehloRngBitGeneratorOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _algorithm = _o->algorithm;
  return tflite::CreateStablehloRngBitGeneratorOptions(
      _fbb,
      _algorithm);
}

inline Conv2DOptionsT *Conv2DOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DOptionsT>(new Conv2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; }
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }
  { auto _e = quantized_bias_type(); _o->quantized_bias_type = _e; }
}

inline ::flatbuffers::Offset<Conv2DOptions> Conv2DOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Conv2DOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  auto _quantized_bias_type = _o->quantized_bias_type;
  return tflite::CreateConv2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _dilation_w_factor,
      _dilation_h_factor,
      _quantized_bias_type);
}

inline Conv3DOptionsT *Conv3DOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv3DOptionsT>(new Conv3DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv3DOptions::UnPackTo(Conv3DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_d(); _o->stride_d = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = dilation_d_factor(); _o->dilation_d_factor = _e; }
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; }
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }
}

inline ::flatbuffers::Offset<Conv3DOptions> Conv3DOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv3DOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Conv3DOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_d = _o->stride_d;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_d_factor = _o->dilation_d_factor;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateConv3DOptions(
      _fbb,
      _padding,
      _stride_d,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _dilation_d_factor,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline Pool2DOptionsT *Pool2DOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Pool2DOptionsT>(new Pool2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = filter_width(); _o->filter_width = _e; }
  { auto _e = filter_height(); _o->filter_height = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline ::flatbuffers::Offset<Pool2DOptions> Pool2DOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool2DOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Pool2DOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _filter_width = _o->filter_width;
  auto _filter_height = _o->filter_height;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreatePool2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _filter_width,
      _filter_height,
      _fused_activation_function);
}

inline DepthwiseConv2DOptionsT *DepthwiseConv2DOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DepthwiseConv2DOptionsT>(new DepthwiseConv2DOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = depth_multiplier(); _o->depth_multiplier = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; }
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }
}

inline ::flatbuffers::Offset<DepthwiseConv2DOptions> DepthwiseConv2DOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthwiseConv2DOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DepthwiseConv2DOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _depth_multiplier = _o->depth_multiplier;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateDepthwiseConv2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _depth_multiplier,
      _fused_activation_function,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline ConcatEmbeddingsOptionsT *ConcatEmbeddingsOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConcatEmbeddingsOptionsT>(new ConcatEmbeddingsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_channels(); _o->num_channels = _e; }
  { auto _e = num_columns_per_channel(); if (_e) { _o->num_columns_per_channel.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->num_columns_per_channel[_i] = _e->Get(_i); } } else { _o->num_columns_per_channel.resize(0); } }
  { auto _e = embedding_dim_per_channel(); if (_e) { _o->embedding_dim_per_channel.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->embedding_dim_per_channel[_i] = _e->Get(_i); } } else { _o->embedding_dim_per_channel.resize(0); } }
}

inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> ConcatEmbeddingsOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcatEmbeddingsOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConcatEmbeddingsOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_channels = _o->num_channels;
  auto _num_columns_per_channel = _o->num_columns_per_channel.size() ? _fbb.CreateVector(_o->num_columns_per_channel) : 0;
  auto _embedding_dim_per_channel = _o->embedding_dim_per_channel.size() ? _fbb.CreateVector(_o->embedding_dim_per_channel) : 0;
  return tflite::CreateConcatEmbeddingsOptions(
      _fbb,
      _num_channels,
      _num_columns_per_channel,
      _embedding_dim_per_channel);
}

inline LSHProjectionOptionsT *LSHProjectionOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LSHProjectionOptionsT>(new LSHProjectionOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline ::flatbuffers::Offset<LSHProjectionOptions> LSHProjectionOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSHProjectionOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LSHProjectionOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return tflite::CreateLSHProjectionOptions(
      _fbb,
      _type);
}

inline SVDFOptionsT *SVDFOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SVDFOptionsT>(new SVDFOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rank(); _o->rank = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline ::flatbuffers::Offset<SVDFOptions> SVDFOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSVDFOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SVDFOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rank = _o->rank;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateSVDFOptions(
      _fbb,
      _rank,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline RNNOptionsT *RNNOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RNNOptionsT>(new RNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RNNOptions::UnPackTo(RNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline ::flatbuffers::Offset<RNNOptions> RNNOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRNNOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RNNOptions> CreateRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RNNOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateRNNOptions(
      _fbb,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline SequenceRNNOptionsT *SequenceRNNOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SequenceRNNOptionsT>(new SequenceRNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline ::flatbuffers::Offset<SequenceRNNOptions> SequenceRNNOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SequenceRNNOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateSequenceRNNOptions(
      _fbb,
      _time_major,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline BidirectionalSequenceRNNOptionsT *BidirectionalSequenceRNNOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BidirectionalSequenceRNNOptionsT>(new BidirectionalSequenceRNNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = merge_outputs(); _o->merge_outputs = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> BidirectionalSequenceRNNOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBidirectionalSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceRNNOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _merge_outputs = _o->merge_outputs;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBidirectionalSequenceRNNOptions(
      _fbb,
      _time_major,
      _fused_activation_function,
      _merge_outputs,
      _asymmetric_quantize_inputs);
}

inline FullyConnectedOptionsT *FullyConnectedOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FullyConnectedOptionsT>(new FullyConnectedOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = weights_format(); _o->weights_format = _e; }
  { auto _e = keep_num_dims(); _o->keep_num_dims = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
  { auto _e = quantized_bias_type(); _o->quantized_bias_type = _e; }
}

inline ::flatbuffers::Offset<FullyConnectedOptions> FullyConnectedOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFullyConnectedOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FullyConnectedOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _weights_format = _o->weights_format;
  auto _keep_num_dims = _o->keep_num_dims;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  auto _quantized_bias_type = _o->quantized_bias_type;
  return tflite::CreateFullyConnectedOptions(
      _fbb,
      _fused_activation_function,
      _weights_format,
      _keep_num_dims,
      _asymmetric_quantize_inputs,
      _quantized_bias_type);
}

inline SoftmaxOptionsT *SoftmaxOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftmaxOptionsT>(new SoftmaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline ::flatbuffers::Offset<SoftmaxOptions> SoftmaxOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return tflite::CreateSoftmaxOptions(
      _fbb,
      _beta);
}

inline ConcatenationOptionsT *ConcatenationOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConcatenationOptionsT>(new ConcatenationOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline ::flatbuffers::Offset<ConcatenationOptions> ConcatenationOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcatenationOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConcatenationOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateConcatenationOptions(
      _fbb,
      _axis,
      _fused_activation_function);
}

inline AddOptionsT *AddOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddOptionsT>(new AddOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddOptions::UnPackTo(AddOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = pot_scale_int16(); _o->pot_scale_int16 = _e; }
}

inline ::flatbuffers::Offset<AddOptions> AddOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AddOptions> CreateAddOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AddOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _pot_scale_int16 = _o->pot_scale_int16;
  return tflite::CreateAddOptions(
      _fbb,
      _fused_activation_function,
      _pot_scale_int16);
}

inline MulOptionsT *MulOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MulOptionsT>(new MulOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MulOptions::UnPackTo(MulOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline ::flatbuffers::Offset<MulOptions> MulOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MulOptions> CreateMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MulOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateMulOptions(
      _fbb,
      _fused_activation_function);
}

inline L2NormOptionsT *L2NormOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<L2NormOptionsT>(new L2NormOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline ::flatbuffers::Offset<L2NormOptions> L2NormOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateL2NormOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(::flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const L2NormOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateL2NormOptions(
      _fbb,
      _fused_activation_function);
}

inline LocalResponseNormalizationOptionsT *LocalResponseNormalizationOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LocalResponseNormalizationOptionsT>(new LocalResponseNormalizationOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = radius(); _o->radius = _e; }
  { auto _e = bias(); _o->bias = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
}

inline ::flatbuffers::Offset<LocalResponseNormalizationOptions> LocalResponseNormalizationOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocalResponseNormalizationOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LocalResponseNormalizationOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _radius = _o->radius;
  auto _bias = _o->bias;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return tflite::CreateLocalResponseNormalizationOptions(
      _fbb,
      _radius,
      _bias,
      _alpha,
      _beta);
}

inline LSTMOptionsT *LSTMOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LSTMOptionsT>(new LSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = kernel_type(); _o->kernel_type = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline ::flatbuffers::Offset<LSTMOptions> LSTMOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTMOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LSTMOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _kernel_type = _o->kernel_type;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _kernel_type,
      _asymmetric_quantize_inputs);
}

inline UnidirectionalSequenceLSTMOptionsT *UnidirectionalSequenceLSTMOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnidirectionalSequenceLSTMOptionsT>(new UnidirectionalSequenceLSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
  { auto _e = diagonal_recurrent_tensors(); _o->diagonal_recurrent_tensors = _e; }
}

inline ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> UnidirectionalSequenceLSTMOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnidirectionalSequenceLSTMOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _time_major = _o->time_major;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  auto _diagonal_recurrent_tensors = _o->diagonal_recurrent_tensors;
  return tflite::CreateUnidirectionalSequenceLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _time_major,
      _asymmetric_quantize_inputs,
      _diagonal_recurrent_tensors);
}

inline BidirectionalSequenceLSTMOptionsT *BidirectionalSequenceLSTMOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BidirectionalSequenceLSTMOptionsT>(new BidirectionalSequenceLSTMOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = merge_outputs(); _o->merge_outputs = _e; }
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> BidirectionalSequenceLSTMOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceLSTMOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _merge_outputs = _o->merge_outputs;
  auto _time_major = _o->time_major;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBidirectionalSequenceLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _merge_outputs,
      _time_major,
      _asymmetric_quantize_inputs);
}

inline ResizeBilinearOptionsT *ResizeBilinearOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResizeBilinearOptionsT>(new ResizeBilinearOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = align_corners(); _o->align_corners = _e; }
  { auto _e = half_pixel_centers(); _o->half_pixel_centers = _e; }
}

inline ::flatbuffers::Offset<ResizeBilinearOptions> ResizeBilinearOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeBilinearOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ResizeBilinearOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _align_corners = _o->align_corners;
  auto _half_pixel_centers = _o->half_pixel_centers;
  return tflite::CreateResizeBilinearOptions(
      _fbb,
      _align_corners,
      _half_pixel_centers);
}

inline ResizeNearestNeighborOptionsT *ResizeNearestNeighborOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResizeNearestNeighborOptionsT>(new ResizeNearestNeighborOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResizeNearestNeighborOptions::UnPackTo(ResizeNearestNeighborOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = align_corners(); _o->align_corners = _e; }
  { auto _e = half_pixel_centers(); _o->half_pixel_centers = _e; }
}

inline ::flatbuffers::Offset<ResizeNearestNeighborOptions> ResizeNearestNeighborOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeNearestNeighborOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ResizeNearestNeighborOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _align_corners = _o->align_corners;
  auto _half_pixel_centers = _o->half_pixel_centers;
  return tflite::CreateResizeNearestNeighborOptions(
      _fbb,
      _align_corners,
      _half_pixel_centers);
}

inline CallOptionsT *CallOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CallOptionsT>(new CallOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallOptions::UnPackTo(CallOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = subgraph(); _o->subgraph = _e; }
}

inline ::flatbuffers::Offset<CallOptions> CallOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CallOptions> CreateCallOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CallOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _subgraph = _o->subgraph;
  return tflite::CreateCallOptions(
      _fbb,
      _subgraph);
}

inline PadOptionsT *PadOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PadOptionsT>(new PadOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PadOptions::UnPackTo(PadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<PadOptions> PadOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PadOptions> CreatePadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PadOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePadOptions(
      _fbb);
}

inline PadV2OptionsT *PadV2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PadV2OptionsT>(new PadV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PadV2Options::UnPackTo(PadV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<PadV2Options> PadV2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadV2Options(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PadV2Options> CreatePadV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PadV2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePadV2Options(
      _fbb);
}

inline ReshapeOptionsT *ReshapeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReshapeOptionsT>(new ReshapeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = new_shape(); if (_e) { _o->new_shape.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_shape[_i] = _e->Get(_i); } } else { _o->new_shape.resize(0); } }
}

inline ::flatbuffers::Offset<ReshapeOptions> ReshapeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshapeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReshapeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _new_shape = _o->new_shape.size() ? _fbb.CreateVector(_o->new_shape) : 0;
  return tflite::CreateReshapeOptions(
      _fbb,
      _new_shape);
}

inline SpaceToBatchNDOptionsT *SpaceToBatchNDOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpaceToBatchNDOptionsT>(new SpaceToBatchNDOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SpaceToBatchNDOptions> SpaceToBatchNDOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToBatchNDOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSpaceToBatchNDOptions(
      _fbb);
}

inline BatchToSpaceNDOptionsT *BatchToSpaceNDOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchToSpaceNDOptionsT>(new BatchToSpaceNDOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<BatchToSpaceNDOptions> BatchToSpaceNDOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchToSpaceNDOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBatchToSpaceNDOptions(
      _fbb);
}

inline SkipGramOptionsT *SkipGramOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SkipGramOptionsT>(new SkipGramOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ngram_size(); _o->ngram_size = _e; }
  { auto _e = max_skip_size(); _o->max_skip_size = _e; }
  { auto _e = include_all_ngrams(); _o->include_all_ngrams = _e; }
}

inline ::flatbuffers::Offset<SkipGramOptions> SkipGramOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkipGramOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SkipGramOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ngram_size = _o->ngram_size;
  auto _max_skip_size = _o->max_skip_size;
  auto _include_all_ngrams = _o->include_all_ngrams;
  return tflite::CreateSkipGramOptions(
      _fbb,
      _ngram_size,
      _max_skip_size,
      _include_all_ngrams);
}

inline SpaceToDepthOptionsT *SpaceToDepthOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpaceToDepthOptionsT>(new SpaceToDepthOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; }
}

inline ::flatbuffers::Offset<SpaceToDepthOptions> SpaceToDepthOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToDepthOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  return tflite::CreateSpaceToDepthOptions(
      _fbb,
      _block_size);
}

inline DepthToSpaceOptionsT *DepthToSpaceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DepthToSpaceOptionsT>(new DepthToSpaceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepthToSpaceOptions::UnPackTo(DepthToSpaceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; }
}

inline ::flatbuffers::Offset<DepthToSpaceOptions> DepthToSpaceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthToSpaceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DepthToSpaceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  return tflite::CreateDepthToSpaceOptions(
      _fbb,
      _block_size);
}

inline SubOptionsT *SubOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubOptionsT>(new SubOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubOptions::UnPackTo(SubOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = pot_scale_int16(); _o->pot_scale_int16 = _e; }
}

inline ::flatbuffers::Offset<SubOptions> SubOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SubOptions> CreateSubOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SubOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _pot_scale_int16 = _o->pot_scale_int16;
  return tflite::CreateSubOptions(
      _fbb,
      _fused_activation_function,
      _pot_scale_int16);
}

inline DivOptionsT *DivOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DivOptionsT>(new DivOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DivOptions::UnPackTo(DivOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline ::flatbuffers::Offset<DivOptions> DivOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DivOptions> CreateDivOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DivOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateDivOptions(
      _fbb,
      _fused_activation_function);
}

inline TopKV2OptionsT *TopKV2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TopKV2OptionsT>(new TopKV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<TopKV2Options> TopKV2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopKV2Options(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TopKV2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTopKV2Options(
      _fbb);
}

inline EmbeddingLookupSparseOptionsT *EmbeddingLookupSparseOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EmbeddingLookupSparseOptionsT>(new EmbeddingLookupSparseOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = combiner(); _o->combiner = _e; }
}

inline ::flatbuffers::Offset<EmbeddingLookupSparseOptions> EmbeddingLookupSparseOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmbeddingLookupSparseOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(::flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupSparseOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _combiner = _o->combiner;
  return tflite::CreateEmbeddingLookupSparseOptions(
      _fbb,
      _combiner);
}

inline GatherOptionsT *GatherOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GatherOptionsT>(new GatherOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GatherOptions::UnPackTo(GatherOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = batch_dims(); _o->batch_dims = _e; }
}

inline ::flatbuffers::Offset<GatherOptions> GatherOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GatherOptions> CreateGatherOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GatherOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _batch_dims = _o->batch_dims;
  return tflite::CreateGatherOptions(
      _fbb,
      _axis,
      _batch_dims);
}

inline TransposeOptionsT *TransposeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TransposeOptionsT>(new TransposeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<TransposeOptions> TransposeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransposeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TransposeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTransposeOptions(
      _fbb);
}

inline ExpOptionsT *ExpOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpOptionsT>(new ExpOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpOptions::UnPackTo(ExpOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ExpOptions> ExpOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ExpOptions> CreateExpOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExpOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateExpOptions(
      _fbb);
}

inline CosOptionsT *CosOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CosOptionsT>(new CosOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CosOptions::UnPackTo(CosOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<CosOptions> CosOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCosOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CosOptions> CreateCosOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CosOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateCosOptions(
      _fbb);
}

inline ReducerOptionsT *ReducerOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReducerOptionsT>(new ReducerOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keep_dims(); _o->keep_dims = _e; }
}

inline ::flatbuffers::Offset<ReducerOptions> ReducerOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReducerOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReducerOptions> CreateReducerOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReducerOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keep_dims = _o->keep_dims;
  return tflite::CreateReducerOptions(
      _fbb,
      _keep_dims);
}

inline SqueezeOptionsT *SqueezeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SqueezeOptionsT>(new SqueezeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = squeeze_dims(); if (_e) { _o->squeeze_dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeeze_dims[_i] = _e->Get(_i); } } else { _o->squeeze_dims.resize(0); } }
}

inline ::flatbuffers::Offset<SqueezeOptions> SqueezeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueezeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SqueezeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _squeeze_dims = _o->squeeze_dims.size() ? _fbb.CreateVector(_o->squeeze_dims) : 0;
  return tflite::CreateSqueezeOptions(
      _fbb,
      _squeeze_dims);
}

inline SplitOptionsT *SplitOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SplitOptionsT>(new SplitOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SplitOptions::UnPackTo(SplitOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_splits(); _o->num_splits = _e; }
}

inline ::flatbuffers::Offset<SplitOptions> SplitOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SplitOptions> CreateSplitOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SplitOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_splits = _o->num_splits;
  return tflite::CreateSplitOptions(
      _fbb,
      _num_splits);
}

inline SplitVOptionsT *SplitVOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SplitVOptionsT>(new SplitVOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SplitVOptions::UnPackTo(SplitVOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_splits(); _o->num_splits = _e; }
}

inline ::flatbuffers::Offset<SplitVOptions> SplitVOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitVOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SplitVOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_splits = _o->num_splits;
  return tflite::CreateSplitVOptions(
      _fbb,
      _num_splits);
}

inline StridedSliceOptionsT *StridedSliceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StridedSliceOptionsT>(new StridedSliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin_mask(); _o->begin_mask = _e; }
  { auto _e = end_mask(); _o->end_mask = _e; }
  { auto _e = ellipsis_mask(); _o->ellipsis_mask = _e; }
  { auto _e = new_axis_mask(); _o->new_axis_mask = _e; }
  { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; }
  { auto _e = offset(); _o->offset = _e; }
}

inline ::flatbuffers::Offset<StridedSliceOptions> StridedSliceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSliceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin_mask = _o->begin_mask;
  auto _end_mask = _o->end_mask;
  auto _ellipsis_mask = _o->ellipsis_mask;
  auto _new_axis_mask = _o->new_axis_mask;
  auto _shrink_axis_mask = _o->shrink_axis_mask;
  auto _offset = _o->offset;
  return tflite::CreateStridedSliceOptions(
      _fbb,
      _begin_mask,
      _end_mask,
      _ellipsis_mask,
      _new_axis_mask,
      _shrink_axis_mask,
      _offset);
}

inline LogSoftmaxOptionsT *LogSoftmaxOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogSoftmaxOptionsT>(new LogSoftmaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<LogSoftmaxOptions> LogSoftmaxOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogSoftmaxOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogSoftmaxOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogSoftmaxOptions(
      _fbb);
}

inline CastOptionsT *CastOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CastOptionsT>(new CastOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CastOptions::UnPackTo(CastOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = in_data_type(); _o->in_data_type = _e; }
  { auto _e = out_data_type(); _o->out_data_type = _e; }
}

inline ::flatbuffers::Offset<CastOptions> CastOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCastOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CastOptions> CreateCastOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CastOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _in_data_type = _o->in_data_type;
  auto _out_data_type = _o->out_data_type;
  return tflite::CreateCastOptions(
      _fbb,
      _in_data_type,
      _out_data_type);
}

inline DequantizeOptionsT *DequantizeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DequantizeOptionsT>(new DequantizeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<DequantizeOptions> DequantizeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDequantizeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DequantizeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDequantizeOptions(
      _fbb);
}

inline MaximumMinimumOptionsT *MaximumMinimumOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MaximumMinimumOptionsT>(new MaximumMinimumOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<MaximumMinimumOptions> MaximumMinimumOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaximumMinimumOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MaximumMinimumOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMaximumMinimumOptions(
      _fbb);
}

inline TileOptionsT *TileOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TileOptionsT>(new TileOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TileOptions::UnPackTo(TileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<TileOptions> TileOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTileOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TileOptions> CreateTileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TileOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTileOptions(
      _fbb);
}

inline ArgMaxOptionsT *ArgMaxOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMaxOptionsT>(new ArgMaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_type(); _o->output_type = _e; }
}

inline ::flatbuffers::Offset<ArgMaxOptions> ArgMaxOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMaxOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_type = _o->output_type;
  return tflite::CreateArgMaxOptions(
      _fbb,
      _output_type);
}

inline ArgMinOptionsT *ArgMinOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMinOptionsT>(new ArgMinOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_type(); _o->output_type = _e; }
}

inline ::flatbuffers::Offset<ArgMinOptions> ArgMinOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMinOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ArgMinOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_type = _o->output_type;
  return tflite::CreateArgMinOptions(
      _fbb,
      _output_type);
}

inline GreaterOptionsT *GreaterOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GreaterOptionsT>(new GreaterOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<GreaterOptions> GreaterOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GreaterOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGreaterOptions(
      _fbb);
}

inline GreaterEqualOptionsT *GreaterEqualOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GreaterEqualOptionsT>(new GreaterEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<GreaterEqualOptions> GreaterEqualOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterEqualOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGreaterEqualOptions(
      _fbb);
}

inline LessOptionsT *LessOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LessOptionsT>(new LessOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessOptions::UnPackTo(LessOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<LessOptions> LessOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LessOptions> CreateLessOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LessOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLessOptions(
      _fbb);
}

inline LessEqualOptionsT *LessEqualOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LessEqualOptionsT>(new LessEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<LessEqualOptions> LessEqualOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessEqualOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LessEqualOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLessEqualOptions(
      _fbb);
}

inline NegOptionsT *NegOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NegOptionsT>(new NegOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NegOptions::UnPackTo(NegOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<NegOptions> NegOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNegOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NegOptions> CreateNegOptions(::flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NegOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNegOptions(
      _fbb);
}

inline SelectOptionsT *SelectOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SelectOptionsT>(new SelectOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SelectOptions::UnPackTo(SelectOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SelectOptions> SelectOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SelectOptions> CreateSelectOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SelectOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSelectOptions(
      _fbb);
}

inline SliceOptionsT *SliceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SliceOptionsT>(new SliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SliceOptions::UnPackTo(SliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SliceOptions> SliceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SliceOptions> CreateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SliceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSliceOptions(
      _fbb);
}

inline TransposeConvOptionsT *TransposeConvOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TransposeConvOptionsT>(new TransposeConvOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = quantized_bias_type(); _o->quantized_bias_type = _e; }
}

inline ::flatbuffers::Offset<TransposeConvOptions> TransposeConvOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransposeConvOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TransposeConvOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _quantized_bias_type = _o->quantized_bias_type;
  return tflite::CreateTransposeConvOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _quantized_bias_type);
}

inline ExpandDimsOptionsT *ExpandDimsOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpandDimsOptionsT>(new ExpandDimsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ExpandDimsOptions> ExpandDimsOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDimsOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateExpandDimsOptions(
      _fbb);
}

inline SparseToDenseOptionsT *SparseToDenseOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SparseToDenseOptionsT>(new SparseToDenseOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = validate_indices(); _o->validate_indices = _e; }
}

inline ::flatbuffers::Offset<SparseToDenseOptions> SparseToDenseOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseToDenseOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _validate_indices = _o->validate_indices;
  return tflite::CreateSparseToDenseOptions(
      _fbb,
      _validate_indices);
}

inline EqualOptionsT *EqualOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EqualOptionsT>(new EqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EqualOptions::UnPackTo(EqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<EqualOptions> EqualOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEqualOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EqualOptions> CreateEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EqualOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateEqualOptions(
      _fbb);
}

inline NotEqualOptionsT *NotEqualOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NotEqualOptionsT>(new NotEqualOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<NotEqualOptions> NotEqualOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotEqualOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NotEqualOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNotEqualOptions(
      _fbb);
}

inline ShapeOptionsT *ShapeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ShapeOptionsT>(new ShapeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = out_type(); _o->out_type = _e; }
}

inline ::flatbuffers::Offset<ShapeOptions> ShapeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShapeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ShapeOptions> CreateShapeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ShapeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _out_type = _o->out_type;
  return tflite::CreateShapeOptions(
      _fbb,
      _out_type);
}

inline RankOptionsT *RankOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RankOptionsT>(new RankOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RankOptions::UnPackTo(RankOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<RankOptions> RankOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRankOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RankOptions> CreateRankOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RankOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRankOptions(
      _fbb);
}

inline PowOptionsT *PowOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PowOptionsT>(new PowOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PowOptions::UnPackTo(PowOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<PowOptions> PowOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PowOptions> CreatePowOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PowOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePowOptions(
      _fbb);
}

inline FakeQuantOptionsT *FakeQuantOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FakeQuantOptionsT>(new FakeQuantOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
  { auto _e = num_bits(); _o->num_bits = _e; }
  { auto _e = narrow_range(); _o->narrow_range = _e; }
}

inline ::flatbuffers::Offset<FakeQuantOptions> FakeQuantOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _num_bits = _o->num_bits;
  auto _narrow_range = _o->narrow_range;
  return tflite::CreateFakeQuantOptions(
      _fbb,
      _min,
      _max,
      _num_bits,
      _narrow_range);
}

inline PackOptionsT *PackOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PackOptionsT>(new PackOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PackOptions::UnPackTo(PackOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values_count(); _o->values_count = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline ::flatbuffers::Offset<PackOptions> PackOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePackOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PackOptions> CreatePackOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PackOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values_count = _o->values_count;
  auto _axis = _o->axis;
  return tflite::CreatePackOptions(
      _fbb,
      _values_count,
      _axis);
}

inline LogicalOrOptionsT *LogicalOrOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalOrOptionsT>(new LogicalOrOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<LogicalOrOptions> LogicalOrOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalOrOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalOrOptions(
      _fbb);
}

inline OneHotOptionsT *OneHotOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OneHotOptionsT>(new OneHotOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline ::flatbuffers::Offset<OneHotOptions> OneHotOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOneHotOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(::flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OneHotOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return tflite::CreateOneHotOptions(
      _fbb,
      _axis);
}

inline AbsOptionsT *AbsOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AbsOptionsT>(new AbsOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AbsOptions::UnPackTo(AbsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<AbsOptions> AbsOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbsOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AbsOptions> CreateAbsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AbsOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAbsOptions(
      _fbb);
}

inline HardSwishOptionsT *HardSwishOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HardSwishOptionsT>(new HardSwishOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HardSwishOptions::UnPackTo(HardSwishOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<HardSwishOptions> HardSwishOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHardSwishOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HardSwishOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHardSwishOptions(
      _fbb);
}

inline LogicalAndOptionsT *LogicalAndOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalAndOptionsT>(new LogicalAndOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<LogicalAndOptions> LogicalAndOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalAndOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalAndOptions(
      _fbb);
}

inline LogicalNotOptionsT *LogicalNotOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalNotOptionsT>(new LogicalNotOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<LogicalNotOptions> LogicalNotOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalNotOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalNotOptions(
      _fbb);
}

inline UnpackOptionsT *UnpackOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnpackOptionsT>(new UnpackOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline ::flatbuffers::Offset<UnpackOptions> UnpackOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnpackOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnpackOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  auto _axis = _o->axis;
  return tflite::CreateUnpackOptions(
      _fbb,
      _num,
      _axis);
}

inline FloorDivOptionsT *FloorDivOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FloorDivOptionsT>(new FloorDivOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<FloorDivOptions> FloorDivOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorDivOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FloorDivOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFloorDivOptions(
      _fbb);
}

inline SquareOptionsT *SquareOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SquareOptionsT>(new SquareOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SquareOptions::UnPackTo(SquareOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SquareOptions> SquareOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquareOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SquareOptions> CreateSquareOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SquareOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSquareOptions(
      _fbb);
}

inline ZerosLikeOptionsT *ZerosLikeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ZerosLikeOptionsT>(new ZerosLikeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ZerosLikeOptions> ZerosLikeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateZerosLikeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateZerosLikeOptions(
      _fbb);
}

inline FillOptionsT *FillOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FillOptionsT>(new FillOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FillOptions::UnPackTo(FillOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<FillOptions> FillOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFillOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FillOptions> CreateFillOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FillOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFillOptions(
      _fbb);
}

inline FloorModOptionsT *FloorModOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FloorModOptionsT>(new FloorModOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorModOptions::UnPackTo(FloorModOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<FloorModOptions> FloorModOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorModOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FloorModOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFloorModOptions(
      _fbb);
}

inline RangeOptionsT *RangeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RangeOptionsT>(new RangeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RangeOptions::UnPackTo(RangeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<RangeOptions> RangeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRangeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RangeOptions> CreateRangeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RangeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRangeOptions(
      _fbb);
}

inline LeakyReluOptionsT *LeakyReluOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LeakyReluOptionsT>(new LeakyReluOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeakyReluOptions::UnPackTo(LeakyReluOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
}

inline ::flatbuffers::Offset<LeakyReluOptions> LeakyReluOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyReluOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return tflite::CreateLeakyReluOptions(
      _fbb,
      _alpha);
}

inline SquaredDifferenceOptionsT *SquaredDifferenceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SquaredDifferenceOptionsT>(new SquaredDifferenceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SquaredDifferenceOptions::UnPackTo(SquaredDifferenceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SquaredDifferenceOptions> SquaredDifferenceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquaredDifferenceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSquaredDifferenceOptions(
      _fbb);
}

inline MirrorPadOptionsT *MirrorPadOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MirrorPadOptionsT>(new MirrorPadOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MirrorPadOptions::UnPackTo(MirrorPadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
}

inline ::flatbuffers::Offset<MirrorPadOptions> MirrorPadOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMirrorPadOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MirrorPadOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return tflite::CreateMirrorPadOptions(
      _fbb,
      _mode);
}

inline UniqueOptionsT *UniqueOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueOptionsT>(new UniqueOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueOptions::UnPackTo(UniqueOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = idx_out_type(); _o->idx_out_type = _e; }
}

inline ::flatbuffers::Offset<UniqueOptions> UniqueOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _idx_out_type = _o->idx_out_type;
  return tflite::CreateUniqueOptions(
      _fbb,
      _idx_out_type);
}

inline ReverseV2OptionsT *ReverseV2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReverseV2OptionsT>(new ReverseV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReverseV2Options::UnPackTo(ReverseV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ReverseV2Options> ReverseV2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseV2Options(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReverseV2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateReverseV2Options(
      _fbb);
}

inline AddNOptionsT *AddNOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddNOptionsT>(new AddNOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddNOptions::UnPackTo(AddNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<AddNOptions> AddNOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddNOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AddNOptions> CreateAddNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AddNOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAddNOptions(
      _fbb);
}

inline GatherNdOptionsT *GatherNdOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GatherNdOptionsT>(new GatherNdOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GatherNdOptions::UnPackTo(GatherNdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<GatherNdOptions> GatherNdOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherNdOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GatherNdOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGatherNdOptions(
      _fbb);
}

inline WhereOptionsT *WhereOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WhereOptionsT>(new WhereOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WhereOptions::UnPackTo(WhereOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<WhereOptions> WhereOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhereOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WhereOptions> CreateWhereOptions(::flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WhereOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateWhereOptions(
      _fbb);
}

inline ReverseSequenceOptionsT *ReverseSequenceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReverseSequenceOptionsT>(new ReverseSequenceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReverseSequenceOptions::UnPackTo(ReverseSequenceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seq_dim(); _o->seq_dim = _e; }
  { auto _e = batch_dim(); _o->batch_dim = _e; }
}

inline ::flatbuffers::Offset<ReverseSequenceOptions> ReverseSequenceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseSequenceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seq_dim = _o->seq_dim;
  auto _batch_dim = _o->batch_dim;
  return tflite::CreateReverseSequenceOptions(
      _fbb,
      _seq_dim,
      _batch_dim);
}

inline MatrixDiagOptionsT *MatrixDiagOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatrixDiagOptionsT>(new MatrixDiagOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatrixDiagOptions::UnPackTo(MatrixDiagOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<MatrixDiagOptions> MatrixDiagOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatrixDiagOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MatrixDiagOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMatrixDiagOptions(
      _fbb);
}

inline QuantizeOptionsT *QuantizeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuantizeOptionsT>(new QuantizeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantizeOptions::UnPackTo(QuantizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<QuantizeOptions> QuantizeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const QuantizeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateQuantizeOptions(
      _fbb);
}

inline MatrixSetDiagOptionsT *MatrixSetDiagOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatrixSetDiagOptionsT>(new MatrixSetDiagOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatrixSetDiagOptions::UnPackTo(MatrixSetDiagOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<MatrixSetDiagOptions> MatrixSetDiagOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatrixSetDiagOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MatrixSetDiagOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMatrixSetDiagOptions(
      _fbb);
}

inline IfOptionsT *IfOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IfOptionsT>(new IfOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IfOptions::UnPackTo(IfOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = then_subgraph_index(); _o->then_subgraph_index = _e; }
  { auto _e = else_subgraph_index(); _o->else_subgraph_index = _e; }
}

inline ::flatbuffers::Offset<IfOptions> IfOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIfOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IfOptions> CreateIfOptions(::flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IfOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _then_subgraph_index = _o->then_subgraph_index;
  auto _else_subgraph_index = _o->else_subgraph_index;
  return tflite::CreateIfOptions(
      _fbb,
      _then_subgraph_index,
      _else_subgraph_index);
}

inline CallOnceOptionsT *CallOnceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CallOnceOptionsT>(new CallOnceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallOnceOptions::UnPackTo(CallOnceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = init_subgraph_index(); _o->init_subgraph_index = _e; }
}

inline ::flatbuffers::Offset<CallOnceOptions> CallOnceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallOnceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CallOnceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _init_subgraph_index = _o->init_subgraph_index;
  return tflite::CreateCallOnceOptions(
      _fbb,
      _init_subgraph_index);
}

inline WhileOptionsT *WhileOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WhileOptionsT>(new WhileOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WhileOptions::UnPackTo(WhileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cond_subgraph_index(); _o->cond_subgraph_index = _e; }
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; }
}

inline ::flatbuffers::Offset<WhileOptions> WhileOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhileOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WhileOptions> CreateWhileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WhileOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cond_subgraph_index = _o->cond_subgraph_index;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateWhileOptions(
      _fbb,
      _cond_subgraph_index,
      _body_subgraph_index);
}

inline NonMaxSuppressionV4OptionsT *NonMaxSuppressionV4Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NonMaxSuppressionV4OptionsT>(new NonMaxSuppressionV4OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NonMaxSuppressionV4Options::UnPackTo(NonMaxSuppressionV4OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<NonMaxSuppressionV4Options> NonMaxSuppressionV4Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppressionV4Options(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV4OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNonMaxSuppressionV4Options(
      _fbb);
}

inline NonMaxSuppressionV5OptionsT *NonMaxSuppressionV5Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NonMaxSuppressionV5OptionsT>(new NonMaxSuppressionV5OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NonMaxSuppressionV5Options::UnPackTo(NonMaxSuppressionV5OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<NonMaxSuppressionV5Options> NonMaxSuppressionV5Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppressionV5Options(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV5OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNonMaxSuppressionV5Options(
      _fbb);
}

inline ScatterNdOptionsT *ScatterNdOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScatterNdOptionsT>(new ScatterNdOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScatterNdOptions::UnPackTo(ScatterNdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ScatterNdOptions> ScatterNdOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScatterNdOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateScatterNdOptions(
      _fbb);
}

inline SelectV2OptionsT *SelectV2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SelectV2OptionsT>(new SelectV2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SelectV2Options::UnPackTo(SelectV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SelectV2Options> SelectV2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectV2Options(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SelectV2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSelectV2Options(
      _fbb);
}

inline DensifyOptionsT *DensifyOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DensifyOptionsT>(new DensifyOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DensifyOptions::UnPackTo(DensifyOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<DensifyOptions> DensifyOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDensifyOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DensifyOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDensifyOptions(
      _fbb);
}

inline SegmentSumOptionsT *SegmentSumOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SegmentSumOptionsT>(new SegmentSumOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SegmentSumOptions::UnPackTo(SegmentSumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SegmentSumOptions> SegmentSumOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSegmentSumOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SegmentSumOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSegmentSumOptions(
      _fbb);
}

inline BatchMatMulOptionsT *BatchMatMulOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchMatMulOptionsT>(new BatchMatMulOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchMatMulOptions::UnPackTo(BatchMatMulOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = adj_x(); _o->adj_x = _e; }
  { auto _e = adj_y(); _o->adj_y = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline ::flatbuffers::Offset<BatchMatMulOptions> BatchMatMulOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchMatMulOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BatchMatMulOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _adj_x = _o->adj_x;
  auto _adj_y = _o->adj_y;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBatchMatMulOptions(
      _fbb,
      _adj_x,
      _adj_y,
      _asymmetric_quantize_inputs);
}

inline CumsumOptionsT *CumsumOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CumsumOptionsT>(new CumsumOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CumsumOptions::UnPackTo(CumsumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exclusive(); _o->exclusive = _e; }
  { auto _e = reverse(); _o->reverse = _e; }
}

inline ::flatbuffers::Offset<CumsumOptions> CumsumOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCumsumOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CumsumOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exclusive = _o->exclusive;
  auto _reverse = _o->reverse;
  return tflite::CreateCumsumOptions(
      _fbb,
      _exclusive,
      _reverse);
}

inline BroadcastToOptionsT *BroadcastToOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BroadcastToOptionsT>(new BroadcastToOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BroadcastToOptions::UnPackTo(BroadcastToOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<BroadcastToOptions> BroadcastToOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastToOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BroadcastToOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBroadcastToOptions(
      _fbb);
}

inline Rfft2dOptionsT *Rfft2dOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Rfft2dOptionsT>(new Rfft2dOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rfft2dOptions::UnPackTo(Rfft2dOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<Rfft2dOptions> Rfft2dOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRfft2dOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Rfft2dOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRfft2dOptions(
      _fbb);
}

inline HashtableOptionsT *HashtableOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HashtableOptionsT>(new HashtableOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableOptions::UnPackTo(HashtableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = table_id(); _o->table_id = _e; }
  { auto _e = key_dtype(); _o->key_dtype = _e; }
  { auto _e = value_dtype(); _o->value_dtype = _e; }
}

inline ::flatbuffers::Offset<HashtableOptions> HashtableOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HashtableOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _table_id = _o->table_id;
  auto _key_dtype = _o->key_dtype;
  auto _value_dtype = _o->value_dtype;
  return tflite::CreateHashtableOptions(
      _fbb,
      _table_id,
      _key_dtype,
      _value_dtype);
}

inline HashtableFindOptionsT *HashtableFindOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HashtableFindOptionsT>(new HashtableFindOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableFindOptions::UnPackTo(HashtableFindOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<HashtableFindOptions> HashtableFindOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableFindOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HashtableFindOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableFindOptions(
      _fbb);
}

inline HashtableImportOptionsT *HashtableImportOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HashtableImportOptionsT>(new HashtableImportOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableImportOptions::UnPackTo(HashtableImportOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<HashtableImportOptions> HashtableImportOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableImportOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HashtableImportOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableImportOptions(
      _fbb);
}

inline HashtableSizeOptionsT *HashtableSizeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HashtableSizeOptionsT>(new HashtableSizeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableSizeOptions::UnPackTo(HashtableSizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<HashtableSizeOptions> HashtableSizeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableSizeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HashtableSizeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableSizeOptions(
      _fbb);
}

inline VarHandleOptionsT *VarHandleOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VarHandleOptionsT>(new VarHandleOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VarHandleOptions::UnPackTo(VarHandleOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = container(); if (_e) _o->container = _e->str(); }
  { auto _e = shared_name(); if (_e) _o->shared_name = _e->str(); }
}

inline ::flatbuffers::Offset<VarHandleOptions> VarHandleOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVarHandleOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(::flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VarHandleOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _container = _o->container.empty() ? 0 : _fbb.CreateString(_o->container);
  auto _shared_name = _o->shared_name.empty() ? 0 : _fbb.CreateString(_o->shared_name);
  return tflite::CreateVarHandleOptions(
      _fbb,
      _container,
      _shared_name);
}

inline ReadVariableOptionsT *ReadVariableOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadVariableOptionsT>(new ReadVariableOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadVariableOptions::UnPackTo(ReadVariableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ReadVariableOptions> ReadVariableOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReadVariableOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadVariableOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateReadVariableOptions(
      _fbb);
}

inline AssignVariableOptionsT *AssignVariableOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AssignVariableOptionsT>(new AssignVariableOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AssignVariableOptions::UnPackTo(AssignVariableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<AssignVariableOptions> AssignVariableOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssignVariableOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AssignVariableOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAssignVariableOptions(
      _fbb);
}

inline RandomOptionsT *RandomOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RandomOptionsT>(new RandomOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RandomOptions::UnPackTo(RandomOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seed(); _o->seed = _e; }
  { auto _e = seed2(); _o->seed2 = _e; }
}

inline ::flatbuffers::Offset<RandomOptions> RandomOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RandomOptions> CreateRandomOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RandomOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seed = _o->seed;
  auto _seed2 = _o->seed2;
  return tflite::CreateRandomOptions(
      _fbb,
      _seed,
      _seed2);
}

inline BucketizeOptionsT *BucketizeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BucketizeOptionsT>(new BucketizeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BucketizeOptions::UnPackTo(BucketizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boundaries(); if (_e) { _o->boundaries.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boundaries[_i] = _e->Get(_i); } } else { _o->boundaries.resize(0); } }
}

inline ::flatbuffers::Offset<BucketizeOptions> BucketizeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBucketizeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BucketizeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boundaries = _o->boundaries.size() ? _fbb.CreateVector(_o->boundaries) : 0;
  return tflite::CreateBucketizeOptions(
      _fbb,
      _boundaries);
}

inline GeluOptionsT *GeluOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeluOptionsT>(new GeluOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeluOptions::UnPackTo(GeluOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = approximate(); _o->approximate = _e; }
}

inline ::flatbuffers::Offset<GeluOptions> GeluOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeluOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeluOptions> CreateGeluOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeluOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _approximate = _o->approximate;
  return tflite::CreateGeluOptions(
      _fbb,
      _approximate);
}

inline DynamicUpdateSliceOptionsT *DynamicUpdateSliceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DynamicUpdateSliceOptionsT>(new DynamicUpdateSliceOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DynamicUpdateSliceOptions::UnPackTo(DynamicUpdateSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<DynamicUpdateSliceOptions> DynamicUpdateSliceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDynamicUpdateSliceOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DynamicUpdateSliceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDynamicUpdateSliceOptions(
      _fbb);
}

inline UnsortedSegmentProdOptionsT *UnsortedSegmentProdOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnsortedSegmentProdOptionsT>(new UnsortedSegmentProdOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnsortedSegmentProdOptions::UnPackTo(UnsortedSegmentProdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<UnsortedSegmentProdOptions> UnsortedSegmentProdOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentProdOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentProdOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateUnsortedSegmentProdOptions(
      _fbb);
}

inline UnsortedSegmentMaxOptionsT *UnsortedSegmentMaxOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnsortedSegmentMaxOptionsT>(new UnsortedSegmentMaxOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnsortedSegmentMaxOptions::UnPackTo(UnsortedSegmentMaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<UnsortedSegmentMaxOptions> UnsortedSegmentMaxOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentMaxOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentMaxOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateUnsortedSegmentMaxOptions(
      _fbb);
}

inline UnsortedSegmentSumOptionsT *UnsortedSegmentSumOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnsortedSegmentSumOptionsT>(new UnsortedSegmentSumOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnsortedSegmentSumOptions::UnPackTo(UnsortedSegmentSumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<UnsortedSegmentSumOptions> UnsortedSegmentSumOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentSumOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentSumOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateUnsortedSegmentSumOptions(
      _fbb);
}

inline ATan2OptionsT *ATan2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ATan2OptionsT>(new ATan2OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ATan2Options::UnPackTo(ATan2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ATan2Options> ATan2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateATan2Options(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ATan2Options> CreateATan2Options(::flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ATan2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateATan2Options(
      _fbb);
}

inline UnsortedSegmentMinOptionsT *UnsortedSegmentMinOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnsortedSegmentMinOptionsT>(new UnsortedSegmentMinOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnsortedSegmentMinOptions::UnPackTo(UnsortedSegmentMinOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<UnsortedSegmentMinOptions> UnsortedSegmentMinOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentMinOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentMinOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateUnsortedSegmentMinOptions(
      _fbb);
}

inline SignOptionsT *SignOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignOptionsT>(new SignOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignOptions::UnPackTo(SignOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<SignOptions> SignOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SignOptions> CreateSignOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SignOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSignOptions(
      _fbb);
}

inline BitcastOptionsT *BitcastOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BitcastOptionsT>(new BitcastOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BitcastOptions::UnPackTo(BitcastOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<BitcastOptions> BitcastOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBitcastOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BitcastOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBitcastOptions(
      _fbb);
}

inline BitwiseXorOptionsT *BitwiseXorOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BitwiseXorOptionsT>(new BitwiseXorOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BitwiseXorOptions::UnPackTo(BitwiseXorOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<BitwiseXorOptions> BitwiseXorOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BitwiseXorOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBitwiseXorOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BitwiseXorOptions> CreateBitwiseXorOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BitwiseXorOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BitwiseXorOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBitwiseXorOptions(
      _fbb);
}

inline RightShiftOptionsT *RightShiftOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RightShiftOptionsT>(new RightShiftOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RightShiftOptions::UnPackTo(RightShiftOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<RightShiftOptions> RightShiftOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RightShiftOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRightShiftOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RightShiftOptions> CreateRightShiftOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RightShiftOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RightShiftOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRightShiftOptions(
      _fbb);
}

inline DilateOptionsT *DilateOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DilateOptionsT>(new DilateOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DilateOptions::UnPackTo(DilateOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<DilateOptions> DilateOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DilateOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDilateOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DilateOptions> CreateDilateOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DilateOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DilateOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDilateOptions(
      _fbb);
}

inline ReduceWindowOptionsT *ReduceWindowOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReduceWindowOptionsT>(new ReduceWindowOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReduceWindowOptions::UnPackTo(ReduceWindowOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reduce_function(); _o->reduce_function = _e; }
}

inline ::flatbuffers::Offset<ReduceWindowOptions> ReduceWindowOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReduceWindowOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceWindowOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReduceWindowOptions> CreateReduceWindowOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReduceWindowOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReduceWindowOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reduce_function = _o->reduce_function;
  return tflite::CreateReduceWindowOptions(
      _fbb,
      _reduce_function);
}

inline OperatorCodeT *OperatorCode::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OperatorCodeT>(new OperatorCodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deprecated_builtin_code(); _o->deprecated_builtin_code = _e; }
  { auto _e = custom_code(); if (_e) _o->custom_code = _e->str(); }
  { auto _e = version(); _o->version = _e; }
  { auto _e = builtin_code(); _o->builtin_code = _e; }
}

inline ::flatbuffers::Offset<OperatorCode> OperatorCode::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorCode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OperatorCode> CreateOperatorCode(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OperatorCodeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deprecated_builtin_code = _o->deprecated_builtin_code;
  auto _custom_code = _o->custom_code.empty() ? 0 : _fbb.CreateString(_o->custom_code);
  auto _version = _o->version;
  auto _builtin_code = _o->builtin_code;
  return tflite::CreateOperatorCode(
      _fbb,
      _deprecated_builtin_code,
      _custom_code,
      _version,
      _builtin_code);
}

inline StableHLOCompositeOptionsT *StableHLOCompositeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StableHLOCompositeOptionsT>(new StableHLOCompositeOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StableHLOCompositeOptions::UnPackTo(StableHLOCompositeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = decomposition_subgraph_index(); _o->decomposition_subgraph_index = _e; }
  { auto _e = composite_attributes(); if (_e) { _o->composite_attributes.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->composite_attributes.begin()); } }
  { auto _e = composite_attributes_format(); _o->composite_attributes_format = _e; }
  { auto _e = version(); _o->version = _e; }
}

inline ::flatbuffers::Offset<StableHLOCompositeOptions> StableHLOCompositeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StableHLOCompositeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStableHLOCompositeOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StableHLOCompositeOptions> CreateStableHLOCompositeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StableHLOCompositeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StableHLOCompositeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _decomposition_subgraph_index = _o->decomposition_subgraph_index;
  auto _composite_attributes = _o->composite_attributes.size() ? _fbb.CreateVector(_o->composite_attributes) : 0;
  auto _composite_attributes_format = _o->composite_attributes_format;
  auto _version = _o->version;
  return tflite::CreateStableHLOCompositeOptions(
      _fbb,
      _name,
      _decomposition_subgraph_index,
      _composite_attributes,
      _composite_attributes_format,
      _version);
}

inline OperatorT *Operator::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OperatorT>(new OperatorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Operator::UnPackTo(OperatorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opcode_index(); _o->opcode_index = _e; }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } else { _o->inputs.resize(0); } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } else { _o->outputs.resize(0); } }
  { auto _e = builtin_options_type(); _o->builtin_options.type = _e; }
  { auto _e = builtin_options(); if (_e) _o->builtin_options.value = tflite::BuiltinOptionsUnion::UnPack(_e, builtin_options_type(), _resolver); }
  { auto _e = custom_options(); if (_e) { _o->custom_options.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->custom_options.begin()); } }
  { auto _e = custom_options_format(); _o->custom_options_format = _e; }
  { auto _e = mutating_variable_inputs(); if (_e) { _o->mutating_variable_inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0; } } else { _o->mutating_variable_inputs.resize(0); } }
  { auto _e = intermediates(); if (_e) { _o->intermediates.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intermediates[_i] = _e->Get(_i); } } else { _o->intermediates.resize(0); } }
  { auto _e = large_custom_options_offset(); _o->large_custom_options_offset = _e; }
  { auto _e = large_custom_options_size(); _o->large_custom_options_size = _e; }
  { auto _e = builtin_options_2_type(); _o->builtin_options_2.type = _e; }
  { auto _e = builtin_options_2(); if (_e) _o->builtin_options_2.value = tflite::BuiltinOptions2Union::UnPack(_e, builtin_options_2_type(), _resolver); }
}

inline ::flatbuffers::Offset<Operator> Operator::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperator(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Operator> CreateOperator(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OperatorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opcode_index = _o->opcode_index;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _builtin_options_type = _o->builtin_options.type;
  auto _builtin_options = _o->builtin_options.Pack(_fbb);
  auto _custom_options = _o->custom_options.size() ? _fbb.CreateVector(_o->custom_options) : 0;
  auto _custom_options_format = _o->custom_options_format;
  auto _mutating_variable_inputs = _o->mutating_variable_inputs.size() ? _fbb.CreateVector(_o->mutating_variable_inputs) : 0;
  auto _intermediates = _o->intermediates.size() ? _fbb.CreateVector(_o->intermediates) : 0;
  auto _large_custom_options_offset = _o->large_custom_options_offset;
  auto _large_custom_options_size = _o->large_custom_options_size;
  auto _builtin_options_2_type = _o->builtin_options_2.type;
  auto _builtin_options_2 = _o->builtin_options_2.Pack(_fbb);
  return tflite::CreateOperator(
      _fbb,
      _opcode_index,
      _inputs,
      _outputs,
      _builtin_options_type,
      _builtin_options,
      _custom_options,
      _custom_options_format,
      _mutating_variable_inputs,
      _intermediates,
      _large_custom_options_offset,
      _large_custom_options_size,
      _builtin_options_2_type,
      _builtin_options_2);
}

inline SubGraphT::SubGraphT(const SubGraphT &o)
      : inputs(o.inputs),
        outputs(o.outputs),
        name(o.name) {
  tensors.reserve(o.tensors.size());
  for (const auto &tensors_ : o.tensors) { tensors.emplace_back((tensors_) ? new tflite::TensorT(*tensors_) : nullptr); }
  operators.reserve(o.operators.size());
  for (const auto &operators_ : o.operators) { operators.emplace_back((operators_) ? new tflite::OperatorT(*operators_) : nullptr); }
}

inline SubGraphT &SubGraphT::operator=(SubGraphT o) FLATBUFFERS_NOEXCEPT {
  std::swap(tensors, o.tensors);
  std::swap(inputs, o.inputs);
  std::swap(outputs, o.outputs);
  std::swap(operators, o.operators);
  std::swap(name, o.name);
  return *this;
}

inline SubGraphT *SubGraph::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubGraphT>(new SubGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubGraph::UnPackTo(SubGraphT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tensors[_i]) { _e->Get(_i)->UnPackTo(_o->tensors[_i].get(), _resolver); } else { _o->tensors[_i] = std::unique_ptr<tflite::TensorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tensors.resize(0); } }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } else { _o->inputs.resize(0); } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } else { _o->outputs.resize(0); } }
  { auto _e = operators(); if (_e) { _o->operators.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->operators[_i]) { _e->Get(_i)->UnPackTo(_o->operators[_i].get(), _resolver); } else { _o->operators[_i] = std::unique_ptr<tflite::OperatorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->operators.resize(0); } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline ::flatbuffers::Offset<SubGraph> SubGraph::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraph(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SubGraph> CreateSubGraph(::flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Tensor>> (_o->tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _operators = _o->operators.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Operator>> (_o->operators.size(), [](size_t i, _VectorArgs *__va) { return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return tflite::CreateSubGraph(
      _fbb,
      _tensors,
      _inputs,
      _outputs,
      _operators,
      _name);
}

inline BufferT *Buffer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BufferT>(new BufferT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Buffer::UnPackTo(BufferT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline ::flatbuffers::Offset<Buffer> Buffer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBuffer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Buffer> CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BufferT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->data.size(), sizeof(uint8_t), 16);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  auto _offset = _o->offset;
  auto _size = _o->size;
  return tflite::CreateBuffer(
      _fbb,
      _data,
      _offset,
      _size);
}

inline MetadataT *Metadata::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MetadataT>(new MetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Metadata::UnPackTo(MetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = buffer(); _o->buffer = _e; }
}

inline ::flatbuffers::Offset<Metadata> Metadata::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Metadata> CreateMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _buffer = _o->buffer;
  return tflite::CreateMetadata(
      _fbb,
      _name,
      _buffer);
}

inline TensorMapT *TensorMap::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorMapT>(new TensorMapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorMap::UnPackTo(TensorMapT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = tensor_index(); _o->tensor_index = _e; }
}

inline ::flatbuffers::Offset<TensorMap> TensorMap::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorMap(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TensorMap> CreateTensorMap(::flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TensorMapT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _tensor_index = _o->tensor_index;
  return tflite::CreateTensorMap(
      _fbb,
      _name,
      _tensor_index);
}

inline SignatureDefT::SignatureDefT(const SignatureDefT &o)
      : signature_key(o.signature_key),
        subgraph_index(o.subgraph_index) {
  inputs.reserve(o.inputs.size());
  for (const auto &inputs_ : o.inputs) { inputs.emplace_back((inputs_) ? new tflite::TensorMapT(*inputs_) : nullptr); }
  outputs.reserve(o.outputs.size());
  for (const auto &outputs_ : o.outputs) { outputs.emplace_back((outputs_) ? new tflite::TensorMapT(*outputs_) : nullptr); }
}

inline SignatureDefT &SignatureDefT::operator=(SignatureDefT o) FLATBUFFERS_NOEXCEPT {
  std::swap(inputs, o.inputs);
  std::swap(outputs, o.outputs);
  std::swap(signature_key, o.signature_key);
  std::swap(subgraph_index, o.subgraph_index);
  return *this;
}

inline SignatureDefT *SignatureDef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignatureDefT>(new SignatureDefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignatureDef::UnPackTo(SignatureDefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->inputs[_i]) { _e->Get(_i)->UnPackTo(_o->inputs[_i].get(), _resolver); } else { _o->inputs[_i] = std::unique_ptr<tflite::TensorMapT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->inputs.resize(0); } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->outputs[_i]) { _e->Get(_i)->UnPackTo(_o->outputs[_i].get(), _resolver); } else { _o->outputs[_i] = std::unique_ptr<tflite::TensorMapT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->outputs.resize(0); } }
  { auto _e = signature_key(); if (_e) _o->signature_key = _e->str(); }
  { auto _e = subgraph_index(); _o->subgraph_index = _e; }
}

inline ::flatbuffers::Offset<SignatureDef> SignatureDef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignatureDef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SignatureDef> CreateSignatureDef(::flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SignatureDefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMap>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMap>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _signature_key = _o->signature_key.empty() ? 0 : _fbb.CreateString(_o->signature_key);
  auto _subgraph_index = _o->subgraph_index;
  return tflite::CreateSignatureDef(
      _fbb,
      _inputs,
      _outputs,
      _signature_key,
      _subgraph_index);
}

inline ModelT::ModelT(const ModelT &o)
      : version(o.version),
        description(o.description),
        metadata_buffer(o.metadata_buffer) {
  operator_codes.reserve(o.operator_codes.size());
  for (const auto &operator_codes_ : o.operator_codes) { operator_codes.emplace_back((operator_codes_) ? new tflite::OperatorCodeT(*operator_codes_) : nullptr); }
  subgraphs.reserve(o.subgraphs.size());
  for (const auto &subgraphs_ : o.subgraphs) { subgraphs.emplace_back((subgraphs_) ? new tflite::SubGraphT(*subgraphs_) : nullptr); }
  buffers.reserve(o.buffers.size());
  for (const auto &buffers_ : o.buffers) { buffers.emplace_back((buffers_) ? new tflite::BufferT(*buffers_) : nullptr); }
  metadata.reserve(o.metadata.size());
  for (const auto &metadata_ : o.metadata) { metadata.emplace_back((metadata_) ? new tflite::MetadataT(*metadata_) : nullptr); }
  signature_defs.reserve(o.signature_defs.size());
  for (const auto &signature_defs_ : o.signature_defs) { signature_defs.emplace_back((signature_defs_) ? new tflite::SignatureDefT(*signature_defs_) : nullptr); }
}

inline ModelT &ModelT::operator=(ModelT o) FLATBUFFERS_NOEXCEPT {
  std::swap(version, o.version);
  std::swap(operator_codes, o.operator_codes);
  std::swap(subgraphs, o.subgraphs);
  std::swap(description, o.description);
  std::swap(buffers, o.buffers);
  std::swap(metadata_buffer, o.metadata_buffer);
  std::swap(metadata, o.metadata);
  std::swap(signature_defs, o.signature_defs);
  return *this;
}

inline ModelT *Model::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ModelT>(new ModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Model::UnPackTo(ModelT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
  { auto _e = operator_codes(); if (_e) { _o->operator_codes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->operator_codes[_i]) { _e->Get(_i)->UnPackTo(_o->operator_codes[_i].get(), _resolver); } else { _o->operator_codes[_i] = std::unique_ptr<tflite::OperatorCodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->operator_codes.resize(0); } }
  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->subgraphs[_i]) { _e->Get(_i)->UnPackTo(_o->subgraphs[_i].get(), _resolver); } else { _o->subgraphs[_i] = std::unique_ptr<tflite::SubGraphT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->subgraphs.resize(0); } }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->buffers[_i]) { _e->Get(_i)->UnPackTo(_o->buffers[_i].get(), _resolver); } else { _o->buffers[_i] = std::unique_ptr<tflite::BufferT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->buffers.resize(0); } }
  { auto _e = metadata_buffer(); if (_e) { _o->metadata_buffer.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata_buffer[_i] = _e->Get(_i); } } else { _o->metadata_buffer.resize(0); } }
  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->metadata[_i]) { _e->Get(_i)->UnPackTo(_o->metadata[_i].get(), _resolver); } else { _o->metadata[_i] = std::unique_ptr<tflite::MetadataT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->metadata.resize(0); } }
  { auto _e = signature_defs(); if (_e) { _o->signature_defs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->signature_defs[_i]) { _e->Get(_i)->UnPackTo(_o->signature_defs[_i].get(), _resolver); } else { _o->signature_defs[_i] = std::unique_ptr<tflite::SignatureDefT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->signature_defs.resize(0); } }
}

inline ::flatbuffers::Offset<Model> Model::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModel(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Model> CreateModel(::flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  auto _operator_codes = _o->operator_codes.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::OperatorCode>> (_o->operator_codes.size(), [](size_t i, _VectorArgs *__va) { return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SubGraph>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Buffer>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _metadata_buffer = _o->metadata_buffer.size() ? _fbb.CreateVector(_o->metadata_buffer) : 0;
  auto _metadata = _o->metadata.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Metadata>> (_o->metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateMetadata(*__va->__fbb, __va->__o->metadata[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _signature_defs = _o->signature_defs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SignatureDef>> (_o->signature_defs.size(), [](size_t i, _VectorArgs *__va) { return CreateSignatureDef(*__va->__fbb, __va->__o->signature_defs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::CreateModel(
      _fbb,
      _version,
      _operator_codes,
      _subgraphs,
      _description,
      _buffers,
      _metadata_buffer,
      _metadata,
      _signature_defs);
}

inline bool VerifyQuantizationDetails(::flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {
  switch (type) {
    case QuantizationDetails_NONE: {
      return true;
    }
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyQuantizationDetailsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizationDetails(
        verifier,  values->Get(i), types->GetEnum<QuantizationDetails>(i))) {
      return false;
    }
  }
  return true;
}

inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetails type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantization *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> QuantizationDetailsUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantizationT *>(value);
      return CreateCustomQuantization(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline QuantizationDetailsUnion::QuantizationDetailsUnion(const QuantizationDetailsUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      value = new tflite::CustomQuantizationT(*reinterpret_cast<tflite::CustomQuantizationT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void QuantizationDetailsUnion::Reset() {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<tflite::CustomQuantizationT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = QuantizationDetails_NONE;
}

inline bool VerifySparseIndexVector(::flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type) {
  switch (type) {
    case SparseIndexVector_NONE: {
      return true;
    }
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const tflite::Int32Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint16Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint8Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySparseIndexVectorVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySparseIndexVector(
        verifier,  values->Get(i), types->GetEnum<SparseIndexVector>(i))) {
      return false;
    }
  }
  return true;
}

inline void *SparseIndexVectorUnion::UnPack(const void *obj, SparseIndexVector type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const tflite::Int32Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint16Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint8Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> SparseIndexVectorUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const tflite::Int32VectorT *>(value);
      return CreateInt32Vector(_fbb, ptr, _rehasher).Union();
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint16VectorT *>(value);
      return CreateUint16Vector(_fbb, ptr, _rehasher).Union();
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint8VectorT *>(value);
      return CreateUint8Vector(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline SparseIndexVectorUnion::SparseIndexVectorUnion(const SparseIndexVectorUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      value = new tflite::Int32VectorT(*reinterpret_cast<tflite::Int32VectorT *>(u.value));
      break;
    }
    case SparseIndexVector_Uint16Vector: {
      value = new tflite::Uint16VectorT(*reinterpret_cast<tflite::Uint16VectorT *>(u.value));
      break;
    }
    case SparseIndexVector_Uint8Vector: {
      value = new tflite::Uint8VectorT(*reinterpret_cast<tflite::Uint8VectorT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void SparseIndexVectorUnion::Reset() {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<tflite::Int32VectorT *>(value);
      delete ptr;
      break;
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<tflite::Uint16VectorT *>(value);
      delete ptr;
      break;
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<tflite::Uint8VectorT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = SparseIndexVector_NONE;
}

inline bool VerifyBuiltinOptions(::flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {
  switch (type) {
    case BuiltinOptions_NONE: {
      return true;
    }
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const tflite::UniqueOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const tflite::ReverseV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const tflite::AddNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const tflite::CosOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const tflite::WhereOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const tflite::RankOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::QuantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const tflite::HardSwishOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const tflite::IfOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const tflite::WhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const tflite::ScatterNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const tflite::SelectV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const tflite::DensifyOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::SegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchMatMulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const tflite::CumsumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOnceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const tflite::BroadcastToOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const tflite::Rfft2dOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv3DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableFindOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableImportOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableSizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const tflite::VarHandleOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::ReadVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::AssignVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const tflite::RandomOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const tflite::BucketizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const tflite::GeluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::DynamicUpdateSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentProdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ATan2Options: {
      auto ptr = reinterpret_cast<const tflite::ATan2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SignOptions: {
      auto ptr = reinterpret_cast<const tflite::SignOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BitcastOptions: {
      auto ptr = reinterpret_cast<const tflite::BitcastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BitwiseXorOptions: {
      auto ptr = reinterpret_cast<const tflite::BitwiseXorOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RightShiftOptions: {
      auto ptr = reinterpret_cast<const tflite::RightShiftOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBuiltinOptionsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions(
        verifier,  values->Get(i), types->GetEnum<BuiltinOptions>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const tflite::UniqueOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const tflite::ReverseV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const tflite::AddNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherNdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const tflite::CosOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const tflite::WhereOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const tflite::RankOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixDiagOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::QuantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const tflite::HardSwishOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const tflite::IfOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const tflite::WhileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const tflite::ScatterNdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const tflite::SelectV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const tflite::DensifyOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::SegmentSumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchMatMulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const tflite::CumsumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOnceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const tflite::BroadcastToOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const tflite::Rfft2dOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv3DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableFindOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableImportOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableSizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const tflite::VarHandleOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::ReadVariableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::AssignVariableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const tflite::RandomOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const tflite::BucketizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const tflite::GeluOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::DynamicUpdateSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentProdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentMaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentMinOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentSumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ATan2Options: {
      auto ptr = reinterpret_cast<const tflite::ATan2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SignOptions: {
      auto ptr = reinterpret_cast<const tflite::SignOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BitcastOptions: {
      auto ptr = reinterpret_cast<const tflite::BitcastOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BitwiseXorOptions: {
      auto ptr = reinterpret_cast<const tflite::BitwiseXorOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RightShiftOptions: {
      auto ptr = reinterpret_cast<const tflite::RightShiftOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> BuiltinOptionsUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptionsT *>(value);
      return CreateConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value);
      return CreateDepthwiseConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value);
      return CreateConcatEmbeddingsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value);
      return CreateLSHProjectionOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptionsT *>(value);
      return CreatePool2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptionsT *>(value);
      return CreateSVDFOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptionsT *>(value);
      return CreateRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value);
      return CreateFullyConnectedOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptionsT *>(value);
      return CreateSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptionsT *>(value);
      return CreateConcatenationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptionsT *>(value);
      return CreateAddOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptionsT *>(value);
      return CreateL2NormOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value);
      return CreateLocalResponseNormalizationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptionsT *>(value);
      return CreateLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value);
      return CreateResizeBilinearOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptionsT *>(value);
      return CreateCallOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptionsT *>(value);
      return CreateReshapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptionsT *>(value);
      return CreateSkipGramOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value);
      return CreateSpaceToDepthOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value);
      return CreateEmbeddingLookupSparseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptionsT *>(value);
      return CreateMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptionsT *>(value);
      return CreatePadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptionsT *>(value);
      return CreateGatherOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value);
      return CreateBatchToSpaceNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value);
      return CreateSpaceToBatchNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptionsT *>(value);
      return CreateTransposeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptionsT *>(value);
      return CreateReducerOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptionsT *>(value);
      return CreateSubOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptionsT *>(value);
      return CreateDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptionsT *>(value);
      return CreateSqueezeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value);
      return CreateSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptionsT *>(value);
      return CreateStridedSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptionsT *>(value);
      return CreateExpOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2OptionsT *>(value);
      return CreateTopKV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptionsT *>(value);
      return CreateSplitOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value);
      return CreateLogSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptionsT *>(value);
      return CreateCastOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptionsT *>(value);
      return CreateDequantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value);
      return CreateMaximumMinimumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptionsT *>(value);
      return CreateArgMaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptionsT *>(value);
      return CreateLessOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptionsT *>(value);
      return CreateNegOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2OptionsT *>(value);
      return CreatePadV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptionsT *>(value);
      return CreateGreaterOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value);
      return CreateGreaterEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptionsT *>(value);
      return CreateLessEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptionsT *>(value);
      return CreateSelectOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptionsT *>(value);
      return CreateSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptionsT *>(value);
      return CreateTransposeConvOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value);
      return CreateSparseToDenseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptionsT *>(value);
      return CreateTileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value);
      return CreateExpandDimsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptionsT *>(value);
      return CreateEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptionsT *>(value);
      return CreateNotEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptionsT *>(value);
      return CreateShapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptionsT *>(value);
      return CreatePowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptionsT *>(value);
      return CreateArgMinOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptionsT *>(value);
      return CreateFakeQuantOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptionsT *>(value);
      return CreatePackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptionsT *>(value);
      return CreateLogicalOrOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptionsT *>(value);
      return CreateOneHotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptionsT *>(value);
      return CreateLogicalAndOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptionsT *>(value);
      return CreateLogicalNotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptionsT *>(value);
      return CreateUnpackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptionsT *>(value);
      return CreateFloorDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptionsT *>(value);
      return CreateSquareOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value);
      return CreateZerosLikeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptionsT *>(value);
      return CreateFillOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptionsT *>(value);
      return CreateBidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptionsT *>(value);
      return CreateBidirectionalSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptionsT *>(value);
      return CreateUnidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptionsT *>(value);
      return CreateFloorModOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptionsT *>(value);
      return CreateRangeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptionsT *>(value);
      return CreateResizeNearestNeighborOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptionsT *>(value);
      return CreateLeakyReluOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptionsT *>(value);
      return CreateSquaredDifferenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptionsT *>(value);
      return CreateMirrorPadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptionsT *>(value);
      return CreateAbsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptionsT *>(value);
      return CreateSplitVOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const tflite::UniqueOptionsT *>(value);
      return CreateUniqueOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const tflite::ReverseV2OptionsT *>(value);
      return CreateReverseV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const tflite::AddNOptionsT *>(value);
      return CreateAddNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherNdOptionsT *>(value);
      return CreateGatherNdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const tflite::CosOptionsT *>(value);
      return CreateCosOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const tflite::WhereOptionsT *>(value);
      return CreateWhereOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const tflite::RankOptionsT *>(value);
      return CreateRankOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptionsT *>(value);
      return CreateReverseSequenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixDiagOptionsT *>(value);
      return CreateMatrixDiagOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::QuantizeOptionsT *>(value);
      return CreateQuantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptionsT *>(value);
      return CreateMatrixSetDiagOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const tflite::HardSwishOptionsT *>(value);
      return CreateHardSwishOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const tflite::IfOptionsT *>(value);
      return CreateIfOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const tflite::WhileOptionsT *>(value);
      return CreateWhileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptionsT *>(value);
      return CreateDepthToSpaceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4OptionsT *>(value);
      return CreateNonMaxSuppressionV4Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5OptionsT *>(value);
      return CreateNonMaxSuppressionV5Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const tflite::ScatterNdOptionsT *>(value);
      return CreateScatterNdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const tflite::SelectV2OptionsT *>(value);
      return CreateSelectV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const tflite::DensifyOptionsT *>(value);
      return CreateDensifyOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::SegmentSumOptionsT *>(value);
      return CreateSegmentSumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchMatMulOptionsT *>(value);
      return CreateBatchMatMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const tflite::CumsumOptionsT *>(value);
      return CreateCumsumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOnceOptionsT *>(value);
      return CreateCallOnceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const tflite::BroadcastToOptionsT *>(value);
      return CreateBroadcastToOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const tflite::Rfft2dOptionsT *>(value);
      return CreateRfft2dOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv3DOptionsT *>(value);
      return CreateConv3DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableOptionsT *>(value);
      return CreateHashtableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableFindOptionsT *>(value);
      return CreateHashtableFindOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableImportOptionsT *>(value);
      return CreateHashtableImportOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableSizeOptionsT *>(value);
      return CreateHashtableSizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const tflite::VarHandleOptionsT *>(value);
      return CreateVarHandleOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::ReadVariableOptionsT *>(value);
      return CreateReadVariableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::AssignVariableOptionsT *>(value);
      return CreateAssignVariableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const tflite::RandomOptionsT *>(value);
      return CreateRandomOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const tflite::BucketizeOptionsT *>(value);
      return CreateBucketizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const tflite::GeluOptionsT *>(value);
      return CreateGeluOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::DynamicUpdateSliceOptionsT *>(value);
      return CreateDynamicUpdateSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentProdOptionsT *>(value);
      return CreateUnsortedSegmentProdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentMaxOptionsT *>(value);
      return CreateUnsortedSegmentMaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentMinOptionsT *>(value);
      return CreateUnsortedSegmentMinOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::UnsortedSegmentSumOptionsT *>(value);
      return CreateUnsortedSegmentSumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ATan2Options: {
      auto ptr = reinterpret_cast<const tflite::ATan2OptionsT *>(value);
      return CreateATan2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SignOptions: {
      auto ptr = reinterpret_cast<const tflite::SignOptionsT *>(value);
      return CreateSignOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BitcastOptions: {
      auto ptr = reinterpret_cast<const tflite::BitcastOptionsT *>(value);
      return CreateBitcastOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BitwiseXorOptions: {
      auto ptr = reinterpret_cast<const tflite::BitwiseXorOptionsT *>(value);
      return CreateBitwiseXorOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RightShiftOptions: {
      auto ptr = reinterpret_cast<const tflite::RightShiftOptionsT *>(value);
      return CreateRightShiftOptions(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BuiltinOptionsUnion::BuiltinOptionsUnion(const BuiltinOptionsUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      value = new tflite::Conv2DOptionsT(*reinterpret_cast<tflite::Conv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      value = new tflite::DepthwiseConv2DOptionsT(*reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      value = new tflite::ConcatEmbeddingsOptionsT(*reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSHProjectionOptions: {
      value = new tflite::LSHProjectionOptionsT(*reinterpret_cast<tflite::LSHProjectionOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Pool2DOptions: {
      value = new tflite::Pool2DOptionsT(*reinterpret_cast<tflite::Pool2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SVDFOptions: {
      value = new tflite::SVDFOptionsT(*reinterpret_cast<tflite::SVDFOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RNNOptions: {
      value = new tflite::RNNOptionsT(*reinterpret_cast<tflite::RNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FullyConnectedOptions: {
      value = new tflite::FullyConnectedOptionsT(*reinterpret_cast<tflite::FullyConnectedOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SoftmaxOptions: {
      value = new tflite::SoftmaxOptionsT(*reinterpret_cast<tflite::SoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatenationOptions: {
      value = new tflite::ConcatenationOptionsT(*reinterpret_cast<tflite::ConcatenationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddOptions: {
      value = new tflite::AddOptionsT(*reinterpret_cast<tflite::AddOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_L2NormOptions: {
      value = new tflite::L2NormOptionsT(*reinterpret_cast<tflite::L2NormOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      value = new tflite::LocalResponseNormalizationOptionsT(*reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSTMOptions: {
      value = new tflite::LSTMOptionsT(*reinterpret_cast<tflite::LSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      value = new tflite::ResizeBilinearOptionsT(*reinterpret_cast<tflite::ResizeBilinearOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOptions: {
      value = new tflite::CallOptionsT(*reinterpret_cast<tflite::CallOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReshapeOptions: {
      value = new tflite::ReshapeOptionsT(*reinterpret_cast<tflite::ReshapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SkipGramOptions: {
      value = new tflite::SkipGramOptionsT(*reinterpret_cast<tflite::SkipGramOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      value = new tflite::SpaceToDepthOptionsT(*reinterpret_cast<tflite::SpaceToDepthOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      value = new tflite::EmbeddingLookupSparseOptionsT(*reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MulOptions: {
      value = new tflite::MulOptionsT(*reinterpret_cast<tflite::MulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadOptions: {
      value = new tflite::PadOptionsT(*reinterpret_cast<tflite::PadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherOptions: {
      value = new tflite::GatherOptionsT(*reinterpret_cast<tflite::GatherOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      value = new tflite::BatchToSpaceNDOptionsT(*reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      value = new tflite::SpaceToBatchNDOptionsT(*reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeOptions: {
      value = new tflite::TransposeOptionsT(*reinterpret_cast<tflite::TransposeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReducerOptions: {
      value = new tflite::ReducerOptionsT(*reinterpret_cast<tflite::ReducerOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SubOptions: {
      value = new tflite::SubOptionsT(*reinterpret_cast<tflite::SubOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DivOptions: {
      value = new tflite::DivOptionsT(*reinterpret_cast<tflite::DivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SqueezeOptions: {
      value = new tflite::SqueezeOptionsT(*reinterpret_cast<tflite::SqueezeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SequenceRNNOptions: {
      value = new tflite::SequenceRNNOptionsT(*reinterpret_cast<tflite::SequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_StridedSliceOptions: {
      value = new tflite::StridedSliceOptionsT(*reinterpret_cast<tflite::StridedSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpOptions: {
      value = new tflite::ExpOptionsT(*reinterpret_cast<tflite::ExpOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TopKV2Options: {
      value = new tflite::TopKV2OptionsT(*reinterpret_cast<tflite::TopKV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitOptions: {
      value = new tflite::SplitOptionsT(*reinterpret_cast<tflite::SplitOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      value = new tflite::LogSoftmaxOptionsT(*reinterpret_cast<tflite::LogSoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CastOptions: {
      value = new tflite::CastOptionsT(*reinterpret_cast<tflite::CastOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DequantizeOptions: {
      value = new tflite::DequantizeOptionsT(*reinterpret_cast<tflite::DequantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      value = new tflite::MaximumMinimumOptionsT(*reinterpret_cast<tflite::MaximumMinimumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMaxOptions: {
      value = new tflite::ArgMaxOptionsT(*reinterpret_cast<tflite::ArgMaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessOptions: {
      value = new tflite::LessOptionsT(*reinterpret_cast<tflite::LessOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NegOptions: {
      value = new tflite::NegOptionsT(*reinterpret_cast<tflite::NegOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadV2Options: {
      value = new tflite::PadV2OptionsT(*reinterpret_cast<tflite::PadV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterOptions: {
      value = new tflite::GreaterOptionsT(*reinterpret_cast<tflite::GreaterOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterEqualOptions: {
      value = new tflite::GreaterEqualOptionsT(*reinterpret_cast<tflite::GreaterEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessEqualOptions: {
      value = new tflite::LessEqualOptionsT(*reinterpret_cast<tflite::LessEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectOptions: {
      value = new tflite::SelectOptionsT(*reinterpret_cast<tflite::SelectOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SliceOptions: {
      value = new tflite::SliceOptionsT(*reinterpret_cast<tflite::SliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeConvOptions: {
      value = new tflite::TransposeConvOptionsT(*reinterpret_cast<tflite::TransposeConvOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SparseToDenseOptions: {
      value = new tflite::SparseToDenseOptionsT(*reinterpret_cast<tflite::SparseToDenseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TileOptions: {
      value = new tflite::TileOptionsT(*reinterpret_cast<tflite::TileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpandDimsOptions: {
      value = new tflite::ExpandDimsOptionsT(*reinterpret_cast<tflite::ExpandDimsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EqualOptions: {
      value = new tflite::EqualOptionsT(*reinterpret_cast<tflite::EqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NotEqualOptions: {
      value = new tflite::NotEqualOptionsT(*reinterpret_cast<tflite::NotEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ShapeOptions: {
      value = new tflite::ShapeOptionsT(*reinterpret_cast<tflite::ShapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PowOptions: {
      value = new tflite::PowOptionsT(*reinterpret_cast<tflite::PowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMinOptions: {
      value = new tflite::ArgMinOptionsT(*reinterpret_cast<tflite::ArgMinOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FakeQuantOptions: {
      value = new tflite::FakeQuantOptionsT(*reinterpret_cast<tflite::FakeQuantOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PackOptions: {
      value = new tflite::PackOptionsT(*reinterpret_cast<tflite::PackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalOrOptions: {
      value = new tflite::LogicalOrOptionsT(*reinterpret_cast<tflite::LogicalOrOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_OneHotOptions: {
      value = new tflite::OneHotOptionsT(*reinterpret_cast<tflite::OneHotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalAndOptions: {
      value = new tflite::LogicalAndOptionsT(*reinterpret_cast<tflite::LogicalAndOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalNotOptions: {
      value = new tflite::LogicalNotOptionsT(*reinterpret_cast<tflite::LogicalNotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnpackOptions: {
      value = new tflite::UnpackOptionsT(*reinterpret_cast<tflite::UnpackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorDivOptions: {
      value = new tflite::FloorDivOptionsT(*reinterpret_cast<tflite::FloorDivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquareOptions: {
      value = new tflite::SquareOptionsT(*reinterpret_cast<tflite::SquareOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ZerosLikeOptions: {
      value = new tflite::ZerosLikeOptionsT(*reinterpret_cast<tflite::ZerosLikeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FillOptions: {
      value = new tflite::FillOptionsT(*reinterpret_cast<tflite::FillOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      value = new tflite::BidirectionalSequenceLSTMOptionsT(*reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      value = new tflite::BidirectionalSequenceRNNOptionsT(*reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      value = new tflite::UnidirectionalSequenceLSTMOptionsT(*reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorModOptions: {
      value = new tflite::FloorModOptionsT(*reinterpret_cast<tflite::FloorModOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RangeOptions: {
      value = new tflite::RangeOptionsT(*reinterpret_cast<tflite::RangeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      value = new tflite::ResizeNearestNeighborOptionsT(*reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LeakyReluOptions: {
      value = new tflite::LeakyReluOptionsT(*reinterpret_cast<tflite::LeakyReluOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      value = new tflite::SquaredDifferenceOptionsT(*reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MirrorPadOptions: {
      value = new tflite::MirrorPadOptionsT(*reinterpret_cast<tflite::MirrorPadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AbsOptions: {
      value = new tflite::AbsOptionsT(*reinterpret_cast<tflite::AbsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitVOptions: {
      value = new tflite::SplitVOptionsT(*reinterpret_cast<tflite::SplitVOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UniqueOptions: {
      value = new tflite::UniqueOptionsT(*reinterpret_cast<tflite::UniqueOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReverseV2Options: {
      value = new tflite::ReverseV2OptionsT(*reinterpret_cast<tflite::ReverseV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddNOptions: {
      value = new tflite::AddNOptionsT(*reinterpret_cast<tflite::AddNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherNdOptions: {
      value = new tflite::GatherNdOptionsT(*reinterpret_cast<tflite::GatherNdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CosOptions: {
      value = new tflite::CosOptionsT(*reinterpret_cast<tflite::CosOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_WhereOptions: {
      value = new tflite::WhereOptionsT(*reinterpret_cast<tflite::WhereOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RankOptions: {
      value = new tflite::RankOptionsT(*reinterpret_cast<tflite::RankOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      value = new tflite::ReverseSequenceOptionsT(*reinterpret_cast<tflite::ReverseSequenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MatrixDiagOptions: {
      value = new tflite::MatrixDiagOptionsT(*reinterpret_cast<tflite::MatrixDiagOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_QuantizeOptions: {
      value = new tflite::QuantizeOptionsT(*reinterpret_cast<tflite::QuantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      value = new tflite::MatrixSetDiagOptionsT(*reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HardSwishOptions: {
      value = new tflite::HardSwishOptionsT(*reinterpret_cast<tflite::HardSwishOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_IfOptions: {
      value = new tflite::IfOptionsT(*reinterpret_cast<tflite::IfOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_WhileOptions: {
      value = new tflite::WhileOptionsT(*reinterpret_cast<tflite::WhileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      value = new tflite::DepthToSpaceOptionsT(*reinterpret_cast<tflite::DepthToSpaceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      value = new tflite::NonMaxSuppressionV4OptionsT(*reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      value = new tflite::NonMaxSuppressionV5OptionsT(*reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ScatterNdOptions: {
      value = new tflite::ScatterNdOptionsT(*reinterpret_cast<tflite::ScatterNdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectV2Options: {
      value = new tflite::SelectV2OptionsT(*reinterpret_cast<tflite::SelectV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DensifyOptions: {
      value = new tflite::DensifyOptionsT(*reinterpret_cast<tflite::DensifyOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SegmentSumOptions: {
      value = new tflite::SegmentSumOptionsT(*reinterpret_cast<tflite::SegmentSumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchMatMulOptions: {
      value = new tflite::BatchMatMulOptionsT(*reinterpret_cast<tflite::BatchMatMulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CumsumOptions: {
      value = new tflite::CumsumOptionsT(*reinterpret_cast<tflite::CumsumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOnceOptions: {
      value = new tflite::CallOnceOptionsT(*reinterpret_cast<tflite::CallOnceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BroadcastToOptions: {
      value = new tflite::BroadcastToOptionsT(*reinterpret_cast<tflite::BroadcastToOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Rfft2dOptions: {
      value = new tflite::Rfft2dOptionsT(*reinterpret_cast<tflite::Rfft2dOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Conv3DOptions: {
      value = new tflite::Conv3DOptionsT(*reinterpret_cast<tflite::Conv3DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableOptions: {
      value = new tflite::HashtableOptionsT(*reinterpret_cast<tflite::HashtableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableFindOptions: {
      value = new tflite::HashtableFindOptionsT(*reinterpret_cast<tflite::HashtableFindOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableImportOptions: {
      value = new tflite::HashtableImportOptionsT(*reinterpret_cast<tflite::HashtableImportOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableSizeOptions: {
      value = new tflite::HashtableSizeOptionsT(*reinterpret_cast<tflite::HashtableSizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_VarHandleOptions: {
      value = new tflite::VarHandleOptionsT(*reinterpret_cast<tflite::VarHandleOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReadVariableOptions: {
      value = new tflite::ReadVariableOptionsT(*reinterpret_cast<tflite::ReadVariableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AssignVariableOptions: {
      value = new tflite::AssignVariableOptionsT(*reinterpret_cast<tflite::AssignVariableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RandomOptions: {
      value = new tflite::RandomOptionsT(*reinterpret_cast<tflite::RandomOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BucketizeOptions: {
      value = new tflite::BucketizeOptionsT(*reinterpret_cast<tflite::BucketizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GeluOptions: {
      value = new tflite::GeluOptionsT(*reinterpret_cast<tflite::GeluOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      value = new tflite::DynamicUpdateSliceOptionsT(*reinterpret_cast<tflite::DynamicUpdateSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      value = new tflite::UnsortedSegmentProdOptionsT(*reinterpret_cast<tflite::UnsortedSegmentProdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      value = new tflite::UnsortedSegmentMaxOptionsT(*reinterpret_cast<tflite::UnsortedSegmentMaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      value = new tflite::UnsortedSegmentMinOptionsT(*reinterpret_cast<tflite::UnsortedSegmentMinOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      value = new tflite::UnsortedSegmentSumOptionsT(*reinterpret_cast<tflite::UnsortedSegmentSumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ATan2Options: {
      value = new tflite::ATan2OptionsT(*reinterpret_cast<tflite::ATan2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SignOptions: {
      value = new tflite::SignOptionsT(*reinterpret_cast<tflite::SignOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BitcastOptions: {
      value = new tflite::BitcastOptionsT(*reinterpret_cast<tflite::BitcastOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BitwiseXorOptions: {
      value = new tflite::BitwiseXorOptionsT(*reinterpret_cast<tflite::BitwiseXorOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RightShiftOptions: {
      value = new tflite::RightShiftOptionsT(*reinterpret_cast<tflite::RightShiftOptionsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BuiltinOptionsUnion::Reset() {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<tflite::Conv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<tflite::LSHProjectionOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<tflite::Pool2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<tflite::SVDFOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<tflite::RNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<tflite::FullyConnectedOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<tflite::SoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<tflite::ConcatenationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<tflite::AddOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<tflite::L2NormOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<tflite::LSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<tflite::CallOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<tflite::ReshapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<tflite::SkipGramOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<tflite::MulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<tflite::PadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<tflite::GatherOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<tflite::TransposeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<tflite::ReducerOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<tflite::SubOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<tflite::DivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<tflite::SqueezeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<tflite::SequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<tflite::StridedSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<tflite::ExpOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<tflite::TopKV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<tflite::SplitOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<tflite::CastOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<tflite::DequantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<tflite::ArgMaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<tflite::LessOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<tflite::NegOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<tflite::PadV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<tflite::GreaterOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<tflite::GreaterEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<tflite::LessEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<tflite::SelectOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<tflite::SliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<tflite::TransposeConvOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<tflite::SparseToDenseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<tflite::TileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<tflite::ExpandDimsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<tflite::EqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<tflite::NotEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<tflite::ShapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<tflite::PowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<tflite::ArgMinOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<tflite::FakeQuantOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<tflite::PackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalOrOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<tflite::OneHotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalAndOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalNotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<tflite::UnpackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<tflite::FloorDivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<tflite::SquareOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<tflite::ZerosLikeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<tflite::FillOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<tflite::FloorModOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<tflite::RangeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<tflite::LeakyReluOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<tflite::MirrorPadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<tflite::AbsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<tflite::SplitVOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<tflite::UniqueOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<tflite::ReverseV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<tflite::AddNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<tflite::GatherNdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<tflite::CosOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<tflite::WhereOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<tflite::RankOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<tflite::ReverseSequenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<tflite::MatrixDiagOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<tflite::QuantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<tflite::HardSwishOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<tflite::IfOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<tflite::WhileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<tflite::DepthToSpaceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<tflite::ScatterNdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<tflite::SelectV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<tflite::DensifyOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<tflite::SegmentSumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<tflite::BatchMatMulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<tflite::CumsumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<tflite::CallOnceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<tflite::BroadcastToOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<tflite::Rfft2dOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<tflite::Conv3DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<tflite::HashtableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<tflite::HashtableFindOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<tflite::HashtableImportOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<tflite::HashtableSizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<tflite::VarHandleOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<tflite::ReadVariableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<tflite::AssignVariableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<tflite::RandomOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<tflite::BucketizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<tflite::GeluOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<tflite::DynamicUpdateSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnsortedSegmentProdOptions: {
      auto ptr = reinterpret_cast<tflite::UnsortedSegmentProdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnsortedSegmentMaxOptions: {
      auto ptr = reinterpret_cast<tflite::UnsortedSegmentMaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnsortedSegmentMinOptions: {
      auto ptr = reinterpret_cast<tflite::UnsortedSegmentMinOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnsortedSegmentSumOptions: {
      auto ptr = reinterpret_cast<tflite::UnsortedSegmentSumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ATan2Options: {
      auto ptr = reinterpret_cast<tflite::ATan2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SignOptions: {
      auto ptr = reinterpret_cast<tflite::SignOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BitcastOptions: {
      auto ptr = reinterpret_cast<tflite::BitcastOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BitwiseXorOptions: {
      auto ptr = reinterpret_cast<tflite::BitwiseXorOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RightShiftOptions: {
      auto ptr = reinterpret_cast<tflite::RightShiftOptionsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BuiltinOptions_NONE;
}

inline bool VerifyBuiltinOptions2(::flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions2 type) {
  switch (type) {
    case BuiltinOptions2_NONE: {
      return true;
    }
    case BuiltinOptions2_StablehloConcatenateOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloConcatenateOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloBroadcastInDimOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloConvolutionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloCustomCallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloReduceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloScatterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloCompareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloDynamicSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloPadOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloIotaOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloDotGeneralOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloReduceWindowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloSortOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloSortOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloWhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloGatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloTransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_DilateOptions: {
      auto ptr = reinterpret_cast<const tflite::DilateOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloRngBitGeneratorOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      auto ptr = reinterpret_cast<const tflite::ReduceWindowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      auto ptr = reinterpret_cast<const tflite::StableHLOCompositeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBuiltinOptions2Vector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions2(
        verifier,  values->Get(i), types->GetEnum<BuiltinOptions2>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BuiltinOptions2Union::UnPack(const void *obj, BuiltinOptions2 type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case BuiltinOptions2_StablehloConcatenateOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloConcatenateOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloBroadcastInDimOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloConvolutionOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloCustomCallOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloReduceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloScatterOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloCompareOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloDynamicSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloPadOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloPadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloIotaOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloDotGeneralOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloReduceWindowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloSortOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloSortOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloWhileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloGatherOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloTransposeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_DilateOptions: {
      auto ptr = reinterpret_cast<const tflite::DilateOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloRngBitGeneratorOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      auto ptr = reinterpret_cast<const tflite::ReduceWindowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      auto ptr = reinterpret_cast<const tflite::StableHLOCompositeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> BuiltinOptions2Union::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case BuiltinOptions2_StablehloConcatenateOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloConcatenateOptionsT *>(value);
      return CreateStablehloConcatenateOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloBroadcastInDimOptionsT *>(value);
      return CreateStablehloBroadcastInDimOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloSliceOptionsT *>(value);
      return CreateStablehloSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloConvolutionOptionsT *>(value);
      return CreateStablehloConvolutionOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloCustomCallOptionsT *>(value);
      return CreateStablehloCustomCallOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloReduceOptionsT *>(value);
      return CreateStablehloReduceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloScatterOptionsT *>(value);
      return CreateStablehloScatterOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloCompareOptionsT *>(value);
      return CreateStablehloCompareOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloDynamicSliceOptionsT *>(value);
      return CreateStablehloDynamicSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloPadOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloPadOptionsT *>(value);
      return CreateStablehloPadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloIotaOptionsT *>(value);
      return CreateStablehloIotaOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloDotGeneralOptionsT *>(value);
      return CreateStablehloDotGeneralOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloReduceWindowOptionsT *>(value);
      return CreateStablehloReduceWindowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloSortOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloSortOptionsT *>(value);
      return CreateStablehloSortOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloWhileOptionsT *>(value);
      return CreateStablehloWhileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloGatherOptionsT *>(value);
      return CreateStablehloGatherOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloTransposeOptionsT *>(value);
      return CreateStablehloTransposeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_DilateOptions: {
      auto ptr = reinterpret_cast<const tflite::DilateOptionsT *>(value);
      return CreateDilateOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      auto ptr = reinterpret_cast<const tflite::StablehloRngBitGeneratorOptionsT *>(value);
      return CreateStablehloRngBitGeneratorOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      auto ptr = reinterpret_cast<const tflite::ReduceWindowOptionsT *>(value);
      return CreateReduceWindowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      auto ptr = reinterpret_cast<const tflite::StableHLOCompositeOptionsT *>(value);
      return CreateStableHLOCompositeOptions(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BuiltinOptions2Union::BuiltinOptions2Union(const BuiltinOptions2Union &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BuiltinOptions2_StablehloConcatenateOptions: {
      value = new tflite::StablehloConcatenateOptionsT(*reinterpret_cast<tflite::StablehloConcatenateOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      value = new tflite::StablehloBroadcastInDimOptionsT(*reinterpret_cast<tflite::StablehloBroadcastInDimOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      value = new tflite::StablehloSliceOptionsT(*reinterpret_cast<tflite::StablehloSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      value = new tflite::StablehloConvolutionOptionsT(*reinterpret_cast<tflite::StablehloConvolutionOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      value = new tflite::StablehloCustomCallOptionsT(*reinterpret_cast<tflite::StablehloCustomCallOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      value = new tflite::StablehloReduceOptionsT(*reinterpret_cast<tflite::StablehloReduceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      value = new tflite::StablehloScatterOptionsT(*reinterpret_cast<tflite::StablehloScatterOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      value = new tflite::StablehloCompareOptionsT(*reinterpret_cast<tflite::StablehloCompareOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      value = new tflite::StablehloDynamicSliceOptionsT(*reinterpret_cast<tflite::StablehloDynamicSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloPadOptions: {
      value = new tflite::StablehloPadOptionsT(*reinterpret_cast<tflite::StablehloPadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      value = new tflite::StablehloIotaOptionsT(*reinterpret_cast<tflite::StablehloIotaOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      value = new tflite::StablehloDotGeneralOptionsT(*reinterpret_cast<tflite::StablehloDotGeneralOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      value = new tflite::StablehloReduceWindowOptionsT(*reinterpret_cast<tflite::StablehloReduceWindowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloSortOptions: {
      value = new tflite::StablehloSortOptionsT(*reinterpret_cast<tflite::StablehloSortOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      value = new tflite::StablehloWhileOptionsT(*reinterpret_cast<tflite::StablehloWhileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      value = new tflite::StablehloGatherOptionsT(*reinterpret_cast<tflite::StablehloGatherOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      value = new tflite::StablehloTransposeOptionsT(*reinterpret_cast<tflite::StablehloTransposeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_DilateOptions: {
      value = new tflite::DilateOptionsT(*reinterpret_cast<tflite::DilateOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      value = new tflite::StablehloRngBitGeneratorOptionsT(*reinterpret_cast<tflite::StablehloRngBitGeneratorOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      value = new tflite::ReduceWindowOptionsT(*reinterpret_cast<tflite::ReduceWindowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      value = new tflite::StableHLOCompositeOptionsT(*reinterpret_cast<tflite::StableHLOCompositeOptionsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BuiltinOptions2Union::Reset() {
  switch (type) {
    case BuiltinOptions2_StablehloConcatenateOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloConcatenateOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloBroadcastInDimOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloBroadcastInDimOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloSliceOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloConvolutionOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloConvolutionOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloCustomCallOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloCustomCallOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloReduceOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloReduceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloScatterOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloScatterOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloCompareOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloCompareOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloDynamicSliceOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloDynamicSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloPadOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloPadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloIotaOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloIotaOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloDotGeneralOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloDotGeneralOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloReduceWindowOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloReduceWindowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloSortOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloSortOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloWhileOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloWhileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloGatherOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloGatherOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloTransposeOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloTransposeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_DilateOptions: {
      auto ptr = reinterpret_cast<tflite::DilateOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StablehloRngBitGeneratorOptions: {
      auto ptr = reinterpret_cast<tflite::StablehloRngBitGeneratorOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_ReduceWindowOptions: {
      auto ptr = reinterpret_cast<tflite::ReduceWindowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions2_StableHLOCompositeOptions: {
      auto ptr = reinterpret_cast<tflite::StableHLOCompositeOptionsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BuiltinOptions2_NONE;
}

inline const tflite::Model *GetModel(const void *buf) {
  return ::flatbuffers::GetRoot<tflite::Model>(buf);
}

inline const tflite::Model *GetSizePrefixedModel(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);
}

inline const char *ModelIdentifier() {
  return "TFL3";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool SizePrefixedModelBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier(), true);
}

inline bool VerifyModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
  return "tflite";
}

inline void FinishModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

inline std::unique_ptr<tflite::ModelT> UnPackModel(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::ModelT>(GetModel(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::ModelT> UnPackSizePrefixedModel(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::ModelT>(GetSizePrefixedModel(buf)->UnPack(res));
}

}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
