<!-- Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
============================================================================

This file is generated by `gulp` & `vulcanize`. Do not directly change it.
Instead, use `gulp regenerate` to create a new version with your changes.
-->

<html><head><meta charset="UTF-8">
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var TF;
(function (TF) {
    var TensorBoard;
    (function (TensorBoard) {
        TensorBoard.TABS = ['events', 'images', 'audio', 'graphs', 'histograms'];
    })(TensorBoard = TF.TensorBoard || (TF.TensorBoard = {}));
})(TF || (TF = {}));
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var TF;
(function (TF) {
    var TensorBoard;
    (function (TensorBoard) {
        TensorBoard.AUTORELOAD_LOCALSTORAGE_KEY = 'TF.TensorBoard.autoReloadEnabled';
        var getAutoReloadFromLocalStorage = function () {
            var val = window.localStorage.getItem(TensorBoard.AUTORELOAD_LOCALSTORAGE_KEY);
            return val === 'true' || val == null; // defaults to true
        };
        TensorBoard.AutoReloadBehavior = {
            properties: {
                autoReloadEnabled: {
                    type: Boolean,
                    observer: '_autoReloadObserver',
                    value: getAutoReloadFromLocalStorage,
                },
                _autoReloadId: {
                    type: Number,
                },
                autoReloadIntervalSecs: {
                    type: Number,
                    value: 120,
                },
            },
            detached: function () { window.clearTimeout(this._autoReloadId); },
            _autoReloadObserver: function (autoReload) {
                window.localStorage.setItem(TensorBoard.AUTORELOAD_LOCALSTORAGE_KEY, autoReload);
                if (autoReload) {
                    var _this = this;
                    this._autoReloadId = window.setTimeout(this._doAutoReload.bind(this), this.autoReloadIntervalSecs * 1000);
                }
                else {
                    window.clearTimeout(this._autoReloadId);
                }
            },
            _doAutoReload: function () {
                if (this.reload == null) {
                    throw new Error('AutoReloadBehavior requires a reload method');
                }
                this.reload();
                this._autoReloadId = window.setTimeout(this._doAutoReload.bind(this), this.autoReloadIntervalSecs * 1000);
            }
        };
    })(TensorBoard = TF.TensorBoard || (TF.TensorBoard = {}));
})(TF || (TF = {}));
</script>
</head><body><div hidden="" by-vulcanize="">
<dom-module id="scrollbar-style" assetpath="../tf-dashboard-common/">
  <template>
    <style>
      .scrollbar::-webkit-scrollbar-track
      {
        visibility: hidden;
      }

      .scrollbar::-webkit-scrollbar
      {
        width: 10px;
      }

      .scrollbar::-webkit-scrollbar-thumb
      {
        border-radius: 10px;
        -webkit-box-shadow: inset 0 0 2px rgba(0,0,0,.3);
        background-color: var(--paper-grey-500);
        color: var(--paper-grey-900);
      }
      .scrollbar {
        box-sizing: border-box;
      }
    </style>
  </template>
</dom-module>
<dom-module id="run-color-style" assetpath="../tf-dashboard-common/">
  <template>
    <style>
    [color-class="light-blue"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-light-blue-500);
      --paper-checkbox-checked-ink-color: var(--paper-light-blue-500);
      --paper-checkbox-unchecked-color: var(--paper-light-blue-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-light-blue-900);
    }
    [color-class="red"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-red-500);
      --paper-checkbox-checked-ink-color: var(--paper-red-500);
      --paper-checkbox-unchecked-color: var(--paper-red-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-red-900);
    }
    [color-class="green"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-green-500);
      --paper-checkbox-checked-ink-color: var(--paper-green-500);
      --paper-checkbox-unchecked-color: var(--paper-green-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-green-900);
    }
    [color-class="purple"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-purple-500);
      --paper-checkbox-checked-ink-color: var(--paper-purple-500);
      --paper-checkbox-unchecked-color: var(--paper-purple-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-purple-900);
    }
    [color-class="teal"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-teal-500);
      --paper-checkbox-checked-ink-color: var(--paper-teal-500);
      --paper-checkbox-unchecked-color: var(--paper-teal-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-teal-900);
    }
    [color-class="pink"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-pink-500);
      --paper-checkbox-checked-ink-color: var(--paper-pink-500);
      --paper-checkbox-unchecked-color: var(--paper-pink-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-pink-900);
    }
    [color-class="orange"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-orange-500);
      --paper-checkbox-checked-ink-color: var(--paper-orange-500);
      --paper-checkbox-unchecked-color: var(--paper-orange-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-orange-900);
    }
    [color-class="brown"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-brown-500);
      --paper-checkbox-checked-ink-color: var(--paper-brown-500);
      --paper-checkbox-unchecked-color: var(--paper-brown-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-brown-900);
    }
    [color-class="indigo"] paper-checkbox {
      --paper-checkbox-checked-color: var(--paper-indigo-500);
      --paper-checkbox-checked-ink-color: var(--paper-indigo-500);
      --paper-checkbox-unchecked-color: var(--paper-indigo-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-indigo-900);
    }
    </style>
  </template>
</dom-module>



<dom-module id="tf-multi-checkbox" assetpath="../tf-multi-checkbox/">
  <style include="scrollbar-style"></style>
  <style include="run-color-style"></style>

  <template>
    <div id="outer-container" class="scrollbar">
      <paper-input id="runs-regex" no-label-float="" label="Write a regex to filter runs" bind-value="{{regexInput}}"></paper-input>
      <template is="dom-repeat" items="[[namesMatchingRegex]]">
        <div class="run-row">
          <div class="checkbox-container vertical-align-container">
            <paper-checkbox class="checkbox vertical-align-center" name="[[item]]" checked$="[[_isChecked(item, runToIsCheckedMapping.*)]]" on-change="_checkboxChange"></paper-checkbox>
          </div>
          <div class="item-label-container">
            <span>[[item]]</span>
          </div>
        </div>
      </template>
    </div>
  <style>
    paper-input {
      --paper-input-container-focus-color: var(--tb-orange-strong);
      --paper-input-container-input: {
        font-size: 14px;
      };
      --paper-input-container-label: {
        font-size: 14px;
      };
    }
    :host {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    #outer-container {
      overflow-y: scroll;
      overflow-x: hidden;
      width: 100%;
      flex-grow: 1;
      flex-shrink: 1;
      word-wrap: break-word;
    }
    .run-row {
      padding-top: 5px;
      padding-bottom: 5px;
      display: flex;
      flex-direction: row;
      font-size: 13px;
    }
    .checkbox-container {
      flex-grow: 0;
      flex-shrink: 0;
    }
    .checkbox {
      padding-left: 2px;
      width: 32px;
    }
    .item-label-container {
      flex-grow: 1;
      flex-shrink: 1;
      width: 0px; /* hack to get the flex-grow to work properly */
    }
    .tooltip-value-container {
      display: flex;
      justify-content: center;
      flex-grow: 0;
      flex-shrink: 0;
      text-align:right;
      padding-left: 2px;
    }
    .vertical-align-container {
      display: flex;
      justify-content: center;
    }
    .vertical-align-container .vertical-align-center {
      align-self: center;
    }
    .vertical-align-container .vertical-align-top {
      align-self: start;
    }
  </style>
  </template>

  <script>
  Polymer({
    is: "tf-multi-checkbox",
    properties: {
      names: Array, // All the runs in consideration
      regexInput: {type: String, value: "",}, // Regex for filtering the runs
      regex: {
        type: Object,
        computed: "makeRegex(regexInput)"
      },
      namesMatchingRegex: {
        type: Array,
        computed: "computeNamesMatchingRegex(names.*, regex)"
      }, // Runs that match the regex
      runToIsCheckedMapping: {
        type: Object,
        value: function() {return {};}
      }, // run name -> Boolean (if its enabled)
      // (Allows state to persist across regex filtering)
      outSelected: {
        type: Array,
        notify: true,
        computed: 'computeOutSelected(namesMatchingRegex.*, runToIsCheckedMapping.*)'
      },
      colorScale: {
        type: Object,
        observer: "synchronizeColors",
      }, // map from run name to css class
    },
    listeners: {
      'dom-change': 'synchronizeColors',
    },
    observers: [
      "_initializeRunToIsCheckedMapping(names.*)",
    ],
    makeRegex: function(regex) {
      try {
        return new RegExp(regex)
      } catch (e) {
        return null;
      }
    },
    _initializeRunToIsCheckedMapping: function(change) {
      var runToIsCheckedMapping = _.clone(this.runToIsCheckedMapping);

      this.names.forEach(function(n) {
        if (runToIsCheckedMapping[n] == null) {
          // runs default to on
          runToIsCheckedMapping[n] = true;
        }
      });
      this.runToIsCheckedMapping = runToIsCheckedMapping;
    },
    computeNamesMatchingRegex: function(__, ___) {
      var regex = this.regex;
      return this.names.filter(function(n) {
        return regex == null || regex.test(n);
      });
    },
    computeOutSelected: function(__, ___) {
      var runToIsCheckedMapping = this.runToIsCheckedMapping;
      return this.namesMatchingRegex.filter(function(n) {
        return runToIsCheckedMapping[n];
      });
    },
    synchronizeColors: function(e) {
      var checkboxes = Array.prototype.slice.call(this.querySelectorAll("paper-checkbox"));
      var scale = this.colorScale;
      checkboxes.forEach(function(p) {
        var color = scale.scale(p.name);
        p.customStyle['--paper-checkbox-checked-color'] = color;
        p.customStyle['--paper-checkbox-checked-ink-color'] = color;
        p.customStyle['--paper-checkbox-unchecked-color'] = color;
        p.customStyle['--paper-checkbox-unchecked-ink-color'] = color;
      });
      this.updateStyles();
      // The updateStyles call fails silently if the browser doesn't have focus,
      // e.g. if TensorBoard was opened into a new tab that isn't visible.
      // As a workaround... we know requestAnimationFrame won't fire until the
      // page has focus, so updateStyles again on requestAnimationFrame.
      var _this = this;
      window.requestAnimationFrame(function() {_this.updateStyles();});
    },
    _checkboxChange: function(e) {
      var name = e.srcElement.name;
      var checked = e.srcElement.checked;
      this.runToIsCheckedMapping[name] = checked;
      // n.b. notifyPath won't work because run names may have periods.
      this.runToIsCheckedMapping = _.clone(this.runToIsCheckedMapping);
    },
    _isChecked: function(item, outSelectedChange) {
      return this.runToIsCheckedMapping[item];
    },
    _initializeRuns: function(change) {
      this.outSelected = change.base.slice();
    },
    toggleAll: function() {
      var _this = this;
      var allOn = this.namesMatchingRegex
                    .filter(function(n) {return !_this.runToIsCheckedMapping[n]})
                    .length === 0;
      this.namesMatchingRegex.forEach(function(n) {_this.runToIsCheckedMapping[n] = !allOn});
      this.runToIsCheckedMapping = _.clone(this.runToIsCheckedMapping);
    },
  });
  </script>
</dom-module>

<dom-module id="tf-run-selector" assetpath="../tf-event-dashboard/">
  <template>
    <div id="top-text">
      <h3 id="tooltip-help" class="tooltip-container">
        Runs
      </h3>
    </div>
    <tf-multi-checkbox id="multiCheckbox" names="[[runs]]" out-selected="{{outSelected}}" color-scale="[[colorScale]]"></tf-multi-checkbox>
    <paper-button class="x-button" id="toggle-all" on-tap="_toggleAll">
    Toggle All Runs
    </paper-button>
    <style>
      :host {
        display: flex;
        flex-direction: column;
        padding-bottom: 10px;
        box-sizing: border-box;
      }
      #top-text {
        width: 100%;
        flex-grow: 0;
        flex-shrink: 0;
        padding-right: 16px;
        padding-bottom: 6px;
        box-sizing: border-box;
        color: var(--paper-grey-800);
      }
      tf-multi-checkbox {
        display: flex;
        flex-grow: 1;
        flex-shrink: 1;
      }
      .x-button {
        font-size: 13px;
        background-color: var(--tb-ui-light-accent);
        margin-top: 5px;
        color: var(--tb-ui-dark-accent);
      }
      #tooltip-help {
        color: var(--paper-grey-800);
        margin: 0;
        font-weight: normal;
        font-size: 14px;
        margin-bottom: 5px;
      }
      paper-button {
        margin-left: 0;
      }
    </style>
  </template>
  <script>
  Polymer({
    is: "tf-run-selector",
    properties: {
      outSelected: {type: Array, notify: true},
      // runs: an array of strings, representing the run names that may be chosen
      runs: Array,
      colorScale: Object, // TF.ColorScale
    },
    _toggleAll: function() {
      this.$.multiCheckbox.toggleAll();
    },
  });
  </script>
</dom-module>
<style is="custom-style">

  :root {
    --tb-orange-weak: #ffa726;
    --tb-orange-strong: #f57c00;
    --tb-grey-darker: #e2e2e2;
    --tb-grey-lighter: #f3f3f3;
    --tb-ui-dark-accent: #757575;
    --tb-ui-light-accent: #e0e0e0;
    --tb-graph-faded: #e0d4b3;
  }

</style>

<dom-module id="tf-x-type-selector" assetpath="../tf-event-dashboard/">
  <template>
    <div id="buttons">
      <h3>Horizontal Axis</h3>
      <paper-button class="x-button selected" id="step" on-tap="_select">
      step
      </paper-button>
      <paper-button class="x-button" id="relative" on-tap="_select">
      relative
      </paper-button>
      <paper-button class="x-button" id="wall_time" on-tap="_select">
      wall
      </paper-button>
    </div>
    <style>
      .x-button {
        width: 30%;
        font-size: 13px;
        background: none;
        margin-top: 10px;
        color: var(--tb-ui-dark-accent);
      }

      .x-button:first-of-type {
        margin-left: 0;
      }

      .x-button.selected {
        background-color: var(--tb-ui-dark-accent);
        color: white!important;
      }

      #buttons h3 {
        color: var(--paper-grey-800);
        margin: 0;
        font-weight: normal;
        font-size: 14px;
        margin-bottom: 5px;
      }
    </style>
  </template>
  <script>
    Polymer({
      is: "tf-x-type-selector",
      properties: {
        outXType: {type: String, notify: true, readOnly: true, value: "step"},
      },
      _select: function(e) {
        var _this = this;
        ["step", "wall_time", "relative"].forEach(function(id) {
          _this.$[id].classList.remove("selected");
        });
        this._setOutXType(e.currentTarget.id);
        e.currentTarget.classList.add("selected");
      },
    });
  </script>
</dom-module>

<dom-module id="tf-color-scale" assetpath="../tf-color-scale/">
  <script>var TF;
(function (TF) {
    TF.palettes = {
        googleStandard: [
            '#db4437',
            '#ff7043',
            '#f4b400',
            '#0f9d58',
            '#00796b',
            '#00acc1',
            '#4285f4',
            '#5c6bc0',
            '#ab47bc' // purple 400
        ],
        googleCool: [
            '#9e9d24',
            '#0f9d58',
            '#00796b',
            '#00acc1',
            '#4285f4',
            '#5c6bc0',
            '#607d8b' // blue gray 500
        ],
        googleWarm: [
            '#795548',
            '#ab47bc',
            '#f06292',
            '#c2185b',
            '#db4437',
            '#ff7043',
            '#f4b400' // google yellow 700
        ],
        googleColorBlindAssist: [
            '#c53929',
            '#ff7043',
            '#f7cb4d',
            '#0b8043',
            '#80deea',
            '#4285f4',
            '#5e35b1' // deep purple 600
        ],
        // These palettes try to be better for color differentiation.
        // https://personal.sron.nl/~pault/
        colorBlindAssist1: ['#4477aa', '#44aaaa', '#aaaa44', '#aa7744', '#aa4455', '#aa4488'],
        colorBlindAssist2: [
            '#88ccee', '#44aa99', '#117733', '#999933', '#ddcc77', '#cc6677',
            '#882255', '#aa4499'
        ],
        colorBlindAssist3: [
            '#332288', '#6699cc', '#88ccee', '#44aa99', '#117733', '#999933',
            '#ddcc77', '#cc6677', '#aa4466', '#882255', '#661100', '#aa4499'
        ],
        // based on this palette: http://mkweb.bcgsc.ca/biovis2012/
        colorBlindAssist4: [
            '#FF6DB6', '#920000', '#924900', '#DBD100', '#24FF24', '#006DDB',
            '#490092'
        ],
        mldash: [
            '#E47EAD', '#F4640D', '#FAA300', '#F5E636', '#00A077', '#0077B8',
            '#00B7ED'
        ],
        // This rainbow palette attempts to keep a constant brightness across hues.
        constantValue: [
            '#f44336', '#ffa216', '#c2d22d', '#51b455', '#1ca091', '#505ec4',
            '#a633ba'
        ]
    };
})(TF || (TF = {}));
</script>
  <script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
// Each color scale is initialized with a configurable number of base hues.
// There are also several palettes available.
// TF.palettes.googleStandard, TF.palettes.googleColorBlind,
// TF.palettes.googleCool, TF.palettes.googleWarm, TF.palettes.constantValue
// Each string is hashed to an integer,
// then mapped to one of the base hues above.
// If there is a collision, the color that is later in an alphabetical sort
// gets nudged a little darker or lighter to disambiguate.
// I would call it mostly stable, in that the same array of strings will
// always return the same colors, but the same individual string may
// shift a little depending on its peers.
//
// runs = ["train", "test", "test1", "test2"]
// ccs = new TF.ColorScale(12, "googleStandard");
// ccs.domain(runs);
// ccs.getColor("train");
// ccs.getColor("test1");
var TF;
(function (TF) {
    var ColorScale = (function () {
        /**
         * The palette you provide defines your spectrum. The colorscale will
         * always use the full spectrum you provide. When you define "numColors"
         * it resamples at regular intervals along the full extent of the spectrum.
         * Thus you get the maximum distance between hues for the "numColors"
         * given. This allows the programmer to tweak the algorithm depending on
         * how big your expected domain is. If you generally think you're going to
         * have a small number of elements in the domain, then a small numColors
         * will be serviceable. With large domains, a small numColors would produce
         * too many hash collisions, so you'd want to bump it up to the threshold
         * of human perception (probably around 14 or 18).
         *
         * @param {string[]} [palette=TF.palettes.googleColorBlind] - The color
         *                 palette you want as an Array of hex strings. Note, the
         *                 length of the array in this palette is independent of the
         *                 param numColors above. The scale will interpolate to
         *                 create the proper "numColors" given in the first param.
         *
         * @param {number} [numColors] - The number of base colors you want
         *                 in the palette. The more colors, the smaller the number
         *                 the more hash collisions you will have, but the more
         *                 differentiable the base colors will be.
         */
        function ColorScale(palette, numColors) {
            if (palette === void 0) { palette = TF.palettes.googleColorBlindAssist; }
            this.LIGHTNESS_NUDGE = 0.8;
            this.numColors = numColors ? numColors : palette.length;
            this.domain([]);
            if (palette.length < 2) {
                throw new Error('Not enough colors in palette. Must be more than one.');
            }
            var k = (this.numColors - 1) / (palette.length - 1);
            this.internalColorScale =
                d3.scale.linear()
                    .domain(d3.range(palette.length).map(function (i) { return i * k; }))
                    .range(palette);
        }
        ColorScale.prototype.hash = function (s) {
            function h(hash, str) {
                hash = (hash << 5) - hash + str.charCodeAt(0);
                return hash & hash;
            }
            return Math.abs(Array.prototype.reduce.call(s, h, 0)) % this.numColors;
        };
        /**
         * Set the domain of strings so we can calculate collisions preemptively.
         * Can be reset at any point.
         *
         * @param {string[]} strings - An array of strings to use as the domain
         *                             for your scale.
         */
        ColorScale.prototype.domain = function (strings) {
            var _this = this;
            this.buckets = d3.range(this.numColors).map(function () { return []; });
            var sortedUniqueKeys = d3.set(strings).values().sort(function (a, b) {
                return a.localeCompare(b);
            });
            sortedUniqueKeys.forEach(function (s) { return _this.addToDomain(s); });
            return this;
        };
        ColorScale.prototype.getBucketForString = function (s) {
            var bucketIdx = this.hash(s);
            return this.buckets[bucketIdx];
        };
        ColorScale.prototype.addToDomain = function (s) {
            var bucketIdx = this.hash(s);
            var bucket = this.buckets[bucketIdx];
            if (bucket.indexOf(s) === -1) {
                bucket.push(s);
            }
        };
        ColorScale.prototype.nudge = function (color, amount) {
            // If amount is zero, just give back same color
            if (amount === 0) {
                return color;
            }
            else if (amount === 1) {
                return d3.hcl(color).brighter(this.LIGHTNESS_NUDGE);
            }
            else {
                return d3.hcl(color).darker((amount - 1) * this.LIGHTNESS_NUDGE);
            }
        };
        /**
         * Use the color scale to transform an element in the domain into a color.
         * If there was a hash conflict, the color will be "nudged" darker or
         * lighter so that it is unique.
         * @param {string} The input string to map to a color.
         * @return {string} The color corresponding to that input string.
         * @throws Will error if input string is not in the scale's domain.
         */
        ColorScale.prototype.scale = function (s) {
            var bucket = this.getBucketForString(s);
            var idx = bucket.indexOf(s);
            if (idx === -1) {
                throw new Error('String was not in the domain.');
            }
            var color = this.internalColorScale(this.hash(s));
            return this.nudge(color, idx).toString();
        };
        return ColorScale;
    }());
    TF.ColorScale = ColorScale;
})(TF || (TF = {}));
</script>
  <script>
    (function() {
      Polymer({
        is: "tf-color-scale",
        properties: {
          runs: {
            type: Array,
          },
          outColorScale: {
            type: Object,
            readOnly: true,
            notify: true,
            value: function() {
              return new TF.ColorScale();
            },
          },
        },
        observers: ['updateColorScale(runs.*)'],
        updateColorScale: function(runsChange) {
          this.outColorScale.domain(this.runs);
        },
      });
    })();
  </script>
</dom-module>

<dom-module id="tf-regex-group" assetpath="../tf-regex-group/">
  <template>
    <div class="regex-list">
      <template is="dom-repeat" items="{{rawRegexes}}">
        <div class="regex-line">
          <paper-checkbox class="active-button" checked="{{item.active}}" disabled="[[!item.valid]]"></paper-checkbox>
          <paper-input id="text-input" class="regex-input" label="Write a regex to create a tag group" no-label-float="" bind-value="{{item.regex}}" invalid="[[!item.valid]]" on-keyup="moveFocus"></paper-input>
          <paper-icon-button icon="close" class="delete-button" aria-label="Delete Regex" tabindex="0" on-tap="deleteRegex"></paper-icon-button>
        </div>
        <style>
          .regex-input {
            width: 230px;
            display: inline-block;
            margin-left: -3px;
          }

          paper-checkbox {
            --paper-checkbox-checked-color: var(--tb-ui-dark-accent);
            --paper-checkbox-unchecked-color: var(--tb-ui-dark-accent);
          }

          .delete-button {
            color: var(--paper-grey-700);
            width: 40px;
            height: 40px;
            margin-right: -10px;
          }

          .regex-list {
            margin-bottom: 10px;
          }

          paper-input {
            --paper-input-container-focus-color: var(--tb-orange-strong);
            --paper-input-container-input: {
              font-size: 14px;
            };
            --paper-input-container-label: {
              font-size: 14px;
            };
          }
        </style>
      </template>
    </div>
  </template>
  <script>
    Polymer({
      is: "tf-regex-group",
      properties: {
        rawRegexes: {
          type: Array,
          value: function() {
            return [{regex: "", active: true, valid: true}];
          }
        },
        regexes: {type: Array, computed: "usableRegexes(rawRegexes.*)", notify: true},
      },
      observers: [
        "addNewRegexIfNeeded(rawRegexes.*)",
        "checkValidity(rawRegexes.*)",
      ],
      checkValidity: function(x) {
        var match = x.path.match(/rawRegexes\.(\d+)\.regex/);
        if (match) {
          var idx = match[1];
          this.set("rawRegexes." + idx + ".valid", this.isValid(x.value));
        }
      },
      isValid: function(s) {
        try {
          new RegExp(s);
          return true;
        } catch (e) {
          return false;
        }
      },
      usableRegexes: function(regexes) {
        var isValid = this.isValid;
        return regexes.base.filter(function (r) {
          // Checking validity here (rather than using the data property)
          // is necessary because otherwise we might send invalid regexes due
          // to the fact that this function can call before the observer does
          return r.regex !== "" && r.active && isValid(r.regex);
        }).map(function(r) {
          return r.regex;
        });
      },
      addNewRegexIfNeeded: function() {
        var last = this.rawRegexes[this.rawRegexes.length - 1];
        if (last.regex !== "") {
          this.push("rawRegexes", {regex: "", active: true, valid: true});
        }
      },
      deleteRegex: function(e) {
        if (this.rawRegexes.length > 1) {
          this.splice("rawRegexes", e.model.index, 1);
        }
      },
      moveFocus: function(e) {
        if (e.keyCode === 13) {
          var idx = e.model.index;
          var inputs = Polymer.dom(this.root).querySelectorAll(".regex-input");
          if (idx < this.rawRegexes.length - 1) {
            inputs[idx+1].$.input.focus();
          } else {
            document.activeElement.blur();
          }
        }
      }
    });
  </script>
</dom-module>


<dom-module id="tf-categorizer" assetpath="../tf-categorizer/">
  <template>
    <div class="inputs">
      <tf-regex-group id="regex-group" regexes="{{regexes}}"></tf-regex-group>
    </div>
    <div id="underscore-categorization">
      <paper-checkbox checked="{{splitOnUnderscore}}">Split on underscores</paper-checkbox>
    </div>
    <style>
      :host {
        display: block;
        padding-bottom: 15px;
      }
      paper-checkbox {
        --paper-checkbox-checked-color: var(--paper-grey-600);
        --paper-checkbox-unchecked-color: var(--paper-grey-600);
        font-size: 14px;
      }
      #underscore-categorization {
        color: var(--paper-grey-700);
      }
    </style>
  </template>
  <script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var Categorizer;
(function (Categorizer) {
    /* Canonical TensorFlow ops are namespaced using forward slashes.
     * This fallback categorizer categorizes by the top-level namespace.
     */
    Categorizer.topLevelNamespaceCategorizer = splitCategorizer(/\//);
    // Try to produce good categorizations on legacy graphs, which often
    // are namespaced like l1_foo/bar or l2_baz/bam.
    // If there is no leading underscore before the first forward slash,
    // then it behaves the same as topLevelNamespaceCategorizer
    Categorizer.legacyUnderscoreCategorizer = splitCategorizer(/[\/_]/);
    function fallbackCategorizer(s) {
        switch (s) {
            case 'TopLevelNamespaceCategorizer':
                return Categorizer.topLevelNamespaceCategorizer;
            case 'LegacyUnderscoreCategorizer':
                return Categorizer.legacyUnderscoreCategorizer;
            default:
                throw new Error('Unrecognized categorization strategy: ' + s);
        }
    }
    Categorizer.fallbackCategorizer = fallbackCategorizer;
    /* An 'extractor' is a function that takes a tag name, and 'extracts' a
     * category name.
     * This function takes an extractor, and produces a categorizer.
     * Currently, it is just used for the fallbackCategorizer, but we may want to
     * refactor the general categorization logic to use the concept of extractors.
     */
    function extractorToCategorizer(extractor) {
        return function (tags) {
            if (tags.length === 0) {
                return [];
            }
            var sortedTags = tags.slice().sort();
            var categories = [];
            var currentCategory = {
                name: extractor(sortedTags[0]),
                tags: [],
            };
            sortedTags.forEach(function (t) {
                var topLevel = extractor(t);
                if (currentCategory.name !== topLevel) {
                    categories.push(currentCategory);
                    currentCategory = {
                        name: topLevel,
                        tags: [],
                    };
                }
                currentCategory.tags.push(t);
            });
            categories.push(currentCategory);
            return categories;
        };
    }
    function splitCategorizer(r) {
        var extractor = function (t) {
            return t.split(r)[0];
        };
        return extractorToCategorizer(extractor);
    }
    function defineCategory(ruledef) {
        var r = new RegExp(ruledef);
        var f = function (tag) {
            return r.test(tag);
        };
        return { name: ruledef, matches: f };
    }
    Categorizer.defineCategory = defineCategory;
    function _categorizer(rules, fallback) {
        return function (tags) {
            var remaining = d3.set(tags);
            var userSpecified = rules.map(function (def) {
                var tags = [];
                remaining.forEach(function (t) {
                    if (def.matches(t)) {
                        tags.push(t);
                    }
                });
                var cat = { name: def.name, tags: tags.sort() };
                return cat;
            });
            var defaultCategories = fallback(remaining.values());
            return userSpecified.concat(defaultCategories);
        };
    }
    Categorizer._categorizer = _categorizer;
    function categorizer(s) {
        var rules = s.categoryDefinitions.map(defineCategory);
        var fallback = fallbackCategorizer(s.fallbackCategorizer);
        return _categorizer(rules, fallback);
    }
    Categorizer.categorizer = categorizer;
    ;
})(Categorizer || (Categorizer = {}));
</script>
  <script>
    Polymer({
      is: "tf-categorizer",
      properties: {
        regexes: {type: Array},
        tags: {type: Array},
        categoriesAreExclusive: {type: Boolean, value: true},
        fallbackCategorizer: {
          type: String,
          computed: "chooseFallbackCategorizer(splitOnUnderscore)"
        },
        splitOnUnderscore: {
          type: Boolean,
          value: false,
        },
        categorizer: {
          type: Object,
          computed: "computeCategorization(regexes.*, categoriesAreExclusive, fallbackCategorizer)",
        },
        categories: {type: Array, value: function() {return [];}, notify: true, readOnly: true},
      },
      observers: ['recategorize(tags.*, categorizer)'],
      computeCategorization: function(regexes, categoriesAreExclusive, fallbackCategorizer) {
        var categorizationStrategy = {
          categoryDefinitions: regexes.base,
          categoriesAreExclusive: categoriesAreExclusive,
          fallbackCategorizer: fallbackCategorizer,
        };
        return Categorizer.categorizer(categorizationStrategy);
      },
      recategorize: function() {
        this.debounce("tf-categorizer-recategorize", function (){
          var categories = this.categorizer(this.tags);
          this._setCategories(categories);
        })
      },
      chooseFallbackCategorizer: function(splitOnUnderscore) {
        if (splitOnUnderscore) {
          return "LegacyUnderscoreCategorizer";
        } else {
          return "TopLevelNamespaceCategorizer";
        }
      },
    });
  </script>
</dom-module>

<dom-module id="tf-chart" assetpath="../tf-event-dashboard/">
  <template>
    <svg id="chartsvg"></svg>
    <div id="tooltip">
      <table>
        <thead>
          <tr>
            <th></th>
            <th>Run</th>
            <th>Value</th>
            <th>Step</th>
            <th>Time</th>
            <th>Relative</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
    </div>
    <style>
      :host {
        -webkit-user-select: none;
        -moz-user-select: none;
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        flex-shrink: 1;
        position: relative;
      }
      svg {
        -webkit-user-select: none;
        -moz-user-select: none;
        flex-grow: 1;
        flex-shrink: 1;
      }
      td {
        padding-left: 5px;
        padding-right: 5px;
        font-size: 13px;
        opacity: 1;
      }
      #tooltip {
        pointer-events: none;
        position: absolute;
        opacity: 0;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        font-size: 14px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 4px;
        line-height: 1.4em;
        padding: 8px;
        z-index: 5;
        cursor: none;
      }
      .swatch {
        border-radius: 50%;
        width: 14px;
        height: 14px;
        display: block;
        border: 2px solid rgba(0,0,0,0);
      }
      .closest .swatch {
        border: 2px solid white;
      }
      th {
        padding-left: 5px;
        padding-right: 5px;
        text-align: left;
      }
      .distant td {
        opacity: 0.8;
      }

      .distant td.swatch {
        opacity: 1;
      }

    </style>
  </template>
  <script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Plottable;
(function (Plottable) {
    var DragZoomLayer = (function (_super) {
        __extends(DragZoomLayer, _super);
        /**
         * Constructs a SelectionBoxLayer with an attached DragInteraction and
         * ClickInteraction. On drag, it triggers an animated zoom into the box
         * that was dragged. On double click, it zooms back out to the original
         * view, before any zooming.
         * The zoom animation uses an easing function (default
         * d3.ease('cubic-in-out')) and is customizable.
         * Usage: Construct the selection box layer and attach x and y scales,
         * and then add the layer over the plot you are zooming on using a
         * Component Group.
         * TODO(danmane) - merge this into Plottable
         */
        function DragZoomLayer(xScale, yScale) {
            _super.call(this);
            this.isZoomed = false;
            this.easeFn = d3.ease('cubic-in-out');
            this._animationTime = 750;
            this.xScale(xScale);
            this.yScale(yScale);
            this._dragInteraction = new Plottable.Interactions.Drag();
            this._dragInteraction.attachTo(this);
            this._doubleClickInteraction = new Plottable.Interactions.DoubleClick();
            this._doubleClickInteraction.attachTo(this);
            this.setupCallbacks();
        }
        /**
         * Register a method that calls when the DragZoom interaction starts.
         */
        DragZoomLayer.prototype.interactionStart = function (cb) { this.onStart = cb; };
        /**
         * Register a method that calls when the DragZoom interaction ends.
         */
        DragZoomLayer.prototype.interactionEnd = function (cb) { this.onEnd = cb; };
        DragZoomLayer.prototype.setupCallbacks = function () {
            var _this = this;
            var dragging = false;
            this._dragInteraction.onDragStart(function (startPoint) {
                _this.bounds({
                    topLeft: startPoint,
                    bottomRight: startPoint,
                });
                _this.onStart();
            });
            this._dragInteraction.onDrag(function (startPoint, endPoint) {
                _this.bounds({ topLeft: startPoint, bottomRight: endPoint });
                _this.boxVisible(true);
                dragging = true;
            });
            this._dragInteraction.onDragEnd(function (startPoint, endPoint) {
                _this.boxVisible(false);
                _this.bounds({ topLeft: startPoint, bottomRight: endPoint });
                if (dragging) {
                    _this.zoom();
                }
                else {
                    _this.onEnd();
                }
                dragging = false;
            });
            this._doubleClickInteraction.onDoubleClick(this.unzoom.bind(this));
        };
        DragZoomLayer.prototype.animationTime = function (animationTime) {
            if (animationTime == null) {
                return this._animationTime;
            }
            if (animationTime < 0) {
                throw new Error('animationTime cannot be negative');
            }
            this._animationTime = animationTime;
            return this;
        };
        /**
         * Set the easing function, which determines how the zoom interpolates
         * over time.
         */
        DragZoomLayer.prototype.ease = function (fn) {
            if (typeof (fn) !== 'function') {
                throw new Error('ease function must be a function');
            }
            if (fn(0) !== 0 || fn(1) !== 1) {
                Plottable.Utils.Window.warn('Easing function does not maintain invariant ' +
                    'f(0)==0 && f(1)==1. Bad behavior may result.');
            }
            this.easeFn = fn;
            return this;
        };
        // Zoom into extent of the selection box bounds
        DragZoomLayer.prototype.zoom = function () {
            var x0 = this.xExtent()[0].valueOf();
            var x1 = this.xExtent()[1].valueOf();
            var y0 = this.yExtent()[1].valueOf();
            var y1 = this.yExtent()[0].valueOf();
            if (x0 === x1 || y0 === y1) {
                return;
            }
            if (!this.isZoomed) {
                this.isZoomed = true;
                this.xDomainToRestore = this.xScale().domain();
                this.yDomainToRestore = this.yScale().domain();
            }
            this.interpolateZoom(x0, x1, y0, y1);
        };
        // Restore the scales to their state before any zoom
        DragZoomLayer.prototype.unzoom = function () {
            if (!this.isZoomed) {
                return;
            }
            this.isZoomed = false;
            this.interpolateZoom(this.xDomainToRestore[0], this.xDomainToRestore[1], this.yDomainToRestore[0], this.yDomainToRestore[1]);
        };
        // If we are zooming, disable interactions, to avoid contention
        DragZoomLayer.prototype.isZooming = function (isZooming) {
            this._dragInteraction.enabled(!isZooming);
            this._doubleClickInteraction.enabled(!isZooming);
        };
        DragZoomLayer.prototype.interpolateZoom = function (x0f, x1f, y0f, y1f) {
            var _this = this;
            var x0s = this.xScale().domain()[0].valueOf();
            var x1s = this.xScale().domain()[1].valueOf();
            var y0s = this.yScale().domain()[0].valueOf();
            var y1s = this.yScale().domain()[1].valueOf();
            // Copy a ref to the ease fn, so that changing ease wont affect zooms in
            // progress.
            var ease = this.easeFn;
            var interpolator = function (a, b, p) {
                return d3.interpolateNumber(a, b)(ease(p));
            };
            this.isZooming(true);
            var start = Date.now();
            var draw = function () {
                var now = Date.now();
                var passed = now - start;
                var p = _this._animationTime === 0 ?
                    1 :
                    Math.min(1, passed / _this._animationTime);
                var x0 = interpolator(x0s, x0f, p);
                var x1 = interpolator(x1s, x1f, p);
                var y0 = interpolator(y0s, y0f, p);
                var y1 = interpolator(y1s, y1f, p);
                _this.xScale().domain([x0, x1]);
                _this.yScale().domain([y0, y1]);
                if (p < 1) {
                    Plottable.Utils.DOM.requestAnimationFramePolyfill(draw);
                }
                else {
                    _this.onEnd();
                    _this.isZooming(false);
                }
            };
            draw();
        };
        return DragZoomLayer;
    }(Plottable.Components.SelectionBoxLayer));
    Plottable.DragZoomLayer = DragZoomLayer;
})(Plottable || (Plottable = {}));
</script>
  <script>var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var TF;
(function (TF) {
    var Y_TOOLTIP_FORMATTER_PRECISION = 4;
    var STEP_FORMATTER_PRECISION = 4;
    var Y_AXIS_FORMATTER_PRECISION = 3;
    var TOOLTIP_Y_PIXEL_OFFSET = 20;
    var TOOLTIP_CIRCLE_SIZE = 4;
    var NAN_SYMBOL_SIZE = 6;
    var BaseChart = (function () {
        function BaseChart(tag, dataFn, xType, colorScale, tooltip) {
            this.dataFn = dataFn;
            this.run2datasets = {};
            this.tag = tag;
            this.colorScale = colorScale;
            this.tooltip = tooltip;
        }
        /**
         * Change the runs on the chart. The work of actually setting the dataset
         * on the plot is deferred to the subclass because it is impl-specific.
         * Changing runs automatically triggers a reload; this ensures that the
         * newly selected run will have data, and that all the runs will be current
         * (it would be weird if one run was ahead of the others, and the display
         * depended on the order in which runs were added)
         */
        BaseChart.prototype.changeRuns = function (runs) {
            this.runs = runs;
            this.reload();
        };
        /**
         * Reload data for each run in view.
         */
        BaseChart.prototype.reload = function () {
            var _this = this;
            this.runs.forEach(function (run) {
                var dataset = _this.getDataset(run);
                _this.dataFn(_this.tag, run).then(function (x) { return dataset.data(x); });
            });
        };
        BaseChart.prototype.getDataset = function (run) {
            if (this.run2datasets[run] === undefined) {
                this.run2datasets[run] =
                    new Plottable.Dataset([], { run: run, tag: this.tag });
            }
            return this.run2datasets[run];
        };
        BaseChart.prototype.buildChart = function (xType) {
            if (this.outer) {
                this.outer.destroy();
            }
            var xComponents = getXComponents(xType);
            this.xAccessor = xComponents.accessor;
            this.xScale = xComponents.scale;
            this.xAxis = xComponents.axis;
            this.xAxis.margin(0).tickLabelPadding(3);
            this.yScale = new Plottable.Scales.Linear();
            this.yAxis = new Plottable.Axes.Numeric(this.yScale, 'left');
            var yFormatter = multiscaleFormatter(Y_AXIS_FORMATTER_PRECISION);
            this.yAxis.margin(0).tickLabelPadding(5).formatter(yFormatter);
            this.yAxis.usesTextWidthApproximation(true);
            this.dzl = new Plottable.DragZoomLayer(this.xScale, this.yScale);
            var center = this.buildPlot(this.xAccessor, this.xScale, this.yScale);
            this.gridlines =
                new Plottable.Components.Gridlines(this.xScale, this.yScale);
            this.center =
                new Plottable.Components.Group([this.gridlines, center, this.dzl]);
            this.outer = new Plottable.Components.Table([
                [this.yAxis, this.center],
                [null, this.xAxis]
            ]);
        };
        BaseChart.prototype.buildPlot = function (xAccessor, xScale, yScale) {
            throw new Error('Abstract method not implemented.');
        };
        BaseChart.prototype.renderTo = function (target) {
            this.outer.renderTo(target);
        };
        BaseChart.prototype.redraw = function () {
            this.outer.redraw();
        };
        BaseChart.prototype.destroy = function () {
            this.outer.destroy();
        };
        return BaseChart;
    }());
    TF.BaseChart = BaseChart;
    var LineChart = (function (_super) {
        __extends(LineChart, _super);
        function LineChart(tag, dataFn, xType, colorScale, tooltip) {
            _super.call(this, tag, dataFn, xType, colorScale, tooltip);
            this.datasets = [];
            // lastPointDataset is a dataset that contains just the last point of
            // every dataset we're currently drawing.
            this.lastPointsDataset = new Plottable.Dataset();
            this.nanDataset = new Plottable.Dataset();
            // need to do a single bind, so we can deregister the callback from
            // old Plottable.Datasets. (Deregistration is done by identity checks.)
            this.updateSpecialDatasets = this._updateSpecialDatasets.bind(this);
            this.buildChart(xType);
        }
        LineChart.prototype.buildPlot = function (xAccessor, xScale, yScale) {
            var _this = this;
            this.yAccessor = function (d) { return d.scalar; };
            var linePlot = new Plottable.Plots.Line();
            linePlot.x(xAccessor, xScale);
            linePlot.y(this.yAccessor, yScale);
            linePlot.attr('stroke', function (d, i, dataset) {
                return _this.colorScale.scale(dataset.metadata().run);
            });
            this.linePlot = linePlot;
            var group = this.setupTooltips(linePlot);
            // The scatterPlot will display the last point for each dataset.
            // This way, if there is only one datum for the series, it is still
            // visible. We hide it when tooltips are active to keep things clean.
            var scatterPlot = new Plottable.Plots.Scatter();
            scatterPlot.x(xAccessor, xScale);
            scatterPlot.y(this.yAccessor, yScale);
            scatterPlot.attr('fill', function (d) { return _this.colorScale.scale(d.run); });
            scatterPlot.attr('opacity', 1);
            scatterPlot.size(TOOLTIP_CIRCLE_SIZE * 2);
            scatterPlot.datasets([this.lastPointsDataset]);
            this.scatterPlot = scatterPlot;
            var nanDisplay = new Plottable.Plots.Scatter();
            nanDisplay.x(xAccessor, xScale);
            nanDisplay.y(function (x) { return x.displayY; }, yScale);
            nanDisplay.attr('fill', function (d) { return _this.colorScale.scale(d.run); });
            nanDisplay.attr('opacity', 1);
            nanDisplay.size(NAN_SYMBOL_SIZE * 2);
            nanDisplay.datasets([this.nanDataset]);
            nanDisplay.symbol(Plottable.SymbolFactories.triangleUp);
            this.nanDisplay = nanDisplay;
            return new Plottable.Components.Group([nanDisplay, scatterPlot, group]);
        };
        /** Constructs special datasets. Each special dataset contains exceptional
         * values from all of the regular datasetes, e.g. last points in series, or
         * NaN values. Those points will have a `run` and `relative` property added
         * (since usually those are context in the surrounding dataset).
         */
        LineChart.prototype._updateSpecialDatasets = function () {
            var lastPointsData = this.datasets
                .map(function (d) {
                var datum = null;
                // filter out NaNs to ensure last point is a clean one
                var nonNanData = d.data().filter(function (x) { return !isNaN(x.scalar); });
                if (nonNanData.length > 0) {
                    var idx = nonNanData.length - 1;
                    datum = nonNanData[idx];
                    datum.run = d.metadata().run;
                    datum.relative = relativeAccessor(datum, -1, d);
                }
                return datum;
            })
                .filter(function (x) { return x != null; });
            this.lastPointsDataset.data(lastPointsData);
            // Take a dataset, return an array of NaN data points
            // the NaN points will have a "displayY" property which is the
            // y-value of a nearby point that was not NaN (0 if all points are NaN)
            var datasetToNaNData = function (d) {
                var displayY = null;
                var data = d.data();
                var i = 0;
                while (i < data.length && displayY == null) {
                    if (!isNaN(data[i].scalar)) {
                        displayY = data[i].scalar;
                    }
                    i++;
                }
                if (displayY == null) {
                    displayY = 0;
                }
                var nanData = [];
                for (i = 0; i < data.length; i++) {
                    if (!isNaN(data[i].scalar)) {
                        displayY = data[i].scalar;
                    }
                    else {
                        data[i].run = d.metadata().run;
                        data[i].displayY = displayY;
                        data[i].relative = relativeAccessor(data[i], -1, d);
                        nanData.push(data[i]);
                    }
                }
                return nanData;
            };
            var nanData = _.flatten(this.datasets.map(datasetToNaNData));
            this.nanDataset.data(nanData);
        };
        LineChart.prototype.setupTooltips = function (plot) {
            var _this = this;
            var pi = new Plottable.Interactions.Pointer();
            pi.attachTo(plot);
            // PointsComponent is a Plottable Component that will hold the little
            // circles we draw over the closest data points
            var pointsComponent = new Plottable.Component();
            var group = new Plottable.Components.Group([plot, pointsComponent]);
            var hideTooltips = function () {
                _this.tooltip.style('opacity', 0);
                _this.scatterPlot.attr('opacity', 1);
                pointsComponent.content().selectAll('.point').remove();
            };
            var enabled = true;
            var disableTooltips = function () {
                enabled = false;
                hideTooltips();
            };
            var enableTooltips = function () { enabled = true; };
            this.dzl.interactionStart(disableTooltips);
            this.dzl.interactionEnd(enableTooltips);
            pi.onPointerMove(function (p) {
                if (!enabled) {
                    return;
                }
                var target = {
                    x: p.x,
                    y: p.y,
                    datum: null,
                    dataset: null,
                };
                var centerBBox = _this.gridlines.content().node().getBBox();
                var points = plot.datasets().map(function (dataset) { return _this.findClosestPoint(target, dataset); });
                var pointsToCircle = points.filter(function (p) { return p != null &&
                    Plottable.Utils.DOM.intersectsBBox(p.x, p.y, centerBBox); });
                var pts = pointsComponent.content().selectAll('.point').data(pointsToCircle, function (p) { return p.dataset.metadata().run; });
                if (points.length !== 0) {
                    pts.enter().append('circle').classed('point', true);
                    pts.attr('r', TOOLTIP_CIRCLE_SIZE)
                        .attr('cx', function (p) { return p.x; })
                        .attr('cy', function (p) { return p.y; })
                        .style('stroke', 'none')
                        .attr('fill', function (p) { return _this.colorScale.scale(p.dataset.metadata().run); });
                    pts.exit().remove();
                    _this.drawTooltips(points, target);
                }
                else {
                    hideTooltips();
                }
            });
            pi.onPointerExit(hideTooltips);
            return group;
        };
        LineChart.prototype.drawTooltips = function (points, target) {
            var _this = this;
            // Formatters for value, step, and wall_time
            this.scatterPlot.attr('opacity', 0);
            var valueFormatter = multiscaleFormatter(Y_TOOLTIP_FORMATTER_PRECISION);
            var dist = function (p) {
                return Math.pow(p.x - target.x, 2) + Math.pow(p.y - target.y, 2);
            };
            var closestDist = _.min(points.map(dist));
            points = _.sortBy(points, function (d) { return d.dataset.metadata().run; });
            var rows = this.tooltip.select('tbody')
                .html('')
                .selectAll('tr')
                .data(points)
                .enter()
                .append('tr');
            // Grey out the point if any of the following are true:
            // - The cursor is outside of the x-extent of the dataset
            // - The point is rendered above or below the screen
            // - The point's y value is NaN
            rows.classed('distant', function (d) {
                var firstPoint = d.dataset.data()[0];
                var lastPoint = _.last(d.dataset.data());
                var firstX = _this.xScale.scale(_this.xAccessor(firstPoint, 0, d.dataset));
                var lastX = _this.xScale.scale(_this.xAccessor(lastPoint, 0, d.dataset));
                var s = d.datum.scalar;
                var yD = _this.yScale.domain();
                return target.x < firstX || target.x > lastX || s < yD[0] ||
                    s > yD[1] || isNaN(s);
            });
            rows.classed('closest', function (p) { return dist(p) === closestDist; });
            // It is a bit hacky that we are manually applying the width to the swatch
            // and the nowrap property to the text here. The reason is as follows:
            // the style gets updated asynchronously by Polymer scopeSubtree observer.
            // Which means we would get incorrect sizing information since the text
            // would wrap by default. However, we need correct measurements so that
            // we can stop the text from falling off the edge of the screen.
            // therefore, we apply the size-critical styles directly.
            rows.style('white-space', 'nowrap');
            rows.append('td')
                .append('span')
                .classed('swatch', true)
                .style('background-color', function (d) { return _this.colorScale.scale(d.dataset.metadata().run); });
            rows.append('td').text(function (d) { return d.dataset.metadata().run; });
            rows.append('td').text(function (d) {
                return isNaN(d.datum.scalar) ? 'NaN' : valueFormatter(d.datum.scalar);
            });
            rows.append('td').text(function (d) { return stepFormatter(d.datum.step); });
            rows.append('td').text(function (d) { return timeFormatter(d.datum.wall_time); });
            rows.append('td').text(function (d) { return relativeFormatter(relativeAccessor(d.datum, -1, d.dataset)); });
            // compute left position
            var documentWidth = document.body.clientWidth;
            var node = this.tooltip.node();
            var parentRect = node.parentElement.getBoundingClientRect();
            var nodeRect = node.getBoundingClientRect();
            // prevent it from falling off the right side of the screen
            var left = Math.min(0, documentWidth - parentRect.left - nodeRect.width - 60);
            this.tooltip.style('left', left + 'px');
            // compute top position
            if (parentRect.bottom + nodeRect.height + TOOLTIP_Y_PIXEL_OFFSET <
                document.body.clientHeight) {
                this.tooltip.style('top', parentRect.bottom + TOOLTIP_Y_PIXEL_OFFSET);
            }
            else {
                this.tooltip.style('bottom', parentRect.top - TOOLTIP_Y_PIXEL_OFFSET);
            }
            this.tooltip.style('opacity', 1);
        };
        LineChart.prototype.findClosestPoint = function (target, dataset) {
            var _this = this;
            var points = dataset.data().map(function (d, i) {
                var x = _this.xAccessor(d, i, dataset);
                var y = _this.yAccessor(d, i, dataset);
                return {
                    x: _this.xScale.scale(x),
                    y: _this.yScale.scale(y),
                    datum: d,
                    dataset: dataset,
                };
            });
            var idx = _.sortedIndex(points, target, function (p) { return p.x; });
            if (idx === points.length) {
                return points[points.length - 1];
            }
            else if (idx === 0) {
                return points[0];
            }
            else {
                var prev = points[idx - 1];
                var next = points[idx];
                var prevDist = Math.abs(prev.x - target.x);
                var nextDist = Math.abs(next.x - target.x);
                return prevDist < nextDist ? prev : next;
            }
        };
        LineChart.prototype.changeRuns = function (runs) {
            var _this = this;
            _super.prototype.changeRuns.call(this, runs);
            runs.reverse(); // draw first run on top
            this.datasets.forEach(function (d) { return d.offUpdate(_this.updateSpecialDatasets); });
            this.datasets = runs.map(function (r) { return _this.getDataset(r); });
            this.datasets.forEach(function (d) { return d.onUpdate(_this.updateSpecialDatasets); });
            this.linePlot.datasets(this.datasets);
        };
        return LineChart;
    }(BaseChart));
    TF.LineChart = LineChart;
    var HistogramChart = (function (_super) {
        __extends(HistogramChart, _super);
        function HistogramChart(tag, dataFn, xType, colorScale, tooltip) {
            _super.call(this, tag, dataFn, xType, colorScale, tooltip);
            this.buildChart(xType);
        }
        HistogramChart.prototype.changeRuns = function (runs) {
            var _this = this;
            _super.prototype.changeRuns.call(this, runs);
            var datasets = runs.map(function (r) { return _this.getDataset(r); });
            this.plots.forEach(function (p) { return p.datasets(datasets); });
        };
        HistogramChart.prototype.buildPlot = function (xAccessor, xScale, yScale) {
            var _this = this;
            var percents = [0, 228, 1587, 3085, 5000, 6915, 8413, 9772, 10000];
            var opacities = _.range(percents.length - 1)
                .map(function (i) { return (percents[i + 1] - percents[i]) / 2500; });
            var accessors = percents.map(function (p, i) { return function (datum) { return datum[i][1]; }; });
            var median = 4;
            var medianAccessor = accessors[median];
            var plots = _.range(accessors.length - 1).map(function (i) {
                var p = new Plottable.Plots.Area();
                p.x(xAccessor, xScale);
                var y0 = i > median ? accessors[i] : accessors[i + 1];
                var y = i > median ? accessors[i + 1] : accessors[i];
                p.y(y, yScale);
                p.y0(y0);
                p.attr('fill', function (d, i, dataset) {
                    return _this.colorScale.scale(dataset.metadata().run);
                });
                p.attr('stroke', function (d, i, dataset) {
                    return _this.colorScale.scale(dataset.metadata().run);
                });
                p.attr('stroke-weight', function (d, i, m) { return '0.5px'; });
                p.attr('stroke-opacity', function () { return opacities[i]; });
                p.attr('fill-opacity', function () { return opacities[i]; });
                return p;
            });
            var medianPlot = new Plottable.Plots.Line();
            medianPlot.x(xAccessor, xScale);
            medianPlot.y(medianAccessor, yScale);
            medianPlot.attr('stroke', function (d, i, m) { return _this.colorScale.scale(m.run); });
            this.plots = plots;
            return new Plottable.Components.Group(plots);
        };
        return HistogramChart;
    }(BaseChart));
    TF.HistogramChart = HistogramChart;
    /* Create a formatter function that will switch between exponential and
     * regular display depending on the scale of the number being formatted,
     * and show `digits` significant digits.
     */
    function multiscaleFormatter(digits) {
        return function (v) {
            var absv = Math.abs(v);
            if (absv < 1E-15) {
                // Sometimes zero-like values get an annoying representation
                absv = 0;
            }
            var f;
            if (absv >= 1E4) {
                f = d3.format('.' + digits + 'e');
            }
            else if (absv > 0 && absv < 0.01) {
                f = d3.format('.' + digits + 'e');
            }
            else {
                f = d3.format('.' + digits + 'g');
            }
            return f(v);
        };
    }
    function accessorize(key) {
        return function (d, index, dataset) { return d[key]; };
    }
    var stepFormatter = Plottable.Formatters.siSuffix(STEP_FORMATTER_PRECISION);
    function stepX() {
        var scale = new Plottable.Scales.Linear();
        var axis = new Plottable.Axes.Numeric(scale, 'bottom');
        axis.formatter(stepFormatter);
        return {
            scale: scale,
            axis: axis,
            accessor: function (d) { return d.step; },
        };
    }
    var timeFormatter = Plottable.Formatters.time('%a %b %e, %H:%M:%S');
    function wallX() {
        var scale = new Plottable.Scales.Time();
        return {
            scale: scale,
            axis: new Plottable.Axes.Time(scale, 'bottom'),
            accessor: function (d) { return d.wall_time; },
        };
    }
    var relativeAccessor = function (d, index, dataset) {
        // We may be rendering the final-point datum for scatterplot.
        // If so, we will have already provided the 'relative' property
        if (d.relative != null) {
            return d.relative;
        }
        var data = dataset.data();
        // I can't imagine how this function would be called when the data is
        // empty (after all, it iterates over the data), but lets guard just
        // to be safe.
        var first = data.length > 0 ? +data[0].wall_time : 0;
        return (+d.wall_time - first) / (60 * 60 * 1000); // ms to hours
    };
    var relativeFormatter = function (n) {
        // we will always show 2 units of precision, e.g days and hours, or
        // minutes and seconds, but not hours and minutes and seconds
        var ret = '';
        var days = Math.floor(n / 24);
        n -= (days * 24);
        if (days) {
            ret += days + 'd ';
        }
        var hours = Math.floor(n);
        n -= hours;
        n *= 60;
        if (hours || days) {
            ret += hours + 'h ';
        }
        var minutes = Math.floor(n);
        n -= minutes;
        n *= 60;
        if (minutes || hours || days) {
            ret += minutes + 'm ';
        }
        var seconds = Math.floor(n);
        return ret + seconds + 's';
    };
    function relativeX() {
        var scale = new Plottable.Scales.Linear();
        return {
            scale: scale,
            axis: new Plottable.Axes.Numeric(scale, 'bottom'),
            accessor: relativeAccessor,
        };
    }
    // a very literal definition of NaN: true for NaN for a non-number type
    // or null, etc. False for Infinity or -Infinity
    var isNaN = function (x) { return +x !== x; };
    function getXComponents(xType) {
        switch (xType) {
            case 'step':
                return stepX();
            case 'wall_time':
                return wallX();
            case 'relative':
                return relativeX();
            default:
                throw new Error('invalid xType: ' + xType);
        }
    }
})(TF || (TF = {}));
</script>
  <script>
    Polymer({
      is: "tf-chart",
      properties: {
        type: String, // "scalar" or "compressedHistogram"
        _chart: Object,
        colorScale: Object,
        tag: String,
        selectedRuns: Array,
        xType: String,
        dataProvider: Function,
        _initialized: Boolean,
      },
      observers: [
        "_makeChart(type, tag, dataProvider, xType, colorScale, _initialized)",
        "_changeRuns(_chart, selectedRuns.*)"
      ],
      _changeRuns: function(chart) {
        if (chart.tag !== this.tag) {
          return; // hack around some weird polymer bug :(
        }
        this._chart.changeRuns(this.selectedRuns);
        this.redraw();
      },
      redraw: function() {
        this._chart.redraw();
      },
      reload: function() {
        this._chart.reload();
      },
      _constructor: function(type) {
        if (type === "scalar") {
          return TF.LineChart;
        } else if (type === "compressedHistogram") {
          return TF.HistogramChart;
        } else {
          throw new Error("Unrecognized chart type");
        }
      },
      _makeChart: function(type, tag, dataProvider, xType, colorScale, _initialized) {
        if (!_initialized) {
          return;
        }
        if (this._chart) this._chart.destroy();
        var cns = this._constructor(type);
        var tooltip = d3.select(this.$.tooltip);
        this.scopeSubtree(this.$.tooltip, true);
        var chart = new cns(tag, dataProvider, xType, colorScale, tooltip);
        var svg = d3.select(this.$.chartsvg);
        this.async(function() {
          chart.renderTo(svg);
          this._chart = chart;
        }, 350);
      },
      attached: function() {
        this._initialized = true;
      },
      detached: function() {
        this._initialized = false;
      }
    });
  </script>
</dom-module>

<dom-module id="tf-collapsable-pane" assetpath="../tf-collapsable-pane/">
  <template>
    <button class="heading" on-tap="togglePane" open-button$="[[opened]]">
    <span class="name">[[name]]</span>
    <span class="hackpadding"></span>
    <span class="count">
      <span>[[count]]</span>
    </span>
  </button>
    <iron-collapse opened="[[opened]]">
      <div class="content">
        <template is="dom-if" if="[[opened]]" restamp="[[restamp]]">
          <content></content>
        </template>
      </div>
    </iron-collapse>
    <style>
      :host {
        display: block;
        margin: 0 5px 1px 10px;
      }

      :host:first-of-type {
        margin-top: 20px;
      }
      
      :host:last-of-type {
        margin-bottom: 20px;
      }

      .heading {
        background-color: white;
        border-radius: 2px;
        border: none;
        cursor: pointer;
        -webkit-tap-highlight-color: rgba(0,0,0,0);
        width: 100%;
        box-sizing: border-box;
        font-size: 15px;
        display: inline-flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        line-height: 1;
        box-shadow: 0 1px 5px rgba(0,0,0,0.2);
        padding: 10px 15px;
      }

      .content {
        padding: 15px;
        border: 1px solid #dedede;
        border-top: none;
        border-bottom-left-radius: 2px;
        border-bottom-right-radius: 2px;
        background: white;
      }

      [open-button] {
        border-bottom-left-radius: 0px !important;
        border-bottom-right-radius: 0px !important;
      }

      .name {
        flex-grow: 0;
      }

      .count {
        flex-grow: 0;
        float: right;
        margin-right: 5px;
        font-size: 12px;
        color: var(--paper-grey-500);
      }

      .hackpadding {
        /* An obnoxious hack, but I can't get justify-content: space-between to work */
        flex-grow: 1;
      }
    </style>
  </template>
  <script>
    Polymer({
      is: "tf-collapsable-pane",
      properties: {
        opened: {type: Boolean, value: false},
        restamp: {type: Boolean, value: true},
        name: {type: String, observer: "hide"},
        count: {type: Number},
      },
      hide: function() {
        this.opened = false;
      },
      togglePane: function() {
        this.opened = !this.opened;
      }
    });
  </script>

</dom-module>

<dom-module id="tf-dashboard-layout" assetpath="../tf-dashboard-common/">
  <template>
    <div id="sidebar">
      <content select=".sidebar"></content>
    </div>

    <div id="center" class="scrollbar">
      <content select=".center"></content>
    </div>
    <style include="scrollbar-style"></style>
    <style>
      #sidebar {
        width: inherit;
        height: 100%;
        overflow: ellipsis;
        flex-grow: 0;
        flex-shrink: 0;
      }

      #center {
        height: 100%;
        overflow-y: scroll;
        flex-grow: 1;
        flex-shrink: 1;
      }

      .tf-graph-dashboard #center {
        background: white;
      }

      :host {
        display: flex;
        flex-direction: row;
        height: 100%;
      }
    </style>
  </template>
  <script>
    Polymer({
      is: "tf-dashboard-layout",
    });
  </script>
</dom-module>
<dom-module id="dashboard-style" assetpath="../tf-dashboard-common/">
  <template>
    <style>
      .card {
        height: 200px;
        width: 300px;
        display: flex;
        flex-direction: column;
        margin: 5px;
        padding: 0 30px 30px 0;
        -webkit-user-select: none;
        -moz-user-select: none;
        position: relative;
      }

      .card .card-title {
        flex-grow: 0;
        flex-shrink: 0;
        margin-bottom: 10px;
        font-size: 14px;
        text-overflow: ellipsis;
        overflow: hidden;
      }

      .card .card-content {
        flex-grow: 1;
        flex-shrink: 1;
        display: flex;
      }
      .card .card-bottom-row {
        flex-grow: 0;
        flex-shrink: 0;
        padding-left: 10px;
        padding-right: 10px;
      }

      .card.selected {
        height: 400px;
        width: 100%;
      }

      [shift] {
        bottom: 20px !important;
      }

      .expand-button {
        position: absolute;
        left: 0px;
        bottom: 20px;
        color: #2196F3;
        display: block;
      }

      #content-container{
        display: block;
      }

      .sidebar {
        display: flex;
        flex-direction: column;
        height: 100%;
        margin-right: 20px;
      }

      #categorizer {
        flex-shrink: 0;
      }

      #xTypeSelector {
        flex-shrink: 0;
        margin: 20px 0;
      }

      #runSelector {
        flex-shrink: 1;
        flex-grow: 1;
      }

      .sidebar-section {
        border-top: solid 1px rgba(0, 0, 0, 0.12);
        padding: 20px 0px 20px 30px;
      }

      .sidebar-section:first-child {
        border: none;
      }

      .sidebar-section:last-child {
        flex-grow: 1;
        display: flex;
      }

      paper-checkbox {
        --paper-checkbox-checked-color: var(--tb-ui-dark-accent);
        --paper-checkbox-unchecked-color: var(--tb-ui-dark-accent);
        font-size: 14px;
      }

    </style>
  </template>
</dom-module>

<dom-module id="tf-downloader" assetpath="../tf-dashboard-common/">
  <template>
    <paper-dropdown-menu no-label-float="true" label="run to download" selected-item-label="{{_run}}">
      <paper-menu class="dropdown-content">
        <template is="dom-repeat" items="[[_runs]]">
          <paper-item no-label-float="true">[[item]]</paper-item>
        </template>
      </paper-menu>
    </paper-dropdown-menu>
    <a download="[[_csvName(_run)]]" href="[[_csvUrl(_run, urlFn)]]">CSV</a>
    <a download="[[_jsonName(_run)]]" href="[[_jsonUrl(_run, urlFn)]]">JSON</a>
    <style>
      :host {
        display: block;
      }
      paper-dropdown-menu {
        width: 220px;
        --paper-input-container-label: {
          font-size: 10px;
        }
        --paper-input-container-input: {
          font-size: 10px;
        }
      }
      a {
        font-size: 10px;
        border-radius: 3px;
        border: 1px solid #EEE;
      }
      paper-input {
        font-size: 22px;
      }
    </style>
  </template>
  <script>
    Polymer({
      is: "tf-downloader",
      properties: {
        _run: String,
        _runs: {
          type: Array,
          computed: "_computeRuns(runToTag.*, selectedRuns.*)",
        },
        selectedRuns: Array,
        runToTag: Object,
        tag: String,
        urlFn: Function,
      },
      _computeRuns: function(runToTagChange, selectedRunsChange) {
        var runToTag = this.runToTag;
        var tag = this.tag;
        return this.selectedRuns.filter(function(x) {
          return runToTag[x].indexOf(tag) !== -1;
        })
      },
      _csvUrl: function(_run, urlFn) {
        return urlFn(this.tag, _run) + "&format=csv";
      },
      _jsonUrl: function(_run, urlFn) {
        return urlFn(this.tag, _run);
      },
      _csvName: function(_run) {
        return "run_" + _run + ",tag_" + this.tag + ".csv";
      },
      _jsonName: function(_run) {
        return "run-" + _run + "-tag-" + this.tag + ".json";
      },
    });
  </script>
</dom-module>

<dom-module id="tf-no-data-warning" assetpath="../tf-dashboard-common/">
  <template>
    <template is="dom-if" if="[[showWarning]]">
      <div class="warning">
        <template is="dom-if" if="[[graphMode]]">
          <h3>
            No graph definition files were found.
          </h3>
          <p>
            To store a graph, create a
            <code>tf.train.SummaryWriter</code>
            and pass the graph either via the constructor, or by calling its
            <code>add_graph()</code> method.
            You may want to check out the
            <a href="https://www.tensorflow.org/versions/master/how_tos/graph_viz/index.html">
              graph visualizer tutorial
            </a>
            .
          </p>
        </template>
        <template is="dom-if" if="[[!graphMode]]">
          <h3>
            No <span>[[dataType]]</span> data was found.
          </h3>
          <p>
            Probable causes:
            </p><ul>
              <li>
                You haven't written any <span>[[dataType]]</span> data
                to your event files.
              </li>
              <li>
                TensorBoard can't find your event files.
              </li>
            </ul>
          <p></p>
        </template>
        <p>
          If you're new to using TensorBoard, and want to find out how to add
          data and set up your event files, check out the
          <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tensorboard/README.md">
            README
          </a>
          and perhaps the
          <a href="https://www.tensorflow.org/versions/master/how_tos/summaries_and_tensorboard/index.html">
            TensorBoard tutorial
          </a>.
        </p>

        <p>
          If you think TensorBoard is configured properly, please see the
          <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tensorboard/README.md#my-tensorboard-isnt-showing-any-data-whats-wrong">
            section of the README devoted to missing data problems
          </a>
          and consider filing an issue on GitHub.
        </p>

      </div>
    </template>
    <style>
      .warning {
        max-width: 540px;
        margin: 80px auto 0 auto;
      }
    </style>
  </template>

  <script>
    Polymer({
      is: "tf-no-data-warning",
      properties: {
        dataType: String,
        showWarning: Boolean,
        graphMode: {type: Boolean, computed: "_isGraph(dataType)"},
      },
      _isGraph: function(dataType) {
        return dataType === "graph";
      },
    });
  </script>
</dom-module>
<script>var TF;
(function (TF) {
    var Dashboard;
    (function (Dashboard) {
        /**
         * ReloadBehavior: A simple behavior for dashboards where the
         * frontendReload() function should find every child element with a
         * given tag name (e.g. "tf-chart" or "tf-image-loader")
         * and call a `reload` method on that child.
         * May later extend it so it has more sophisticated logic, e.g. reloading
         * only tags that are in view.
         */
        function ReloadBehavior(tagName) {
            return {
                properties: {
                    reloadTag: {
                        type: String,
                        value: tagName,
                    },
                },
                frontendReload: function () {
                    var elements = this.getElementsByTagName(this.reloadTag);
                    Array.prototype.forEach.call(elements, function (x) { x.reload(); });
                },
            };
        }
        Dashboard.ReloadBehavior = ReloadBehavior;
    })(Dashboard = TF.Dashboard || (TF.Dashboard = {}));
})(TF || (TF = {}));
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var TF;
(function (TF) {
    var Backend;
    (function (Backend) {
        /**
         * Manages many fetch requests. Launches up to nSimultaneousRequests
         * simultaneously, and maintains a LIFO queue of requests to process when
         * more urls are requested than can be handled at once. The queue can be
         * cleared.
         *
         * When a request is made, a Promise is returned which resolves with the
         * parsed JSON result from the request.
         */
        var RequestCancellationError = (function (_super) {
            __extends(RequestCancellationError, _super);
            function RequestCancellationError() {
                _super.apply(this, arguments);
                this.name = 'RequestCancellationError';
            }
            return RequestCancellationError;
        }(Error));
        Backend.RequestCancellationError = RequestCancellationError;
        var RequestNetworkError = (function (_super) {
            __extends(RequestNetworkError, _super);
            function RequestNetworkError(req, url) {
                _super.call(this);
                this.message = "RequestNetworkError: " + req.status + " at " + url;
                this.name = 'RequestNetworkError';
                this.req = req;
                this.url = url;
            }
            return RequestNetworkError;
        }(Error));
        Backend.RequestNetworkError = RequestNetworkError;
        var RequestManager = (function () {
            function RequestManager(nSimultaneousRequests, maxRetries) {
                if (nSimultaneousRequests === void 0) { nSimultaneousRequests = 10; }
                if (maxRetries === void 0) { maxRetries = 3; }
                this._queue = [];
                this._nActiveRequests = 0;
                this._nSimultaneousRequests = nSimultaneousRequests;
                this._maxRetries = maxRetries;
            }
            /* Gives a promise that loads assets from given url (respects queuing) */
            RequestManager.prototype.request = function (url) {
                var _this = this;
                var promise = new Promise(function (resolve, reject) {
                    var resolver = { resolve: resolve, reject: reject };
                    _this._queue.push(resolver);
                    _this.launchRequests();
                })
                    .then(function () {
                    return _this.promiseWithRetries(url, _this._maxRetries);
                })
                    .then(function (response) {
                    // Success - Let's free space for another active
                    // reqest, and launch it
                    _this._nActiveRequests--;
                    _this.launchRequests();
                    return response;
                }, function (rejection) {
                    if (rejection.name === 'RequestNetworkError') {
                        // If we failed due to network error, we should
                        // decrement
                        // _nActiveRequests because this request was
                        // active
                        _this._nActiveRequests--;
                        _this.launchRequests();
                    }
                    return Promise.reject(rejection);
                });
                return promise;
            };
            RequestManager.prototype.clearQueue = function () {
                while (this._queue.length > 0) {
                    this._queue.pop().reject(new RequestCancellationError('Request cancelled by clearQueue'));
                }
            };
            /* Return number of currently pending requests */
            RequestManager.prototype.activeRequests = function () {
                return this._nActiveRequests;
            };
            /* Return total number of outstanding requests (includes queue) */
            RequestManager.prototype.outstandingRequests = function () {
                return this._nActiveRequests + this._queue.length;
            };
            RequestManager.prototype.launchRequests = function () {
                while (this._nActiveRequests < this._nSimultaneousRequests &&
                    this._queue.length > 0) {
                    this._nActiveRequests++;
                    this._queue.pop().resolve();
                }
            };
            /**
             * Try to request a given URL using overwritable _promiseFromUrl method.
             * If the request fails for any reason, we will retry up to maxRetries
             * times. In practice, this will help us paper over transient network issues
             * like '502 Bad Gateway'.
             * By default, Chrome displays network errors in console, so
             * the user will be able to tell when the requests are failing. I think this
             * is a feature, if the request failures and retries are causing any
             * pain to users, they can see it and file issues.
             */
            RequestManager.prototype.promiseWithRetries = function (url, maxRetries) {
                var _this = this;
                var success = function (x) { return x; };
                var failure = function (x) {
                    if (maxRetries > 0) {
                        return _this.promiseWithRetries(url, maxRetries - 1);
                    }
                    else {
                        return Promise.reject(x);
                    }
                };
                return this._promiseFromUrl(url).then(success, failure);
            };
            /* Actually get promise from url using XMLHttpRequest */
            RequestManager.prototype._promiseFromUrl = function (url) {
                return new Promise(function (resolve, reject) {
                    var req = new XMLHttpRequest();
                    req.open('GET', url);
                    req.onload = function () {
                        if (req.status === 200) {
                            resolve(JSON.parse(req.responseText));
                        }
                        else {
                            reject(new RequestNetworkError(req, url));
                        }
                    };
                    req.onerror = function () {
                        reject(new RequestNetworkError(req, url));
                    };
                    req.send();
                });
            };
            return RequestManager;
        }());
        Backend.RequestManager = RequestManager;
    })(Backend = TF.Backend || (TF.Backend = {}));
})(TF || (TF = {}));
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var TF;
(function (TF) {
    var Backend;
    (function (Backend) {
        Backend.BAD_CHARACTERS = '#%&{}\\/<>*? $!\'":@+`|=() ';
        /** Cleanup a url so that it can be loaded from a filesystem. */
        function demoify(s) {
            // for consistency with python's urllib.urlencode
            s = s.replace(new RegExp('%20', 'g'), '+');
            for (var i = 0; i < Backend.BAD_CHARACTERS.length; i++) {
                var c = Backend.BAD_CHARACTERS[i];
                s = s.replace(new RegExp('\\' + c, 'g'), '_');
            }
            return s;
        }
        Backend.demoify = demoify;
        function queryEncoder(params) {
            // It's important that the keys be sorted, so we always grab the right file
            // if we are talking to the backend generated by serialze_tensorboard.py
            if (params == null) {
                return '';
            }
            var components = _.keys(params)
                .sort()
                .filter(function (k) { return params[k] !== undefined; })
                .map(function (k) { return k + '=' + encodeURIComponent(params[k]); });
            var result = components.length ? '?' + components.join('&') : '';
            // Replace parens for consistency with urllib.urlencode
            return result.replace(/\(/g, '%28').replace(/\)/g, '%29');
        }
        Backend.queryEncoder = queryEncoder;
    })(Backend = TF.Backend || (TF.Backend = {}));
})(TF || (TF = {}));
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var TF;
(function (TF) {
    var Backend;
    (function (Backend) {
        ;
        /**
         * The standard router for communicating with the TensorBoard backend
         * @param dataDir {string} The base prefix for finding data on server.
         * @param demoMode {boolean} Whether to modify urls for filesystem demo usage.
         */
        function router(dataDir, demoMode) {
            if (dataDir === void 0) { dataDir = '/data'; }
            if (demoMode === void 0) { demoMode = false; }
            var clean = demoMode ? Backend.demoify : function (x) { return x; };
            if (dataDir[dataDir.length - 1] === '/') {
                dataDir = dataDir.slice(0, dataDir.length - 1);
            }
            function standardRoute(route, demoExtension) {
                if (demoExtension === void 0) { demoExtension = '.json'; }
                return function (tag, run) {
                    var url = dataDir + '/' + route + clean(Backend.queryEncoder({ tag: tag, run: run }));
                    if (demoMode) {
                        url += demoExtension;
                    }
                    return url;
                };
            }
            function individualImageUrl(query) {
                var url = dataDir + '/' + clean('individualImage?' + query);
                if (demoMode) {
                    url += '.png';
                }
                return url;
            }
            function individualAudioUrl(query) {
                var url = dataDir + '/' + clean('individualAudio?' + query);
                if (demoMode) {
                    url += '.wav';
                }
                return url;
            }
            function graphUrl(run, limit_attr_size, large_attrs_key) {
                var query_params = [['run', clean(run)]];
                if (limit_attr_size != null && !demoMode) {
                    query_params.push(['limit_attr_size', String(limit_attr_size)]);
                }
                if (large_attrs_key != null && !demoMode) {
                    query_params.push(['large_attrs_key', large_attrs_key]);
                }
                var query = query_params
                    .map(function (param) {
                    return param[0] + '=' + encodeURIComponent(param[1]);
                })
                    .join('&');
                var url = dataDir + '/graph' + clean('?' + query);
                if (demoMode) {
                    url += '.pbtxt';
                }
                return url;
            }
            return {
                runs: function () { return dataDir + '/runs' + (demoMode ? '.json' : ''); },
                individualImage: individualImageUrl,
                individualAudio: individualAudioUrl,
                graph: graphUrl,
                scalars: standardRoute('scalars'),
                histograms: standardRoute('histograms'),
                compressedHistograms: standardRoute('compressedHistograms'),
                images: standardRoute('images'),
                audio: standardRoute('audio'),
                runMetadata: standardRoute('run_metadata', '.pbtxt'),
            };
        }
        Backend.router = router;
        ;
    })(Backend = TF.Backend || (TF.Backend = {}));
})(TF || (TF = {}));
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var TF;
(function (TF) {
    var Backend;
    (function (Backend_1) {
        Backend_1.TYPES = [
            'scalar', 'histogram', 'compressedHistogram', 'graph', 'image', 'audio',
            'runMetadata'
        ];
        /**
         * The Backend class provides a convenient and typed interface to the backend.
         *
         * It provides methods corresponding to the different data sources on the
         * TensorBoard backend. These methods return a promise containing the data
         * from the backend. This class does some post-processing on the data; for
         * example, converting data elements tuples into js objects so that they can
         * be accessed in a more convenient and clearly-documented fashion.
         */
        var Backend = (function () {
            /**
             * Construct a Backend instance.
             * @param router the Router with info on what urls to get data from
             * @param requestManager The RequestManager, overwritable so you may
             * manually clear request queue, etc. Defaults to a new RequestManager.
             */
            function Backend(r, requestManager) {
                this.router = r;
                this.requestManager = requestManager || new Backend_1.RequestManager();
            }
            /**
             * Returns a listing of all the available data in the TensorBoard backend.
             * Will be deprecated in the future, in favor of
             * per-data-type methods.
             */
            Backend.prototype.runs = function () {
                return this.requestManager.request(this.router.runs());
            };
            /**
             * Return a promise showing the Run-to-Tag mapping for scalar data.
             * TODO(cassandrax): Replace this with the direct route, when
             * available.
             */
            Backend.prototype.scalarRuns = function () {
                return this.runs().then(function (x) { return _.mapValues(x, 'scalars'); });
            };
            /**
             * Return a promise showing the Run-to-Tag mapping for histogram data.
             * TODO(cassandrax): Replace this with the direct route, when
             * available.
             */
            Backend.prototype.histogramRuns = function () {
                return this.runs().then(function (x) { return _.mapValues(x, 'histograms'); });
            };
            /**
             * Return a promise showing the Run-to-Tag mapping for image data.
             * TODO(cassandrax): Replace this with the direct route, when
             * available.
             */
            Backend.prototype.imageRuns = function () {
                return this.runs().then(function (x) { return _.mapValues(x, 'images'); });
            };
            /**
             * Return a promise showing the Run-to-Tag mapping for audio data.
             * TODO(cassandrax): Replace this with the direct route, when
             * available.
             */
            Backend.prototype.audioRuns = function () {
                return this.runs().then(function (x) { return _.mapValues(x, 'audio'); });
            };
            /**
             * Return a promise showing the Run-to-Tag mapping for compressedHistogram
             * data.
             * TODO(cassandrax): Replace this with the direct route, when
             * available.
             */
            Backend.prototype.compressedHistogramRuns = function () {
                return this.runs().then(function (x) { return _.mapValues(x, 'compressedHistograms'); });
            };
            /**
             * Return a promise showing list of runs that contain graphs.
             * TODO(cassandrax): Replace this with the direct route, when
             * available.
             */
            Backend.prototype.graphRuns = function () {
                return this.runs().then(function (x) { return _.keys(x).filter(function (k) { return x[k].graph; }); });
            };
            /**
             * Return a promise showing the Run-to-Tag mapping for run_metadata objects.
             * TODO(cassandrax): Replace this with the direct route, when
             * available.
             */
            Backend.prototype.runMetadataRuns = function () {
                return this.runs().then(function (x) { return _.mapValues(x, 'run_metadata'); });
            };
            /**
             * Return a promise of a graph string from the backend.
             */
            Backend.prototype.graph = function (tag, limit_attr_size, large_attrs_key) {
                var url = this.router.graph(tag, limit_attr_size, large_attrs_key);
                return this.requestManager.request(url);
            };
            /**
             * Return a promise containing ScalarDatums for given run and tag.
             */
            Backend.prototype.scalar = function (tag, run) {
                var p;
                var url = this.router.scalars(tag, run);
                p = this.requestManager.request(url);
                return p.then(map(detupler(createScalar)));
            };
            /**
             * Return a promise containing HistogramDatums for given run and tag.
             */
            Backend.prototype.histogram = function (tag, run) {
                var p;
                var url = this.router.histograms(tag, run);
                p = this.requestManager.request(url);
                return p.then(map(detupler(createHistogram))).then(function (histos) {
                    return histos.map(function (histo, i) {
                        return {
                            wall_time: histo.wall_time,
                            step: histo.step,
                            bins: convertBins(histo)
                        };
                    });
                });
            };
            /**
             * Return a promise containing ImageDatums for given run and tag.
             */
            Backend.prototype.image = function (tag, run) {
                var url = this.router.images(tag, run);
                var p;
                p = this.requestManager.request(url);
                return p.then(map(this.createImage.bind(this)));
            };
            /**
             * Return a promise containing AudioDatums for given run and tag.
             */
            Backend.prototype.audio = function (tag, run) {
                var url = this.router.audio(tag, run);
                var p;
                p = this.requestManager.request(url);
                return p.then(map(this.createAudio.bind(this)));
            };
            /**
             * Returns a promise to load the string RunMetadata for given run/tag.
             */
            Backend.prototype.runMetadata = function (tag, run) {
                var url = this.router.runMetadata(tag, run);
                return this.requestManager.request(url);
            };
            /**
             * Get compressedHistogram data.
             * Unlike other methods, don't bother reprocessing this data into a nicer
             * format. This is because we will deprecate this route.
             */
            Backend.prototype.compressedHistogram = function (tag, run) {
                var url = this.router.compressedHistograms(tag, run);
                var p;
                p = this.requestManager.request(url);
                return p.then(map(detupler(function (x) { return x; })));
            };
            Backend.prototype.createImage = function (x) {
                return {
                    width: x.width,
                    height: x.height,
                    wall_time: timeToDate(x.wall_time),
                    step: x.step,
                    url: this.router.individualImage(x.query),
                };
            };
            Backend.prototype.createAudio = function (x) {
                return {
                    content_type: x.content_type,
                    wall_time: timeToDate(x.wall_time),
                    step: x.step,
                    url: this.router.individualAudio(x.query),
                };
            };
            return Backend;
        }());
        Backend_1.Backend = Backend;
        /** Given a RunToTag, return sorted array of all runs */
        function getRuns(r) { return _.keys(r).sort(); }
        Backend_1.getRuns = getRuns;
        /** Given a RunToTag, return array of all tags (sorted + dedup'd) */
        function getTags(r) {
            return _.union.apply(null, _.values(r)).sort();
        }
        Backend_1.getTags = getTags;
        /**
         * Given a RunToTag and an array of runs, return every tag that appears for
         * at least one run.
         * Sorted, deduplicated.
         */
        function filterTags(r, runs) {
            var result = [];
            runs.forEach(function (x) { return result = result.concat(r[x]); });
            return _.uniq(result).sort();
        }
        Backend_1.filterTags = filterTags;
        function timeToDate(x) { return new Date(x * 1000); }
        ;
        /**  Just a curryable map to make things cute and tidy. */
        function map(f) {
            return function (arr) { return arr.map(f); };
        }
        ;
        /**
         * This is a higher order function that takes a function that transforms a
         * T into a G, and returns a function that takes TupleData<T>s and converts
         * them into the intersection of a G and a Datum.
         */
        function detupler(xform) {
            return function (x) {
                // Create a G, assert it has type <G & Datum>
                var obj = xform(x[2]);
                // ... patch in the properties of datum
                obj.wall_time = timeToDate(x[0]);
                obj.step = x[1];
                return obj;
            };
        }
        ;
        function createScalar(x) { return { scalar: x }; }
        ;
        function createHistogram(x) {
            return {
                min: x[0],
                max: x[1],
                nItems: x[2],
                sum: x[3],
                sumSquares: x[4],
                bucketRightEdges: x[5],
                bucketCounts: x[6],
            };
        }
        ;
        /**
         * Takes histogram data as stored by tensorboard backend and converts it to
         * the standard d3 histogram data format to make it more compatible and easier
         * to visualize. When visualizing histograms, having the left edge and width
         * makes things quite a bit easier.
         *
         * @param histogram A histogram from tensorboard backend.
         * @return A histogram bin. Each bin has an x (left edge), a dx (width),
         *     and a y (count).
         *
         * If given rightedges are inclusive, then these left edges (x) are exclusive.
         */
        function convertBins(histogram) {
            if (histogram.bucketRightEdges.length !== histogram.bucketCounts.length) {
                throw (new Error('Edges and counts are of different lengths.'));
            }
            var previousRightEdge = histogram.min;
            return histogram.bucketRightEdges.map(function (rightEdge, i) {
                // Use the previous bin's rightEdge as the new leftEdge
                var left = previousRightEdge;
                // We need to clip the rightEdge because right-most edge can be
                // infinite-sized
                var right = Math.min(histogram.max, rightEdge);
                // Store rightEdgeValue for next iteration
                previousRightEdge = rightEdge;
                return { x: left, dx: right - left, y: histogram.bucketCounts[i] };
            });
        }
        Backend_1.convertBins = convertBins;
    })(Backend = TF.Backend || (TF.Backend = {}));
})(TF || (TF = {}));
</script>
<script>var TF;
(function (TF) {
    var Backend;
    (function (Backend) {
        Backend.Behavior = {
            properties: {
                /** *** Required properties *** */
                /** Data type. One of TF.Backend.TYPES */
                dataType: {
                    type: String,
                    observer: '_throwErrorOnUnrecognizedType',
                },
                /** TF.Backend.Backend for data loading. */
                backend: {
                    type: Object,
                },
                /** Should it automatically load when configured ready? Default true. */
                autoLoad: {
                    type: Boolean,
                    value: true,
                },
                /** *** Component-provided properties *** */
                /** Every tag available for data type (sorted, dedpulicated) */
                tags: {
                    type: Array,
                    readOnly: true,
                    notify: true,
                },
                /** Every run available for data type (sorted) */
                runs: {
                    type: Array,
                    readOnly: true,
                    notify: true,
                },
                /** Mapping from runs to tags for the data type */
                run2tag: {
                    type: Object,
                    readOnly: true,
                    notify: true,
                },
                /** Promise provider for the data. Useful for passing to subcomponents */
                dataProvider: { type: Function, computed: '_getDataProvider(dataType, backend)' },
                /** Has the dashboard loaded yet? */
                loadState: {
                    type: String,
                    value: 'noload',
                    readOnly: true,
                },
                /**
                 * True if dashboard has loaded, and no tags were found.
                 * Persists through subsequent reloads (ie. still true while
                 * next load is pending) so warning won't flash away every reload
                 * when there is no data.
                 */
                dataNotFound: {
                    type: Boolean,
                    value: false,
                    readOnly: true,
                }
            },
            observers: ['_do_autoLoad(dataType, backend, autoLoad)'],
            /**
             * Reloading works in two steps:
             * Backend reload, which gets metadata on available runs, tags, etc from
             *   the backend.
             * Frontend reload, which loads new data for each chart or visual display.
             * Backend reload logic is provided by this behaivor. The frontend reload
             *   logic should be provided elsewhere, since it is component-specific.
             * To keep things simple and consistent, we do the backend reload first,
             *   and the frontend reload afterwards.
             */
            reload: function () {
                var _this = this;
                return this.backendReload().then(function (x) { return _this.frontendReload(); });
            },
            /**
             * Load data from backend and then set run2tag, tags, runs, and loadState.
             * Returns a promise that resolves/rejects when data is loaded.
             */
            backendReload: function () {
                var _this = this;
                if (this.dataType == null) {
                    throw new Error('TF.Backend.Behavior: Need a dataType to reload.');
                }
                if (this.backend == null) {
                    throw new Error('TF.Backend.Behavior: Need a backend to reload.');
                }
                var runsRoute = this.backend[this.dataType + 'Runs'].bind(this.backend);
                this._setLoadState('pending');
                return runsRoute().then(function (x) {
                    _this._setLoadState('loaded');
                    if (_.isEqual(x, _this.run2tag)) {
                        // If x and run2tag are equal, let's avoid updating everything
                        // since that can needlessly trigger run changes, reloads, etc
                        return x;
                    }
                    _this._setRun2tag(x);
                    var tags = TF.Backend.getTags(x);
                    _this._setDataNotFound(tags.length === 0);
                    _this._setTags(tags);
                    _this._setRuns(TF.Backend.getRuns(x));
                    return x;
                }, function (fail) {
                    _this._setLoadState('failure');
                    return fail;
                });
            },
            _do_autoLoad: function (type, backend, autoLoad) {
                if (autoLoad) {
                    this.reload();
                }
                ;
            },
            _getDataProvider: function (dataType, backend) {
                return this.backend[this.dataType].bind(this.backend);
            },
            _throwErrorOnUnrecognizedType: function (dataType) {
                if (TF.Backend.TYPES.indexOf(dataType) === -1) {
                    throw new Error('TF.Backend.Behavior: Unknown dataType ' + dataType);
                }
            },
        };
    })(Backend = TF.Backend || (TF.Backend = {}));
})(TF || (TF = {}));
</script>

<dom-module id="tf-event-dashboard" assetpath="../tf-event-dashboard/">
  <template>
    <div id="plumbing">
      <tf-color-scale id="colorScale" runs="[[runs]]" out-color-scale="{{colorScale}}"></tf-color-scale>
    </div>

    <tf-dashboard-layout>
      <div class="sidebar">
        <div class="sidebar-section">
          <tf-categorizer id="categorizer" tags="[[_visibleTags]]" categories="{{categories}}"></tf-categorizer>
          <paper-checkbox id="download-option" checked="{{_show_download_links}}">Data download links</paper-checkbox>
        </div>
        <div class="sidebar-section">
          <tf-x-type-selector id="xTypeSelector" out-x-type="{{xType}}"></tf-x-type-selector>
        </div>
        <div class="sidebar-section">
          <tf-run-selector id="runSelector" runs="[[runs]]" color-scale="[[colorScale]]" out-selected="{{selectedRuns}}"></tf-run-selector>
        </div>
      </div>
      <div class="center">
        <tf-no-data-warning data-type="scalar" show-warning="[[dataNotFound]]"></tf-no-data-warning>
        <template is="dom-repeat" items="[[categories]]">
          <tf-collapsable-pane name="[[item.name]]" count="[[item.tags.length]]">
            <div class="layout horizontal wrap">
              <template is="dom-repeat" items="[[item.tags]]" as="tag">
                <div class="card">
                  <span class="card-title">[[tag]]</span>
                  <div class="card-content">
                    <tf-chart tag="[[tag]]" data-provider="[[dataProvider]]" type="scalar" id="chart" selected-runs="[[validRuns(tag, selectedRuns.*, run2tag.*)]]" x-type="[[xType]]" color-scale="[[colorScale]]" on-keyup="toggleSelected" tabindex="2"></tf-chart>
                    <paper-icon-button class="expand-button" shift$="[[_show_download_links]]" icon="fullscreen" on-tap="toggleSelected"></paper-icon-button>
                  </div>
                  <template is="dom-if" if="[[_show_download_links]]">
                    <div class="card-bottom-row">
                      <tf-downloader selected-runs="[[selectedRuns]]" tag="[[tag]]" url-fn="[[scalarUrl]]" run-to-tag="[[run2tag]]">
                      </tf-downloader>
                    </div>
                  </template>
                </div>
              </template>
            </div>
          </tf-collapsable-pane>
        </template>
      </div>
    </tf-dashboard-layout>

    <style include="dashboard-style"></style>

  </template>

  <script>
    Polymer({
      is: "tf-event-dashboard",
      behaviors: [
        TF.Dashboard.ReloadBehavior("tf-chart"),
        TF.Backend.Behavior,
      ],
      properties: {
        dataType: {value: "scalar"},
        router: Object,
        scalarUrl: {
          type: Function,
          computed: "_getScalarUrl(router)",
        },
        _visibleTags: {
          type: Array,
          computed: "_getVisibleTags(selectedRuns.*, run2tag.*)"
        },
        _show_download_links: Boolean,
        colorScale: {
          type: Object,
          notify: true,
        },
      },
      attached: function() {
        this.async(function() {
          this.fire("rendered");
        });
      },
      observers: ['redraw(_show_download_links)'],
      redraw: function(_show_download_links) {
        var els = this.getElementsByTagName("tf-chart");
        for (var i=0; i<els.length; i++) {
          els[i].redraw();
        }
      },
      _getVisibleTags: function() {
        var keys = this.selectedRuns;
        var dict = this.run2tag;
        return _.union.apply(null, keys.map(function(k) {return dict[k]}));
      },
      _getScalarUrl: function() {
        return this.router.scalars;
      },
      toggleSelected: function(e) {
        var currentTarget = Polymer.dom(e.currentTarget);
        var parentDiv = currentTarget.parentNode.parentNode;
        parentDiv.classList.toggle("selected");
        var chart = currentTarget.previousElementSibling;
        if (chart) {
          chart.redraw();
        }
      },
      validRuns: function(tag, runsChange, run2tagChange) {
        var _this = this;
        var result = this.selectedRuns.filter(function(r) {
          return _this.run2tag[r] && _this.run2tag[r].indexOf(tag) !== -1;
        });
        return result;
      },
    });
  </script>
</dom-module>

<dom-module id="tf-histogram-dashboard" assetpath="../tf-histogram-dashboard/">
  <template>
    <div id="plumbing">
      <tf-color-scale id="colorScale" runs="[[runs]]" out-color-scale="{{colorScale}}"></tf-color-scale>
    </div>

    <tf-dashboard-layout>
      <div class="sidebar">
        <div class="sidebar-section">
          <tf-categorizer id="categorizer" tags="[[_visibleTags]]" categories="{{categories}}"></tf-categorizer>
        </div>
        <div class="sidebar-section">
          <tf-x-type-selector id="xTypeSelector" out-x-type="{{xType}}"></tf-x-type-selector>
        </div>
        <div class="sidebar-section">
          <tf-run-selector id="runSelector" runs="[[runs]]" color-scale="[[colorScale]]" out-selected="{{selectedRuns}}"></tf-run-selector>
          </div>
      </div>

      <div class="center">
        <tf-no-data-warning data-type="histogram" show-warning="[[dataNotFound]]"></tf-no-data-warning>
        <template is="dom-repeat" items="[[categories]]">
          <tf-collapsable-pane name="[[item.name]]" count="[[_count(item.tags, selectedRuns.*, runToCompressedHistograms.*)]]">
            <div class="layout horizontal wrap">
              <template is="dom-repeat" items="[[item.tags]]" as="tag">
                <template is="dom-repeat" items="[[selectedRuns]]" as="run">
                  <template is="dom-if" if="[[_exists(run, tag, run2tag.*)]]">
                    <div class="card">
                      <span class="card-title">[[tag]]</span>
                      <div class="card-content">
                        <tf-chart tag="[[tag]]" type="compressedHistogram" id="chart" selected-runs="[[_array(run)]]" x-type="[[xType]]" data-provider="[[dataProvider]]" color-scale="[[colorScale]]" on-keyup="toggleSelected" tabindex="2"></tf-chart>
                        <paper-icon-button class="expand-button" icon="fullscreen" on-tap="toggleSelected"></paper-icon-button>
                      </div>
                    </div>
                  </template>
                </template>
              </template>
            </div>
          </tf-collapsable-pane>
        </template>
      </div>
    </tf-dashboard-layout>

    <style include="dashboard-style"></style>
  </template>

  <script>
    Polymer({
      is: "tf-histogram-dashboard",
      behaviors: [
        TF.Dashboard.ReloadBehavior("tf-chart"),
        TF.Backend.Behavior,
      ],
      properties: {
        _visibleTags: {
          type: Array,
          computed: "_getVisibleTags(selectedRuns.*, run2tag.*)"
        },
        dataType: {value: "compressedHistogram"},
      },
      _exists: function(run, tag) {
        return this.run2tag[run].indexOf(tag) !== -1;
      },
      attached: function() {
        this.async(function() {
          this.fire("rendered");
        });
      },
      _array: function(x) {
        return [x];
      },
      _count: function(tags) {
        var targetTags = {};
        tags.forEach(function(t) {
          targetTags[t] = true;
        });
        var count = 0;
        var _this = this;
        this.selectedRuns.forEach(function(r) {
          _this.run2tag[r].forEach(function(t) {
            if (targetTags[t]) {
              count++;
            }
          });
        });
        return count;
      },
      _getVisibleTags: function() {
        var keys = this.selectedRuns;
        var dict = this.run2tag;
        return _.union.apply(null, keys.map(function(k) {return dict[k]}));
      },
      toggleSelected: function(e) {
        var currentTarget = Polymer.dom(e.currentTarget);
        var parentDiv = currentTarget.parentNode.parentNode;
        parentDiv.classList.toggle("selected");
        var chart = currentTarget.previousElementSibling;
        if (chart) {
          chart.redraw();
        }
      },
    });
  </script>
</dom-module>

<dom-module id="tf-image-loader" assetpath="../tf-image-dashboard/">
  <style>
  :host {
    display: block;
  }
  img {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    border: 1px solid #555;
  }
  </style>
  <template>
    <template is="dom-if" if="[[imageUrl]]">
      <img src="[[imageUrl]]" on-error="reload">
    </template>
  </template>
  <script>
    Polymer({
      is: "tf-image-loader",
      properties: {
        run: String,
        tag: String,
        imagesGenerator: Function,
        imageUrl: String,
      },
      reload: function() {
        var _this = this;
        this.imageUrl = ""; // force reload
        this.imagesGenerator(this.tag, this.run).then(function(metadatas) {
          var last_metadata = _.last(metadatas);
          _this.imageUrl = last_metadata.url;
        });
      },
      ready: function() {
        // Need to test so that it will not error if it is constructed w/o
        // all properties (so that it's possible to use stub to mock it out)
        if (this.run != null && this.tag != null && this.imagesGenerator != null) {
          this.reload();
        }
      },
    });
  </script>
</dom-module>

<dom-module id="tf-image-grid" assetpath="../tf-image-dashboard/">
  <template>
    <style include="scrollbar-style"></style>
    <div id="fullContainer" class="container scrollbar">
      <div id="topRow" class="container">
        <div class="noshrink cell" id="paddingCell"></div>
        <template is="dom-repeat" items="[[runs]]" as="run">
        <div class="run-name-cell cell noshrink">
          <span>[[run]]</span>
        </div>
      </template>
      </div>
      <div id="bottomContainer" class="container">
        <template is="dom-repeat" items="[[tags]]" as="tag">
          <div class="image-row container noshrink">
            <div class="tag-name-cell cell noshrink">
              <span class="tag-name">[[tag]]</span>
            </div>
            <template is="dom-repeat" items="[[runs]]" as="run">
              <div class="image-cell cell noshrink">
                <template is="dom-if" if="[[_exists(run, tag, runToImages.*)]]">
                  <tf-image-loader id="loader" run="[[run]]" tag="[[tag]]" images-generator="[[imagesGenerator]]">
                  </tf-image-loader>
                </template>
              </div>
            </template>
          </div>
        </template>
      </div>
    </div>
    <style>
      :host {
        display: block;
        height: 100%;
      }
      .container {
        display: flex;
        flex-wrap: nowrap;
      }
      #fullContainer {
        width: 100%;
        height: 100%;
        flex-direction: column;
        padding-top: 20px;
        overflow: scroll;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
      }
      #topRow {
        flex-direction: row;
      }
      #bottomContainer {
        flex-direction: column;
        height: 100%;
        width: 100%;
      }
      .cell {
        margin-right: 10px;
      }
      .image-row {
        flex-direction: row;
        padding-top: 10px;
      }
      .image-cell {
        width: 300px;
        height: 300px;
      }
      .tag-name-cell {
        height: 300px;
        width: 300px;
        display:flex;
        flex-direction: column;
        justify-content: center;
      }
      .tag-name {
        word-wrap: break-word;
        text-align: center;
        white-space: nowrap;
      }
      .run-name-cell {
        width: 300px;
        height: 30px;
        text-align: center;
      }
      .noshrink {
        flex-shrink: 0;
      }
      #paddingCell {
        width: 300px;
        height: 30px;
      }
    </style>
  </template>
  <script>
    Polymer({
      is: "tf-image-grid",
      properties: {
        runToImages: Object,
        tags: Array,
        runs: Array,
        imagesGenerator: Function,
      },
      _exists: function (run, tag) {
        return this.runToImages[run].indexOf(tag) !== -1;
      },
    });
  </script>
</dom-module>

<dom-module id="tf-image-dashboard" assetpath="../tf-image-dashboard/">
  <template>
    <div class="center">
      <tf-no-data-warning data-type="image" show-warning="[[dataNotFound]]"></tf-no-data-warning>
      <tf-image-grid id="imagegrid" run-to-images="[[run2tag]]" images-generator="[[dataProvider]]" tags="[[tags]]" runs="[[runs]]"></tf-image-grid>
    </div>

    <style>
      .center {
        padding-left: 10px;
        padding-right: 10px;
        height: 100%;
        width: 100%;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
      }
      :host {
        height: 100%;
        display: block;
      }

    </style>
  </template>
  <script>
    Polymer({
      is: "tf-image-dashboard",
      properties: {
        dataType: {value: "image"},
      },
      behaviors: [
        TF.Dashboard.ReloadBehavior("tf-image-loader"),
        TF.Backend.Behavior
      ],
      attached: function() {
        this.async(function() {
          this.fire("rendered");
        });
      },
      _hasImages: function(runToImagesChange) {
        return _.values(runToImagesChange.base).some(function(arr) {
          return arr.length > 0;
        });
      },
    });
  </script>
</dom-module>

<dom-module id="tf-audio-loader" assetpath="../tf-audio-dashboard/">
  <style>
  :host {
    display: block;
  }
  img {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
  }
  </style>
  <template>
    <template is="dom-if" if="[[audioUrl]]">
      <audio controls="" loop="">
        <source src="[[audioUrl]]" type="[[audioContentType]]">
      </audio>
    </template>
  </template>
  <script>
    Polymer({
      is: "tf-audio-loader",
      properties: {
        run: String,
        tag: String,
        audioGenerator: Function,
        audioUrl: String,
        audioContentType: String
      },
      reload: function() {
        var _this = this;
        this.audioUrl = ""; // force reload
        this.audioContentType = "";
        this.audioGenerator(this.tag, this.run).then(function(metadatas) {
          var last_metadata = _.last(metadatas);
          _this.audioUrl = last_metadata.url;
          _this.audioContentType = last_metadata.content_type;
        })
      },
      ready: function() {
        // Need to test so that it will not error if it is constructed w/o
        // all properties (so that it's possible to use stub to mock it out)
        if (this.run != null && this.tag != null && this.audioGenerator != null) {
          this.reload();
        }
      },
    });
  </script>
</dom-module>

<dom-module id="tf-audio-grid" assetpath="../tf-audio-dashboard/">
  <template>
    <style include="scrollbar-style"></style>
    <div id="fullContainer" class="container scrollbar">
      <div id="topRow" class="container">
        <div class="noshrink" id="paddingCell"></div>
        <template is="dom-repeat" items="[[runs]]" as="run">
        <div class="run-name-cell noshrink">
          <span>[[run]]</span>
        </div>
      </template>
      </div>
      <div id="bottomContainer" class="container">
        <template is="dom-repeat" items="[[tags]]" as="tag">
          <div class="audio-row container noshrink">
            <div class="tag-name-cell noshrink">
              <span class="tag-name">[[tag]]</span>
            </div>
            <template is="dom-repeat" items="[[runs]]" as="run">
              <div class="audio-cell noshrink">
                <template is="dom-if" if="[[_exists(run, tag, runToAudio.*)]]">
                  <tf-audio-loader id="loader" run="[[run]]" tag="[[tag]]" audio-generator="[[audioGenerator]]">
                  </tf-audio-loader>
                </template>
              </div>
            </template>
          </div>
        </template>
      </div>
    </div>
    <style>
      :host {
        display: block;
        height: 100%;
      }
      .container {
        display: flex;
        flex-wrap: nowrap;
      }
      #fullContainer {
        width: 100%;
        height: 100%;
        flex-direction: column;
        padding-top: 20px;
        overflow: scroll;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
      }
      #topRow {
        flex-direction: row;
      }
      #bottomContainer {
        flex-direction: column;
        height: 100%;
        width: 100%;
      }
      .audio-row {
        flex-direction: row;
        padding-top: 5px;
      }
      .audio-cell {
        width: 300px;
        height: 30px;
        border: 1px solid black;
      }
      .tag-name-cell {
        width: 300px;
        height: 30px;
        display:flex;
        flex-direction: column;
        justify-content: center;
      }
      .tag-name {
        word-wrap: break-word;
        text-align: center;
        white-space: nowrap;
      }
      .run-name-cell {
        width: 300px;
        height: 30px;
        text-align: center;
      }
      .noshrink {
        flex-shrink: 0;
      }
      #paddingCell {
        width: 300px;
        height: 30px;
      }
    </style>
  </template>
  <script>
    Polymer({
      is: "tf-audio-grid",
      properties: {
        runToAudio: Object,
        tags: Array,
        runs: Array,
        audioGenerator: Function,
      },
      _exists: function (run, tag) {
        return this.runToAudio[run].indexOf(tag) !== -1;
      },
    });
  </script>
</dom-module>

<dom-module id="tf-audio-dashboard" assetpath="../tf-audio-dashboard/">
  <template>
    <div class="center">
      <tf-no-data-warning data-type="audio" show-warning="[[dataNotFound]]"></tf-no-data-warning>
      <tf-audio-grid id="audioGrid" run-to-audio="[[run2tag]]" audio-generator="[[dataProvider]]" tags="[[tags]]" runs="[[runs]]"></tf-audio-grid>
    </div>

    <style>
      .center {
        padding-left: 10px;
        padding-right: 10px;
        height: 100%;
        width: 100%;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
      }
      :host {
        height: 100%;
        display: block;
      }

    </style>
  </template>
  <script>
    Polymer({
      is: "tf-audio-dashboard",
      properties: {
        dataType: {value: "audio"},
      },
      behaviors: [
        TF.Dashboard.ReloadBehavior("tf-audio-loader"),
        TF.Backend.Behavior
      ],
      attached: function() {
        this.async(function() {
          this.fire("rendered");
        });
      },
      _hasAudio: function(runToAudioChange) {
        return _.values(runToAudioChange.base).some(function(arr) {
          return arr.length > 0;
        });
      },
    });
  </script>
</dom-module>

<dom-module id="tf-graph-loader" assetpath="../tf-graph-loader/">
</dom-module>

<script>
Polymer({

  is: 'tf-graph-loader',

  properties: {
    /**
     * @type {value: number, msg: string}
     *
     * A number between 0 and 100 denoting the % of progress
     * for the progress bar and the displayed message.
     */
    progress: {
      type: Object,
      notify: true,
    },
    datasets: Array,
    selectedDataset: Number,
    selectedFile: {
      type: Object,
      observer: '_selectedFileChanged'
    },
    outGraphHierarchy: {
      type: Object,
      readOnly: true, //readonly so outsider can't change this via binding
      notify: true
    },
    outGraph: {
      type: Object,
      readOnly: true, //readonly so outsider can't change this via binding
      notify: true
    },
    outHierarchyParams: {
      type: Object,
      readOnly: true,
      notify: true
    },
    outStats: {
      type: Object,
      readOnly: true, // This property produces data.
      notify: true
    }
  },
  observers: [
    '_selectedDatasetChanged(selectedDataset, datasets)',
    '_readAndParseMetadata(selectedMetadataTag)'
  ],
  _readAndParseMetadata: function(metadataIndex) {
    if (metadataIndex == -1 || this.datasets[this.selectedDataset] == null ||
        this.datasets[this.selectedDataset].runMetadata == null ||
        this.datasets[this.selectedDataset].runMetadata[metadataIndex] == null) {
      this._setOutStats(null);
      return;
    }
    var path = this.datasets[this.selectedDataset].runMetadata[metadataIndex].path;
    // Reset the progress bar to 0.
    this.set('progress', {
      value: 0,
      msg: ''
    });
    var tracker = tf.graph.util.getTracker(this);
    tf.graph.parser.fetchAndParseMetadata(path, tracker)
    .then(function(stats) {
      this._setOutStats(stats);
    }.bind(this));
  },
  _parseAndConstructHierarchicalGraph: function(path, pbTxtFile) {
    // Reset the progress bar to 0.
    this.set('progress', {
      value: 0,
      msg: ''
    });
    var tracker = tf.graph.util.getTracker(this);
    var hierarchyParams = {
      verifyTemplate: true,
      // If a set of numbered op nodes has at least this number of nodes
      // then group them into a series node.
      seriesNodeMinSize: 5,
      // A map of series node names to series grouping settings, to indicate
      // if a series is to be rendered as grouped or ungrouped.
      // Starts out empty which allows the renderer to decide which series
      // are initially rendered grouped and which aren't.
      seriesMap: {},
    };
    this._setOutHierarchyParams(hierarchyParams);
    var dataTracker = tf.graph.util.getSubtaskTracker(tracker, 30, 'Data');
    tf.graph.parser.fetchAndParseGraphData(path, pbTxtFile, dataTracker)
    .then(function(graph) {
      // Build the flat graph (consists only of Op nodes).

      // This is the whitelist of inputs on op types that are considered
      // reference edges. "Assign 0" indicates that the first input to
      // an OpNode with operation type "Assign" is a reference edge.
      var refEdges = {};
      refEdges["Assign 0"] = true;
      refEdges["AssignAdd 0"] = true;
      refEdges["AssignSub 0"] = true;
      refEdges["assign 0"] = true;
      refEdges["assign_add 0"] = true;
      refEdges["assign_sub 0"] = true;
      refEdges["count_up_to 0"] = true;
      refEdges["ScatterAdd 0"] = true;
      refEdges["ScatterSub 0"] = true;
      refEdges["ScatterUpdate 0"] = true;
      refEdges["scatter_add 0"] = true;
      refEdges["scatter_sub 0"] = true;
      refEdges["scatter_update 0"] = true;
      var buildParams = {
        enableEmbedding: true,
        inEmbeddingTypes: ['Const'],
        outEmbeddingTypes: ['^[a-zA-Z]+Summary$'],
        refEdges: refEdges
      };
      var graphTracker = tf.graph.util.getSubtaskTracker(tracker, 20, 'Graph');
      return tf.graph.build(graph, buildParams, graphTracker);
    })
    .then(function(graph) {
      this._setOutGraph(graph);
      var hierarchyTracker = tf.graph.util.getSubtaskTracker(tracker, 50,
          'Namespace hierarchy');
      return tf.graph.hierarchy.build(graph, hierarchyParams, hierarchyTracker);
    }.bind(this))
    .then(function(graphHierarchy) {
      // Update the properties which notify the parent with the
      // graph hierarchy and whether the data has live stats or not.
      this._setOutGraphHierarchy(graphHierarchy);
    }.bind(this))
    .catch(function(e) {
      // Generic error catch, for errors that happened outside
      // asynchronous tasks.
      tracker.reportError("Graph visualization failed: " + e, e);
    });
  },
  _selectedDatasetChanged: function(datasetIndex, datasets) {
    this._parseAndConstructHierarchicalGraph(datasets[datasetIndex].path);
  },
  _selectedFileChanged: function(e) {
    if (!e) {
      return;
    }
    var file = e.target.files[0];
    if (!file) {
      return;
    }

    // Clear out the value of the file chooser. This ensures that if the user
    // selects the same file, we'll re-read it.
    e.target.value = '';

    this._parseAndConstructHierarchicalGraph(null, file);
  }
});
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    /**
     * Mapping from color palette name to color palette, which contains
     * exact colors for multiple states of a single color palette.
     */
    tf.COLORS = [
        {
            'name': 'Google Blue',
            'color': '#4184f3',
            'active': '#3a53c5',
            'disabled': '#cad8fc'
        },
        {
            'name': 'Google Red',
            'color': '#db4437',
            'active': '#8f2a0c',
            'disabled': '#e8c6c1'
        },
        {
            'name': 'Google Yellow',
            'color': '#f4b400',
            'active': '#db9200',
            'disabled': '#f7e8b0'
        },
        {
            'name': 'Google Green',
            'color': '#0f9d58',
            'active': '#488046',
            'disabled': '#c2e1cc'
        },
        {
            'name': 'Purple',
            'color': '#aa46bb',
            'active': '#5c1398',
            'disabled': '#d7bce6'
        },
        {
            'name': 'Teal',
            'color': '#00abc0',
            'active': '#47828e',
            'disabled': '#c2eaf2'
        },
        {
            'name': 'Deep Orange',
            'color': '#ff6f42',
            'active': '#ca4a06',
            'disabled': '#f2cbba'
        },
        {
            'name': 'Lime',
            'color': '#9d9c23',
            'active': '#7f771d',
            'disabled': '#f1f4c2'
        },
        {
            'name': 'Indigo',
            'color': '#5b6abf',
            'active': '#3e47a9',
            'disabled': '#c5c8e8'
        },
        {
            'name': 'Pink',
            'color': '#ef6191',
            'active': '#ca1c60',
            'disabled': '#e9b9ce'
        },
        {
            'name': 'Deep Teal',
            'color': '#00786a',
            'active': '#2b4f43',
            'disabled': '#bededa'
        },
        {
            'name': 'Deep Pink',
            'color': '#c1175a',
            'active': '#75084f',
            'disabled': '#de8cae'
        },
        {
            'name': 'Gray',
            'color': '#9E9E9E',
            'active': '#424242',
            'disabled': 'F5F5F5' // 100
        }
    ].reduce(function (m, c) {
        m[c.name] = c;
        return m;
    }, {});
    /**
     * Mapping from op category to color palette name
     * e.g.,  OP_GROUP_COLORS['state_ops'] = 'Google Blue';
     */
    tf.OP_GROUP_COLORS = [
        {
            color: 'Google Red',
            groups: [
                'gen_legacy_ops', 'legacy_ops', 'legacy_flogs_input',
                'legacy_image_input', 'legacy_input_example_input',
                'legacy_sequence_input', 'legacy_seti_input_input'
            ]
        },
        { color: 'Deep Orange', groups: ['constant_ops'] },
        { color: 'Indigo', groups: ['state_ops'] },
        { color: 'Purple', groups: ['nn_ops', 'nn'] },
        { color: 'Google Green', groups: ['math_ops'] },
        { color: 'Lime', groups: ['array_ops'] },
        { color: 'Teal', groups: ['control_flow_ops', 'data_flow_ops'] },
        { color: 'Pink', groups: ['summary_ops'] },
        { color: 'Deep Pink', groups: ['io_ops'] }
    ].reduce(function (m, c) {
        c.groups.forEach(function (group) { m[group] = c.color; });
        return m;
    }, {});
})(tf || (tf = {}));
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph_1) {
        /** Delimiter used in node names to denote namespaces. */
        graph_1.NAMESPACE_DELIM = '/';
        graph_1.ROOT_NAME = '__root__';
        /** Attribute key used for storing attributes that are too large. */
        graph_1.LARGE_ATTRS_KEY = '_too_large_attrs';
        /**
         * Maximum allowed size in bytes, before the attribute is considered large
         * and filtered out of the graph.
         */
        graph_1.LIMIT_ATTR_SIZE = 1024;
        // Separator between the source and the destination name of the edge.
        graph_1.EDGE_KEY_DELIM = '--';
        (function (GraphType) {
            GraphType[GraphType["FULL"] = 0] = "FULL";
            GraphType[GraphType["EMBEDDED"] = 1] = "EMBEDDED";
            GraphType[GraphType["META"] = 2] = "META";
            GraphType[GraphType["SERIES"] = 3] = "SERIES";
            GraphType[GraphType["CORE"] = 4] = "CORE";
            GraphType[GraphType["SHADOW"] = 5] = "SHADOW";
            GraphType[GraphType["BRIDGE"] = 6] = "BRIDGE";
            GraphType[GraphType["EDGE"] = 7] = "EDGE";
        })(graph_1.GraphType || (graph_1.GraphType = {}));
        var GraphType = graph_1.GraphType;
        ;
        (function (NodeType) {
            NodeType[NodeType["META"] = 0] = "META";
            NodeType[NodeType["OP"] = 1] = "OP";
            NodeType[NodeType["SERIES"] = 2] = "SERIES";
            NodeType[NodeType["BRIDGE"] = 3] = "BRIDGE";
            NodeType[NodeType["ELLIPSIS"] = 4] = "ELLIPSIS";
        })(graph_1.NodeType || (graph_1.NodeType = {}));
        var NodeType = graph_1.NodeType;
        ;
        /** Indicates if a node is to be included in the main graph when rendered. */
        (function (InclusionType) {
            InclusionType[InclusionType["INCLUDE"] = 0] = "INCLUDE";
            InclusionType[InclusionType["EXCLUDE"] = 1] = "EXCLUDE";
            InclusionType[InclusionType["UNSPECIFIED"] = 2] = "UNSPECIFIED";
        })(graph_1.InclusionType || (graph_1.InclusionType = {}));
        var InclusionType = graph_1.InclusionType;
        ;
        /** Indicates if a series is to be grouped in the graph when rendered. */
        (function (SeriesGroupingType) {
            SeriesGroupingType[SeriesGroupingType["GROUP"] = 0] = "GROUP";
            SeriesGroupingType[SeriesGroupingType["UNGROUP"] = 1] = "UNGROUP";
        })(graph_1.SeriesGroupingType || (graph_1.SeriesGroupingType = {}));
        var SeriesGroupingType = graph_1.SeriesGroupingType;
        ;
        /** Attribute key reserved for the shapes of the output tensors. */
        var OUTPUT_SHAPES_KEY = '_output_shapes';
        /**
         * A SlimGraph is inspired by graphlib.Graph, but having only the functionality
         * that we need.
         */
        var SlimGraph = (function () {
            function SlimGraph() {
                this.nodes = {};
                this.edges = [];
            }
            return SlimGraph;
        }());
        graph_1.SlimGraph = SlimGraph;
        var EllipsisNodeImpl = (function () {
            /**
             * Constructs a new ellipsis annotation node.
             *
             * @param numNodes The number of additional annotations this node represents.
             */
            function EllipsisNodeImpl(numNodes) {
                this.type = NodeType.ELLIPSIS;
                this.isGroupNode = false;
                this.cardinality = 1;
                this.parentNode = null;
                this.stats = null;
                this.setNumMoreNodes(numNodes);
                this.include = InclusionType.UNSPECIFIED;
            }
            EllipsisNodeImpl.prototype.setNumMoreNodes = function (numNodes) {
                this.numMoreNodes = numNodes;
                this.name = '... ' + numNodes + ' more';
            };
            return EllipsisNodeImpl;
        }());
        graph_1.EllipsisNodeImpl = EllipsisNodeImpl;
        ;
        /**
         * A label object for nodes in the full graph and leaf nodes in the render
         * graph.
         */
        var OpNodeImpl = (function () {
            /**
             * Constructs a new Op node.
             *
             * @param rawNode The raw node.
             */
            function OpNodeImpl(rawNode) {
                this.op = rawNode.op;
                this.name = rawNode.name;
                this.device = rawNode.device;
                this.attr = rawNode.attr;
                // An array of normalized inputs that denote the incoming edges to
                // the current node. Each input contains the normalized name of the
                // source node, whether it has a number part and whether it is a
                // control dependency.
                this.inputs = normalizeInputs(rawNode.input);
                this.outputShapes = extractOutputShapes(rawNode.attr);
                // additional properties
                this.type = NodeType.OP;
                this.isGroupNode = false;
                this.cardinality = 1;
                this.inEmbeddings = [];
                this.outEmbeddings = [];
                this.parentNode = null;
                this.include = InclusionType.UNSPECIFIED;
                this.owningSeries = null;
            }
            return OpNodeImpl;
        }());
        ;
        function createMetanode(name, opt) {
            if (opt === void 0) { opt = {}; }
            return new MetanodeImpl(name, opt);
        }
        graph_1.createMetanode = createMetanode;
        /**
         * Joins the information from the stats file (memory, compute time) with the
         * graph information.
         */
        function joinStatsInfoWithGraph(graph, stats) {
            _.each(stats.dev_stats, function (devStats) {
                _.each(devStats.node_stats, function (nodeStats) {
                    // Lookup the node in the graph by its original name, e.g. A. If not
                    // found, lookup by the rewritten name A/(A) in case the name is both
                    // a namespace and a node name.
                    var nodeName = nodeStats.node_name in graph.nodes ? nodeStats.node_name :
                        nodeStats.node_name +
                            graph_1.NAMESPACE_DELIM + '(' + nodeStats.node_name + ')';
                    // Couldn't find a matching node.
                    if (!(nodeName in graph.nodes)) {
                        return;
                    }
                    // Compute the total bytes used.
                    var totalBytes = 0;
                    if (nodeStats.memory) {
                        _.each(nodeStats.memory, function (alloc) {
                            if (alloc.total_bytes) {
                                if (alloc.total_bytes > 0) {
                                    totalBytes += Number(alloc.total_bytes);
                                }
                                else {
                                    /* tslint:disable */
                                    console.log('ignoring negative memory allocation for ' + nodeName);
                                }
                            }
                        });
                    }
                    var outputSize = null;
                    if (nodeStats.output) {
                        outputSize = _.map(nodeStats.output, function (output) {
                            return _.map(output.tensor_description.shape.dim, function (dim) { return Number(dim.size); });
                        });
                    }
                    graph.nodes[nodeName].device = devStats.device;
                    if (graph.nodes[nodeName].stats == null) {
                        graph.nodes[nodeName].stats = new NodeStats(outputSize);
                    }
                    graph.nodes[nodeName].stats.addBytesAllocation(totalBytes);
                    if (nodeStats.all_end_rel_micros) {
                        if (nodeStats.all_end_rel_micros > 0) {
                            graph.nodes[nodeName].stats.addExecutionTime(nodeStats.all_start_micros, nodeStats.all_start_micros + nodeStats.all_end_rel_micros);
                        }
                        else {
                            /* tslint:disable */
                            console.log('ignoring negative runtime for ' + nodeName);
                        }
                    }
                });
            });
        }
        graph_1.joinStatsInfoWithGraph = joinStatsInfoWithGraph;
        /**
         * Execution stats for the node.
         */
        var NodeStats = (function () {
            function NodeStats(outputSize) {
                this.outputSize = outputSize;
            }
            /**
             * Add the start and end time for a particular kernel execution of this op.
             * Ops can have multiple kernel executions within the same session run.
             */
            NodeStats.prototype.addExecutionTime = function (startTime, endTime) {
                if (this.startTime != null) {
                    this.startTime = Math.min(this.startTime, startTime);
                }
                else {
                    this.startTime = startTime;
                }
                if (this.endTime != null) {
                    this.endTime = Math.max(this.endTime, endTime);
                }
                else {
                    this.endTime = endTime;
                }
            };
            /**
             * Add the bytes allocated for a particular kernel execution of this op.
             * Ops can have multiple kernel executions within the same session run.
             */
            NodeStats.prototype.addBytesAllocation = function (totalBytes) {
                if (this.totalBytes != null) {
                    this.totalBytes = Math.max(this.totalBytes, totalBytes);
                }
                else {
                    this.totalBytes = totalBytes;
                }
            };
            Object.defineProperty(NodeStats.prototype, "totalMicros", {
                /**
                 * Total number of compute time in microseconds used for the node.
                 * Sum of all children if it is a Group node. Null if it is unknown.
                 */
                get: function () {
                    if (this.startTime == null || this.endTime == null) {
                        return null;
                    }
                    return this.endTime - this.startTime;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Combines the specified stats with the current stats.
             * Modifies the current object. This method is used to
             * compute aggregate stats for group nodes.
             */
            NodeStats.prototype.combine = function (stats) {
                if (stats.totalBytes != null) {
                    this.totalBytes += stats.totalBytes;
                }
                if (stats.totalMicros != null) {
                    this.addExecutionTime(stats.startTime, stats.endTime);
                }
            };
            return NodeStats;
        }());
        graph_1.NodeStats = NodeStats;
        var MetanodeImpl = (function () {
            /** A label object for meta-nodes in the graph hierarchy */
            function MetanodeImpl(name, opt) {
                if (opt === void 0) { opt = {}; }
                this.name = name;
                this.type = NodeType.META;
                /** number of levels under this group */
                this.depth = 1;
                this.isGroupNode = true;
                /** # of leaf nodes (including embedded ones) */
                this.cardinality = 0;
                /** graph contains metanodes, nodes, edges
                 * and metaedges for main items within this metanode
                 */
                this.metagraph =
                    createGraph(name, GraphType.META, opt);
                /** bridgegraph must be constructed lazily-see hierarchy.getBridgegraph() */
                this.bridgegraph = null;
                /**
                 * A dictionary that count ops type of nodes in this metanode
                 * (op type => count).
                 */
                this.opHistogram = {};
                this.deviceHistogram = {};
                /** unique id for a metanode of similar subgraph */
                this.templateId = null;
                /** Metanode which contains this node, if any */
                this.parentNode = null;
                this.hasNonControlEdges = false;
                this.include = InclusionType.UNSPECIFIED;
            }
            MetanodeImpl.prototype.getFirstChild = function () {
                return this.metagraph.node(this.metagraph.nodes()[0]);
            };
            /**
             * Returns the op node associated with the metanode.
             * For example, if the metanode is 'sgd', the associated
             * op node is sgd/(sgd).
             */
            MetanodeImpl.prototype.getRootOp = function () {
                var nameSplit = this.name.split('/');
                var rootOpName = this.name + '/(' + nameSplit[nameSplit.length - 1] + ')';
                return this.metagraph.node(rootOpName);
            };
            /**
             * Return an array of the names of all the leaves (non-GroupNodes) inside
             * this metanode. This performs a breadth-first search of the tree, so
             * immediate child leaves will appear earlier in the output array than
             * descendant leaves.
             */
            MetanodeImpl.prototype.leaves = function () {
                var leaves = [];
                var queue = [this];
                var metagraph; // Defined here due to a limitation of ES6->5 compilation.
                while (queue.length) {
                    var node = queue.shift();
                    if (node.isGroupNode) {
                        metagraph = node.metagraph;
                        _.each(metagraph.nodes(), function (name) { return queue.push(metagraph.node(name)); });
                    }
                    else {
                        leaves.push(node.name);
                    }
                }
                return leaves;
            };
            return MetanodeImpl;
        }());
        ;
        function createMetaedge(v, w) {
            return new MetaedgeImpl(v, w);
        }
        graph_1.createMetaedge = createMetaedge;
        /**
         * A label object for edges between metanodes of subgraphs in the render graph.
         */
        var MetaedgeImpl = (function () {
            function MetaedgeImpl(v, w) {
                this.v = v;
                this.w = w;
                this.baseEdgeList = [];
                this.inbound = null;
                this.numRegularEdges = 0;
                this.numControlEdges = 0;
                this.numRefEdges = 0;
                this.totalSize = 0;
            }
            MetaedgeImpl.prototype.addBaseEdge = function (edge, h) {
                this.baseEdgeList.push(edge);
                if (edge.isControlDependency) {
                    this.numControlEdges += 1;
                }
                else {
                    this.numRegularEdges += 1;
                }
                if (edge.isReferenceEdge) {
                    this.numRefEdges += 1;
                }
                // Compute the size of the tensor flowing through this
                // base edge.
                this.totalSize += MetaedgeImpl.computeSizeOfEdge(edge, h);
                h.maxMetaEdgeSize = Math.max(h.maxMetaEdgeSize, this.totalSize);
            };
            MetaedgeImpl.computeSizeOfEdge = function (edge, h) {
                var opNode = h.node(edge.v);
                if (opNode.outputShapes == null) {
                    // No shape information. Asssume a single number. This gives
                    // a lower bound for the total size.
                    return 1;
                }
                h.hasShapeInfo = true;
                // Sum the sizes of all output tensors.
                return _(opNode.outputShapes).map(function (shape) {
                    // If the shape is unknown, treat it as 1 when computing
                    // total size. This gives a lower bound for the total size.
                    if (shape == null) {
                        return 1;
                    }
                    // Multiply all shapes to get the total size of the tensor.
                    // E.g. The total size of [4, 2, 1] is 4 * 2 * 1.
                    return _(shape).reduce(function (accumulated, currSize) {
                        // If this particular dimension is unknown, treat
                        // it as 1 when computing total size. This gives a lower bound
                        // for the total size.
                        if (currSize === -1) {
                            currSize = 1;
                        }
                        return accumulated * currSize;
                    }, 1);
                }).sum();
            };
            return MetaedgeImpl;
        }());
        graph_1.MetaedgeImpl = MetaedgeImpl;
        function createSeriesNode(prefix, suffix, parent, clusterId, name) {
            return new SeriesNodeImpl(prefix, suffix, parent, clusterId, name);
        }
        graph_1.createSeriesNode = createSeriesNode;
        function getSeriesNodeName(prefix, suffix, parent, startId, endId) {
            var numRepresentation = (typeof startId !== 'undefined' && typeof endId !== 'undefined') ?
                '[' + startId + '-' + endId + ']' :
                '#';
            var pattern = prefix + numRepresentation + suffix;
            return (parent ? parent + '/' : '') + pattern;
        }
        graph_1.getSeriesNodeName = getSeriesNodeName;
        var SeriesNodeImpl = (function () {
            function SeriesNodeImpl(prefix, suffix, parent, clusterId, name) {
                this.name = name || getSeriesNodeName(prefix, suffix, parent);
                this.type = NodeType.SERIES;
                this.hasLoop = false;
                this.prefix = prefix;
                this.suffix = suffix;
                this.clusterId = clusterId;
                this.ids = [];
                this.parent = parent;
                this.isGroupNode = true;
                this.cardinality = 0;
                this.metagraph = createGraph(name, GraphType.SERIES);
                // bridgegraph must be constructed lazily-see hierarchy.getBridgegraph()
                this.bridgegraph = null;
                this.parentNode = null;
                this.deviceHistogram = {};
                this.hasNonControlEdges = false;
                this.include = InclusionType.UNSPECIFIED;
            }
            return SeriesNodeImpl;
        }());
        /**
         * Extracts the shapes of the output tensors from the attr property in the
         * node proto.
         */
        function extractOutputShapes(attr) {
            var result = null;
            // We don't know anything about the output tensors.
            if (!attr) {
                return null;
            }
            for (var i = 0; i < attr.length; i++) {
                var _a = attr[i], key = _a.key, value = _a.value;
                if (key === OUTPUT_SHAPES_KEY) {
                    // Map all output tensors into array of numbers denoting their shape.
                    var result_1 = value.list.shape.map(function (shape) {
                        if (shape.unknown_rank) {
                            // This output tensor is of unknown rank. We don't know if it is a
                            // scalar, or a tensor, or of what shape it is.
                            return null;
                        }
                        if (shape.dim == null ||
                            (shape.dim.length === 1 && shape.dim[0].size == null)) {
                            // This output tensor is a scalar.
                            return [];
                        }
                        // This output tensor has a known rank. Map each dimension size
                        // into a number.
                        return shape.dim.map(function (dim) {
                            // Size can be -1 if this particular dimension is unknown.
                            return dim.size;
                        });
                    });
                    // Since we already processed it, remove the entry from the attribute
                    // list (saves memory).
                    attr.splice(i, 1);
                    return result_1;
                }
            }
            // We didn't find OUTPUT_SHAPES_KEY in attributes, so we don't know anything
            // about the output tensors.
            return null;
        }
        /**
         * Normalizes the inputs and extracts associated metadata:
         * 1) Inputs can contain a colon followed by a number at the end
         *    (e.g. inputName:1) and we remove this from the input name, and take note
         *    that the input was numbered.
         * 2) Control dependency inputs contain caret at the beginning and we
         *    remove this and annotate the edge as a control dependency.
         * @param inputs Array of unnormalized names of input nodes.
         */
        function normalizeInputs(inputs) {
            var normalizedInputs = [];
            _.each(inputs, function (inputName) {
                var start = inputName[0] === '^';
                var colon = inputName.lastIndexOf(':');
                var end = colon !== -1 &&
                    inputName.length - colon > 1 &&
                    !(/\D/).test(inputName.substring(colon + 1)) ?
                    colon : inputName.length;
                var name = inputName.substring(start ? 1 : 0, end);
                if (normalizedInputs.length === 0 ||
                    name !== normalizedInputs[normalizedInputs.length - 1].name) {
                    normalizedInputs.push({
                        name: name,
                        outputTensorIndex: end === inputName.length ? 0 : Number(inputName.slice(colon + 1)),
                        isControlDependency: start
                    });
                }
            });
            return normalizedInputs;
        }
        function addEdgeToGraph(graph, inputName, outputNode, input, params, index) {
            // Don't allow loops in the graph.
            if (inputName === outputNode.name) {
                return;
            }
            // Check if this op type and input number corresponds to a
            // reference edge using the refEdges dictionary in the params.
            var isRefEdge = params.refEdges[outputNode.op + ' ' + index] === true;
            graph.edges.push({
                v: inputName,
                w: outputNode.name,
                outputTensorIndex: input.outputTensorIndex,
                isControlDependency: input.isControlDependency,
                isReferenceEdge: isRefEdge
            });
        }
        function build(rawNodes, params, tracker) {
            /**
             * A dictionary that maps each in-embedding node name to the node
             * object.
             */
            var inEmbedding = {};
            /**
             * A dictionary that maps each out-embedding node name to the node
             * object.
             */
            var outEmbedding = {};
            /**
             * A dictionary that maps each node name to an array of the node's
             * out-embedding node label objects.
             */
            var outEmbeddings = {};
            var isInEmbeddedPred = getEmbedPredicate(params.inEmbeddingTypes);
            var isOutEmbeddedPred = getEmbedPredicate(params.outEmbeddingTypes);
            var embeddingNodeNames = [];
            /**
             * A list of all the non-embedding node names which appear in the processed
             * list of raw nodes. Here we pre-allocate enough room for all the rawNodes,
             * even though there will some number of embeddings. The excess array length
             * is spliced off later.
             *
             * Experimentation shows that around 30% of the array will go unused, and
             * even for very large networks that amounts to less than 10k spaces.
             */
            var nodeNames = new Array(rawNodes.length);
            return tf.graph.util
                .runAsyncTask('Normalizing names', 30, function () {
                var opNodes = new Array(rawNodes.length);
                var index = 0;
                _.each(rawNodes, function (rawNode) {
                    var opNode = new OpNodeImpl(rawNode);
                    if (isInEmbeddedPred(opNode)) {
                        embeddingNodeNames.push(opNode.name);
                        inEmbedding[opNode.name] = opNode;
                        return;
                    }
                    if (isOutEmbeddedPred(opNode)) {
                        embeddingNodeNames.push(opNode.name);
                        outEmbedding[opNode.name] = opNode;
                        _.each(opNode.inputs, function (input) {
                            var inputName = input.name;
                            outEmbeddings[inputName] = outEmbeddings[inputName] || [];
                            outEmbeddings[inputName].push(opNode);
                        });
                        return;
                    }
                    // The node is not an embedding, so add it to the names and nodes
                    // lists.
                    opNodes[index] = opNode;
                    nodeNames[index] = opNode.name;
                    index++;
                });
                opNodes.splice(index);
                nodeNames.splice(index);
                return opNodes;
            }, tracker)
                .then(function (opNodes) {
                // Create the graph data structure from the graphlib library.
                return tf.graph.util.runAsyncTask('Building the data structure', 70, function () {
                    var normalizedNameDict = mapStrictHierarchy(nodeNames, embeddingNodeNames);
                    var graph = new SlimGraph;
                    // Add the nodes to the graph.
                    _.each(opNodes, function (opNode) {
                        var normalizedName = normalizedNameDict[opNode.name] || opNode.name;
                        graph.nodes[normalizedName] = opNode;
                        // Check if the node has out-embeddings. If yes, add them to the
                        // node.
                        if (opNode.name in outEmbeddings) {
                            opNode.outEmbeddings = outEmbeddings[opNode.name];
                            // Normalize the names of the out-embeddings.
                            _.each(opNode.outEmbeddings, function (node) {
                                node.name = normalizedNameDict[node.name] || node.name;
                            });
                        }
                        // Update the name of the node.
                        opNode.name = normalizedName;
                    });
                    // Visit each node's inputs to add the edges to the graph. If the
                    // input
                    // is an in-embedding, then add it to the node's in-embeddings
                    // instead.
                    _.each(opNodes, function (opNode) {
                        _.each(opNode.inputs, function (input, i) {
                            var inputName = input.name;
                            if (inputName in inEmbedding) {
                                var inEmbedNode = inEmbedding[inputName];
                                opNode.inEmbeddings.push(inEmbedNode);
                                // Move the inputs of the in-embedding node into incoming
                                // edges of
                                // the main node. E.g. the control dependency of a constant
                                // node
                                // should be moved to the op node where the constant is
                                // embedded.
                                for (var _i = 0, _a = inEmbedNode.inputs; _i < _a.length; _i++) {
                                    var embedInput = _a[_i];
                                    addEdgeToGraph(graph, normalizedNameDict[embedInput.name] ||
                                        embedInput.name, opNode, embedInput, params, i);
                                }
                            }
                            else if (inputName in outEmbedding) {
                                // Move the inputs of the out-embedding node into inputs of
                                // the main node where the out-embedding points to.
                                var outEmbedNode = outEmbedding[inputName];
                                for (var _b = 0, _c = outEmbedNode.inputs; _b < _c.length; _b++) {
                                    var embedInput = _c[_b];
                                    addEdgeToGraph(graph, normalizedNameDict[embedInput.name] ||
                                        embedInput.name, opNode, input, params, i);
                                }
                            }
                            else {
                                addEdgeToGraph(graph, normalizedNameDict[inputName] || inputName, opNode, input, params, i);
                            }
                        });
                    });
                    // Normalize the names of in-embeddings.
                    _.each(inEmbedding, function (node, name) {
                        node.name = normalizedNameDict[node.name] || node.name;
                    });
                    return graph;
                }, tracker);
            });
        }
        graph_1.build = build;
        ;
        /**
         * Create a new graphlib.Graph() instance with default parameters
         */
        function createGraph(name, type, opt) {
            if (opt === void 0) { opt = {}; }
            var graph = new graphlib.Graph(opt);
            graph.setGraph({
                name: name,
                rankdir: 'BT',
                type: type
            });
            return graph;
        }
        graph_1.createGraph = createGraph;
        ;
        /**
         * Create a predicate for checking whether a node should be embedded based on
         * the specified types.
         */
        function getEmbedPredicate(types) {
            return function (node) {
                // check types
                for (var i = 0; i < types.length; i++) {
                    var regExp = new RegExp(types[i]);
                    if (node.op.match(regExp)) {
                        return true;
                    }
                }
                return false;
            };
        }
        ;
        /**
         * Returns a strict node name (name => name/(name)) to avoid conflicts
         * where the node name is also a namespace.
         */
        function getStrictName(name) {
            var parts = name.split(graph_1.NAMESPACE_DELIM);
            return name + graph_1.NAMESPACE_DELIM + '(' + parts[parts.length - 1] + ')';
        }
        /**
         * For each op node (embedding or non-embedding), rename it if there is a
         * non-embedding node under its namespace. For example, assume node name 'A'.
         * If there is a non-embedding node under its namespace (e.g. 'A/B'), 'A' will
         * be renamed to 'A/(A)'. Then the namespace 'A' will contain 2 nodes: '(A)'
         * and 'B'. If all the nodes under 'A' are embedding nodes (e.g. constant and
         * summary), keep 'A' as an Op node and don't create a namespace.
         *
         * @param nodeNames An array of regular (non-embedding) node names.
         * @param embeddingNodeNames An array of embedding node names.
         * @return Dictionary object mapping names that need to be renamed to
         *     new names.
         */
        function mapStrictHierarchy(nodeNames, embeddingNodeNames) {
            /** Dictionary that maps the old new to the new name */
            var newNameDictionary = {};
            /** Set used to store all namespaces. */
            var namespaceSet = {};
            // sort the nodes to make prefix check faster
            nodeNames.sort();
            // look for nodes with a prefix a,a/b -> a/(a),a/b
            for (var i = 0; i < nodeNames.length - 1; ++i) {
                var a = nodeNames[i];
                // Get all the parent namespaces of the current node
                // and add them in the namespace set.
                _.each(getHierarchicalPath(a).slice(0, -1), function (ns) {
                    namespaceSet[ns] = true;
                });
                for (var j = i + 1; j < nodeNames.length; ++j) {
                    var b = nodeNames[j];
                    if (_.startsWith(b, a)) {
                        if (b.length > a.length && b.charAt(a.length) === graph_1.NAMESPACE_DELIM) {
                            newNameDictionary[a] = getStrictName(a);
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            // Go through all the embedding node names and rename them in case they
            // collide with namespaces.
            _.each(embeddingNodeNames, function (embeddingName) {
                if (embeddingName in namespaceSet) {
                    // Rename to follow strict hierarchy.
                    newNameDictionary[embeddingName] = getStrictName(embeddingName);
                }
            });
            return newNameDictionary;
        }
        ;
        /**
         * Returns a list of the degrees of each node in the graph.
         */
        function degreeSequence(graph) {
            var degrees = graph.nodes().map(function (name) {
                return graph.neighbors(name).length;
            });
            degrees.sort();
            return degrees;
        }
        ;
        /**
         * Returns if the degree sequence of the two graphs is the same.
         */
        function hasSimilarDegreeSequence(graph1, graph2) {
            var dg1 = degreeSequence(graph1);
            var dg2 = degreeSequence(graph2);
            for (var i = 0; i < dg1.length; i++) {
                if (dg1[i] !== dg2[i]) {
                    return false;
                }
            }
            return true;
        }
        graph_1.hasSimilarDegreeSequence = hasSimilarDegreeSequence;
        ;
        /**
         * Returns the hierarchical path of the current node, based on the node's name.
         * For example, if the name is 'a/b/c', the returned path is
         * ['a', 'a/b', 'a/b/c'].
         */
        function getHierarchicalPath(name, seriesNames) {
            var path = [];
            var i = name.indexOf(graph_1.NAMESPACE_DELIM);
            // Push all parent portions of the path.
            while (i >= 0) {
                path.push(name.substring(0, i));
                i = name.indexOf(graph_1.NAMESPACE_DELIM, i + 1);
            }
            // If the node's path is under a series, then add the series node name to the
            // hierarchical path as the parent of the leaf.
            if (seriesNames) {
                var seriesName = seriesNames[name];
                if (seriesName) {
                    path.push(seriesName);
                }
            }
            // Push the leaf of the path.
            path.push(name);
            return path;
        }
        graph_1.getHierarchicalPath = getHierarchicalPath;
        ;
        /**
         * Returns the string for the node inclusion toggle button, dependant
         * on the provided current InclusionType.
         */
        function getIncludeNodeButtonString(include) {
            if (include === tf.graph.InclusionType.EXCLUDE) {
                return 'Add to main graph';
            }
            else {
                return 'Remove from main graph';
            }
        }
        graph_1.getIncludeNodeButtonString = getIncludeNodeButtonString;
        ;
        /**
         * Returns the string for the series node grouping toggle button, dependant
         * on the provided current SeriesGroupingType.
         */
        function getGroupSeriesNodeButtonString(group) {
            if (group === tf.graph.SeriesGroupingType.GROUP) {
                return 'Ungroup this series of nodes';
            }
            else {
                return 'Group this series of nodes';
            }
        }
        graph_1.getGroupSeriesNodeButtonString = getGroupSeriesNodeButtonString;
        ;
        /**
         * Toggle the node series grouping option in the provided map, setting it
         * to ungroup if the series is not already in the map.
         */
        function toggleNodeSeriesGroup(map, name) {
            if (!(name in map) || map[name] === tf.graph.SeriesGroupingType.GROUP) {
                map[name] = tf.graph.SeriesGroupingType.UNGROUP;
            }
            else {
                map[name] = tf.graph.SeriesGroupingType.GROUP;
            }
        }
        graph_1.toggleNodeSeriesGroup = toggleNodeSeriesGroup;
        ;
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module tf.graph
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
/**
 * Package for the Graph Hierarchy for TensorFlow graph.
 */
var tf;
(function (tf) {
    var graph;
    (function (graph_1) {
        var hierarchy;
        (function (hierarchy_1) {
            /**
             * Class for the Graph Hierarchy for TensorFlow graph.
             */
            var HierarchyImpl = (function () {
                function HierarchyImpl() {
                    this.hasShapeInfo = false;
                    this.maxMetaEdgeSize = 1;
                    this.root = graph_1.createMetanode(graph_1.ROOT_NAME, { compound: true });
                    this.templates = null;
                    this.devices = null;
                    /**
                     * @type {Object} Dictionary object that maps node name to the node
                     * (could be op-node, metanode, or series-node)
                     */
                    this.index = {};
                    this.index[graph_1.ROOT_NAME] = this.root;
                    this.orderings = {};
                }
                HierarchyImpl.prototype.getNodeMap = function () {
                    return this.index;
                };
                HierarchyImpl.prototype.node = function (name) {
                    return this.index[name];
                };
                HierarchyImpl.prototype.setNode = function (name, node) {
                    this.index[name] = node;
                };
                /**
                 * Given the name of a node in this hierarchy, get its bridgegraph, creating
                 * it on the fly if necessary. If the node is not a GroupNode, then this
                 * method returns null. If the provided name does not map to a node in the
                 * hierarchy, an error will be thrown.
                 */
                HierarchyImpl.prototype.getBridgegraph = function (nodeName) {
                    var _this = this;
                    var node = this.index[nodeName];
                    if (!node) {
                        throw Error('Could not find node in hierarchy: ' + nodeName);
                    }
                    if (!('metagraph' in node)) {
                        return null;
                    }
                    var groupNode = node;
                    if (groupNode.bridgegraph) {
                        return groupNode.bridgegraph;
                    }
                    var bridgegraph = groupNode.bridgegraph =
                        graph_1.createGraph('BRIDGEGRAPH', graph_1.GraphType.BRIDGE);
                    if (!node.parentNode || !('metagraph' in node.parentNode)) {
                        return bridgegraph;
                    }
                    var parentNode = node.parentNode;
                    var parentMetagraph = parentNode.metagraph;
                    var parentBridgegraph = this.getBridgegraph(parentNode.name);
                    // For each of the parent node's two Metaedge containing graphs, process
                    // each Metaedge involving this node.
                    _.each([parentMetagraph, parentBridgegraph], function (parentGraph) {
                        _(parentGraph.edges())
                            .filter(function (e) { return e.v === nodeName || e.w === nodeName; })
                            .each(function (parentEdgeObj) {
                            var inbound = parentEdgeObj.w === nodeName;
                            var parentMetaedge = parentGraph.edge(parentEdgeObj);
                            // The parent's Metaedge represents some number of underlying
                            // BaseEdges from the original full graph. For each of those, we need
                            // to determine which immediate child is involved and make sure
                            // there's a Metaedge in the bridgegraph that covers it.
                            _.each(parentMetaedge.baseEdgeList, function (baseEdge) {
                                // Based on the direction, figure out which is the descendant node
                                // and which is the 'other' node (sibling of parent or ancestor).
                                var _a = inbound ?
                                    [baseEdge.w, parentEdgeObj.v] :
                                    [baseEdge.v, parentEdgeObj.w], descendantName = _a[0], otherName = _a[1];
                                // Determine the immediate child containing this descendant node.
                                var childName = _this.getChildName(nodeName, descendantName);
                                // Look for an existing Metaedge in the bridgegraph (or create a
                                // new one) that covers the relationship between child and other.
                                var bridgeEdgeObj = {
                                    v: inbound ? otherName : childName,
                                    w: inbound ? childName : otherName,
                                };
                                var bridgeMetaedge = bridgegraph.edge(bridgeEdgeObj);
                                if (!bridgeMetaedge) {
                                    bridgeMetaedge = graph_1.createMetaedge(bridgeEdgeObj.v, bridgeEdgeObj.w);
                                    bridgeMetaedge.inbound = inbound;
                                    bridgegraph.setEdge(bridgeEdgeObj.v, bridgeEdgeObj.w, bridgeMetaedge);
                                }
                                // Copy the BaseEdge from the parent's Metaedge into this
                                // bridgegraph Metaedge.
                                bridgeMetaedge.addBaseEdge(baseEdge, _this);
                            });
                        })
                            .value(); // force lodash chain execution.
                    });
                    return bridgegraph;
                };
                /**
                 * Utility function for determining the name of the immediate child under a
                 * node for a given descendant path. If the descendant corresponds to no
                 * immediate child, an error is thrown.
                 */
                HierarchyImpl.prototype.getChildName = function (nodeName, descendantName) {
                    // Walk up the hierarchy from the descendant to find the child.
                    var currentNode = this.index[descendantName];
                    while (currentNode) {
                        if (currentNode.parentNode && currentNode.parentNode.name === nodeName) {
                            return currentNode.name;
                        }
                        currentNode = currentNode.parentNode;
                    }
                    throw Error('Could not find immediate child for descendant: ' + descendantName);
                };
                ;
                /** Given the name of a node, return its incoming metaedges. */
                HierarchyImpl.prototype.getPredecessors = function (nodeName) {
                    var _this = this;
                    var node = this.index[nodeName];
                    if (!node) {
                        throw Error('Could not find node with name: ' + nodeName);
                    }
                    var predecessors = this.getOneWayEdges(node, true);
                    // Add embedded predecessors, such as constants.
                    if (!node.isGroupNode) {
                        _.each(node.inEmbeddings, function (embeddedNode) {
                            _.each(node.inputs, function (input) {
                                if (input.name === embeddedNode.name) {
                                    // Make a new metaedge holding the edge between the
                                    // node and the in-embedding.
                                    var metaedge = new graph_1.MetaedgeImpl(embeddedNode.name, nodeName);
                                    metaedge.addBaseEdge({
                                        isControlDependency: input.isControlDependency,
                                        outputTensorIndex: input.outputTensorIndex,
                                        isReferenceEdge: false,
                                        v: embeddedNode.name,
                                        w: nodeName
                                    }, _this);
                                    predecessors.regular.push(metaedge);
                                }
                            });
                        });
                    }
                    return predecessors;
                };
                /**
                 * Given the name of a node, return its outgoing metaedges.
                 *
                 * This is the inverse of getPredecessors(). See that method's documentation
                 * for an in-depth example.
                 */
                HierarchyImpl.prototype.getSuccessors = function (nodeName) {
                    var _this = this;
                    var node = this.index[nodeName];
                    if (!node) {
                        throw Error('Could not find node with name: ' + nodeName);
                    }
                    var successors = this.getOneWayEdges(node, false);
                    // Add embedded successors, such as summaries.
                    if (!node.isGroupNode) {
                        _.each(node.outEmbeddings, function (embeddedNode) {
                            _.each(embeddedNode.inputs, function (input) {
                                if (input.name === nodeName) {
                                    // Make a new metaedge holding the edge between the
                                    // node and the out-embedding.
                                    var metaedge = new graph_1.MetaedgeImpl(nodeName, embeddedNode.name);
                                    metaedge.addBaseEdge({
                                        isControlDependency: input.isControlDependency,
                                        outputTensorIndex: input.outputTensorIndex,
                                        isReferenceEdge: false,
                                        v: nodeName,
                                        w: embeddedNode.name
                                    }, _this);
                                    successors.regular.push(metaedge);
                                }
                            });
                        });
                    }
                    return successors;
                };
                /** Helper method for getPredecessors and getSuccessors */
                HierarchyImpl.prototype.getOneWayEdges = function (node, inEdges) {
                    var edges = { control: [], regular: [] };
                    // A node with no parent cannot have any edges.
                    if (!node.parentNode || !node.parentNode.isGroupNode) {
                        return edges;
                    }
                    var parentNode = node.parentNode;
                    var metagraph = parentNode.metagraph;
                    var bridgegraph = this.getBridgegraph(parentNode.name);
                    findEdgeTargetsInGraph(metagraph, node, inEdges, edges);
                    findEdgeTargetsInGraph(bridgegraph, node, inEdges, edges);
                    return edges;
                };
                /**
                 * For a given GroupNode, get or calculate an object which describes a
                 * topological ordering of child nodes within that GroupNode's metagraph.
                 *
                 * This ordering is used when rendering bridge control edges which are
                 * sometimes backwards relative to the dataflow.
                 *
                 * For example, say we have a graph with two edges A->B and A->C, and we're
                 * interested in the ordering under ROOT. In this case, any of the following
                 * would be legitimate return values:
                 *
                 *  - { 'A': 0, 'B': 1, 'C': 2 } -- most likely
                 *  - { 'A': 0, 'B': 2, 'C': 1 } -- less likely
                 *  - { 'A': 12, 'B': 100, 'C': 99 } -- unlikely, but still OK
                 *
                 * The algorithm does not guarantee that all numbers from 0-N (where N is
                 * the number of nodes) appear exactly once. Rather it guarantees that if
                 * there is a path between two nodes, the earlier one will have a lower
                 * number in the ordering hash.
                 *
                 * When generating the ordering, we ignore control Metaedges (those which
                 * represent only BaseEdges that have isControlDependency set to true).
                 *
                 * If there is no node with the specified name, an error is thrown. If the
                 * node with the specified name is not a group node, null is returned.
                 */
                HierarchyImpl.prototype.getTopologicalOrdering = function (nodeName) {
                    var node = this.index[nodeName];
                    if (!node) {
                        throw Error('Could not find node with name: ' + nodeName);
                    }
                    if (!node.isGroupNode) {
                        return null;
                    }
                    if (nodeName in this.orderings) {
                        return this.orderings[nodeName];
                    }
                    // Mapping of a child node names to lists of their successors.
                    var successors = {};
                    // Set of node names which have appeared as a destination.
                    var destinations = {};
                    var metagraph = node.metagraph;
                    _.each(metagraph.edges(), function (e) {
                        if (!metagraph.edge(e).numRegularEdges) {
                            return; // Skip control edges.
                        }
                        // Keep track of successors and destinations.
                        if (!(e.v in successors)) {
                            successors[e.v] = [];
                        }
                        successors[e.v].push(e.w);
                        destinations[e.w] = true;
                    });
                    // Seed the queue with true sources (those that are not destinations).
                    var queue = _.difference(_.keys(successors), _.keys(destinations));
                    // Produce an ordering by traversing the graph breadth first.
                    var ordering = this.orderings[nodeName] = {};
                    var index = 0;
                    while (queue.length) {
                        var childName = queue.shift();
                        ordering[childName] = index++;
                        _.each(successors[childName], function (succName) { return queue.push(succName); });
                        delete successors[childName]; // Prevent cycles from infinite looping.
                    }
                    return ordering;
                };
                /**
                 * Returns a d3 Ordinal function that can be used to look up the index of
                 * a node based on its template id.
                 */
                HierarchyImpl.prototype.getTemplateIndex = function () {
                    var templateNames = d3.keys(this.templates);
                    var templateIndex = d3.scale.ordinal()
                        .domain(templateNames)
                        .range(d3.range(0, templateNames.length));
                    return function (templateId) { return templateIndex(templateId); };
                };
                return HierarchyImpl;
            }());
            /**
             * Internal utility function - given a graph (should be either a metagraph or a
             * bridgegraph) and a node which is known to be in that graph, determine
             * the other ends of edges that involve that node in the direction specified
             * by whether it's inbound.
             *
             * For example if you wanted to find the predecessors of a node, you'd call
             * this method for the parent's metagraph and bridgegraph, specifying inbound
             * as true (look at the source of inbound edges to the specified node).
             *
             * Discovered target names are appended to the targets array.
             */
            function findEdgeTargetsInGraph(graph, node, inbound, targets) {
                var edges = inbound ? graph.inEdges(node.name) : graph.outEdges(node.name);
                _.each(edges, function (e) {
                    var metaedge = graph.edge(e);
                    var targetList = metaedge.numRegularEdges ? targets.regular : targets.control;
                    targetList.push(metaedge);
                });
            }
            /**
             * @param graph The raw graph.
             * @param params Parameters used when building a hierarchy.
             */
            function build(graph, params, tracker) {
                var h = new HierarchyImpl();
                var seriesNames = {};
                return tf.graph.util
                    .runAsyncTask('Adding nodes', 20, function () {
                    // Get all the possible device names.
                    var deviceNames = {};
                    _.each(graph.nodes, function (node, nodeName) {
                        if (node.device != null) {
                            deviceNames[node.device] = true;
                        }
                    });
                    h.devices = _.keys(deviceNames);
                    addNodes(h, graph);
                }, tracker)
                    .then(function () {
                    return tf.graph.util.runAsyncTask('Detect series', 20, function () {
                        if (params.seriesNodeMinSize > 0) {
                            groupSeries(h.root, h, seriesNames, params.seriesNodeMinSize, params.seriesMap);
                        }
                    }, tracker);
                })
                    .then(function () {
                    return tf.graph.util.runAsyncTask('Adding edges', 30, function () {
                        addEdges(h, graph, seriesNames);
                    }, tracker);
                })
                    .then(function () {
                    return tf.graph.util.runAsyncTask('Finding similar subgraphs', 30, function () {
                        h.templates = graph_1.template.detect(h, params.verifyTemplate);
                    }, tracker);
                })
                    .then(function () { return h; });
            }
            hierarchy_1.build = build;
            ;
            function joinAndAggregateStats(h, stats) {
                // Get all the possible device names.
                var deviceNames = {};
                _.each(h.root.leaves(), function (nodeName) {
                    var leaf = h.node(nodeName);
                    if (leaf.device != null) {
                        deviceNames[leaf.device] = true;
                    }
                });
                h.devices = _.keys(deviceNames);
                // Reset stats for each group node.
                _.each(h.getNodeMap(), function (node, nodeName) {
                    if (node.isGroupNode) {
                        node.stats = new graph_1.NodeStats(null);
                        node.deviceHistogram = {};
                    }
                });
                // Bubble-up the stats and device distribution from leaves to parents.
                _.each(h.root.leaves(), function (nodeName) {
                    var leaf = h.node(nodeName);
                    var node = leaf;
                    while (node.parentNode != null) {
                        if (leaf.device != null) {
                            var deviceHistogram = node.parentNode.deviceHistogram;
                            deviceHistogram[leaf.device] = (deviceHistogram[leaf.device] || 0) + 1;
                        }
                        if (leaf.stats != null) {
                            node.parentNode.stats.combine(leaf.stats);
                        }
                        node = node.parentNode;
                    }
                });
            }
            hierarchy_1.joinAndAggregateStats = joinAndAggregateStats;
            /**
             * Creates the metanodes in the hierarchical graph and assigns parent-child
             * relationship between them.
             */
            function addNodes(h, graph) {
                _.each(graph.nodes, function (node, nodeName) {
                    var path = graph_1.getHierarchicalPath(node.name);
                    var parent = h.root;
                    parent.depth = Math.max(path.length, parent.depth);
                    // Create parent metanodes for each depth. For example if the node name
                    // is 'a/b/c', then create metanodes 'a' and 'a/b', where 'a/b' is a child
                    // of a.
                    for (var i = 0; i < path.length; i++) {
                        parent.depth = Math.max(parent.depth, path.length - i);
                        parent.cardinality += node.cardinality;
                        parent.opHistogram[node.op] = (parent.opHistogram[node.op] || 0) + 1;
                        if (node.device != null) {
                            parent.deviceHistogram[node.device] =
                                (parent.deviceHistogram[node.device] || 0) + 1;
                        }
                        if (i === path.length - 1) {
                            break;
                        }
                        var name_1 = path[i];
                        var child = h.node(name_1);
                        if (!child) {
                            child = graph_1.createMetanode(name_1);
                            child.parentNode = parent;
                            h.setNode(name_1, child);
                            parent.metagraph.setNode(name_1, child);
                        }
                        parent = child;
                    }
                    // Assuming node name is 'a/b/c', assign the OpNode as a child of the
                    // metanode 'a/b'.
                    h.setNode(node.name, node);
                    node.parentNode = parent;
                    parent.metagraph.setNode(node.name, node);
                    // Add each of the in-embeddings and out-embeddings in the hierarchy.
                    _.each(node.inEmbeddings, function (embedding) {
                        h.setNode(embedding.name, embedding);
                        embedding.parentNode = node;
                    });
                    _.each(node.outEmbeddings, function (embedding) {
                        h.setNode(embedding.name, embedding);
                        embedding.parentNode = node;
                    });
                });
            }
            ;
            /**
             * For each metanode in the hierarchical graph, this method adds:
             * the edges in the metagraph. These are edges between nodes
             * that share the same parent.
             */
            function addEdges(h, graph, seriesNames) {
                var nodeIndex = h.getNodeMap();
                // Ancestor paths for the source and destination nodes of an edge. These are
                // reused for each edge rather than allocating new ones. It's about 10% faster
                // than allocating new ones on each pass through the loop.
                var sourcePath = [];
                var destPath = [];
                // Insert the ancestor path for a node into the provided array, including the
                // node itself. Return the index of the last node inserted (always ROOT).
                var getPath = function (node, path) {
                    var i = 0;
                    while (node) {
                        path[i++] = node.name;
                        node = node.parentNode;
                    }
                    return i - 1;
                };
                _.each(graph.edges, function (baseEdge) {
                    // Get the hierarchical paths for the source and destination of the edge.
                    var sourceAncestorIndex = getPath(graph.nodes[baseEdge.v], sourcePath);
                    var destAncestorIndex = getPath(graph.nodes[baseEdge.w], destPath);
                    // If the hierarchical path cannot be found for either endpoint, then we
                    // cannot create the edge. This happens for example when a node has a
                    // control dependency on a summary node, which are embedded.
                    if (sourceAncestorIndex === -1 || destAncestorIndex === -1) {
                        return;
                    }
                    // Find the lowest shared ancestor between source and dest by looking for
                    // the highest nodes that differ between their ancestor paths.
                    while (sourcePath[sourceAncestorIndex] === destPath[destAncestorIndex]) {
                        sourceAncestorIndex--;
                        destAncestorIndex--;
                        if (sourceAncestorIndex < 0 || destAncestorIndex < 0) {
                            // This would only occur if the two nodes were the same (a cycle in the
                            // graph), or if one endpoint was a strict ancestor of the other. The
                            // latter shouldn't happen because we rename nodes which are both
                            // metanodes and op nodes. E.g. 'A/B' becomes 'A/B/(B)'.
                            throw Error('No difference found between ancestor paths.');
                        }
                    }
                    var sharedAncestorNode = nodeIndex[sourcePath[sourceAncestorIndex + 1]];
                    var sourceAncestorName = sourcePath[sourceAncestorIndex];
                    var destAncestorName = destPath[destAncestorIndex];
                    // Find or create the Metaedge which should contain this BaseEdge inside
                    // the shared ancestor.
                    var metaedge = sharedAncestorNode.metagraph.edge(sourceAncestorName, destAncestorName);
                    if (!metaedge) {
                        metaedge = graph_1.createMetaedge(sourceAncestorName, destAncestorName);
                        sharedAncestorNode.metagraph
                            .setEdge(sourceAncestorName, destAncestorName, metaedge);
                    }
                    if (!sharedAncestorNode.hasNonControlEdges &&
                        !baseEdge.isControlDependency) {
                        sharedAncestorNode.hasNonControlEdges = true;
                    }
                    metaedge.addBaseEdge(baseEdge, h);
                });
            }
            ;
            /**
             * Using the hierarchy template information, detect series in the provided
             * metanode.  For each detected series, create a new SeriesNode
             * and remove series members from the metanode's metagraph and move them to
             * the new series node's metagraph.
             *
             * @param metanode
             * @param hierarchy
             * @param seriesNames Map of node names to their series they are contained in.
             *     This should be provided empty and is populated by this method.
             * @param threshold If the series has this many nodes or more, then group them
             *     into a series.
             * @param map Map of series names to their series grouping type, if one has
             *     been set.
             * @return A dictionary from node name to series node name that contains the
             *     node.
             */
            function groupSeries(metanode, hierarchy, seriesNames, threshold, map) {
                var metagraph = metanode.metagraph;
                _.each(metagraph.nodes(), function (n) {
                    var child = metagraph.node(n);
                    if (child.type === tf.graph.NodeType.META) {
                        groupSeries(child, hierarchy, seriesNames, threshold, map);
                    }
                });
                var clusters = clusterNodes(metagraph);
                var seriesDict = detectSeries(clusters, metagraph);
                // Add each series node to the graph and add its grouped children to its own
                // metagraph.
                _.each(seriesDict, function (seriesNode, seriesName) {
                    var nodeMemberNames = seriesNode.metagraph.nodes();
                    _.each(nodeMemberNames, function (n) {
                        var child = metagraph.node(n);
                        if (!child.owningSeries) {
                            child.owningSeries = seriesName;
                        }
                    });
                    // If the series contains less than the threshold number of nodes and
                    // this series has not been adding to the series map, then set this
                    // series to be shown ungrouped in the map.
                    if (nodeMemberNames.length < threshold && !(seriesNode.name in map)) {
                        map[seriesNode.name] = tf.graph.SeriesGroupingType.UNGROUP;
                    }
                    // If the series is in the map as ungrouped then do not group the series.
                    if (seriesNode.name in map
                        && map[seriesNode.name] === tf.graph.SeriesGroupingType.UNGROUP) {
                        return;
                    }
                    hierarchy.setNode(seriesName, seriesNode); // add to the index
                    metagraph.setNode(seriesName, seriesNode);
                    _.each(nodeMemberNames, function (n) {
                        var child = metagraph.node(n);
                        seriesNode.metagraph.setNode(n, child);
                        seriesNode.parentNode = child.parentNode;
                        seriesNode.cardinality++;
                        if (child.device != null) {
                            seriesNode.deviceHistogram[child.device] =
                                (seriesNode.deviceHistogram[child.device] || 0) + 1;
                        }
                        child.parentNode = seriesNode;
                        seriesNames[n] = seriesName;
                        // Remove now-grouped node from its original parent's metagraph.
                        metagraph.removeNode(n);
                    });
                });
            }
            ;
            /** cluster op-nodes with similar op */
            function clusterNodes(metagraph) {
                var result = {};
                return _.reduce(metagraph.nodes(), function (clusters, n) {
                    var child = metagraph.node(n);
                    if (child.type === graph_1.NodeType.META) {
                        // skip metanodes
                        return clusters;
                    }
                    var template = child.op;
                    if (template) {
                        clusters[template] = clusters[template] || [];
                        clusters[template].push(child.name);
                    }
                    return clusters;
                }, result);
            }
            /**
             * For each cluster of op-nodes based op type, try to detect groupings.
             * Infer series name using by trying to find pattern '<number>' in the node
             * name.
             *
             * @param clusters Dictionary output from clusterNodes().
             * @param metagraph
             * @return A dictionary from series name => seriesNode
             */
            function detectSeries(clusters, metagraph) {
                var seriesDict = {};
                _.each(clusters, function (members, clusterId) {
                    if (members.length <= 1) {
                        return;
                    } // isolated clusters can't make series
                    /** @type {Object}  A dictionary mapping seriesName to seriesInfoArray,
                     * which is an array that contains objects with name, id, prefix, suffix,
                     * and parent properties.
                     */
                    var candidatesDict = {};
                    // Group all nodes that have the same name, with the exception of a
                    // number at the end of the name after an underscore, which is allowed to
                    // vary.
                    _.each(members, function (name) {
                        var isGroup = name.charAt(name.length - 1) === '*';
                        var namepath = name.split('/');
                        var leaf = namepath[namepath.length - 1];
                        var parent = namepath.slice(0, namepath.length - 1).join('/');
                        var matches = leaf.match(/^(\D*)_(\d+)$/);
                        var prefix;
                        var id;
                        var suffix = '';
                        if (matches) {
                            prefix = matches[1]; // the front non-numeric characters
                            id = matches[2]; // the digits
                        }
                        else {
                            prefix = isGroup ? leaf.substr(0, leaf.length - 1) : leaf;
                            id = 0;
                            suffix = isGroup ? '*' : '';
                        }
                        var seriesName = graph_1.getSeriesNodeName(prefix, suffix, parent);
                        candidatesDict[seriesName] = candidatesDict[seriesName] || [];
                        var seriesNode = graph_1.createSeriesNode(prefix, suffix, parent, +id, name);
                        candidatesDict[seriesName].push(seriesNode);
                    });
                    // In each group of nodes, group nodes in bunches that have monotonically
                    // increasing numbers in their names.  Each of these bunches is a series.
                    _.each(candidatesDict, function (seriesInfoArray, seriesName) {
                        if (seriesInfoArray.length < 2) {
                            return;
                        }
                        seriesInfoArray.sort(function (a, b) {
                            return (+a.clusterId) - (+b.clusterId);
                        });
                        // Loop through the nodes sorted by its detected series number, grouping
                        // all nodes with monotonically-increasing series numbers.
                        var seriesNodes = [seriesInfoArray[0]];
                        for (var index = 1; index < seriesInfoArray.length; index++) {
                            var nextNode = seriesInfoArray[index];
                            if (nextNode.clusterId === seriesNodes[seriesNodes.length - 1].clusterId
                                + 1) {
                                seriesNodes.push(nextNode);
                                continue;
                            }
                            addSeriesToDict(seriesNodes, seriesDict, +clusterId, metagraph);
                            seriesNodes = [nextNode];
                        }
                        addSeriesToDict(seriesNodes, seriesDict, +clusterId, metagraph);
                    });
                });
                return seriesDict;
            }
            /**
             * Add a series to the provided dictionary mapping series names to series.
             *
             * @param seriesNodes the nodes in the series. Contains
             *     name, id, prefix, suffix and parent properties of the node.
             * @param seriesDict the dictionary of series
             * @param clusterId ID of the template of the nodes of the series
             * @param metagraph
             */
            function addSeriesToDict(seriesNodes, seriesDict, clusterId, metagraph) {
                if (seriesNodes.length > 1) {
                    var curSeriesName = graph_1.getSeriesNodeName(seriesNodes[0].prefix, seriesNodes[0].suffix, seriesNodes[0].parent, seriesNodes[0].clusterId, seriesNodes[seriesNodes.length - 1].clusterId);
                    var curSeriesNode_1 = graph_1.createSeriesNode(seriesNodes[0].prefix, seriesNodes[0].suffix, seriesNodes[0].parent, clusterId, curSeriesName);
                    _.each(seriesNodes, function (node) {
                        curSeriesNode_1.ids.push(node.clusterId);
                        curSeriesNode_1.metagraph.setNode(node.name, metagraph.node(node.name));
                    });
                    seriesDict[curSeriesName] = curSeriesNode_1;
                }
            }
        })(hierarchy = graph_1.hierarchy || (graph_1.hierarchy = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module tf.graph.hierarchy
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph_1) {
        var layout;
        (function (layout) {
            /** Set of parameters that define the look and feel of the graph. */
            layout.PARAMS = {
                animation: {
                    /** Default duration for graph animations in ms. */
                    duration: 250
                },
                graph: {
                    /** Graph parameter for metanode. */
                    meta: {
                        /**
                         * Dagre's nodesep param - number of pixels that
                         * separate nodes horizontally in the layout.
                         *
                         * See https://github.com/cpettitt/dagre/wiki#configuring-the-layout
                         */
                        nodeSep: 5,
                        /**
                         * Dagre's ranksep param - number of pixels
                         * between each rank in the layout.
                         *
                         * See https://github.com/cpettitt/dagre/wiki#configuring-the-layout
                         */
                        rankSep: 25,
                        /**
                         * Dagre's edgesep param - number of pixels that separate
                         * edges horizontally in the layout.
                         */
                        edgeSep: 5,
                    },
                    /** Graph parameter for metanode. */
                    series: {
                        /**
                         * Dagre's nodesep param - number of pixels that
                         * separate nodes horizontally in the layout.
                         *
                         * See https://github.com/cpettitt/dagre/wiki#configuring-the-layout
                         */
                        nodeSep: 5,
                        /**
                         * Dagre's ranksep param - number of pixels
                         * between each rank in the layout.
                         *
                         * See https://github.com/cpettitt/dagre/wiki#configuring-the-layout
                         */
                        rankSep: 25,
                        /**
                         * Dagre's edgesep param - number of pixels that separate
                         * edges horizontally in the layout.
                         */
                        edgeSep: 5
                    },
                    /**
                     * Padding is used to correctly position the graph SVG inside of its parent
                     * element. The padding amounts are applied using an SVG transform of X and
                     * Y coordinates.
                     */
                    padding: {
                        paddingTop: 40,
                        paddingLeft: 20
                    }
                },
                subscene: {
                    meta: {
                        paddingTop: 10,
                        paddingBottom: 10,
                        paddingLeft: 10,
                        paddingRight: 10,
                        /**
                         * Used to leave room for the label on top of the highest node in
                         * the core graph.
                         */
                        labelHeight: 20,
                        /** X-space between each extracted node and the core graph. */
                        extractXOffset: 15,
                        /** Y-space between each extracted node. */
                        extractYOffset: 20
                    },
                    series: {
                        paddingTop: 10,
                        paddingBottom: 10,
                        paddingLeft: 10,
                        paddingRight: 10,
                        labelHeight: 10
                    }
                },
                nodeSize: {
                    /** Size of meta nodes. */
                    meta: {
                        radius: 5,
                        width: 60,
                        /** A scale for the node's height based on number of nodes inside */
                        height: d3.scale.linear().domain([1, 200]).range([15, 60]).clamp(true),
                        /** The radius of the circle denoting the expand button. */
                        expandButtonRadius: 3
                    },
                    /** Size of op nodes. */
                    op: {
                        width: 15,
                        height: 6,
                        radius: 3,
                        labelOffset: -8
                    },
                    /** Size of series nodes. */
                    series: {
                        expanded: {
                            // For expanded series nodes, width and height will be
                            // computed to account for the subscene.
                            radius: 10,
                            labelOffset: 0,
                        },
                        vertical: {
                            // When unexpanded, series whose underlying metagraphs contain
                            // one or more non-control edges will show as a vertical stack
                            // of ellipses.
                            width: 16,
                            height: 13,
                            labelOffset: -13,
                        },
                        horizontal: {
                            // When unexpanded, series whose underlying metagraphs contain
                            // no non-control edges will show as a horizontal stack of
                            // ellipses.
                            width: 24,
                            height: 8,
                            radius: 10,
                            labelOffset: -10,
                        },
                    },
                    /** Size of bridge nodes. */
                    bridge: {
                        // NOTE: bridge nodes will normally be invisible, but they must
                        // take up some space so that the layout step leaves room for
                        // their edges.
                        width: 20,
                        height: 20,
                        radius: 2,
                        labelOffset: 0
                    }
                },
                shortcutSize: {
                    /** Size of shortcuts for op nodes */
                    op: {
                        width: 10,
                        height: 4
                    },
                    /** Size of shortcuts for meta nodes */
                    meta: {
                        width: 12,
                        height: 4,
                        radius: 1
                    },
                    /** Size of shortcuts for series nodes */
                    series: {
                        width: 14,
                        height: 4,
                    }
                },
                annotations: {
                    /** Maximum possible width of the bounding box for in annotations */
                    inboxWidth: 50,
                    /** Maximum possible width of the bounding box for out annotations */
                    outboxWidth: 50,
                    /** X-space between the shape and each annotation-node. */
                    xOffset: 10,
                    /** Y-space between each annotation-node. */
                    yOffset: 3,
                    /** X-space between each annotation-node and its label. */
                    labelOffset: 2,
                    /** Estimate max width for annotation label */
                    labelWidth: 35
                },
                constant: {
                    size: {
                        width: 4,
                        height: 4
                    }
                },
                series: {
                    /** Maximum number of repeated item for unexpanded series node. */
                    maxStackCount: 3,
                    /**
                     * Positioning offset ratio for collapsed stack
                     * of parallel series (series without edges between its members).
                     */
                    parallelStackOffsetRatio: 0.2,
                    /**
                     * Positioning offset ratio for collapsed stack
                     * of tower series (series with edges between its members).
                     */
                    towerStackOffsetRatio: 0.5
                },
                minimap: {
                    /** The maximum width/height the minimap can have. */
                    size: 150
                }
            };
            /** Calculate layout for a scene of a group node. */
            function layoutScene(renderNodeInfo) {
                // Update layout, size, and annotations of its children nodes and edges.
                if (renderNodeInfo.node.isGroupNode) {
                    layoutChildren(renderNodeInfo);
                }
                // Update position of its children nodes and edges
                if (renderNodeInfo.node.type === graph_1.NodeType.META) {
                    layoutMetanode(renderNodeInfo);
                }
                else if (renderNodeInfo.node.type === graph_1.NodeType.SERIES) {
                    layoutSeriesNode(renderNodeInfo);
                }
            }
            layout.layoutScene = layoutScene;
            ;
            /**
             * Updates the total width of an unexpanded node which includes the size of its
             * in and out annotations.
             */
            function updateTotalWidthOfNode(renderInfo) {
                renderInfo.inboxWidth = renderInfo.inAnnotations.list.length > 0 ?
                    layout.PARAMS.annotations.inboxWidth : 0;
                renderInfo.outboxWidth = renderInfo.outAnnotations.list.length > 0 ?
                    layout.PARAMS.annotations.outboxWidth : 0;
                // Assign the width of the core box (the main shape of the node).
                renderInfo.coreBox.width = renderInfo.width;
                renderInfo.coreBox.height = renderInfo.height;
                // TODO(jimbo): Account for font width rather than using a magic number.
                var labelLength = renderInfo.node.name.length -
                    renderInfo.node.name.lastIndexOf(graph_1.NAMESPACE_DELIM) - 1;
                var charWidth = 3; // 3 pixels per character.
                // Compute the total width of the node.
                renderInfo.width = Math.max(renderInfo.coreBox.width +
                    renderInfo.inboxWidth + renderInfo.outboxWidth, labelLength * charWidth);
            }
            /**
             * Update layout, size, and annotations of its children nodes and edges.
             */
            function layoutChildren(renderNodeInfo) {
                var children = renderNodeInfo.coreGraph.nodes().map(function (n) {
                    return renderNodeInfo.coreGraph.node(n);
                }).concat(renderNodeInfo.isolatedInExtract, renderNodeInfo.isolatedOutExtract);
                _.each(children, function (childNodeInfo) {
                    // Set size of each child
                    switch (childNodeInfo.node.type) {
                        case graph_1.NodeType.OP:
                            _.extend(childNodeInfo, layout.PARAMS.nodeSize.op);
                            break;
                        case graph_1.NodeType.BRIDGE:
                            _.extend(childNodeInfo, layout.PARAMS.nodeSize.bridge);
                            break;
                        case graph_1.NodeType.META:
                            if (!childNodeInfo.expanded) {
                                // Set fixed width and scalable height based on cardinality
                                _.extend(childNodeInfo, layout.PARAMS.nodeSize.meta);
                                childNodeInfo.height =
                                    layout.PARAMS.nodeSize.meta.height(childNodeInfo.node.cardinality);
                            }
                            else {
                                var childGroupNodeInfo = childNodeInfo;
                                layoutScene(childGroupNodeInfo); // Recursively layout its subscene.
                            }
                            break;
                        case graph_1.NodeType.SERIES:
                            if (childNodeInfo.expanded) {
                                _.extend(childNodeInfo, layout.PARAMS.nodeSize.series.expanded);
                                var childGroupNodeInfo = childNodeInfo;
                                layoutScene(childGroupNodeInfo); // Recursively layout its subscene.
                            }
                            else {
                                var childGroupNodeInfo = childNodeInfo;
                                var seriesParams = childGroupNodeInfo.node.hasNonControlEdges ?
                                    layout.PARAMS.nodeSize.series.vertical :
                                    layout.PARAMS.nodeSize.series.horizontal;
                                _.extend(childNodeInfo, seriesParams);
                            }
                            break;
                        default:
                            throw Error('Unrecognized node type: ' + childNodeInfo.node.type);
                    }
                    // Compute total width of un-expanded nodes. Width of expanded nodes
                    // has already been computed.
                    if (!childNodeInfo.expanded) {
                        updateTotalWidthOfNode(childNodeInfo);
                    }
                    // Layout each child's annotations
                    layoutAnnotation(childNodeInfo);
                });
            }
            /**
             * Calculate layout for a graph using dagre
             * @param graph the graph to be laid out
             * @param params layout parameters
             * @return width and height of the core graph
             */
            function dagreLayout(graph, params) {
                _.extend(graph.graph(), {
                    nodesep: params.nodeSep,
                    ranksep: params.rankSep,
                    edgesep: params.edgeSep
                });
                var bridgeNodeNames = [];
                var nonBridgeNodeNames = [];
                // Split out nodes into bridge and non-bridge nodes, and calculate the total
                // width we should use for bridge nodes.
                _.each(graph.nodes(), function (nodeName) {
                    var nodeInfo = graph.node(nodeName);
                    if (nodeInfo.node.type === graph_1.NodeType.BRIDGE) {
                        bridgeNodeNames.push(nodeName);
                    }
                    else {
                        nonBridgeNodeNames.push(nodeName);
                    }
                });
                // If there are no non-bridge nodes, then the graph has zero size.
                if (!nonBridgeNodeNames.length) {
                    return {
                        width: 0,
                        height: 0,
                    };
                }
                dagre.layout(graph);
                // Calculate the true bounding box of the graph by iterating over nodes and
                // edges rather than accepting dagre's word for it. In particular, we should
                // ignore the extra-wide bridge nodes and bridge edges, and allow for
                // annotation boxes and labels.
                var minX = Infinity;
                var minY = Infinity;
                var maxX = -Infinity;
                var maxY = -Infinity;
                _.each(nonBridgeNodeNames, function (nodeName) {
                    var nodeInfo = graph.node(nodeName);
                    var w = 0.5 * nodeInfo.width;
                    var x1 = nodeInfo.x - w;
                    var x2 = nodeInfo.x + w;
                    minX = x1 < minX ? x1 : minX;
                    maxX = x2 > maxX ? x2 : maxX;
                    // TODO(jimbo): Account for the height of labels above op nodes here.
                    var h = 0.5 * nodeInfo.height;
                    var y1 = nodeInfo.y - h;
                    var y2 = nodeInfo.y + h;
                    minY = y1 < minY ? y1 : minY;
                    maxY = y2 > maxY ? y2 : maxY;
                });
                _.each(graph.edges(), function (edgeObj) {
                    var edgeInfo = graph.edge(edgeObj);
                    if (edgeInfo.structural) {
                        return; // Skip structural edges from min/max calculations.
                    }
                    // Since the node size passed to dagre includes the in and out
                    // annotations, the endpoints of the edge produced by dagre may not
                    // point to the actual node shape (rectangle, ellipse). We correct the
                    // end-points by finding the intersection of a line between the
                    // next-to-last (next-to-first) point and the destination (source)
                    // rectangle.
                    var sourceNode = graph.node(edgeInfo.metaedge.v);
                    var destNode = graph.node(edgeInfo.metaedge.w);
                    // Straight 3-points edges are special case, since they are curved after
                    // our default correction. To keep them straight, we remove the mid point
                    // and correct the first and the last point to be the center of the
                    // source and destination node respectively.
                    if (edgeInfo.points.length === 3 && isStraightLine(edgeInfo.points)) {
                        if (sourceNode != null) {
                            var cxSource = sourceNode.expanded ?
                                sourceNode.x : computeCXPositionOfNodeShape(sourceNode);
                            edgeInfo.points[0].x = cxSource;
                        }
                        if (destNode != null) {
                            var cxDest = destNode.expanded ?
                                destNode.x : computeCXPositionOfNodeShape(destNode);
                            edgeInfo.points[2].x = cxDest;
                        }
                        // Remove the middle point so the edge doesn't curve.
                        edgeInfo.points = [edgeInfo.points[0], edgeInfo.points[1]];
                    }
                    // Correct the destination endpoint of the edge.
                    var nextToLastPoint = edgeInfo.points[edgeInfo.points.length - 2];
                    // The destination node might be null if this is a bridge edge.
                    if (destNode != null) {
                        edgeInfo.points[edgeInfo.points.length - 1] =
                            intersectPointAndNode(nextToLastPoint, destNode);
                    }
                    // Correct the source endpoint of the edge.
                    var secondPoint = edgeInfo.points[1];
                    // The source might be null if this is a bridge edge.
                    if (sourceNode != null) {
                        edgeInfo.points[0] = intersectPointAndNode(secondPoint, sourceNode);
                    }
                    _.each(edgeInfo.points, function (point) {
                        minX = point.x < minX ? point.x : minX;
                        maxX = point.x > maxX ? point.x : maxX;
                        minY = point.y < minY ? point.y : minY;
                        maxY = point.y > maxY ? point.y : maxY;
                    });
                });
                // Shift all nodes and edge points to account for the left-padding amount,
                // and the invisible bridge nodes.
                _.each(graph.nodes(), function (nodeName) {
                    var nodeInfo = graph.node(nodeName);
                    nodeInfo.x -= minX;
                    nodeInfo.y -= minY;
                });
                _.each(graph.edges(), function (edgeObj) {
                    _.each(graph.edge(edgeObj).points, function (point) {
                        point.x -= minX;
                        point.y -= minY;
                    });
                });
                return {
                    width: maxX - minX,
                    height: maxY - minY
                };
            }
            /** Layout a metanode. Only called for an expanded node. */
            function layoutMetanode(renderNodeInfo) {
                // First, copy params specific to meta nodes onto this render info object.
                var params = layout.PARAMS.subscene.meta;
                _.extend(renderNodeInfo, params);
                // Invoke dagre.layout() on the core graph and record the bounding box
                // dimensions.
                _.extend(renderNodeInfo.coreBox, dagreLayout(renderNodeInfo.coreGraph, layout.PARAMS.graph.meta));
                // Calculate the position of nodes in isolatedInExtract relative to the
                // top-left corner of inExtractBox (the bounding box for all inExtract nodes)
                // and calculate the size of the inExtractBox.
                var maxInExtractWidth = _.max(renderNodeInfo.isolatedInExtract, function (renderNode) { return renderNode.width; }).width;
                renderNodeInfo.inExtractBox.width = maxInExtractWidth != null ?
                    maxInExtractWidth : 0;
                renderNodeInfo.inExtractBox.height =
                    _.reduce(renderNodeInfo.isolatedInExtract, function (height, child, i) {
                        var yOffset = i > 0 ? params.extractYOffset : 0;
                        // use width/height here to avoid overlaps between extracts
                        child.x = 0;
                        child.y = height + yOffset + child.height / 2;
                        return height + yOffset + child.height;
                    }, 0);
                // Calculate the position of nodes in isolatedOutExtract relative to the
                // top-left corner of outExtractBox (the bounding box for all outExtract
                // nodes) and calculate the size of the outExtractBox.
                var maxOutExtractWidth = _.max(renderNodeInfo.isolatedOutExtract, function (renderNode) { return renderNode.width; }).width;
                renderNodeInfo.outExtractBox.width = maxOutExtractWidth != null ?
                    maxOutExtractWidth : 0;
                renderNodeInfo.outExtractBox.height =
                    _.reduce(renderNodeInfo.isolatedOutExtract, function (height, child, i) {
                        var yOffset = i > 0 ? params.extractYOffset : 0;
                        // use width/height here to avoid overlaps between extracts
                        child.x = 0;
                        child.y = height + yOffset + child.height / 2;
                        return height + yOffset + child.height;
                    }, 0);
                // Compute the total padding between the core graph, in-extract and
                // out-extract boxes.
                var numParts = 0;
                if (renderNodeInfo.isolatedInExtract.length > 0) {
                    numParts++;
                }
                if (renderNodeInfo.isolatedOutExtract.length > 0) {
                    numParts++;
                }
                if (renderNodeInfo.coreGraph.nodeCount() > 0) {
                    numParts++;
                }
                var offset = layout.PARAMS.subscene.meta.extractXOffset;
                var padding = numParts <= 1 ? 0 : (numParts <= 2 ? offset : 2 * offset);
                // Add the in-extract and out-extract width to the core box width.
                renderNodeInfo.coreBox.width += renderNodeInfo.inExtractBox.width +
                    renderNodeInfo.outExtractBox.width + padding;
                renderNodeInfo.coreBox.height =
                    params.labelHeight +
                        Math.max(renderNodeInfo.inExtractBox.height, renderNodeInfo.coreBox.height, renderNodeInfo.outExtractBox.height);
                // Determine the whole metanode's width (from left to right).
                renderNodeInfo.width = renderNodeInfo.coreBox.width +
                    params.paddingLeft + params.paddingRight;
                // Determine the whole metanode's height (from top to bottom).
                renderNodeInfo.height =
                    renderNodeInfo.paddingTop +
                        renderNodeInfo.coreBox.height +
                        renderNodeInfo.paddingBottom;
            }
            /**
             * Calculate layout for series node's core graph. Only called for an expanded
             * series.
             */
            function layoutSeriesNode(node) {
                var graph = node.coreGraph;
                var params = layout.PARAMS.subscene.series;
                _.extend(node, params);
                // Layout the core.
                _.extend(node.coreBox, dagreLayout(node.coreGraph, layout.PARAMS.graph.series));
                _.each(graph.nodes(), function (nodeName) {
                    graph.node(nodeName).excluded = false;
                });
                // Series do not have in/outExtractBox so no need to include them here.
                node.width = node.coreBox.width + params.paddingLeft + params.paddingRight;
                node.height = node.coreBox.height + params.paddingTop + params.paddingBottom;
            }
            /**
             * Calculate layout for annotations of a given node.
             * This will modify positions of the given node and its annotations.
             *
             * @see tf.graph.render.Node and tf.graph.render.Annotation
             * for description of each property of each render node.
             *
             */
            function layoutAnnotation(renderNodeInfo) {
                // If the render node is an expanded metanode, then its annotations will not
                // be visible and we should skip the annotation calculations.
                if (renderNodeInfo.expanded) {
                    return;
                }
                var inAnnotations = renderNodeInfo.inAnnotations.list;
                var outAnnotations = renderNodeInfo.outAnnotations.list;
                // Calculate size for in-annotations
                _.each(inAnnotations, function (a) { return sizeAnnotation(a); });
                // Calculate size for out-annotations
                _.each(outAnnotations, function (a) { return sizeAnnotation(a); });
                var params = layout.PARAMS.annotations;
                // Calculate annotation node position (a.dx, a.dy)
                // and total height for in-annotations
                // After this chunk of code:
                // inboxHeight = sum of annotation heights+ (annotation.length - 1 * yOffset)
                var inboxHeight = _.reduce(inAnnotations, function (height, a, i) {
                    var yOffset = i > 0 ? params.yOffset : 0;
                    a.dx = -(renderNodeInfo.coreBox.width + a.width) / 2 - params.xOffset;
                    a.dy = height + yOffset + a.height / 2;
                    return height + yOffset + a.height;
                }, 0);
                _.each(inAnnotations, function (a) {
                    a.dy -= inboxHeight / 2;
                    a.labelOffset = params.labelOffset;
                });
                // Calculate annotation node position (a.dx, a.dy)
                // and total height for out-annotations
                // After this chunk of code:
                // outboxHeight = sum of annotation heights +
                //                (annotation.length - 1 * yOffset)
                var outboxHeight = _.reduce(outAnnotations, function (height, a, i) {
                    var yOffset = i > 0 ? params.yOffset : 0;
                    a.dx = (renderNodeInfo.coreBox.width + a.width) / 2 + params.xOffset;
                    a.dy = height + yOffset + a.height / 2;
                    return height + yOffset + a.height;
                }, 0);
                _.each(outAnnotations, function (a) {
                    // adjust by (half of ) the total height
                    // so dy is relative to the host node's center.
                    a.dy -= outboxHeight / 2;
                    a.labelOffset = params.labelOffset;
                });
                // Creating scales for touch point between the in-annotation edges
                // and their hosts.
                var inTouchHeight = Math.min(renderNodeInfo.height / 2 - renderNodeInfo.radius, inboxHeight / 2);
                inTouchHeight = inTouchHeight < 0 ? 0 : inTouchHeight;
                var inY = d3.scale.linear()
                    .domain([0, inAnnotations.length - 1])
                    .range([-inTouchHeight, inTouchHeight]);
                // Calculate annotation edge position
                _.each(inAnnotations, function (a, i) {
                    a.points = [
                        // The annotation node end
                        {
                            dx: a.dx + a.width / 2,
                            dy: a.dy
                        },
                        // The host node end
                        {
                            dx: -renderNodeInfo.coreBox.width / 2,
                            // only use scale if there are more than one,
                            // otherwise center it vertically
                            dy: inAnnotations.length > 1 ? inY(i) : 0
                        }
                    ];
                });
                // Creating scales for touch point between the out-annotation edges
                // and their hosts.
                var outTouchHeight = Math.min(renderNodeInfo.height / 2 - renderNodeInfo.radius, outboxHeight / 2);
                outTouchHeight = outTouchHeight < 0 ? 0 : outTouchHeight;
                var outY = d3.scale.linear()
                    .domain([0, outAnnotations.length - 1])
                    .range([-outTouchHeight, outTouchHeight]);
                _.each(outAnnotations, function (a, i) {
                    // Add point from the border of the annotation node
                    a.points = [
                        // The host node end
                        {
                            dx: renderNodeInfo.coreBox.width / 2,
                            // only use scale if there are more than one,
                            // otherwise center it vertically
                            dy: outAnnotations.length > 1 ? outY(i) : 0
                        },
                        // The annotation node end
                        {
                            dx: a.dx - a.width / 2,
                            dy: a.dy
                        }
                    ];
                });
                renderNodeInfo.height =
                    Math.max(renderNodeInfo.height, inboxHeight, outboxHeight);
            }
            /**
             * Set size of an annotation node.
             */
            function sizeAnnotation(a) {
                switch (a.annotationType) {
                    case graph_1.render.AnnotationType.CONSTANT:
                        _.extend(a, layout.PARAMS.constant.size);
                        break;
                    case graph_1.render.AnnotationType.SHORTCUT:
                        if (a.node.type === graph_1.NodeType.OP) {
                            _.extend(a, layout.PARAMS.shortcutSize.op);
                        }
                        else if (a.node.type === graph_1.NodeType.META) {
                            _.extend(a, layout.PARAMS.shortcutSize.meta);
                        }
                        else if (a.node.type === graph_1.NodeType.SERIES) {
                            _.extend(a, layout.PARAMS.shortcutSize.series);
                        }
                        else {
                            throw Error('Invalid node type: ' + a.node.type);
                        }
                        break;
                    case graph_1.render.AnnotationType.SUMMARY:
                        _.extend(a, layout.PARAMS.constant.size);
                        break;
                }
            }
            /**
             * Determines the center position of the node's shape. The position depends
             * on if the node has in and out-annotations.
             */
            function computeCXPositionOfNodeShape(renderInfo) {
                if (renderInfo.expanded) {
                    return renderInfo.x;
                }
                var dx = renderInfo.inAnnotations.list.length ? renderInfo.inboxWidth : 0;
                return renderInfo.x - renderInfo.width / 2 + dx +
                    renderInfo.coreBox.width / 2;
            }
            layout.computeCXPositionOfNodeShape = computeCXPositionOfNodeShape;
            /** Returns the angle (in degrees) between two points. */
            function angleBetweenTwoPoints(a, b) {
                var dx = b.x - a.x;
                var dy = b.y - a.y;
                return 180 * Math.atan(dy / dx) / Math.PI;
            }
            /**
             * Returns if a line going through the specified points is a straight line.
             */
            function isStraightLine(points) {
                var angle = angleBetweenTwoPoints(points[0], points[1]);
                for (var i = 1; i < points.length - 1; i++) {
                    var newAngle = angleBetweenTwoPoints(points[i], points[i + 1]);
                    // Have a tolerance of 1 degree.
                    if (Math.abs(newAngle - angle) > 1) {
                        return false;
                    }
                    angle = newAngle;
                }
                return true;
            }
            /**
             * Returns the intersection of a line between the provided point
             * and the provided rectangle.
             */
            function intersectPointAndNode(point, node) {
                // cx and cy are the center of the rectangle.
                var cx = node.expanded ?
                    node.x : computeCXPositionOfNodeShape(node);
                var cy = node.y;
                // Calculate the slope
                var dx = point.x - cx;
                var dy = point.y - cy;
                var w = node.expanded ? node.width : node.coreBox.width;
                var h = node.expanded ? node.height : node.coreBox.height;
                var deltaX, deltaY;
                if (Math.abs(dy) * w / 2 > Math.abs(dx) * h / 2) {
                    // The intersection is above or below the rectangle.
                    if (dy < 0) {
                        h = -h;
                    }
                    deltaX = dy === 0 ? 0 : h / 2 * dx / dy;
                    deltaY = h / 2;
                }
                else {
                    // The intersection is left or right of the rectangle.
                    if (dx < 0) {
                        w = -w;
                    }
                    deltaX = w / 2;
                    deltaY = dx === 0 ? 0 : w / 2 * dy / dx;
                }
                return { x: cx + deltaX, y: cy + deltaY };
            }
        })(layout = graph_1.layout || (graph_1.layout = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph) {
        var parser;
        (function (parser) {
            /**
             * Parses a native js value, which can be either a string, boolean or number.
             *
             * @param value The value to be parsed.
             */
            function parseValue(value) {
                if (value === 'true') {
                    return true;
                }
                if (value === 'false') {
                    return false;
                }
                var firstChar = value[0];
                if (firstChar === '"') {
                    return value.substring(1, value.length - 1);
                }
                var num = parseFloat(value);
                return isNaN(num) ? value : num;
            }
            /**
             * Fetches a text file and returns a promise of the result.
             */
            function fetchPbTxt(filepath) {
                return new Promise(function (resolve, reject) {
                    d3.text(filepath, function (error, text) {
                        if (error) {
                            reject(error);
                            return;
                        }
                        resolve(text);
                    });
                });
            }
            parser.fetchPbTxt = fetchPbTxt;
            /**
             * Fetches the metadata file, parses it and returns a promise of the result.
             */
            function fetchAndParseMetadata(path, tracker) {
                return tf.graph.util
                    .runTask('Reading metadata pbtxt', 40, function () {
                    if (path == null) {
                        return Promise.resolve(null);
                    }
                    return fetchPbTxt(path).then(function (text) { return new Blob([text]); });
                }, tracker)
                    .then(function (blob) {
                    return tf.graph.util.runTask('Parsing metadata.pbtxt', 60, function () {
                        return blob != null ? parseStatsPbTxt(blob) : null;
                    }, tracker);
                });
            }
            parser.fetchAndParseMetadata = fetchAndParseMetadata;
            /**
             * Fetches the graph file, parses it and returns a promise of the result.
             */
            function fetchAndParseGraphData(path, pbTxtFile, tracker) {
                return tf.graph.util
                    .runTask('Reading graph pbtxt', 40, function () {
                    return pbTxtFile ? Promise.resolve(pbTxtFile) :
                        fetchPbTxt(path).then(function (text) { return new Blob([text]); });
                }, tracker)
                    .then(function (blob) {
                    return tf.graph.util.runTask('Parsing graph.pbtxt', 60, function () {
                        return parseGraphPbTxt(blob);
                    }, tracker);
                });
            }
            parser.fetchAndParseGraphData = fetchAndParseGraphData;
            /**
             * Parse a file object in a streaming fashion line by line (or custom delim).
             * Can handle very large files.
             * @param input The file object
             * @param callback The callback called on each line
             * @param chunkSize The size of each read chunk. (optional)
             * @param delim The delimiter used to split a line. (optional)
             * @returns A promise for when it is finished.
             */
            function streamParse(file, callback, chunkSize, delim) {
                if (chunkSize === void 0) { chunkSize = 1000000; }
                if (delim === void 0) { delim = '\n'; }
                return new Promise(function (resolve, reject) {
                    var offset = 0;
                    var fileSize = file.size - 1;
                    var data = '';
                    function readHandler(evt) {
                        if (evt.target.error == null) {
                            offset += evt.target.result.length;
                            var str = evt.target.result;
                            var parts = str.split(delim);
                            var first = data + parts[0];
                            if (parts.length === 1) {
                                data = first;
                                readChunk(offset, chunkSize);
                                return;
                            }
                            data = parts[parts.length - 1];
                            callback(first);
                            for (var i = 1; i < parts.length - 1; i++) {
                                callback(parts[i]);
                            }
                        }
                        else {
                            // read error
                            reject(evt.target.error);
                            return;
                        }
                        if (offset >= fileSize) {
                            if (data) {
                                callback(data);
                            }
                            resolve(true);
                            return;
                        }
                        readChunk(offset, chunkSize);
                    }
                    function readChunk(offset, size) {
                        var reader = new FileReader();
                        var blob = file.slice(offset, offset + size);
                        reader.onload = readHandler;
                        reader.readAsText(blob);
                    }
                    readChunk(offset, chunkSize);
                });
            }
            parser.streamParse = streamParse;
            /**
             * Since proto-txt doesn't explicitly say whether an attribute is repeated
             * (an array) or not, we keep a hard-coded list of attributes that are known
             * to be repeated. This list is used in parsing time to convert repeated
             * attributes into arrays even when the attribute only shows up once in the
             * object.
             */
            var GRAPH_REPEATED_FIELDS = {
                'node': true,
                'node.input': true,
                'node.attr': true,
                'node.attr.value.list.type': true,
                'node.attr.value.shape.dim': true,
                'node.attr.value.tensor.string_val': true,
                'node.attr.value.tensor.tensor_shape.dim': true,
                'node.attr.value.list.shape': true,
                'node.attr.value.list.shape.dim': true,
                'node.attr.value.list.s': true
            };
            var METADATA_REPEATED_FIELDS = {
                'step_stats.dev_stats': true,
                'step_stats.dev_stats.node_stats': true,
                'step_stats.dev_stats.node_stats.output': true,
                'step_stats.dev_stats.node_stats.memory': true,
                'step_stats.dev_stats.node_stats.output.tensor_description.shape.dim': true
            };
            /**
             * Parses a blob of proto txt file into a raw Graph object.
             */
            function parseGraphPbTxt(input) {
                return parsePbtxtFile(input, GRAPH_REPEATED_FIELDS).then(function (obj) { return obj['node']; });
            }
            parser.parseGraphPbTxt = parseGraphPbTxt;
            /**
             * Parses a blob of proto txt file into a StepStats object.
             */
            function parseStatsPbTxt(input) {
                return parsePbtxtFile(input, METADATA_REPEATED_FIELDS)
                    .then(function (obj) { return obj['step_stats']; });
            }
            parser.parseStatsPbTxt = parseStatsPbTxt;
            /**
             * Parses a blob of proto txt file into javascript object.
             *
             * @param input The Blob or file object implementing slice.
             * @param repeatedFields Map (Set) of all the repeated fields, since you can't
             *   tell directly from the pbtxt if a field is repeated or not.
             * @returns The parsed object.
             */
            function parsePbtxtFile(input, repeatedFields) {
                var output = {};
                var stack = [];
                var path = [];
                var current = output;
                function splitNameAndValueInAttribute(line) {
                    var colonIndex = line.indexOf(':');
                    var name = line.substring(0, colonIndex).trim();
                    var value = parseValue(line.substring(colonIndex + 2).trim());
                    return {
                        name: name,
                        value: value
                    };
                }
                /**
                 * Adds a value, given the attribute name and the host object. If the
                 * attribute already exists, but is not an array, it will convert it to an
                 * array of values.
                 *
                 * @param obj The host object that holds the attribute.
                 * @param name The attribute name (key).
                 * @param value The attribute value.
                 * @param path A path that identifies the attribute. Used to check if
                 *     an attribute is an array or not.
                 */
                function addAttribute(obj, name, value, path) {
                    // We treat 'node' specially since it is done so often.
                    var existingValue = obj[name];
                    if (existingValue == null) {
                        obj[name] = path.join('.') in repeatedFields ? [value] : value;
                    }
                    else if (Array.isArray(existingValue)) {
                        existingValue.push(value);
                    }
                    else {
                        obj[name] = [existingValue, value];
                    }
                }
                // Run through the file a line at a time.
                return streamParse(input, function (line) {
                    if (!line) {
                        return;
                    }
                    line = line.trim();
                    switch (line[line.length - 1]) {
                        case '{':
                            var name_1 = line.substring(0, line.length - 2).trim();
                            var newValue = {};
                            stack.push(current);
                            path.push(name_1);
                            addAttribute(current, name_1, newValue, path);
                            current = newValue;
                            break;
                        case '}':
                            current = stack.pop();
                            path.pop();
                            break;
                        default:
                            var x = splitNameAndValueInAttribute(line);
                            addAttribute(current, x.name, x.value, path.concat(x.name));
                            break;
                    }
                }).then(function () {
                    return output;
                });
            }
        })(parser = graph.parser || (graph.parser = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // Close module tf.graph.parser.
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
</script>
<script>var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
/**
 * Package for the Render Hierarchy for TensorFlow graph.
 */
var tf;
(function (tf) {
    var graph;
    (function (graph_1) {
        var render;
        (function (render) {
            /**
             * Color parameters for op nodes.
             */
            render.OpNodeColors = { DEFAULT_FILL: 'white', DEFAULT_STROKE: '#b2b2b2' };
            /**
             * Color parameters for node encoding.
             * @type {Object}
             */
            render.MetanodeColors = {
                /**
                 * Default fill and stroke to use when no other information is available.
                 */
                DEFAULT_FILL: '#d9d9d9',
                DEFAULT_STROKE: '#a6a6a6',
                SATURATION: 0.6,
                LIGHTNESS: 0.85,
                /**
                 * Neutral color to use when the node is expanded (used when coloring by
                 * compute time, memory and device).
                 */
                EXPANDED_COLOR: '#f0f0f0',
                /**
                 * Standard hue values for node color palette.
                 */
                HUES: [220, 100, 180, 40, 20, 340, 260, 300, 140, 60],
                STRUCTURE_PALETTE: function (id, lightened) {
                    // The code below is a flexible way to computationally create a set
                    // of colors that go well together.
                    var hues = render.MetanodeColors.HUES;
                    var n = hues.length;
                    var hue = hues[id % n];
                    var m = Math.sin(hue * Math.PI / 360);
                    var sat = lightened ? 30 : 90 - 60 * m;
                    var light = lightened ? 95 : 80;
                    return d3.hsl(hue, .01 * sat, .01 * light).toString();
                },
                DEVICE_PALETTE: function (index) { return render.MetanodeColors.STRUCTURE_PALETTE(index); },
                UNKNOWN: '#eee',
                GRADIENT_OUTLINE: '#888'
            };
            /**
             * Color parameters for op nodes.
             */
            render.SeriesNodeColors = {
                DEFAULT_FILL: 'white',
                DEFAULT_STROKE: '#b2b2b2'
            };
            /**
             * Parameters that affect how the graph is rendered on the screen.
             */
            var PARAMS = {
                /**
                 * Whether to extract high degree nodes from the core part of the graph.
                 */
                enableExtraction: true,
                /**
                 * Maximum in-degree that a node can have without being considered as
                 * high in-degree node.
                 */
                maxInDegree: 4,
                /**
                 * Maximum out-degree that a node can have without being considered as
                 * high out-degree node.
                 */
                maxOutDegree: 4,
                /**
                 * Maximum number of control edges a node can have before they aren't
                 * displayed.
                 */
                maxControlDegree: 4,
                /**
                 * Types patterns for predefined out-extract nodes, which are
                 * sink-like nodes that will be extracted from the main graph.
                 */
                outExtractTypes: [
                    'NoOp' // NoOps are sink-like used for managing control dependencies.
                ],
                /**
                 * Types patterns for predefined in-extract nodes, which are
                 * source-like nodes that will be extracted from the main graph.
                 */
                inExtractTypes: ['Variable'],
                /**
                 * When removing edges from a high degree node, remove all of its edges if
                 * detachAllEdgesForHighDegree is true.  Otherwise remove all in-edges if
                 * the node has high in-degree, or all out-edges if the node has high
                 * out-degree.
                 */
                detachAllEdgesForHighDegree: true,
                /**
                 * After extracting high in/out degree nodes and predefined
                 * source-like/sink-like, extract isolated nodes to the side
                 * if this extractIsolatedNodesWithAnnotationsOnOneSide is true.
                 */
                extractIsolatedNodesWithAnnotationsOnOneSide: true,
                /**
                 * Whether to add bridge nodes and edges to the core when building the
                 * subhierarchy of an expanded metanode. See buildSubhierarchy().
                 */
                enableBridgegraph: true,
                /**
                 * 2 colors, for the minimum and maximum value respectively, whenever we
                 * have a gradient scale.
                 */
                minMaxColors: ['#fff5f0', '#fb6a4a'],
                /**
                 * Maximum number of annotations to be displayed on a node before an
                 * ellipsis is used.
                 */
                maxAnnotations: 5
            };
            /**
             * Stores the rendering information, such as x and y coordinates,
             * for each node in the graph.
             */
            var RenderGraphInfo = (function () {
                function RenderGraphInfo(hierarchy, displayingStats) {
                    this.hierarchy = hierarchy;
                    this.displayingStats = displayingStats;
                    this.index = {};
                    this.computeScales();
                    // Maps node name to whether the rendering hierarchy was already
                    // constructed.
                    this.hasSubhierarchy = {};
                    this.root = new RenderGroupNodeInfo(hierarchy.root);
                    this.index[hierarchy.root.name] = this.root;
                    this.buildSubhierarchy(hierarchy.root.name);
                    this.root.expanded = true;
                }
                RenderGraphInfo.prototype.computeScales = function () {
                    this.deviceColorMap = d3.scale.ordinal()
                        .domain(this.hierarchy.devices)
                        .range(_.map(d3.range(this.hierarchy.devices.length), render.MetanodeColors.DEVICE_PALETTE));
                    var topLevelGraph = this.hierarchy.root.metagraph;
                    // Find the maximum and minimum memory usage.
                    var memoryExtent = d3.extent(topLevelGraph.nodes(), function (nodeName, index) {
                        var node = topLevelGraph.node(nodeName);
                        // Some ops don't have stats at all.
                        if (node.stats != null) {
                            return node.stats.totalBytes;
                        }
                    });
                    this.memoryUsageScale = d3.scale.linear()
                        .domain(memoryExtent)
                        .range(PARAMS.minMaxColors);
                    // Find also the minimum and maximum compute time.
                    var computeTimeExtent = d3.extent(topLevelGraph.nodes(), function (nodeName, index) {
                        var node = topLevelGraph.node(nodeName);
                        // Some ops don't have stats at all.
                        if (node.stats != null) {
                            return node.stats.totalMicros;
                        }
                    });
                    this.computeTimeScale = d3.scale.linear()
                        .domain(computeTimeExtent)
                        .range(PARAMS.minMaxColors);
                    this.edgeWidthScale = this.hierarchy.hasShapeInfo ?
                        graph_1.scene.edge.EDGE_WIDTH_SCALE :
                        d3.scale.linear()
                            .domain([1, this.hierarchy.maxMetaEdgeSize])
                            .range([graph_1.scene.edge.MIN_EDGE_WIDTH, graph_1.scene.edge.MAX_EDGE_WIDTH]);
                };
                /**
                 * Get a previously created RenderNodeInfo by its node name.
                 */
                RenderGraphInfo.prototype.getRenderNodeByName = function (nodeName) {
                    return this.index[nodeName];
                };
                /**
                 * Get the underlying node in the hierarchical graph by its name.
                 */
                RenderGraphInfo.prototype.getNodeByName = function (nodeName) {
                    return this.hierarchy.node(nodeName);
                };
                /**
                 * Get a previously created RenderNodeInfo for the specified node name,
                 * or create one if it hasn't been created yet.
                 */
                RenderGraphInfo.prototype.getOrCreateRenderNodeByName = function (nodeName) {
                    var _this = this;
                    // Polymer may invoke this with null.
                    if (!nodeName) {
                        return null;
                    }
                    if (nodeName in this.index) {
                        return this.index[nodeName];
                    }
                    var node = this.hierarchy.node(nodeName);
                    // Exit early if the node does not exist in the hierarchy. This can happen
                    // when a graph is reloaded while the infocard points to a node not visible
                    // at the top-level.
                    if (!node) {
                        return null;
                    }
                    var renderInfo = node.isGroupNode ?
                        new RenderGroupNodeInfo(node) :
                        new RenderNodeInfo(node);
                    this.index[nodeName] = renderInfo;
                    if (node.stats) {
                        renderInfo.memoryColor = this.memoryUsageScale(node.stats.totalBytes);
                        renderInfo.computeTimeColor =
                            this.computeTimeScale(node.stats.totalMicros);
                    }
                    // We only fade nodes when we're displaying stats.
                    renderInfo.isFadedOut = this.displayingStats &&
                        !tf.graph.util.hasDisplayableNodeStats(node.stats);
                    if (node.isGroupNode) {
                        // Make a list of tuples (device, proportion), where proportion
                        // is the fraction of op nodes that have that device.
                        var pairs = _.pairs(node.deviceHistogram);
                        if (pairs.length > 0) {
                            // Compute the total # of devices.
                            var numDevices_1 = _.sum(pairs, _.last);
                            renderInfo.deviceColors = _.map(pairs, function (pair) { return ({
                                color: _this.deviceColorMap(pair[0]),
                                // Normalize to a proportion of total # of devices.
                                proportion: pair[1] / numDevices_1
                            }); });
                        }
                    }
                    else {
                        var device = renderInfo.node.device;
                        if (device) {
                            renderInfo.deviceColors = [{
                                    color: this.deviceColorMap(device),
                                    proportion: 1.0
                                }];
                        }
                    }
                    return this.index[nodeName];
                };
                /**
                 * Return the nearest ancestor node, including itself, that is visible
                 * in the visualization. This method is used so that we can select
                 * (highlight) a node that isn't drawn yet, by selecting (highlighting)
                 * its nearest ancestor that has been drawn.
                 */
                RenderGraphInfo.prototype.getNearestVisibleAncestor = function (name) {
                    var path = graph_1.getHierarchicalPath(name);
                    for (var i = 0; i < path.length; i++) {
                        var nodeName = path[i];
                        // Op nodes have expanded set to false by default.
                        if (!this.getRenderNodeByName(nodeName).expanded) {
                            return nodeName;
                        }
                    }
                    // Fallthrough. If everything was expanded return the node.
                    return name;
                };
                // TODO(jimbo): Delete this an any code it touches (all deprecated).
                RenderGraphInfo.prototype.setDepth = function (depth) {
                    setGroupNodeDepth(this.root, +depth);
                };
                /**
                 * Returns true if the renderNode is an isolated node within its parent node.
                 */
                RenderGraphInfo.prototype.isNodeAuxiliary = function (renderNode) {
                    var parentNode = this.getRenderNodeByName(renderNode.node.parentNode.name);
                    var found = _.find(parentNode.isolatedInExtract, function (node) {
                        return node.node.name === renderNode.node.name;
                    });
                    if (found) {
                        return true;
                    }
                    found = _.find(parentNode.isolatedOutExtract, function (node) {
                        return node.node.name === renderNode.node.name;
                    });
                    return !!found;
                };
                RenderGraphInfo.prototype.buildSubhierarchy = function (nodeName) {
                    var _this = this;
                    // Terminate if the rendering hierarchy was already constructed
                    // for this node.
                    if (nodeName in this.hasSubhierarchy) {
                        return;
                    }
                    var renderNodeInfo = this.index[nodeName];
                    // If it is not a meta node or a series node, don't do anything.
                    if (renderNodeInfo.node.type !== graph_1.NodeType.META &&
                        renderNodeInfo.node.type !== graph_1.NodeType.SERIES) {
                        return;
                    }
                    // At this point we know the rendering information is about a group node.
                    var renderGroupNodeInfo = renderNodeInfo;
                    var metagraph = renderGroupNodeInfo.node.metagraph;
                    var coreGraph = renderGroupNodeInfo.coreGraph;
                    // Create render nodes to represent each child from the metagraph. Although
                    // these will initially be added to the coreGraph, they may later be
                    // extracted. Also, due to extraction, the coreGraph may contain disjoint
                    // groups between which there is no visible path (other than annotations).
                    _.each(metagraph.nodes(), function (childName) {
                        var childRenderInfo = _this.getOrCreateRenderNodeByName(childName);
                        var childNode = childRenderInfo.node;
                        coreGraph.setNode(childName, childRenderInfo);
                        if (!childNode.isGroupNode) {
                            _.each(childNode.inEmbeddings, function (embedding) {
                                var renderMetaedgeInfo = new RenderMetaedgeInfo(null);
                                addInAnnotation(childRenderInfo, embedding, null, renderMetaedgeInfo, AnnotationType.CONSTANT);
                                _this.index[embedding.name] = new RenderNodeInfo(embedding);
                            });
                            _.each(childNode.outEmbeddings, function (embedding) {
                                var renderMetaedgeInfo = new RenderMetaedgeInfo(null);
                                addOutAnnotation(childRenderInfo, embedding, null, renderMetaedgeInfo, AnnotationType.SUMMARY);
                                _this.index[embedding.name] = new RenderNodeInfo(embedding);
                            });
                        }
                    });
                    // Add render metaedge info for edges in the metagraph.
                    _.each(metagraph.edges(), function (edgeObj) {
                        var metaedge = metagraph.edge(edgeObj);
                        var renderMetaedgeInfo = new RenderMetaedgeInfo(metaedge);
                        renderMetaedgeInfo.isFadedOut =
                            _this.index[edgeObj.v].isFadedOut || _this.index[edgeObj.w].isFadedOut;
                        coreGraph.setEdge(edgeObj.v, edgeObj.w, renderMetaedgeInfo);
                    });
                    if (PARAMS.enableExtraction &&
                        renderGroupNodeInfo.node.type === graph_1.NodeType.META) {
                        extractHighDegrees(renderGroupNodeInfo);
                    }
                    // Record that we constructed the rendering hierarchy for this node, so we
                    // don't construct it another time.
                    this.hasSubhierarchy[nodeName] = true;
                    // Look up the parent node's render information and short circuit if none.
                    var parentNode = renderGroupNodeInfo.node.parentNode;
                    if (!parentNode) {
                        return;
                    }
                    var parentNodeInfo = this.index[parentNode.name];
                    // Utility function for computing the name of a bridge node.
                    var getBridgeNodeName = function (inbound) {
                        var rest = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            rest[_i - 1] = arguments[_i];
                        }
                        return rest.concat([inbound ? 'IN' : 'OUT']).join('~~');
                    };
                    // Build out the bridgegraph.
                    var bridgegraph = this.hierarchy.getBridgegraph(nodeName);
                    // Look for popular nodes so we can make annotations instead of paths.
                    var otherCounts = {
                        // Counts of edges coming INTO other nodes by name (outgoing from self).
                        in: {},
                        // Counts of edges going OUT from other nodes by name (coming into self).
                        out: {},
                        // Counts of all control edges involving other nodes by name.
                        control: {},
                    };
                    _.each(bridgegraph.edges(), function (e) {
                        // An edge is inbound if its destination node is in the metagraph.
                        var inbound = !!metagraph.node(e.w);
                        var otherName = inbound ? e.v : e.w;
                        var metaedge = bridgegraph.edge(e);
                        if (!metaedge.numRegularEdges) {
                            otherCounts.control[otherName] =
                                (otherCounts.control[otherName] || 0) + 1;
                        }
                        else if (inbound) {
                            otherCounts.out[otherName] = (otherCounts.out[otherName] || 0) + 1;
                        }
                        else {
                            otherCounts.in[otherName] = (otherCounts.in[otherName] || 0) + 1;
                        }
                    });
                    // Add annotations and edges for bridgegraph relationships.
                    var hierarchyNodeMap = this.hierarchy.getNodeMap();
                    _.each(bridgegraph.edges(), function (bridgeEdgeObj) {
                        var bridgeMetaedge = bridgegraph.edge(bridgeEdgeObj);
                        // Determine whether this bridge edge is incoming by checking the
                        // metagraph for a node that matches the destination end.
                        var inbound = !!metagraph.node(bridgeEdgeObj.w);
                        // Based on the direction of the edge, one endpoint will be an immediate
                        // child of this renderNodeInfo, and the other endpoint will be a sibling
                        // of the parent (or an ancestor further up).
                        var _a = inbound ?
                            [bridgeEdgeObj.w, bridgeEdgeObj.v] :
                            [bridgeEdgeObj.v, bridgeEdgeObj.w], childName = _a[0], otherName = _a[1];
                        var childRenderInfo = _this.index[childName];
                        var otherRenderInfo = _this.index[otherName];
                        var otherNode = otherRenderInfo ?
                            otherRenderInfo.node :
                            hierarchyNodeMap[otherName];
                        // Determine whether this edge is a control edge between nodes where
                        // either node is high-degree with respect to control edges. This will
                        // be a signal to show it as an annotation instead of a bridge edge.
                        var isHighDegreeControlEdge = !bridgeMetaedge.numRegularEdges &&
                            otherCounts.control[otherName] > PARAMS.maxControlDegree;
                        var _b = inbound ?
                            [renderNodeInfo.inAnnotations, childRenderInfo.inAnnotations] :
                            [renderNodeInfo.outAnnotations, childRenderInfo.outAnnotations], childAnnotations = _b[1];
                        var isOtherHighDegree = inbound ?
                            otherCounts.out[otherName] > PARAMS.maxOutDegree :
                            otherCounts.in[otherName] > PARAMS.maxInDegree;
                        // The adjoining render metaedge info from the parent's coreGraph, if any.
                        // It will either be a Metaedge involving this node directly, if it
                        // previously came from a metagraph, or it'll be a Metaedge involving
                        // a previously created bridge node standing in for the other node.
                        var adjoiningMetaedge = null;
                        // We can only hope to render a bridge path if:
                        //  - bridgegraph paths are enabled,
                        //  - the other node is not too high-degree,
                        //  - the child is in the core (not extracted for being high-degree), and
                        //  - there's a path (in the traversal sense) between child and other.
                        var canDrawBridgePath = false;
                        if (PARAMS.enableBridgegraph &&
                            !isOtherHighDegree &&
                            !isHighDegreeControlEdge &&
                            childRenderInfo.isInCore()) {
                            // Utility function for finding an adjoining metaedge.
                            var findAdjoiningMetaedge = function (targetName) {
                                var adjoiningEdgeObj = inbound ?
                                    { v: targetName, w: nodeName } :
                                    { v: nodeName, w: targetName };
                                return parentNodeInfo.coreGraph.edge(adjoiningEdgeObj);
                            };
                            adjoiningMetaedge = findAdjoiningMetaedge(otherName);
                            if (!adjoiningMetaedge) {
                                adjoiningMetaedge = findAdjoiningMetaedge(getBridgeNodeName(inbound, otherName, parentNode.name));
                            }
                            canDrawBridgePath = !!adjoiningMetaedge;
                        }
                        // Although dataflow edges are acyclic, control dependency edges may
                        // actually point 'backwards' in the graph. If this bridgeMetaedge is
                        // a control dependency, we need to determine whether it's backwards
                        // pointing so that we render it appropriately.
                        //
                        // For instance, say we're rendering a graph with nodes named A/B and Z/Y,
                        // and we're currently rendering the bridgegraph for A. Further, let's say
                        // that there was an original BaseEdge from A/B->Z/Y and a CONTROL EDGE
                        // from Z/Y=>A/B.
                        //
                        //     +----------------+
                        //     | A              |
                        //     |  +-----+       |         +------+
                        //     |  | B   |>-----\x3e|>-------\x3e| Z    |
                        //     |  |     |       |         |      |
                        //     |  |     |   *   |         |      |
                        //     |  |     |<=====<|<=======<|      |
                        //     |  +-----+       |         +------+
                        //     +----------------+
                        //
                        // When we render the subhierarchy for Metanode A, we'll come across a
                        // control-only Metaedge in the bridgegraph from Z=>A/B (*). The question
                        // is whether this edge is backwards.
                        //
                        // To answer that question, we follow the chain of adjoining metaedges
                        // until we reach the topmost one. In this case, that's the control-only
                        // Metaedge Z=>A in the ROOT's metagraph. We determine that this edge
                        // is backwards by looking at the topological ordering of ROOT's metagraph
                        // (which ignores control edges) and seeing that Z comes AFTER A.
                        //
                        // The property of being backwards is independent of whether the edge
                        // is inbound or outbound. In the preceding example, if we were building
                        // the subhierarchy for Z, we'd find bridge edge Z/Y=>A, walk to its
                        // topmost adjoining metaedge Z=>A and discover that it's backwards.
                        var backwards = false;
                        if (adjoiningMetaedge && !bridgeMetaedge.numRegularEdges) {
                            // Find the top-most adjoining render metaedge information, and the
                            // GroupNode whose metagraph must contain the associated metaedge.
                            var topAdjoiningMetaedge = adjoiningMetaedge;
                            var topGroupNode = parentNodeInfo.node;
                            while (topAdjoiningMetaedge.adjoiningMetaedge) {
                                topAdjoiningMetaedge = topAdjoiningMetaedge.adjoiningMetaedge;
                                topGroupNode = topGroupNode.parentNode;
                            }
                            // Check against the topological ordering for the top node. The current
                            // bridge metaedge we're evaluating is backwards if its source comes
                            // after its destination.
                            var ordering = _this.hierarchy.getTopologicalOrdering(topGroupNode.name);
                            var e = topAdjoiningMetaedge.metaedge;
                            backwards = ordering[e.v] > ordering[e.w];
                        }
                        // Render backwards control edges as annotations.
                        canDrawBridgePath = canDrawBridgePath && !backwards;
                        // If we can't make a bridge path for any reason, then we add an
                        // annotation instead.
                        if (!canDrawBridgePath) {
                            childAnnotations.push(new Annotation(otherNode, otherRenderInfo, new RenderMetaedgeInfo(bridgeMetaedge), AnnotationType.SHORTCUT, inbound));
                            return;
                        }
                        // At this point, all conditions have been met for drawing a bridge path.
                        // Find or create the IN/OUT node representing otherNode.
                        var bridgeContainerName = getBridgeNodeName(inbound, nodeName);
                        var bridgeNodeName = getBridgeNodeName(inbound, otherName, nodeName);
                        var bridgeNodeRenderInfo = coreGraph.node(bridgeNodeName);
                        if (!bridgeNodeRenderInfo) {
                            // Find or create the directional container for the bridge node.
                            var bridgeContainerInfo = coreGraph.node(bridgeContainerName);
                            if (!bridgeContainerInfo) {
                                var bridgeContainerNode = {
                                    // Important node properties.
                                    name: bridgeContainerName,
                                    type: graph_1.NodeType.BRIDGE,
                                    // Unused node properties.
                                    isGroupNode: false,
                                    cardinality: 0,
                                    parentNode: null,
                                    stats: null,
                                    include: graph_1.InclusionType.UNSPECIFIED,
                                    // BridgeNode properties.
                                    inbound: inbound,
                                };
                                bridgeContainerInfo =
                                    new RenderNodeInfo(bridgeContainerNode);
                                _this.index[bridgeContainerName] = bridgeContainerInfo;
                                coreGraph.setNode(bridgeContainerName, bridgeContainerInfo);
                            }
                            var bridgeNode = {
                                // Important node properties.
                                name: bridgeNodeName,
                                type: graph_1.NodeType.BRIDGE,
                                // Unimportant node properties.
                                isGroupNode: false,
                                cardinality: 1,
                                parentNode: null,
                                stats: null,
                                include: graph_1.InclusionType.UNSPECIFIED,
                                // BridgeNode properties.
                                inbound: inbound,
                            };
                            bridgeNodeRenderInfo = new RenderNodeInfo(bridgeNode);
                            _this.index[bridgeNodeName] = bridgeNodeRenderInfo;
                            coreGraph.setNode(bridgeNodeName, bridgeNodeRenderInfo);
                            // Set bridgeNode to be a graphlib child of the container node.
                            coreGraph.setParent(bridgeNodeName, bridgeContainerName);
                            bridgeContainerInfo.node.cardinality++;
                        }
                        // Create and add a bridge render metaedge.
                        var bridgeRenderMetaedge = new RenderMetaedgeInfo(bridgeMetaedge);
                        bridgeRenderMetaedge.adjoiningMetaedge = adjoiningMetaedge;
                        inbound ?
                            coreGraph.setEdge(bridgeNodeName, childName, bridgeRenderMetaedge) :
                            coreGraph.setEdge(childName, bridgeNodeName, bridgeRenderMetaedge);
                    }); // End _.each(bridgegraph.edges).
                    // For each bridge container (IN and/or OUT), add structural edges between
                    // terminal nodes and that container. A terminal node is one which has no
                    // non-bridge edges in the direction of the container.
                    //
                    // For example, consider a Metanode A which contains two child nodes A/B
                    // and A/C. Let's say it has one edge in the metagraph from A/B->A/C, and
                    // one edge in the bridgegraph from Z->A/C.
                    //
                    // At this point, we've added a container bridge node IN to house all
                    // incoming bridge nodes. We've also added a bridge node Z' (with parent IN)
                    // to A, and a bridge edge from Z'->C.
                    //
                    //     +----------------------+
                    //     | A          +---+     |
                    //     |    +------\x3e| C |     |
                    //     |    |       +---+     |
                    //     |    |         ^       |
                    //     |    |         |       |
                    //     |    |    +----|----+  |
                    //     |    |    | IN |    |  |
                    //     |  +---+  |  +---+  |  |
                    //     |  | B |  |  | Z'|  |  |
                    //     |  +---+  |  +---+  |  |
                    //     |         +---------+  |
                    //     +----------------------+
                    //
                    // With no other help, dagre would lay out B and Z' on the same level,
                    // because both of them have no incoming edges. In other words, B is a
                    // terminal node in the INCOMING direction.
                    //
                    // But we want to force dagre to lay out Z' (and everything in IN) lower
                    // than all non-bridge nodes, so that there's enough room for the bridge
                    // edges after they've been adjusted to meet up with paths coming in from
                    // outside.
                    //
                    // To force Z' (and all other bridge nodes) to be lowest in the graph, we
                    // identify terminal nodes like B and give them structural edges to
                    // a new structural bridge node S which we add to IN.
                    //
                    //     +----------------------+
                    //     | A          +---+     |
                    //     |       +---\x3e| C |     |
                    //     |       |    +---+     |
                    //     |     +---+    ^       |
                    //     |     | B |    |       |
                    //     |     +---+    |       |
                    //     |       ^      |       |
                    //     |       |      |       |
                    //     |  +----|------|----+  |
                    //     |  |IN  |      |    |  |
                    //     |  |  +---+  +---+  |  |
                    //     |  |  | S |  | Z'|  |  |
                    //     |  |  +---+  +---+  |  |
                    //     |  +----------------+  |
                    //     +----------------------+
                    //
                    // This ensures that dagre will lay out the bridge containers strictly at
                    // the ends of the graph. The structural edges will never be seen in the
                    // visualization except as a debugging aid.
                    _.each([true, false], function (inbound) {
                        var bridgeContainerName = getBridgeNodeName(inbound, nodeName);
                        var bridgeContainerInfo = coreGraph.node(bridgeContainerName);
                        if (!bridgeContainerInfo) {
                            return;
                        }
                        _.each(coreGraph.nodes(), function (childName) {
                            // Short-circuit if this child is a bridge node or it's not a terminal
                            // node in the direction we're interested in.
                            var childNodeInfo = coreGraph.node(childName);
                            if (childNodeInfo.node.type === graph_1.NodeType.BRIDGE) {
                                return;
                            }
                            var isTerminal = inbound ?
                                !coreGraph.predecessors(childName).length :
                                !coreGraph.successors(childName).length;
                            if (!isTerminal) {
                                return;
                            }
                            // Find or create a bridge node in the container for all structural
                            // metaedges. It would have been nice to skip this step and simply
                            // set a metaedge between the terminal node and the container node, but
                            // in that case, something about the graph upsets dagre.layout()'s
                            // longestPath algorithm (was getting errors due to an undefined).
                            var structuralNodeName = getBridgeNodeName(inbound, nodeName, 'STRUCTURAL_TARGET');
                            var structuralRenderInfo = coreGraph.node(structuralNodeName);
                            if (!structuralRenderInfo) {
                                var bridgeNode = {
                                    // Important Node properties.
                                    name: structuralNodeName,
                                    type: graph_1.NodeType.BRIDGE,
                                    // Unimportant Node properties.
                                    isGroupNode: false,
                                    cardinality: 1,
                                    parentNode: null,
                                    stats: null,
                                    include: graph_1.InclusionType.UNSPECIFIED,
                                    // BridgeNode properties.
                                    inbound: inbound,
                                };
                                structuralRenderInfo = new RenderNodeInfo(bridgeNode);
                                structuralRenderInfo.structural = true;
                                _this.index[structuralNodeName] = structuralRenderInfo;
                                coreGraph.setNode(structuralNodeName, structuralRenderInfo);
                                bridgeContainerInfo.node.cardinality++;
                                coreGraph.setParent(structuralNodeName, bridgeContainerName);
                            }
                            // Create the structural Metaedge and insert it.
                            var structuralMetaedgeInfo = new RenderMetaedgeInfo(null);
                            structuralMetaedgeInfo.structural = true;
                            structuralMetaedgeInfo.weight--; // Reduce weight for dagre layout.
                            inbound ?
                                coreGraph.setEdge(structuralNodeName, childName, structuralMetaedgeInfo) :
                                coreGraph.setEdge(childName, structuralNodeName, structuralMetaedgeInfo);
                        });
                    });
                };
                return RenderGraphInfo;
            }());
            render.RenderGraphInfo = RenderGraphInfo;
            /**
             * A class for rendering annotation object which contains label
             * about the node embedded as annotation, type of annotation and the location
             * of both the annotation's node and edge.
             *
             * Annotation objects include embedded constants, embedded summary, and
             * edge shortcuts.
             */
            var Annotation = (function () {
                /**
                 * Creates a new Annotation.
                 *
                 * @param node The underlying node this annotation points to.
                 * @param renderNodeInfo The render information for the underlying node
                 *     this annotation points to. This can be null if the annotation
                 *     denotes an embedding (constant, summary), in which case we
                 *     use the node property.
                 * @param renderMetaedgeInfo The render information for the edge associated
                 *     with the annotation.
                 * @param type The type of the annotation.
                 * @param isIn True if it is an in-annotation. False if it is an
                 *     out-annotation.
                 */
                function Annotation(node, renderNodeInfo, renderMetaedgeInfo, type, isIn) {
                    this.node = node;
                    this.renderNodeInfo = renderNodeInfo;
                    this.renderMetaedgeInfo = renderMetaedgeInfo;
                    this.annotationType = type;
                    // Properties specified by layout
                    this.dx = 0;
                    this.dy = 0;
                    this.width = 0;
                    this.height = 0;
                    this.isIn = isIn;
                    this.points = [];
                }
                return Annotation;
            }());
            render.Annotation = Annotation;
            ;
            (function (AnnotationType) {
                AnnotationType[AnnotationType["SHORTCUT"] = 0] = "SHORTCUT";
                AnnotationType[AnnotationType["CONSTANT"] = 1] = "CONSTANT";
                AnnotationType[AnnotationType["SUMMARY"] = 2] = "SUMMARY";
                AnnotationType[AnnotationType["ELLIPSIS"] = 3] = "ELLIPSIS";
            })(render.AnnotationType || (render.AnnotationType = {}));
            var AnnotationType = render.AnnotationType;
            ;
            /**
             * Manages a list of annotations. Two will be used for each
             * RenderNodeInfo, one for in annotations and one for out annotations.
             */
            var AnnotationList = (function () {
                function AnnotationList() {
                    this.list = [];
                    this.nodeNames = {};
                }
                /**
                 * Append an annotation to the list, or a stand-in ellipsis annotation instead
                 * if this would make it too many.
                 */
                AnnotationList.prototype.push = function (annotation) {
                    if (annotation.node.name in this.nodeNames) {
                        return; // Skip duplicate annotation.
                    }
                    this.nodeNames[annotation.node.name] = true;
                    if (this.list.length < PARAMS.maxAnnotations) {
                        this.list.push(annotation);
                        return;
                    }
                    var lastAnnotation = this.list[this.list.length - 1];
                    if (lastAnnotation.annotationType === AnnotationType.ELLIPSIS) {
                        var ellipsisNode_1 = lastAnnotation.node;
                        ellipsisNode_1.setNumMoreNodes(++ellipsisNode_1.numMoreNodes);
                        return;
                    }
                    var ellipsisNode = new tf.graph.EllipsisNodeImpl(1);
                    this.list.push(new Annotation(ellipsisNode, new RenderNodeInfo(ellipsisNode), null, AnnotationType.ELLIPSIS, annotation.isIn));
                };
                return AnnotationList;
            }());
            render.AnnotationList = AnnotationList;
            /**
             * Contains rendering information about a node in the hierarchical graph.
             */
            var RenderNodeInfo = (function () {
                function RenderNodeInfo(node) {
                    this.node = node;
                    this.expanded = false;
                    this.inAnnotations = new AnnotationList();
                    this.outAnnotations = new AnnotationList();
                    // Params specified by layout
                    this.x = 0;
                    this.y = 0;
                    this.width = 0;
                    this.height = 0;
                    this.inboxWidth = 0;
                    this.outboxWidth = 0;
                    this.excluded = false;
                    // Params for bridge paths.
                    this.structural = false;
                    // Params for node box.
                    this.labelOffset = 0;
                    this.radius = 0;
                    // Params for expanded node
                    this.labelHeight = 0;
                    this.paddingTop = 0;
                    this.paddingLeft = 0;
                    this.paddingRight = 0;
                    this.paddingBottom = 0;
                    this.isInExtract = false;
                    this.isOutExtract = false;
                    this.coreBox = { width: 0, height: 0 };
                    // By default, we don't fade nodes out. Default to false for safety.
                    this.isFadedOut = false;
                }
                RenderNodeInfo.prototype.isInCore = function () {
                    return !this.isInExtract && !this.isOutExtract;
                };
                return RenderNodeInfo;
            }());
            render.RenderNodeInfo = RenderNodeInfo;
            /**
             * Contains rendering information about a Metaedge from the underlying
             * hierarchical graph. It may be from either a metagraph or a bridgegraph.
             */
            var RenderMetaedgeInfo = (function () {
                function RenderMetaedgeInfo(metaedge) {
                    this.metaedge = metaedge;
                    this.adjoiningMetaedge = null;
                    this.structural = false;
                    this.weight = 1;
                    this.isFadedOut = false;
                }
                return RenderMetaedgeInfo;
            }());
            render.RenderMetaedgeInfo = RenderMetaedgeInfo;
            function addInAnnotation(node, predecessor, predecessorRenderInfo, edge, type) {
                var annotation = new Annotation(predecessor, predecessorRenderInfo, edge, type, true);
                node.inAnnotations.push(annotation);
            }
            function addOutAnnotation(node, successor, successorRenderInfo, edge, type) {
                var annotation = new Annotation(successor, successorRenderInfo, edge, type, false);
                node.outAnnotations.push(annotation);
            }
            function setGraphDepth(graph, depth) {
                _.each(graph.nodes(), function (nodeName) {
                    var child = graph.node(nodeName);
                    child.expanded = depth > 1; // set all child of depth 1 to collapsed
                    if (depth > 0) {
                        switch (child.node.type) {
                            case graph_1.NodeType.META:
                            case graph_1.NodeType.SERIES:
                                setGroupNodeDepth(child, depth - 1);
                                break;
                        }
                    }
                });
            }
            ;
            var RenderGroupNodeInfo = (function (_super) {
                __extends(RenderGroupNodeInfo, _super);
                function RenderGroupNodeInfo(groupNode) {
                    _super.call(this, groupNode);
                    var metagraph = groupNode.metagraph;
                    var gl = metagraph.graph();
                    this.coreGraph =
                        graph_1.createGraph(gl.name, graph_1.GraphType.CORE, { compound: true });
                    this.inExtractBox = { width: 0, height: 0 };
                    this.outExtractBox = { width: 0, height: 0 };
                    this.isolatedInExtract = [];
                    this.isolatedOutExtract = [];
                }
                return RenderGroupNodeInfo;
            }(RenderNodeInfo));
            render.RenderGroupNodeInfo = RenderGroupNodeInfo;
            function setGroupNodeDepth(renderInfo, depth) {
                if (renderInfo.coreGraph) {
                    setGraphDepth(renderInfo.coreGraph, depth);
                }
            }
            /**
             * Remove an edge from the graph and add annotations to both ends of the edge.
             *
             * @param The core graph.
             * @param v Source name.
             * @param w Sink name.
             */
            function createShortcut(graph, v, w) {
                var src = graph.node(v);
                var sink = graph.node(w);
                var edge = graph.edge(v, w);
                // If either of the nodes is explicitly included in the main graph and
                // both nodes are in the main graph then do not create the shortcut
                // and instead keep the real edge.
                if ((src.node.include === graph_1.InclusionType.INCLUDE ||
                    sink.node.include === graph_1.InclusionType.INCLUDE) &&
                    src.node.include !== graph_1.InclusionType.EXCLUDE &&
                    sink.node.include !== graph_1.InclusionType.EXCLUDE) {
                    return;
                }
                // Add each annotation.
                addOutAnnotation(src, sink.node, sink, edge, AnnotationType.SHORTCUT);
                addInAnnotation(sink, src.node, src, edge, AnnotationType.SHORTCUT);
                // Remove the edge from the core graph.
                graph.removeEdge(v, w);
            }
            /**
             * Remove edges from a node, and set its isOutExtract property to true,
             * and remove the node and move it to isolatedOutExtract.
             *
             * If detachAllEdgesForHighDegree or forceDetach is true, extract all of its
             * edges. Otherwise, only extract all in-edges.
             */
            function makeOutExtract(renderNode, n, forceDetach) {
                var graph = renderNode.coreGraph;
                var child = graph.node(n);
                child.isOutExtract = true;
                _.each(graph.predecessors(n), function (p, index) {
                    createShortcut(graph, p, n);
                });
                if (PARAMS.detachAllEdgesForHighDegree || forceDetach) {
                    _.each(graph.successors(n), function (s, index) {
                        createShortcut(graph, n, s);
                    });
                }
                // Remove the node from the core graph if it no longer has neighbors.
                if (graph.neighbors(n).length === 0) {
                    child.node.include = graph_1.InclusionType.EXCLUDE;
                    renderNode.isolatedOutExtract.push(child);
                    graph.removeNode(n);
                }
            }
            /**
             * Remove edges from a node, set its isInExtract property to true,
             * and remove the node and move it to isolatedInExtract.
             *
             * If detachAllEdgesForHighDegree or forceDetach is true, extract all of its
             * edges. Otherwise, only remove all out-edges.
             */
            function makeInExtract(renderNode, n, forceDetach) {
                var graph = renderNode.coreGraph;
                var child = graph.node(n);
                child.isInExtract = true;
                _.each(graph.successors(n), function (s, index) {
                    createShortcut(graph, n, s);
                });
                if (PARAMS.detachAllEdgesForHighDegree || forceDetach) {
                    _.each(graph.predecessors(n), function (p, index) {
                        createShortcut(graph, p, n);
                    });
                }
                // Remove the node from the core graph if it no longer has neighbors.
                if (graph.neighbors(n).length === 0) {
                    child.node.include = graph_1.InclusionType.EXCLUDE;
                    renderNode.isolatedInExtract.push(child);
                    graph.removeNode(n);
                }
            }
            render.makeInExtract = makeInExtract;
            /**
             * Check whether the node's type is a member of the given list of types.
             *
             * @param node Node.
             * @param types List of type to match.
             */
            function hasTypeIn(node, types) {
                if (node.type === graph_1.NodeType.OP) {
                    for (var i = 0; i < types.length; i++) {
                        if (node.op === types[i]) {
                            return true;
                        }
                    }
                }
                else if (node.type === graph_1.NodeType.META) {
                    var rootOpNode = node.getRootOp();
                    if (rootOpNode) {
                        for (var i = 0; i < types.length; i++) {
                            if (rootOpNode.op === types[i]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            /** Move nodes that are specified to be excluded out of the core graph. */
            function extractSpecifiedNodes(renderNode) {
                var graph = renderNode.coreGraph;
                _.each(graph.nodes(), function (n) {
                    var renderInfo = graph.node(n);
                    if (renderInfo.node.include === graph_1.InclusionType.EXCLUDE) {
                        if (renderNode.coreGraph.outEdges(n).length >
                            renderNode.coreGraph.inEdges(n).length) {
                            makeOutExtract(renderNode, n, true);
                        }
                        else {
                            makeInExtract(renderNode, n, true);
                        }
                    }
                });
            }
            /** Remove edges from pre-defined out-extract patterns */
            function extractPredefinedSink(renderNode) {
                var graph = renderNode.coreGraph;
                _.each(graph.nodes(), function (n) {
                    var renderInfo = graph.node(n);
                    if (renderInfo.node.include !== graph_1.InclusionType.UNSPECIFIED) {
                        return;
                    }
                    if (hasTypeIn(renderInfo.node, PARAMS.outExtractTypes)) {
                        makeOutExtract(renderNode, n);
                    }
                });
            }
            /** Remove edges from pre-defined in-extract patterns */
            function extractPredefinedSource(renderNode) {
                var graph = renderNode.coreGraph;
                _.each(graph.nodes(), function (n) {
                    var renderInfo = graph.node(n);
                    if (renderInfo.node.include !== graph_1.InclusionType.UNSPECIFIED) {
                        return;
                    }
                    if (hasTypeIn(renderInfo.node, PARAMS.inExtractTypes)) {
                        makeInExtract(renderNode, n);
                    }
                });
            }
            /** Extract from nodes with in-degree > maxInDegree */
            function extractHighInDegree(renderNode) {
                var graph = renderNode.coreGraph;
                var maxInDegree = PARAMS.maxInDegree;
                // detect first so degrees don't get affected by other removal
                var highInDegreeNames = _.filter(graph.nodes(), function (n) {
                    if (graph.node(n).node.include !== graph_1.InclusionType.UNSPECIFIED) {
                        return false;
                    }
                    // Count the in-degree based on only regular edges, unless there are
                    // no regular edges, in which case use the number of control edges.
                    // This is done so that control edges don't effect if nodes are extracted
                    // from the core graph, unless the node is only used for control.
                    var numEdgesToCount = _.reduce(graph.predecessors(n), function (numEdgesToCount, pred) {
                        var metaedge = graph.edge(pred, n).metaedge;
                        return numEdgesToCount + (metaedge.numRegularEdges ? 1 : 0);
                    }, 0);
                    if (numEdgesToCount === 0 && graph.predecessors(n).length > 0) {
                        numEdgesToCount = graph.predecessors(n).length;
                    }
                    return numEdgesToCount > maxInDegree;
                });
                _.each(highInDegreeNames, function (n) {
                    makeOutExtract(renderNode, n);
                });
            }
            /** Extract nodes with out-degree > maxOutDegree */
            function extractHighOutDegree(renderNode) {
                var graph = renderNode.coreGraph;
                var maxOutDegree = PARAMS.maxOutDegree;
                // detect first so degrees don't get affected by other removal
                var highOutDegreeNames = _.filter(graph.nodes(), function (n) {
                    if (graph.node(n).node.include !== graph_1.InclusionType.UNSPECIFIED) {
                        return false;
                    }
                    // Count the out-degree based on only regular edges, unless there are
                    // no regular edges, in which case use the number of control edges.
                    // This is done so that control edges don't effect if nodes are extracted
                    // from the core graph, unless the node is only used for control.
                    var numEdgesToCount = _.reduce(graph.successors(n), function (numEdgesToCount, succ) {
                        var metaedge = graph.edge(n, succ).metaedge;
                        return numEdgesToCount + (metaedge.numRegularEdges ? 1 : 0);
                    }, 0);
                    if (numEdgesToCount === 0 && graph.successors(n).length > 0) {
                        numEdgesToCount = graph.successors(n).length;
                    }
                    return numEdgesToCount > maxOutDegree;
                });
                _.each(highOutDegreeNames, function (n) {
                    makeInExtract(renderNode, n);
                });
            }
            /** Remove control edges from nodes that have too many control edges */
            function removeControlEdges(renderNode) {
                var graph = renderNode.coreGraph;
                // Collect control edges into a map by node name.
                var map = {};
                _.each(graph.edges(), function (e) {
                    if (!graph.edge(e).metaedge.numRegularEdges) {
                        (map[e.v] = map[e.v] || []).push(e);
                        (map[e.w] = map[e.w] || []).push(e);
                    }
                });
                // For each node with too many control edges, turn them into annotations.
                _.each(map, function (edges, nodeName) {
                    if (edges.length > PARAMS.maxControlDegree) {
                        _.each(edges, function (e) { return createShortcut(graph, e.v, e.w); });
                    }
                });
            }
            /**
             * Given an integer, picks a hue that is far apart from other colors.
             * The formula for picking color that avoid collision is:
             *     hue = (color range * golden ratio * index) % color range
             */
            function mapIndexToHue(id) {
                var GOLDEN_RATIO = 1.61803398875;
                // Hue of 0 is reserved for the gray nodes.
                var MIN_HUE = 1;
                var MAX_HUE = 359;
                var COLOR_RANGE = MAX_HUE - MIN_HUE;
                return MIN_HUE + ((COLOR_RANGE * GOLDEN_RATIO * id) % COLOR_RANGE);
            }
            render.mapIndexToHue = mapIndexToHue;
            ;
            /**
             * Remove edges and add to annotation instead.
             *
             * For root node, consider predefined types for source and sink.
             * We do not extract predefined type from non-root so that Variables and the
             * sgd node (op type = 'NoOp') do not get extract from inside own group.
             *
             * The order of extraction is important here as swapping the order can totally
             * screw up the graph layout.
             *
             * @param {Render.Node} renderNode Node to manipulate.
             */
            function extractHighDegrees(renderNode) {
                extractSpecifiedNodes(renderNode);
                if (PARAMS.outExtractTypes) {
                    extractPredefinedSink(renderNode);
                }
                // This has to come before extract high in-degree to protect the core part
                // that takes many variables.
                if (PARAMS.inExtractTypes) {
                    extractPredefinedSource(renderNode);
                }
                // This has to come before extract high out-degree to protect the core part
                // that output to many places as there are more high-degree sinks than
                // sources.
                if (PARAMS.maxInDegree) {
                    extractHighInDegree(renderNode);
                }
                if (PARAMS.maxOutDegree) {
                    extractHighOutDegree(renderNode);
                }
                if (PARAMS.maxControlDegree) {
                    removeControlEdges(renderNode);
                }
                // Extract isolated nodes, which can be
                // (1) source-like and sink-like nodes that are not originally isolated but
                //     become isolated after further removal.
                // (2) isolated nodes with annotations on one-side.  These might be either
                //     - nodes that originally have high out-degree but because we remove
                //       high in-degree nodes first, they no longer have high in-degree when
                //       we check.  (Detecting all high-degree before removing also leads to
                //       another problem.)
                //     - nodes that do not have high degree, but their neighbors are all
                //       extracted, so it might make sense to extract them too.
                var graph = renderNode.coreGraph;
                _.each(graph.nodes(), function (n) {
                    var child = graph.node(n);
                    var degree = graph.neighbors(n).length;
                    if (child.node.include !== graph_1.InclusionType.UNSPECIFIED) {
                        return;
                    }
                    if (degree === 0) {
                        var hasOutAnnotations = child.outAnnotations.list.length > 0;
                        var hasInAnnotations = child.inAnnotations.list.length > 0;
                        if (child.isInExtract) {
                            // This case only happens if detachAllEdgesForHighDegree is false.
                            // (Otherwise all source-like nodes are all isolated already.)
                            renderNode.isolatedInExtract.push(child);
                            child.node.include = graph_1.InclusionType.EXCLUDE;
                            graph.removeNode(n);
                        }
                        else if (child.isOutExtract) {
                            // This case only happens if detachAllEdgesForHighDegree is false.
                            // // (Otherwise all sink-like nodes are all isolated already.)
                            renderNode.isolatedOutExtract.push(child);
                            child.node.include = graph_1.InclusionType.EXCLUDE;
                            graph.removeNode(n);
                        }
                        else if (PARAMS.extractIsolatedNodesWithAnnotationsOnOneSide) {
                            if (hasOutAnnotations && !hasInAnnotations) {
                                child.isInExtract = true; // for ones with high out-annotations
                                renderNode.isolatedInExtract.push(child);
                                child.node.include = graph_1.InclusionType.EXCLUDE;
                                graph.removeNode(n);
                            }
                            else if (hasInAnnotations && !hasOutAnnotations) {
                                child.isOutExtract = true; // for ones with high in-annotations
                                renderNode.isolatedOutExtract.push(child);
                                child.node.include = graph_1.InclusionType.EXCLUDE;
                                graph.removeNode(n);
                            }
                            else {
                            }
                        }
                    }
                });
            }
        })(render = graph_1.render || (graph_1.render = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module tf.graph.render
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph) {
        var scene;
        (function (scene) {
            var annotation;
            (function (annotation_1) {
                /**
                 * Populate a given annotation container group
                 *
                 *     <g class='{in|out}-annotations'></g>
                 *
                 * with annotation group of the following structure:
                 *
                 * <g class='annotation'>
                 *   <g class='annotation-node'>
                 *   \x3c!--
                 *   Content here determined by Scene.node.buildGroup.
                 *   --\x3e
                 *   </g>
                 * </g>
                 *
                 * @param container selection of the container.
                 * @param annotationData node.{in|out}Annotations
                 * @param d node to build group for.
                 * @param sceneElement <tf-graph-scene> polymer element.
                 * @return selection of appended objects
                 */
                function buildGroup(container, annotationData, d, sceneElement) {
                    // Select all children and join with data.
                    var annotationGroups = container
                        .selectAll(function () {
                        // using d3's selector function
                        // See https://github.com/mbostock/d3/releases/tag/v2.0.0
                        // (It's not listed in the d3 wiki.)
                        return this.childNodes;
                    })
                        .data(annotationData.list, function (d) { return d.node.name; });
                    annotationGroups.enter()
                        .append('g')
                        .attr('data-name', function (a) { return a.node.name; })
                        .each(function (a) {
                        var aGroup = d3.select(this);
                        // Add annotation to the index in the scene
                        sceneElement.addAnnotationGroup(a, d, aGroup);
                        // Append annotation edge
                        var edgeType = scene.Class.Annotation.EDGE;
                        var metaedge = a.renderMetaedgeInfo && a.renderMetaedgeInfo.metaedge;
                        if (metaedge && !metaedge.numRegularEdges) {
                            edgeType += ' ' + scene.Class.Annotation.CONTROL_EDGE;
                        }
                        // If any edges are reference edges, add the reference edge class.
                        if (metaedge && metaedge.numRefEdges) {
                            edgeType += ' ' + scene.Class.Edge.REF_LINE;
                        }
                        scene.edge.appendEdge(aGroup, a, sceneElement, edgeType);
                        if (a.annotationType !== graph.render.AnnotationType.ELLIPSIS) {
                            addAnnotationLabelFromNode(aGroup, a);
                            buildShape(aGroup, a);
                        }
                        else {
                            addAnnotationLabel(aGroup, a.node.name, a, scene.Class.Annotation.ELLIPSIS);
                        }
                    });
                    annotationGroups
                        .attr('class', function (a) {
                        return scene.Class.Annotation.GROUP + ' ' +
                            annotationToClassName(a.annotationType) + ' ' +
                            scene.node.nodeClass(a);
                    })
                        .each(function (a) {
                        var aGroup = d3.select(this);
                        update(aGroup, d, a, sceneElement);
                        if (a.annotationType !== graph.render.AnnotationType.ELLIPSIS) {
                            addInteraction(aGroup, d, a, sceneElement);
                        }
                    });
                    annotationGroups.exit()
                        .each(function (a) {
                        var aGroup = d3.select(this);
                        // Remove annotation from the index in the scene
                        sceneElement.removeAnnotationGroup(a, d, aGroup);
                    })
                        .remove();
                    return annotationGroups;
                }
                annotation_1.buildGroup = buildGroup;
                ;
                /**
                 * Maps an annotation enum to a class name used in css rules.
                 */
                function annotationToClassName(annotationType) {
                    return (graph.render.AnnotationType[annotationType] || '').toLowerCase() || null;
                }
                function buildShape(aGroup, a) {
                    if (a.annotationType === graph.render.AnnotationType.SUMMARY) {
                        var summary = scene.selectOrCreateChild(aGroup, 'use');
                        summary.attr({
                            'class': 'summary',
                            'xlink:href': '#summary-icon',
                            'cursor': 'pointer'
                        });
                    }
                    else {
                        var shape = scene.node.buildShape(aGroup, a, scene.Class.Annotation.NODE);
                        // add title tag to get native tooltips
                        scene.selectOrCreateChild(shape, 'title').text(a.node.name);
                    }
                }
                function addAnnotationLabelFromNode(aGroup, a) {
                    var namePath = a.node.name.split('/');
                    var text = namePath[namePath.length - 1];
                    var shortenedText = text.length > 8 ? text.substring(0, 8) + '...' : text;
                    return addAnnotationLabel(aGroup, shortenedText, a, null, text);
                }
                function addAnnotationLabel(aGroup, label, a, additionalClassNames, fullLabel) {
                    var classNames = scene.Class.Annotation.LABEL;
                    if (additionalClassNames) {
                        classNames += ' ' + additionalClassNames;
                    }
                    var titleText = fullLabel ? fullLabel : label;
                    return aGroup.append('text')
                        .attr('class', classNames)
                        .attr('dy', '.35em')
                        .attr('text-anchor', a.isIn ? 'end' : 'start')
                        .text(label)
                        .append('title')
                        .text(titleText);
                }
                function addInteraction(selection, d, annotation, sceneElement) {
                    selection
                        .on('mouseover', function (a) {
                        sceneElement.fire('annotation-highlight', { name: a.node.name, hostName: d.node.name });
                    })
                        .on('mouseout', function (a) {
                        sceneElement.fire('annotation-unhighlight', { name: a.node.name, hostName: d.node.name });
                    })
                        .on('click', function (a) {
                        // Stop this event's propagation so that it isn't also considered a
                        // graph-select.
                        d3.event.stopPropagation();
                        sceneElement.fire('annotation-select', { name: a.node.name, hostName: d.node.name });
                    });
                    if (annotation.annotationType !== graph.render.AnnotationType.SUMMARY &&
                        annotation.annotationType !== graph.render.AnnotationType.CONSTANT) {
                        selection.on('contextmenu', scene.contextmenu.getMenu(scene.node.getContextMenu(annotation.node, sceneElement)));
                    }
                }
                ;
                /**
                 * Adjust annotation's position.
                 *
                 * @param aGroup selection of a 'g.annotation' element.
                 * @param d Host node data.
                 * @param a annotation node data.
                 * @param scene <tf-graph-scene> polymer element.
                 */
                function update(aGroup, d, a, sceneElement) {
                    var cx = graph.layout.computeCXPositionOfNodeShape(d);
                    // Annotations that point to embedded nodes (constants,summary)
                    // don't have a render information attached so we don't stylize these.
                    // Also we don't stylize ellipsis annotations (the string '... and X more').
                    if (a.renderNodeInfo &&
                        a.annotationType !== graph.render.AnnotationType.ELLIPSIS) {
                        scene.node.stylize(aGroup, a.renderNodeInfo, sceneElement, scene.Class.Annotation.NODE);
                    }
                    if (a.annotationType === graph.render.AnnotationType.SUMMARY) {
                        // Update the width of the annotation to give space for the image.
                        a.width += 10;
                    }
                    // label position
                    aGroup.select('text.' + scene.Class.Annotation.LABEL).transition().attr({
                        x: cx + a.dx + (a.isIn ? -1 : 1) * (a.width / 2 + a.labelOffset),
                        y: d.y + a.dy
                    });
                    // Some annotations (such as summary) are represented using a 12x12 image tag.
                    // Purposely omitted units (e.g. pixels) since the images are vector graphics.
                    // If there is an image, we adjust the location of the image to be vertically
                    // centered with the node and horizontally centered between the arrow and the
                    // text label.
                    aGroup.select('use.summary').transition().attr({
                        x: cx + a.dx - 3,
                        y: d.y + a.dy - 6
                    });
                    // Node position (only one of the shape selection will be non-empty.)
                    scene.positionEllipse(aGroup.select('.' + scene.Class.Annotation.NODE + ' ellipse'), cx + a.dx, d.y + a.dy, a.width, a.height);
                    scene.positionRect(aGroup.select('.' + scene.Class.Annotation.NODE + ' rect'), cx + a.dx, d.y + a.dy, a.width, a.height);
                    scene.positionRect(aGroup.select('.' + scene.Class.Annotation.NODE + ' use'), cx + a.dx, d.y + a.dy, a.width, a.height);
                    // Edge position
                    aGroup.select('path.' + scene.Class.Annotation.EDGE).transition().attr('d', function (a) {
                        // map relative position to absolute position
                        var points = a.points.map(function (p) { return { x: p.dx + cx, y: p.dy + d.y }; });
                        return scene.edge.interpolate(points);
                    });
                }
                ;
            })(annotation = scene.annotation || (scene.annotation = {}));
        })(scene = graph.scene || (graph.scene = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph) {
        var scene;
        (function (scene) {
            var contextmenu;
            (function (contextmenu) {
                /**
                 * Returns the event listener, which can be used as an argument for the d3
                 * selection.on function. Renders the context menu that is to be displayed
                 * in response to the event.
                 */
                function getMenu(menu) {
                    var menuSelection = d3.select('.context-menu');
                    // Close the menu when anything else is clicked.
                    d3.select('body').on('click.context', function () { menuSelection.style('display', 'none'); });
                    // Function called to populate the context menu.
                    return function (data, index) {
                        var _this = this;
                        // Position and display the menu.
                        var event = d3.event;
                        menuSelection.style({
                            'display': 'block',
                            'left': (event.layerX + 1) + 'px',
                            'top': (event.layerY + 1) + 'px'
                        });
                        // Stop the event from propagating further.
                        event.preventDefault();
                        event.stopPropagation();
                        // Add provided items to the context menu.
                        menuSelection.html('');
                        var list = menuSelection.append('ul');
                        list.selectAll('li')
                            .data(menu)
                            .enter()
                            .append('li')
                            .html(function (d) { return d.title(data); })
                            .on('click', function (d, i) {
                            d.action(_this, data, index);
                            menuSelection.style('display', 'none');
                        });
                    };
                }
                contextmenu.getMenu = getMenu;
                ;
            })(contextmenu = scene.contextmenu || (scene.contextmenu = {}));
        })(scene = graph.scene || (graph.scene = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph_1) {
        var scene;
        (function (scene) {
            var edge;
            (function (edge) {
                /** Delimiter between dimensions when showing sizes of tensors. */
                var TENSOR_SHAPE_DELIM = '';
                /** The minimum stroke width of an edge. */
                edge.MIN_EDGE_WIDTH = 0.75;
                /** The maximum stroke width of an edge. */
                edge.MAX_EDGE_WIDTH = 12;
                /** The exponent used in the power scale for edge thickness. */
                var EDGE_WIDTH_SCALE_EXPONENT = 0.3;
                /** The domain (min and max value) for the edge width. */
                var DOMAIN_EDGE_WIDTH_SCALE = [1, 5E6];
                edge.EDGE_WIDTH_SCALE = d3.scale.pow()
                    .exponent(EDGE_WIDTH_SCALE_EXPONENT)
                    .domain(DOMAIN_EDGE_WIDTH_SCALE)
                    .range([edge.MIN_EDGE_WIDTH, edge.MAX_EDGE_WIDTH])
                    .clamp(true);
                var arrowheadMap = d3.scale.quantize().domain([edge.MIN_EDGE_WIDTH, edge.MAX_EDGE_WIDTH]).range([
                    'small', 'medium', 'large', 'xlarge'
                ]);
                /** Minimum stroke width to put edge labels in the middle of edges */
                var CENTER_EDGE_LABEL_MIN_STROKE_WIDTH = 2.5;
                function getEdgeKey(edgeObj) {
                    return edgeObj.v + graph_1.EDGE_KEY_DELIM + edgeObj.w;
                }
                edge.getEdgeKey = getEdgeKey;
                /**
                 * Select or Create a 'g.edges' group to a given sceneGroup
                 * and builds a number of 'g.edge' groups inside the group.
                 *
                 * Structure Pattern:
                 *
                 * <g class='edges'>
                 *   <g class='edge'>
                 *     <path class='edgeline'/>
                 *   </g>
                 *   ...
                 * </g>
                 *
                 *
                 * @param sceneGroup container
                 * @param graph
                 * @param sceneElement <tf-graph-scene> polymer element.
                 * @return selection of the created nodeGroups
                 */
                function buildGroup(sceneGroup, graph, sceneElement) {
                    var edges = [];
                    edges = _.reduce(graph.edges(), function (edges, edgeObj) {
                        var edgeLabel = graph.edge(edgeObj);
                        edges.push({
                            v: edgeObj.v,
                            w: edgeObj.w,
                            label: edgeLabel
                        });
                        return edges;
                    }, edges);
                    var container = scene.selectOrCreateChild(sceneGroup, 'g', scene.Class.Edge.CONTAINER);
                    // Select all children and join with data.
                    // (Note that all children of g.edges are g.edge)
                    var edgeGroups = container.selectAll(function () {
                        // using d3's selector function
                        // See https://github.com/mbostock/d3/releases/tag/v2.0.0
                        // (It's not listed in the d3 wiki.)
                        return this.childNodes;
                    }).data(edges, getEdgeKey);
                    // Make edges a group to support rendering multiple lines for metaedge
                    edgeGroups.enter()
                        .append('g')
                        .attr('class', scene.Class.Edge.GROUP)
                        .attr('data-edge', getEdgeKey)
                        .each(function (d) {
                        var edgeGroup = d3.select(this);
                        d.label.edgeGroup = edgeGroup;
                        // index node group for quick highlighting
                        sceneElement._edgeGroupIndex[getEdgeKey(d)] = edgeGroup;
                        // Add line during enter because we're assuming that type of line
                        // normally does not change.
                        appendEdge(edgeGroup, d, sceneElement);
                    });
                    edgeGroups.each(position);
                    edgeGroups.each(function (d) {
                        stylize(d3.select(this), d, sceneElement);
                    });
                    edgeGroups.exit()
                        .each(function (d) {
                        delete sceneElement._edgeGroupIndex[getEdgeKey(d)];
                    })
                        .remove();
                    return edgeGroups;
                }
                edge.buildGroup = buildGroup;
                ;
                /**
                 * Returns the label for the given base edge.
                 * The label is the shape of the underlying tensor.
                 */
                function getLabelForBaseEdge(baseEdge, renderInfo) {
                    var node = renderInfo.getNodeByName(baseEdge.v);
                    if (node.outputShapes == null || node.outputShapes.length === 0) {
                        return null;
                    }
                    var shape = node.outputShapes[baseEdge.outputTensorIndex];
                    if (shape == null) {
                        return null;
                    }
                    if (shape.length === 0) {
                        return 'scalar';
                    }
                    return shape.map(function (size) { return size === -1 ? '?' : size; })
                        .join(TENSOR_SHAPE_DELIM);
                }
                edge.getLabelForBaseEdge = getLabelForBaseEdge;
                /**
                 * Creates the label for the given metaedge. If the metaedge consists
                 * of only 1 tensor, and it's shape is known, the label will contain that
                 * shape. Otherwise, the label will say the number of tensors in the metaedge.
                 */
                function getLabelForEdge(metaedge, renderInfo) {
                    var isMultiEdge = metaedge.baseEdgeList.length > 1;
                    return isMultiEdge ?
                        metaedge.baseEdgeList.length + ' tensors' :
                        getLabelForBaseEdge(metaedge.baseEdgeList[0], renderInfo);
                }
                edge.getLabelForEdge = getLabelForEdge;
                /**
                 * Shortens the path enought such that the tip of the start/end marker will
                 * point to the start/end of the path. The marker can be of arbitrary size.
                 *
                 * @param points Array of path control points.
                 * @param marker D3 selection of the <marker> svg element.
                 * @param isStart Is the marker a `start-marker`. If false, the marker is
                 *     an `end-marker`.
                 * @return The new array of control points.
                 */
                function adjustPathPointsForMarker(points, marker, isStart) {
                    var lineFunc = d3.svg.line()
                        .x(function (d) { return d.x; })
                        .y(function (d) { return d.y; });
                    var path = d3.select(document.createElementNS('http://www.w3.org/2000/svg', 'path'))
                        .attr('d', lineFunc(points));
                    var markerWidth = +marker.attr('markerWidth');
                    var viewBox = marker.attr('viewBox').split(' ').map(Number);
                    var viewBoxWidth = viewBox[2] - viewBox[0];
                    var refX = +marker.attr('refX');
                    var pathNode = path.node();
                    if (isStart) {
                        var fractionStickingOut = refX / viewBoxWidth;
                        var length_1 = markerWidth * fractionStickingOut;
                        var point = pathNode.getPointAtLength(length_1);
                        // Figure out how many segments of the path we need to remove in order
                        // to shorten the path.
                        var segIndex = pathNode.getPathSegAtLength(length_1);
                        // Update the very first segment.
                        points[segIndex - 1] = { x: point.x, y: point.y };
                        // Ignore every point before segIndex - 1.
                        return points.slice(segIndex - 1);
                    }
                    else {
                        var fractionStickingOut = 1 - refX / viewBoxWidth;
                        var length_2 = pathNode.getTotalLength() - markerWidth * fractionStickingOut;
                        var point = pathNode.getPointAtLength(length_2);
                        // Figure out how many segments of the path we need to remove in order
                        // to shorten the path.
                        var segIndex = pathNode.getPathSegAtLength(length_2);
                        // Update the very last segment.
                        points[segIndex] = { x: point.x, y: point.y };
                        // Ignore every point after segIndex.
                        return points.slice(0, segIndex + 1);
                    }
                }
                /**
                 * For a given d3 selection and data object, create a path to represent the
                 * edge described in d.label.
                 *
                 * If d.label is defined, it will be a RenderMetaedgeInfo instance. It
                 * will sometimes be undefined, for example for some Annotation edges for which
                 * there is no underlying Metaedge in the hierarchical graph.
                 */
                function appendEdge(edgeGroup, d, sceneElement, edgeClass) {
                    var size = 1;
                    if (d.label != null && d.label.metaedge != null) {
                        // There is an underlying Metaedge.
                        size = d.label.metaedge.totalSize;
                    }
                    edgeClass = edgeClass || scene.Class.Edge.LINE; // set default type
                    if (d.label && d.label.structural) {
                        edgeClass += ' ' + scene.Class.Edge.STRUCTURAL;
                    }
                    // Give the path a unique id, which will be used to link
                    // the textPath (edge label) to this path.
                    var pathId = 'path_' + getEdgeKey(d);
                    var strokeWidth = sceneElement.renderHierarchy.edgeWidthScale(size);
                    var path = edgeGroup.append('path')
                        .attr({
                        'id': pathId,
                        'class': edgeClass,
                    })
                        .style({ 'stroke-width': strokeWidth + 'px' });
                    // Check if there is a reference edge and add an arrowhead of the right size.
                    if (d.label && d.label.metaedge && d.label.metaedge.numRefEdges) {
                        var markerId = "ref-arrowhead-" + arrowheadMap(strokeWidth);
                        path.style('marker-start', "url(#" + markerId + ")");
                        d.label.startMarkerId = markerId;
                    }
                    if (d.label == null || d.label.metaedge == null) {
                        // There is no associated metaedge, thus no text.
                        // This happens for annotation edges.
                        return;
                    }
                    var labelForEdge = getLabelForEdge(d.label.metaedge, sceneElement.renderHierarchy);
                    if (labelForEdge == null) {
                        // We have no information to show on this edge.
                        return;
                    }
                    // Put edge label in the middle of edge only if the edge is thick enough.
                    var baseline = strokeWidth > CENTER_EDGE_LABEL_MIN_STROKE_WIDTH ?
                        'central' :
                        'text-after-edge';
                    edgeGroup.append('text')
                        .append('textPath')
                        .attr({
                        'xlink:href': '#' + pathId,
                        'startOffset': '50%',
                        'text-anchor': 'middle',
                        'dominant-baseline': 'central'
                    })
                        .text(labelForEdge);
                }
                edge.appendEdge = appendEdge;
                ;
                edge.interpolate = d3.svg.line()
                    .interpolate('basis')
                    .x(function (d) { return d.x; })
                    .y(function (d) { return d.y; });
                /**
                 * Returns a tween interpolator for the endpoint of an edge path.
                 */
                function getEdgePathInterpolator(d, i, a) {
                    var renderMetaedgeInfo = d.label;
                    var adjoiningMetaedge = renderMetaedgeInfo.adjoiningMetaedge;
                    var points = renderMetaedgeInfo.points;
                    // Adjust the path so that start/end markers point to the end
                    // of the path.
                    if (d.label.startMarkerId) {
                        points = adjustPathPointsForMarker(points, d3.select('#' + d.label.startMarkerId), true);
                    }
                    if (d.label.endMarkerId) {
                        points = adjustPathPointsForMarker(points, d3.select('#' + d.label.endMarkerId), false);
                    }
                    if (!adjoiningMetaedge) {
                        return d3.interpolate(a, edge.interpolate(points));
                    }
                    var renderPath = this;
                    // Get the adjoining path that matches the adjoining metaedge.
                    var adjoiningPath = (adjoiningMetaedge.edgeGroup.node()
                        .firstChild);
                    // Find the desired SVGPoint along the adjoining path, then convert those
                    // coordinates into the space of the renderPath using its Current
                    // Transformation Matrix (CTM).
                    var inbound = renderMetaedgeInfo.metaedge.inbound;
                    return function (t) {
                        var adjoiningPoint = adjoiningPath
                            .getPointAtLength(inbound ? adjoiningPath.getTotalLength() : 0)
                            .matrixTransform(adjoiningPath.getCTM())
                            .matrixTransform(renderPath.getCTM().inverse());
                        // Update the relevant point in the renderMetaedgeInfo's points list, then
                        // re-interpolate the path.
                        var index = inbound ? 0 : points.length - 1;
                        points[index].x = adjoiningPoint.x;
                        points[index].y = adjoiningPoint.y;
                        var dPath = edge.interpolate(points);
                        return dPath;
                    };
                }
                function position(d) {
                    d3.select(this)
                        .select('path.' + scene.Class.Edge.LINE)
                        .transition()
                        .attrTween('d', getEdgePathInterpolator);
                }
                ;
                /**
                 * For a given d3 selection and data object, mark the edge as a control
                 * dependency if it contains only control edges.
                 *
                 * d's label property will be a RenderMetaedgeInfo object.
                 */
                function stylize(edgeGroup, d, stylize) {
                    edgeGroup.classed('faded', d.label.isFadedOut);
                    var metaedge = d.label.metaedge;
                    edgeGroup.select('path.' + scene.Class.Edge.LINE)
                        .classed('control-dep', metaedge && !metaedge.numRegularEdges);
                }
                ;
            })(edge = scene.edge || (scene.edge = {}));
        })(scene = graph_1.scene || (graph_1.scene = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph) {
        var scene;
        (function (scene) {
            var node;
            (function (node_1) {
                /**
                 * Select or Create a 'g.nodes' group to a given sceneGroup
                 * and builds a number of 'g.node' groups inside the group.
                 *
                 * Structure Pattern:
                 *
                 * <g class='nodes'>
                 *   <g class='node'>
                 *     <g class='in-annotations'>
                 *       ...
                 *     </g>
                 *     <g class='out-annotations'>
                 *       ...
                 *     </g>
                 *     <g class='nodeshape'>
                 *      \x3c!--
                 *      Content of the node shape should be for the node itself. For example a
                 *      Metanode would have a <rect> with rounded edges, an op would have an
                 *      <ellipse>. More complex nodes like series may contain multiple
                 *      elements which are conditionally visible based on whether the node is
                 *      expanded.
                 *      --\x3e
                 *     </g>
                 *     <text class='label'>node name</text>
                 *     <g class='subscene'>
                 *       \x3c!--
                 *       Content of  the subscene (only for metanode and series node).
                 *
                 *       Subscene is a svg group that contains content of the
                 *       metanode's metagraph that is recursively generated by Scene.build().
                 *
                 *       When the graph is expanded multiple times, a subscene can contain
                 *       nested subscenes inside.
                 *       --\x3e
                 *     </g>
                 *   </g>
                 *   ...
                 * </g>
                 *
                 *
                 * @param sceneGroup selection of the container
                 * @param nodeData array of render node information to map
                 * @param sceneElement <tf-graph-scene> polymer element
                 * @return selection of the created nodeGroups
                 */
                function buildGroup(sceneGroup, nodeData, sceneElement) {
                    var container = scene.selectOrCreateChild(sceneGroup, 'g', scene.Class.Node.CONTAINER);
                    // Select all children and join with data.
                    // (Note that all children of g.nodes are g.node)
                    var nodeGroups = container
                        .selectAll(function () {
                        // using d3's selector function
                        // See https://github.com/mbostock/d3/releases/tag/v2.0.0
                        // (It's not listed in the d3 wiki.)
                        return this.childNodes; // this here refers to container.node()
                    })
                        .data(nodeData, function (d) {
                        // make sure that we don't have to swap shape type
                        return d.node.name + ':' + d.node.type;
                    });
                    // ENTER
                    nodeGroups.enter()
                        .append('g')
                        .attr('data-name', function (d) { return d.node.name; })
                        .each(function (d) {
                        var nodeGroup = d3.select(this);
                        // index node group for quick stylizing
                        sceneElement.addNodeGroup(d.node.name, nodeGroup);
                    });
                    // UPDATE
                    nodeGroups
                        .attr('class', function (d) { return scene.Class.Node.GROUP + ' ' + nodeClass(d); })
                        .each(function (d) {
                        var nodeGroup = d3.select(this);
                        // Add g.in-annotations (always add -- to keep layer order
                        // consistent.)
                        var inAnnotationBox = scene.selectOrCreateChild(nodeGroup, 'g', scene.Class.Annotation.INBOX);
                        scene.annotation.buildGroup(inAnnotationBox, d.inAnnotations, d, sceneElement);
                        // Add g.out-annotations  (always add -- to keep layer order
                        // consistent.)
                        var outAnnotationBox = scene.selectOrCreateChild(nodeGroup, 'g', scene.Class.Annotation.OUTBOX);
                        scene.annotation.buildGroup(outAnnotationBox, d.outAnnotations, d, sceneElement);
                        // Build .shape first (background of the node).
                        var shape = buildShape(nodeGroup, d, scene.Class.Node.SHAPE);
                        if (d.node.isGroupNode) {
                            addButton(shape, d, sceneElement);
                        }
                        addInteraction(shape, d, sceneElement);
                        // Build subscene on the top.
                        subsceneBuild(nodeGroup, d, sceneElement);
                        // Build label last. Should be on top of everything else.
                        var label = labelBuild(nodeGroup, d, sceneElement);
                        // Do not add interaction to metanode labels as they live inside the
                        // metanode shape which already has the same interactions.
                        addInteraction(label, d, sceneElement, d.node.type === graph.NodeType.META);
                        stylize(nodeGroup, d, sceneElement);
                        position(nodeGroup, d);
                    });
                    // EXIT
                    nodeGroups.exit()
                        .each(function (d) {
                        // remove all indices on remove
                        sceneElement.removeNodeGroup(d.node.name);
                        var nodeGroup = d3.select(this);
                        if (d.inAnnotations.list.length > 0) {
                            nodeGroup.select('.' + scene.Class.Annotation.INBOX)
                                .selectAll('.' + scene.Class.Annotation.GROUP)
                                .each(function (a) { sceneElement.removeAnnotationGroup(a, d); });
                        }
                        if (d.outAnnotations.list.length > 0) {
                            nodeGroup.select('.' + scene.Class.Annotation.OUTBOX)
                                .selectAll('.' + scene.Class.Annotation.GROUP)
                                .each(function (a) { sceneElement.removeAnnotationGroup(a, d); });
                        }
                    })
                        .remove();
                    return nodeGroups;
                }
                node_1.buildGroup = buildGroup;
                ;
                /**
                 * Update or remove the subscene of a render group node depending on whether it
                 * is a expanded. If the node is not a group node, this method has no effect.
                 *
                 * @param nodeGroup selection of the container
                 * @param renderNodeInfo the render information for the node.
                 * @param sceneElement <tf-graph-scene> polymer element.
                 * @return Selection of the subscene group, or null if node group does not have
                 *        a subscene. Op nodes, bridge nodes and unexpanded group nodes will
                 *        not have a subscene.
                 */
                function subsceneBuild(nodeGroup, renderNodeInfo, sceneElement) {
                    if (renderNodeInfo.node.isGroupNode) {
                        if (renderNodeInfo.expanded) {
                            // Recursively build the subscene.
                            return scene.buildGroup(nodeGroup, renderNodeInfo, sceneElement, scene.Class.Subscene.GROUP);
                        }
                        // Clean out existing subscene if the node is not expanded.
                        scene.selectChild(nodeGroup, 'g', scene.Class.Subscene.GROUP).remove();
                    }
                    return null;
                }
                ;
                /**
                 * Translate the subscene of the given node group
                 */
                function subscenePosition(nodeGroup, d) {
                    var x0 = d.x - d.width / 2.0 + d.paddingLeft;
                    var y0 = d.y - d.height / 2.0 + d.paddingTop;
                    var subscene = scene.selectChild(nodeGroup, 'g', scene.Class.Subscene.GROUP);
                    scene.translate(subscene, x0, y0);
                }
                ;
                /**
                 * Add an expand/collapse button to a group node
                 *
                 * @param selection The group node selection.
                 * @param d Info about the node being rendered.
                 * @param sceneElement <tf-graph-scene> polymer element.
                 */
                function addButton(selection, d, sceneElement) {
                    var group = scene.selectOrCreateChild(selection, 'g', scene.Class.Node.BUTTON_CONTAINER);
                    scene.selectOrCreateChild(group, 'circle', scene.Class.Node.BUTTON_CIRCLE);
                    scene.selectOrCreateChild(group, 'path', scene.Class.Node.EXPAND_BUTTON)
                        .attr('d', 'M0,-2.2 V2.2 M-2.2,0 H2.2');
                    scene.selectOrCreateChild(group, 'path', scene.Class.Node.COLLAPSE_BUTTON)
                        .attr('d', 'M-2.2,0 H2.2');
                    group.on('click', function (d) {
                        // Stop this event's propagation so that it isn't also considered a
                        // node-select.
                        d3.event.stopPropagation();
                        sceneElement.fire('node-toggle-expand', { name: d.node.name });
                    });
                    scene.positionButton(group, d);
                }
                ;
                /**
                 * Fire node-* events when the selection is interacted.
                 *
                 * @param disableInteraction When true, have the provided selection
                 * ignore all pointer events. Used for text labels inside of metanodes, which
                 * don't need interaction as their surrounding shape has interaction, and if
                 * given interaction would cause conflicts with the expand/collapse button.
                 */
                function addInteraction(selection, d, sceneElement, disableInteraction) {
                    if (disableInteraction) {
                        selection.attr('pointer-events', 'none');
                        return;
                    }
                    var contextMenuFunction = scene.contextmenu.getMenu(getContextMenu(d.node, sceneElement));
                    selection
                        .on('dblclick', function (d) {
                        sceneElement.fire('node-toggle-expand', { name: d.node.name });
                    })
                        .on('mouseover', function (d) {
                        // don't send mouseover over expanded group,
                        // otherwise it is causing too much glitches
                        if (sceneElement.isNodeExpanded(d)) {
                            return;
                        }
                        sceneElement.fire('node-highlight', { name: d.node.name });
                    })
                        .on('mouseout', function (d) {
                        // don't send mouseover over expanded group,
                        // otherwise it is causing too much glitches
                        if (sceneElement.isNodeExpanded(d)) {
                            return;
                        }
                        sceneElement.fire('node-unhighlight', { name: d.node.name });
                    })
                        .on('click', function (d) {
                        // Stop this event's propagation so that it isn't also considered
                        // a graph-select.
                        d3.event.stopPropagation();
                        sceneElement.fire('node-select', { name: d.node.name });
                    })
                        .on('contextmenu', function (d, i) {
                        sceneElement.fire('node-select', { name: d.node.name });
                        contextMenuFunction.call(d, i);
                    });
                }
                ;
                /**
                 * Returns the d3 context menu specification for the provided node.
                 */
                function getContextMenu(node, sceneElement) {
                    var menu = [{
                            title: function (d) { return graph.getIncludeNodeButtonString(node.include); },
                            action: function (elm, d, i) {
                                sceneElement.fire('node-toggle-extract', { name: node.name });
                            }
                        }];
                    if (canBeInSeries(node)) {
                        menu.push({
                            title: function (d) { return getGroupSettingLabel(node); },
                            action: function (elm, d, i) {
                                sceneElement.fire('node-toggle-seriesgroup', { name: getSeriesName(node) });
                            }
                        });
                    }
                    return menu;
                }
                node_1.getContextMenu = getContextMenu;
                /** Returns if a node can be part of a grouped series */
                function canBeInSeries(node) {
                    return getSeriesName(node) !== null;
                }
                node_1.canBeInSeries = canBeInSeries;
                /**
                 * Returns the name of the possible grouped series containing this node.
                 * Returns null if the node cannot be part of a grouped series of nodes.
                 */
                function getSeriesName(node) {
                    if (!node) {
                        return null;
                    }
                    if (node.type === graph.NodeType.SERIES) {
                        return node.name;
                    }
                    if (node.type === graph.NodeType.OP) {
                        var op = node;
                        return op.owningSeries;
                    }
                    return null;
                }
                node_1.getSeriesName = getSeriesName;
                /**
                 * Returns the SeriesNode that represents the series that the provided node
                 * is contained in (or itself if the provided node is itself a SeriesNode).
                 * Returns null if the node is not rendered as part of a series.
                 */
                function getContainingSeries(node) {
                    var s = null;
                    if (!node) {
                        return null;
                    }
                    else if (node.type === graph.NodeType.SERIES) {
                        s = node;
                    }
                    else if (node.parentNode && node.parentNode.type === graph.NodeType.SERIES) {
                        s = node.parentNode;
                    }
                    return s;
                }
                /**
                 * Returns the label for a button to toggle the group setting of the provided
                 * node.
                 */
                function getGroupSettingLabel(node) {
                    return tf.graph.getGroupSeriesNodeButtonString(getContainingSeries(node) !== null ? tf.graph.SeriesGroupingType.GROUP :
                        tf.graph.SeriesGroupingType.UNGROUP);
                }
                node_1.getGroupSettingLabel = getGroupSettingLabel;
                /**
                 * Append svg text for label and assign data.
                 * @param nodeGroup
                 * @param renderNodeInfo The render node information for the label.
                 * @param sceneElement <tf-graph-scene> polymer element.
                 */
                function labelBuild(nodeGroup, renderNodeInfo, sceneElement) {
                    var namePath = renderNodeInfo.node.name.split('/');
                    var text = namePath[namePath.length - 1];
                    // Truncate long labels for unexpanded Metanodes.
                    var useFontScale = renderNodeInfo.node.type === graph.NodeType.META &&
                        !renderNodeInfo.expanded;
                    var label = scene.selectOrCreateChild(nodeGroup, 'text', scene.Class.Node.LABEL);
                    // Make sure the label is visually on top among its siblings.
                    var labelNode = label.node();
                    labelNode.parentNode.appendChild(labelNode);
                    label.attr('dy', '.35em').attr('text-anchor', 'middle');
                    if (useFontScale) {
                        if (text.length > sceneElement.maxMetanodeLabelLength) {
                            text = text.substr(0, sceneElement.maxMetanodeLabelLength - 2) + '...';
                        }
                        var scale = getLabelFontScale(sceneElement);
                        label.attr('font-size', scale(text.length) + 'px');
                    }
                    label.text(text);
                    return label;
                }
                ;
                /**
                 * d3 scale used for sizing font of labels, used by labelBuild,
                 * initialized once by getLabelFontScale.
                 */
                var fontScale = null;
                function getLabelFontScale(sceneElement) {
                    if (!fontScale) {
                        fontScale = d3.scale.linear()
                            .domain([sceneElement.maxMetanodeLabelLengthLargeFont,
                            sceneElement.maxMetanodeLabelLength])
                            .range([sceneElement.maxMetanodeLabelLengthFontSize,
                            sceneElement.minMetanodeLabelLengthFontSize]).clamp(true);
                    }
                    return fontScale;
                }
                /**
                 * Set label position of a given node group
                 */
                function labelPosition(nodeGroup, cx, cy, yOffset) {
                    scene.selectChild(nodeGroup, 'text', scene.Class.Node.LABEL)
                        .transition()
                        .attr('x', cx)
                        .attr('y', cy + yOffset);
                }
                ;
                /**
                 * Select or append/insert shape for a node and assign renderNode
                 * as the shape's data.
                 *
                 * @param nodeGroup
                 * @param d Render node information.
                 * @param nodeClass class for the element.
                 * @return Selection of the shape.
                 */
                function buildShape(nodeGroup, d, nodeClass) {
                    // Create a group to house the underlying visual elements.
                    var shapeGroup = scene.selectOrCreateChild(nodeGroup, 'g', nodeClass);
                    // TODO(jimbo): DOM structure should be templated in HTML somewhere, not JS.
                    switch (d.node.type) {
                        case graph.NodeType.OP:
                            scene.selectOrCreateChild(shapeGroup, 'ellipse', scene.Class.Node.COLOR_TARGET);
                            break;
                        case graph.NodeType.SERIES:
                            // Choose the correct stamp to use to represent this series.
                            var stampType = 'annotation';
                            var groupNodeInfo = d;
                            if (groupNodeInfo.coreGraph) {
                                stampType =
                                    groupNodeInfo.node.hasNonControlEdges ? 'vertical' : 'horizontal';
                            }
                            var classList = [scene.Class.Node.COLOR_TARGET];
                            if (groupNodeInfo.isFadedOut) {
                                classList.push('faded-ellipse');
                            }
                            scene.selectOrCreateChild(shapeGroup, 'use', classList)
                                .attr('xlink:href', '#op-series-' + stampType + '-stamp');
                            scene.selectOrCreateChild(shapeGroup, 'rect', scene.Class.Node.COLOR_TARGET)
                                .attr({ rx: d.radius, ry: d.radius });
                            break;
                        case graph.NodeType.BRIDGE:
                            scene.selectOrCreateChild(shapeGroup, 'rect', scene.Class.Node.COLOR_TARGET)
                                .attr({ rx: d.radius, ry: d.radius });
                            break;
                        case graph.NodeType.META:
                            scene.selectOrCreateChild(shapeGroup, 'rect', scene.Class.Node.COLOR_TARGET)
                                .attr({ rx: d.radius, ry: d.radius });
                            break;
                        default:
                            throw Error('Unrecognized node type: ' + d.node.type);
                    }
                    return shapeGroup;
                }
                node_1.buildShape = buildShape;
                ;
                function nodeClass(d) {
                    switch (d.node.type) {
                        case graph.NodeType.OP:
                            return scene.Class.OPNODE;
                        case graph.NodeType.META:
                            return scene.Class.METANODE;
                        case graph.NodeType.SERIES:
                            return scene.Class.SERIESNODE;
                        case graph.NodeType.BRIDGE:
                            return scene.Class.BRIDGENODE;
                        case graph.NodeType.ELLIPSIS:
                            return scene.Class.ELLIPSISNODE;
                    }
                    ;
                    throw Error('Unrecognized node type: ' + d.node.type);
                }
                node_1.nodeClass = nodeClass;
                ;
                /** Modify node and its subscene and its label's positional attributes */
                function position(nodeGroup, d) {
                    var shapeGroup = scene.selectChild(nodeGroup, 'g', scene.Class.Node.SHAPE);
                    var cx = graph.layout.computeCXPositionOfNodeShape(d);
                    switch (d.node.type) {
                        case graph.NodeType.OP: {
                            // position shape
                            var shape = scene.selectChild(shapeGroup, 'ellipse');
                            scene.positionEllipse(shape, cx, d.y, d.coreBox.width, d.coreBox.height);
                            labelPosition(nodeGroup, cx, d.y, d.labelOffset);
                            break;
                        }
                        case graph.NodeType.META: {
                            // position shape
                            var shape = scene.selectChild(shapeGroup, 'rect');
                            if (d.expanded) {
                                scene.positionRect(shape, d.x, d.y, d.width, d.height);
                                subscenePosition(nodeGroup, d);
                                // put label on top
                                labelPosition(nodeGroup, cx, d.y, -d.height / 2 + d.labelHeight / 2);
                            }
                            else {
                                scene.positionRect(shape, cx, d.y, d.coreBox.width, d.coreBox.height);
                                labelPosition(nodeGroup, cx, d.y, 0);
                            }
                            break;
                        }
                        case graph.NodeType.SERIES: {
                            var shape = scene.selectChild(shapeGroup, 'use');
                            if (d.expanded) {
                                scene.positionRect(shape, d.x, d.y, d.width, d.height);
                                subscenePosition(nodeGroup, d);
                                // put label on top
                                labelPosition(nodeGroup, cx, d.y, -d.height / 2 + d.labelHeight / 2);
                            }
                            else {
                                scene.positionRect(shape, cx, d.y, d.coreBox.width, d.coreBox.height);
                                labelPosition(nodeGroup, cx, d.y, d.labelOffset);
                            }
                            break;
                        }
                        case graph.NodeType.BRIDGE: {
                            // position shape
                            // NOTE: In reality, these will not be visible, but it helps to put them
                            // in the correct position for debugging purposes.
                            var shape = scene.selectChild(shapeGroup, 'rect');
                            scene.positionRect(shape, d.x, d.y, d.width, d.height);
                            break;
                        }
                        default: {
                            throw Error('Unrecognized node type: ' + d.node.type);
                        }
                    }
                }
                ;
                /** Enum specifying the options to color nodes by */
                (function (ColorBy) {
                    ColorBy[ColorBy["STRUCTURE"] = 0] = "STRUCTURE";
                    ColorBy[ColorBy["DEVICE"] = 1] = "DEVICE";
                    ColorBy[ColorBy["COMPUTE_TIME"] = 2] = "COMPUTE_TIME";
                    ColorBy[ColorBy["MEMORY"] = 3] = "MEMORY";
                })(node_1.ColorBy || (node_1.ColorBy = {}));
                var ColorBy = node_1.ColorBy;
                ;
                /**
                 * Returns the fill color for the node given its state and the 'color by'
                 * option.
                 */
                function getFillForNode(templateIndex, colorBy, renderInfo, isExpanded) {
                    var colorParams = graph.render.MetanodeColors;
                    switch (colorBy) {
                        case ColorBy.STRUCTURE:
                            if (renderInfo.node.type === graph.NodeType.META) {
                                var tid = renderInfo.node.templateId;
                                return tid === null ?
                                    colorParams.UNKNOWN :
                                    colorParams.STRUCTURE_PALETTE(templateIndex(tid), isExpanded);
                            }
                            else if (renderInfo.node.type === graph.NodeType.SERIES) {
                                // If expanded, we're showing the background rect, which we want to
                                // appear gray. Otherwise we're showing a stack of ellipses which we
                                // want to show white.
                                return isExpanded ? colorParams.EXPANDED_COLOR : 'white';
                            }
                            else if (renderInfo.node.type === graph.NodeType.BRIDGE) {
                                return renderInfo.structural ?
                                    '#f0e' :
                                    renderInfo.node.inbound ? '#0ef' : '#fe0';
                            }
                            else {
                                // Op nodes are white.
                                return 'white';
                            }
                        case ColorBy.DEVICE:
                            if (renderInfo.deviceColors == null) {
                                // Return the hue for unknown device.
                                return colorParams.UNKNOWN;
                            }
                            var id = renderInfo.node.name;
                            var escapedId = tf.graph.util.escapeQuerySelector(id);
                            var gradientDefs = d3.select('svg#svg defs #linearGradients');
                            var linearGradient_1 = gradientDefs.select('linearGradient#' + escapedId);
                            // If the linear gradient is not there yet, create it.
                            if (linearGradient_1.size() === 0) {
                                linearGradient_1 = gradientDefs.append('linearGradient').attr('id', id);
                                // Re-create the stops of the linear gradient.
                                linearGradient_1.selectAll('*').remove();
                                var cumulativeProportion_1 = 0;
                                // For each device, create a stop using the proportion of that device.
                                _.each(renderInfo.deviceColors, function (d) {
                                    var color = d.color;
                                    linearGradient_1.append('stop')
                                        .attr('offset', cumulativeProportion_1)
                                        .attr('stop-color', color);
                                    linearGradient_1.append('stop')
                                        .attr('offset', cumulativeProportion_1 + d.proportion)
                                        .attr('stop-color', color);
                                    cumulativeProportion_1 += d.proportion;
                                });
                            }
                            return isExpanded ? colorParams.EXPANDED_COLOR : "url(#" + escapedId + ")";
                        case ColorBy.COMPUTE_TIME:
                            return isExpanded ?
                                colorParams.EXPANDED_COLOR : renderInfo.computeTimeColor ||
                                colorParams.UNKNOWN;
                        case ColorBy.MEMORY:
                            return isExpanded ?
                                colorParams.EXPANDED_COLOR : renderInfo.memoryColor ||
                                colorParams.UNKNOWN;
                        default:
                            throw new Error('Unknown case to color nodes by');
                    }
                }
                node_1.getFillForNode = getFillForNode;
                /**
                 * Modify node style by toggling class and assign attributes (only for things
                 * that can't be done in css).
                 */
                function stylize(nodeGroup, renderInfo, sceneElement, nodeClass) {
                    nodeClass = nodeClass || scene.Class.Node.SHAPE;
                    var isHighlighted = sceneElement.isNodeHighlighted(renderInfo.node.name);
                    var isSelected = sceneElement.isNodeSelected(renderInfo.node.name);
                    var isExtract = renderInfo.isInExtract || renderInfo.isOutExtract;
                    var isExpanded = renderInfo.expanded;
                    var isFadedOut = renderInfo.isFadedOut;
                    nodeGroup.classed('highlighted', isHighlighted);
                    nodeGroup.classed('selected', isSelected);
                    nodeGroup.classed('extract', isExtract);
                    nodeGroup.classed('expanded', isExpanded);
                    nodeGroup.classed('faded', isFadedOut);
                    // Main node always exists here and it will be reached before subscene,
                    // so d3 selection is fine here.
                    var node = nodeGroup.select('.' + nodeClass + ' .' + scene.Class.Node.COLOR_TARGET);
                    var fillColor = getFillForNode(sceneElement.templateIndex, ColorBy[sceneElement.colorBy.toUpperCase()], renderInfo, isExpanded);
                    node.style('fill', fillColor);
                    // Choose outline to be darker version of node color if the node is a single
                    // color and is not selected.
                    node.style('stroke', isSelected ? null : getStrokeForFill(fillColor));
                }
                node_1.stylize = stylize;
                ;
                /**
                 * Given a node's fill color/gradient, determine the stroke for the node.
                 */
                function getStrokeForFill(fill) {
                    // If node is colored by a gradient, then use a dark gray outline.
                    return fill.substring(0, 3) === 'url' ?
                        graph.render.MetanodeColors.GRADIENT_OUTLINE :
                        d3.rgb(fill).darker().toString();
                }
                node_1.getStrokeForFill = getStrokeForFill;
            })(node = scene.node || (scene.node = {}));
        })(scene = graph.scene || (graph.scene = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph) {
        var scene;
        (function (scene) {
            /** Enums element class of objects in the scene */
            scene.Class = {
                Node: {
                    // <g> element that contains nodes.
                    CONTAINER: 'nodes',
                    // <g> element that contains detail about a node.
                    GROUP: 'node',
                    // <g> element that contains visual elements (like rect, ellipse).
                    SHAPE: 'nodeshape',
                    // <*> element(s) under SHAPE that should receive color updates.
                    COLOR_TARGET: 'nodecolortarget',
                    // <text> element showing the node's label.
                    LABEL: 'nodelabel',
                    // <g> element that contains all visuals for the expand/collapse
                    // button for expandable group nodes.
                    BUTTON_CONTAINER: 'buttoncontainer',
                    // <circle> element that surrounds expand/collapse buttons.
                    BUTTON_CIRCLE: 'buttoncircle',
                    // <path> element of the expand button.
                    EXPAND_BUTTON: 'expandbutton',
                    // <path> element of the collapse button.
                    COLLAPSE_BUTTON: 'collapsebutton'
                },
                Edge: {
                    CONTAINER: 'edges',
                    GROUP: 'edge',
                    LINE: 'edgeline',
                    REF_LINE: 'refline',
                    STRUCTURAL: 'structural'
                },
                Annotation: {
                    OUTBOX: 'out-annotations',
                    INBOX: 'in-annotations',
                    GROUP: 'annotation',
                    NODE: 'annotation-node',
                    EDGE: 'annotation-edge',
                    CONTROL_EDGE: 'annotation-control-edge',
                    LABEL: 'annotation-label',
                    ELLIPSIS: 'annotation-ellipsis'
                },
                Scene: {
                    GROUP: 'scene',
                    CORE: 'core',
                    INEXTRACT: 'in-extract',
                    OUTEXTRACT: 'out-extract'
                },
                Subscene: { GROUP: 'subscene' },
                OPNODE: 'op',
                METANODE: 'meta',
                SERIESNODE: 'series',
                BRIDGENODE: 'bridge',
                ELLIPSISNODE: 'ellipsis'
            };
            /**
             * Helper method for fitting the graph in the svg view.
             *
             * @param svg The main svg.
             * @param zoomG The svg group used for panning and zooming.
             * @param d3zoom The zoom behavior.
             * @param callback Called when the fitting is done.
             */
            function fit(svg, zoomG, d3zoom, callback) {
                var svgRect = svg.getBoundingClientRect();
                var sceneSize = null;
                try {
                    sceneSize = zoomG.getBBox();
                    if (sceneSize.width === 0) {
                        // There is no scene anymore. We have been detached from the dom.
                        return;
                    }
                }
                catch (e) {
                    // Firefox produced NS_ERROR_FAILURE if we have been
                    // detached from the dom.
                    return;
                }
                var scale = 0.9 * Math.min(svgRect.width / sceneSize.width, svgRect.height / sceneSize.height, 2);
                var params = graph.layout.PARAMS.graph;
                var zoomEvent = d3zoom.scale(scale)
                    .on('zoomend.fitted', function () {
                    // Remove the listener for the zoomend event,
                    // so we don't get called at the end of regular zoom events,
                    // just those that fit the graph to screen.
                    d3zoom.on('zoomend.fitted', null);
                    callback();
                })
                    .translate([params.padding.paddingLeft, params.padding.paddingTop])
                    .event;
                d3.select(zoomG).transition().duration(500).call(zoomEvent);
            }
            scene.fit = fit;
            ;
            /**
             * Helper method for panning the graph to center on the provided node,
             * if the node is currently off-screen.
             *
             * @param nodeName The node to center the graph on
             * @param svg The root SVG element for the graph
             * @param zoomG The svg group used for panning and zooming.
             * @param d3zoom The zoom behavior.
             * @return True if the graph had to be panned to display the
             *            provided node.
             */
            function panToNode(nodeName, svg, zoomG, d3zoom) {
                var node = d3
                    .select('[data-name="' + nodeName + '"].' + scene.Class.Node.GROUP)
                    .node();
                if (!node) {
                    return false;
                }
                var translate = d3zoom.translate();
                // Check if the selected node is off-screen in either
                // X or Y dimension in either direction.
                var nodeBox = node.getBBox();
                var nodeCtm = node.getScreenCTM();
                var pointTL = svg.createSVGPoint();
                var pointBR = svg.createSVGPoint();
                pointTL.x = nodeBox.x;
                pointTL.y = nodeBox.y;
                pointBR.x = nodeBox.x + nodeBox.width;
                pointBR.y = nodeBox.y + nodeBox.height;
                pointTL = pointTL.matrixTransform(nodeCtm);
                pointBR = pointBR.matrixTransform(nodeCtm);
                var isOutsideOfBounds = function (start, end, bound) {
                    return end < 0 || start > bound;
                };
                var svgRect = svg.getBoundingClientRect();
                if (isOutsideOfBounds(pointTL.x, pointBR.x, svgRect.width) ||
                    isOutsideOfBounds(pointTL.y, pointBR.y, svgRect.height)) {
                    // Determine the amount to transform the graph in both X and Y
                    // dimensions in order to center the selected node. This takes into
                    // acount the position of the node, the size of the svg scene, the
                    // amount the scene has been scaled by through zooming, and any previous
                    // transform already performed by this logic.
                    var centerX = (pointTL.x + pointBR.x) / 2;
                    var centerY = (pointTL.y + pointBR.y) / 2;
                    var dx = ((svgRect.width / 2) - centerX);
                    var dy = ((svgRect.height / 2) - centerY);
                    var zoomEvent = d3zoom.translate([translate[0] + dx, translate[1] + dy])
                        .event;
                    d3.select(zoomG).transition().duration(500).call(zoomEvent);
                    return true;
                }
                return false;
            }
            scene.panToNode = panToNode;
            ;
            /**
             * Given a container d3 selection, select a child svg element of a given tag
             * and class if exists or append / insert one otherwise.  If multiple children
             * matches the tag and class name, returns only the first one.
             *
             * @param container
             * @param tagName tag name.
             * @param className (optional) Class name or a list of class names.
             * @param before (optional) reference DOM node for insertion.
             * @return selection of the element
             */
            function selectOrCreateChild(container, tagName, className, before) {
                var child = selectChild(container, tagName, className);
                if (!child.empty()) {
                    return child;
                }
                var newElement = document.createElementNS('http://www.w3.org/2000/svg', tagName);
                if (className instanceof Array) {
                    for (var i = 0; i < className.length; i++) {
                        newElement.classList.add(className[i]);
                    }
                }
                else {
                    newElement.classList.add(className);
                }
                if (before) {
                    container.node().insertBefore(newElement, before);
                }
                else {
                    container.node().appendChild(newElement);
                }
                return d3.select(newElement)
                    .datum(container.datum());
            }
            scene.selectOrCreateChild = selectOrCreateChild;
            ;
            /**
             * Given a container d3 selection, select a child element of a given tag and
             * class. If multiple children matches the tag and class name, returns only
             * the first one.
             *
             * @param container
             * @param tagName tag name.
             * @param className (optional) Class name or list of class names.
             * @return selection of the element, or an empty selection
             */
            function selectChild(container, tagName, className) {
                var children = container.node().childNodes;
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (child.tagName === tagName) {
                        if (className instanceof Array) {
                            var hasAllClasses = true;
                            for (var j = 0; j < className.length; j++) {
                                hasAllClasses =
                                    hasAllClasses && child.classList.contains(className[j]);
                            }
                            if (hasAllClasses) {
                                return d3.select(child);
                            }
                        }
                        else if ((!className || child.classList.contains(className))) {
                            return d3.select(child);
                        }
                    }
                }
                return d3.select(null);
            }
            scene.selectChild = selectChild;
            ;
            /**
             * Select or create a sceneGroup and build/update its nodes and edges.
             *
             * Structure Pattern:
             *
             * <g class='scene'>
             *   <g class='core'>
             *     <g class='edges'>
             *       ... stuff from tf.graph.scene.edges.build ...
             *     </g>
             *     <g class='nodes'>
             *       ... stuff from tf.graph.scene.nodes.build ...
             *     </g>
             *   </g>
             *   <g class='in-extract'>
             *     <g class='nodes'>
             *       ... stuff from tf.graph.scene.nodes.build ...
             *     </g>
             *   </g>
             *   <g class='out-extract'>
             *     <g class='nodes'>
             *       ... stuff from tf.graph.scene.nodes.build ...
             *     </g>
             *   </g>
             * </g>
             *
             * @param container D3 selection of the parent.
             * @param renderNode render node of a metanode or series node.
             * @param sceneElement <tf-graph-scene> polymer element.
             * @param sceneClass class attribute of the scene (default='scene').
             */
            function buildGroup(container, renderNode, sceneElement, sceneClass) {
                sceneClass = sceneClass || scene.Class.Scene.GROUP;
                var isNewSceneGroup = selectChild(container, 'g', sceneClass).empty();
                var sceneGroup = selectOrCreateChild(container, 'g', sceneClass);
                // core
                var coreGroup = selectOrCreateChild(sceneGroup, 'g', scene.Class.Scene.CORE);
                var coreNodes = _.reduce(renderNode.coreGraph.nodes(), function (nodes, name) {
                    var node = renderNode.coreGraph.node(name);
                    if (!node.excluded) {
                        nodes.push(node);
                    }
                    return nodes;
                }, []);
                if (renderNode.node.type === graph.NodeType.SERIES) {
                    // For series, we want the first item on top, so reverse the array so
                    // the first item in the series becomes last item in the top, and thus
                    // is rendered on the top.
                    coreNodes.reverse();
                }
                // Create the layer of edges for this scene (paths).
                scene.edge.buildGroup(coreGroup, renderNode.coreGraph, sceneElement);
                // Create the layer of nodes for this scene (ellipses, rects etc).
                scene.node.buildGroup(coreGroup, coreNodes, sceneElement);
                // In-extract
                if (renderNode.isolatedInExtract.length > 0) {
                    var inExtractGroup = selectOrCreateChild(sceneGroup, 'g', scene.Class.Scene.INEXTRACT);
                    scene.node.buildGroup(inExtractGroup, renderNode.isolatedInExtract, sceneElement);
                }
                else {
                    selectChild(sceneGroup, 'g', scene.Class.Scene.INEXTRACT).remove();
                }
                // Out-extract
                if (renderNode.isolatedOutExtract.length > 0) {
                    var outExtractGroup = selectOrCreateChild(sceneGroup, 'g', scene.Class.Scene.OUTEXTRACT);
                    scene.node.buildGroup(outExtractGroup, renderNode.isolatedOutExtract, sceneElement);
                }
                else {
                    selectChild(sceneGroup, 'g', scene.Class.Scene.OUTEXTRACT).remove();
                }
                position(sceneGroup, renderNode);
                // Fade in the scene group if it didn't already exist.
                if (isNewSceneGroup) {
                    sceneGroup.attr('opacity', 0).transition().attr('opacity', 1);
                }
                return sceneGroup;
            }
            scene.buildGroup = buildGroup;
            ;
            /**
             * Given a scene's svg group, set  g.in-extract, g.coreGraph, g.out-extract svg
             * groups' position relative to the scene.
             *
             * @param sceneGroup
             * @param renderNode render node of a metanode or series node.
             */
            function position(sceneGroup, renderNode) {
                // Translate scenes down by the label height so that when showing graphs in
                // expanded metanodes, the graphs are below the labels.  Do not shift them
                // down for series nodes as series nodes don't have labels inside of their
                // bounding boxes.
                var yTranslate = renderNode.node.type === graph.NodeType.SERIES ?
                    0 : graph.layout.PARAMS.subscene.meta.labelHeight;
                // core
                translate(selectChild(sceneGroup, 'g', scene.Class.Scene.CORE), 0, yTranslate);
                // in-extract
                var hasInExtract = renderNode.isolatedInExtract.length > 0;
                var hasOutExtract = renderNode.isolatedOutExtract.length > 0;
                if (hasInExtract) {
                    var offset = graph.layout.PARAMS.subscene.meta.extractXOffset;
                    var inExtractX = renderNode.coreBox.width -
                        renderNode.inExtractBox.width / 2 - renderNode.outExtractBox.width -
                        (hasOutExtract ? offset : 0);
                    translate(selectChild(sceneGroup, 'g', scene.Class.Scene.INEXTRACT), inExtractX, yTranslate);
                }
                // out-extract
                if (hasOutExtract) {
                    var outExtractX = renderNode.coreBox.width -
                        renderNode.outExtractBox.width / 2;
                    translate(selectChild(sceneGroup, 'g', scene.Class.Scene.OUTEXTRACT), outExtractX, yTranslate);
                }
            }
            ;
            /** Adds a click listener to a group that fires a graph-select event */
            function addGraphClickListener(graphGroup, sceneElement) {
                d3.select(graphGroup).on('click', function () {
                    sceneElement.fire('graph-select');
                });
            }
            scene.addGraphClickListener = addGraphClickListener;
            ;
            /** Helper for adding transform: translate(x0, y0) */
            function translate(selection, x0, y0) {
                // If it is already placed on the screen, make it a transition.
                if (selection.attr('transform') != null) {
                    selection = selection.transition('position');
                }
                selection.attr('transform', 'translate(' + x0 + ',' + y0 + ')');
            }
            scene.translate = translate;
            ;
            /**
             * Helper for setting position of a svg rect
             * @param rect rect to set position of.
             * @param cx Center x.
             * @param cy Center x.
             * @param width Width to set.
             * @param height Height to set.
             */
            function positionRect(rect, cx, cy, width, height) {
                rect.transition().attr({
                    x: cx - width / 2,
                    y: cy - height / 2,
                    width: width,
                    height: height
                });
            }
            scene.positionRect = positionRect;
            ;
            /**
             * Helper for setting position of a svg expand/collapse button
             * @param button container group
             * @param renderNode the render node of the group node to position
             *        the button on.
             */
            function positionButton(button, renderNode) {
                var cx = graph.layout.computeCXPositionOfNodeShape(renderNode);
                // Position the button in the top-right corner of the group node,
                // with space given the draw the button inside of the corner.
                var width = renderNode.expanded ?
                    renderNode.width : renderNode.coreBox.width;
                var height = renderNode.expanded ?
                    renderNode.height : renderNode.coreBox.height;
                var x = cx + width / 2 - 6;
                var y = renderNode.y - height / 2 + 6;
                // For unexpanded series nodes, the button has special placement due
                // to the unique visuals of this group node.
                if (renderNode.node.type === graph.NodeType.SERIES && !renderNode.expanded) {
                    x += 10;
                    y -= 2;
                }
                var translateStr = 'translate(' + x + ',' + y + ')';
                button.selectAll('path').transition().attr('transform', translateStr);
                button.select('circle').transition().attr({ cx: x, cy: y, r: graph.layout.PARAMS.nodeSize.meta.expandButtonRadius });
            }
            scene.positionButton = positionButton;
            ;
            /**
             * Helper for setting position of a svg ellipse
             * @param ellipse ellipse to set position of.
             * @param cx Center x.
             * @param cy Center x.
             * @param width Width to set.
             * @param height Height to set.
             */
            function positionEllipse(ellipse, cx, cy, width, height) {
                ellipse.transition().attr({
                    cx: cx,
                    cy: cy,
                    rx: width / 2,
                    ry: height / 2
                });
            }
            scene.positionEllipse = positionEllipse;
            ;
        })(scene = graph.scene || (graph.scene = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // close module
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph_1) {
        var template;
        (function (template) {
            /**
             * Detect repeating patterns of subgraphs.
             * Assign templateId to each subgraph if it belongs to a template.
             * Returns clusters of similar subgraphs .
             *
             * @param graph
             * @param verifyTemplate whether to run the template verification algorithm
             * @return a dict (template id => Array of node names)
             */
            function detect(h, verifyTemplate) {
                // In any particular subgraph, there are either
                // - leaf nodes (which do not have subgraph)
                // - metanode nodes - some of them have only one member (singular metanode)
                //                    and some have multiple members (non-singular metanode)
                // First, generate a nearest neighbor hash of metanode nodes.
                var nnGroups = clusterSimilarSubgraphs(h);
                // For each metanode, compare its subgraph (starting from shallower groups)
                // and assign template id.
                var templates = groupTemplateAndAssignId(nnGroups, verifyTemplate);
                // Sort the templates by minimum level in the graph at which they appear,
                // as this leads to optimal setting of the colors of each template for
                // maximum differentiation.
                return _(templates)
                    .pairs()
                    .sortBy(function (pair) {
                    return pair[1].level;
                })
                    .map(function (pair) {
                    return [pair[0], pair[1].nodes];
                })
                    .object()
                    .value();
            }
            template.detect = detect;
            ;
            /**
             * @return Unique string for a metanode based on depth, |V|, |E| and
             * op type histogram.
             */
            function getSignature(metanode) {
                // depth=<number> |V|=<number> |E|=<number>
                var props = _.map({
                    'depth': metanode.depth,
                    '|V|': metanode.metagraph.nodes().length,
                    '|E|': metanode.metagraph.edges().length
                }, function (v, k) { return k + '=' + v; })
                    .join(' ');
                // optype1=count1,optype2=count2
                var ops = _.map(metanode.opHistogram, function (count, op) {
                    return op + '=' + count;
                }).join(',');
                return props + ' [ops] ' + ops;
            }
            /**
             * Generate a nearest neighbor hash of metanodes
             * based on depth, |V|, |E|, and opHistogram of their subgraph
             * (excluding leaf nodes and singular metanodes).
             * @param graph The graph
             * @return Array of pairs of [signature,
             *   Object with min level of the template and an Array of tf.graph.Group]
             *   sort by ascending order of minimum depth at which metanode appears.
             */
            function clusterSimilarSubgraphs(h) {
                /** a dict from metanode.signature() => Array of tf.graph.Groups */
                var hashDict = _(h.getNodeMap()).reduce(function (hash, node, name) {
                    if (node.type !== graph_1.NodeType.META) {
                        return hash;
                    }
                    var levelOfMetaNode = name.split('/').length - 1;
                    var signature = getSignature(node);
                    var templateInfo = hash[signature] ||
                        { nodes: [], level: levelOfMetaNode };
                    hash[signature] = templateInfo;
                    templateInfo.nodes.push(node);
                    if (templateInfo.level > levelOfMetaNode) {
                        templateInfo.level = levelOfMetaNode;
                    }
                    return hash;
                }, {});
                return _(hashDict)
                    .pairs()
                    .filter(function (pair) {
                    return pair[1].nodes.length > 1;
                })
                    .sortBy(function (pair) {
                    // sort by depth
                    // (all members in the same nnGroup has equal depth)
                    return pair[1].nodes[0].depth;
                })
                    .value();
            }
            function groupTemplateAndAssignId(nnGroups, verifyTemplate) {
                // For each metanode, compare its subgraph (starting from shallower groups)
                // and assign template id.
                var result = {};
                return _.reduce(nnGroups, function (templates, nnGroupPair) {
                    var signature = nnGroupPair[0], nnGroup = nnGroupPair[1].nodes, clusters = [];
                    nnGroup.forEach(function (metanode) {
                        // check with each existing cluster
                        for (var i = 0; i < clusters.length; i++) {
                            var similar = !verifyTemplate ||
                                isSimilarSubgraph(clusters[i].metanode.metagraph, metanode.metagraph);
                            // if similar, just add this metanode to the cluster
                            if (similar) {
                                // get template from the first one
                                metanode.templateId = clusters[i].metanode.templateId;
                                clusters[i].members.push(metanode.name);
                                return;
                            }
                        }
                        // otherwise create a new cluster with id 'signature [count] '
                        metanode.templateId = signature + '[' + clusters.length + ']';
                        clusters.push({
                            metanode: metanode,
                            members: [metanode.name]
                        });
                    });
                    clusters.forEach(function (c) {
                        templates[c.metanode.templateId] = {
                            level: nnGroupPair[1].level,
                            nodes: c.members
                        };
                    });
                    return templates;
                }, result);
            }
            function sortNodes(names, graph, prefix) {
                return _.sortByAll(names, function (name) {
                    var node = graph.node(name);
                    return node.op;
                }, function (name) {
                    var node = graph.node(name);
                    return node.templateId;
                }, function (name) {
                    return graph.neighbors(name).length;
                }, function (name) {
                    return graph.predecessors(name).length;
                }, function (name) {
                    return graph.successors(name).length;
                }, function (name) {
                    return name.substr(prefix.length);
                });
            }
            function isSimilarSubgraph(g1, g2) {
                if (!tf.graph.hasSimilarDegreeSequence(g1, g2)) {
                    return false;
                }
                // if we want to skip, just return true here.
                // return true;
                // Verify sequence by running DFS
                var g1prefix = g1.graph().name;
                var g2prefix = g2.graph().name;
                var visited1 = {};
                var visited2 = {};
                var stack = [];
                /**
                 * push sources or successors into the stack
                 * if the visiting pattern has been similar.
                 */
                function stackPushIfNotDifferent(n1, n2) {
                    var sub1 = n1.substr(g1prefix.length), sub2 = n2.substr(g2prefix.length);
                    /* tslint:disable */
                    if (visited1[sub1] ^ visited2[sub1]) {
                        console.warn('different visit pattern', '[' + g1prefix + ']', sub1, '[' + g2prefix + ']', sub2);
                        return true;
                    }
                    /* tslint:enable */
                    if (!visited1[sub1]) {
                        visited1[sub1] = visited2[sub2] = true;
                        stack.push({ n1: n1, n2: n2 });
                    }
                    return false;
                }
                // check if have same # of sources then sort and push
                var sources1 = g1.sources();
                var sources2 = g2.sources();
                if (sources1.length !== sources2.length) {
                    /* tslint:disable */
                    console.log('different source length');
                    /* tslint:enable */
                    return false;
                }
                sources1 = sortNodes(sources1, g1, g1prefix);
                sources2 = sortNodes(sources2, g2, g2prefix);
                for (var i = 0; i < sources1.length; i++) {
                    var different = stackPushIfNotDifferent(sources1[i], sources2[i]);
                    if (different) {
                        return false;
                    }
                }
                while (stack.length > 0) {
                    var cur = stack.pop();
                    // check node
                    var similar = isSimilarNode(g1.node(cur.n1), g2.node(cur.n2));
                    if (!similar) {
                        return false;
                    }
                    // check if have same # of successors then sort and push
                    var succ1 = g1.successors(cur.n1), succ2 = g2.successors(cur.n2);
                    if (succ1.length !== succ2.length) {
                        /* tslint:disable */
                        console.log('# of successors mismatch', succ1, succ2);
                        /* tslint:enable */
                        return false;
                    }
                    succ1 = sortNodes(succ1, g1, g1prefix);
                    succ2 = sortNodes(succ2, g2, g2prefix);
                    for (var j = 0; j < succ1.length; j++) {
                        var different = stackPushIfNotDifferent(succ1[j], succ2[j]);
                        if (different) {
                            return false;
                        }
                    }
                }
                return true;
            }
            /**
             * Returns if two nodes have identical structure.
             */
            function isSimilarNode(n1, n2) {
                if (n1.type === graph_1.NodeType.META) {
                    // compare metanode
                    var metanode1 = n1;
                    var metanode2 = n2;
                    return metanode1.templateId && metanode2.templateId &&
                        metanode1.templateId === metanode2.templateId;
                }
                else if (n1.type === graph_1.NodeType.OP && n2.type === graph_1.NodeType.OP) {
                    // compare leaf node
                    return n1.op === n2.op;
                }
                else if (n1.type === graph_1.NodeType.SERIES && n2.type === graph_1.NodeType.SERIES) {
                    // compare series node sizes and operations
                    // (only need to check one op as all op nodes are identical in series)
                    var sn1 = n1;
                    var sn2 = n2;
                    var seriesnode1Count = sn1.metagraph.nodeCount();
                    return (seriesnode1Count === sn2.metagraph.nodeCount() &&
                        (seriesnode1Count === 0 ||
                            (sn1.metagraph.node(sn1.metagraph.nodes()[0]).op ===
                                sn2.metagraph.node(sn2.metagraph.nodes()[0]).op)));
                }
                return false;
            }
        })(template = graph_1.template || (graph_1.template = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {}));
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
/**
 * @fileoverview Utility functions for the tensorflow graph visualizer.
 */
var tf;
(function (tf) {
    var graph;
    (function (graph) {
        var util;
        (function (util) {
            /**
             * Recommended delay (ms) when running an expensive task asynchronously
             * that gives enough time for the progress bar to update its UI.
             */
            var ASYNC_TASK_DELAY = 20;
            function time(msg, task) {
                var start = Date.now();
                var result = task();
                /* tslint:disable */
                console.log(msg, ':', Date.now() - start, 'ms');
                /* tslint:enable */
                return result;
            }
            util.time = time;
            /**
             * Creates a tracker that sets the progress property of the
             * provided polymer component. The provided component must have
             * a property called 'progress' that is not read-only. The progress
             * property is an object with a numerical 'value' property and a
             * string 'msg' property.
             */
            function getTracker(polymerComponent) {
                return {
                    setMessage: function (msg) {
                        polymerComponent.set('progress', { value: polymerComponent.progress.value, msg: msg });
                    },
                    updateProgress: function (value) {
                        polymerComponent.set('progress', {
                            value: polymerComponent.progress.value + value,
                            msg: polymerComponent.progress.msg
                        });
                    },
                    reportError: function (msg, err) {
                        // Log the stack trace in the console.
                        console.error(err.stack);
                        // And send a user-friendly message to the UI.
                        polymerComponent.set('progress', { value: polymerComponent.progress.value, msg: msg, error: true });
                    },
                };
            }
            util.getTracker = getTracker;
            /**
             * Creates a tracker for a subtask given the parent tracker, the total
             * progress
             * of the subtask and the subtask message. The parent task should pass a
             * subtracker to its subtasks. The subtask reports its own progress which
             * becames relative to the main task.
             */
            function getSubtaskTracker(parentTracker, impactOnTotalProgress, subtaskMsg) {
                return {
                    setMessage: function (progressMsg) {
                        // The parent should show a concatenation of its message along with
                        // its subtask tracker message.
                        parentTracker.setMessage(subtaskMsg + ': ' + progressMsg);
                    },
                    updateProgress: function (incrementValue) {
                        // Update the parent progress relative to the child progress.
                        // For example, if the sub-task progresses by 30%, and the impact on the
                        // total progress is 50%, then the task progresses by 30% * 50% = 15%.
                        parentTracker.updateProgress(incrementValue * impactOnTotalProgress / 100);
                    },
                    reportError: function (msg, err) {
                        // The parent should show a concatenation of its message along with
                        // its subtask error message.
                        parentTracker.reportError(subtaskMsg + ': ' + msg, err);
                    }
                };
            }
            util.getSubtaskTracker = getSubtaskTracker;
            /**
             * Runs an expensive task and return the result.
             */
            function runTask(msg, incProgressValue, task, tracker) {
                // Update the progress message to say the current running task.
                tracker.setMessage(msg);
                // Run the expensive task with a delay that gives enough time for the
                // UI to update.
                try {
                    var result = tf.graph.util.time(msg, task);
                    // Update the progress value.
                    tracker.updateProgress(incProgressValue);
                    // Return the result to be used by other tasks.
                    return result;
                }
                catch (e) {
                    // Errors that happen inside asynchronous tasks are
                    // reported to the tracker using a user-friendly message.
                    tracker.reportError('Failed ' + msg, e);
                }
            }
            util.runTask = runTask;
            /**
             * Runs an expensive task asynchronously and returns a promise of the result.
             */
            function runAsyncTask(msg, incProgressValue, task, tracker) {
                return new Promise(function (resolve, reject) {
                    // Update the progress message to say the current running task.
                    tracker.setMessage(msg);
                    // Run the expensive task with a delay that gives enough time for the
                    // UI to update.
                    setTimeout(function () {
                        try {
                            var result = tf.graph.util.time(msg, task);
                            // Update the progress value.
                            tracker.updateProgress(incProgressValue);
                            // Return the result to be used by other tasks.
                            resolve(result);
                        }
                        catch (e) {
                            // Errors that happen inside asynchronous tasks are
                            // reported to the tracker using a user-friendly message.
                            tracker.reportError('Failed ' + msg, e);
                        }
                    }, ASYNC_TASK_DELAY);
                });
            }
            util.runAsyncTask = runAsyncTask;
            /**
             * Returns a query selector with escaped special characters that are not
             * allowed in a query selector.
             */
            function escapeQuerySelector(querySelector) {
                return querySelector.replace(/([:.\[\],/\\\(\)])/g, '\\$1');
            }
            util.escapeQuerySelector = escapeQuerySelector;
            // For unit conversion.
            util.MEMORY_UNITS = [
                // Atomic unit.
                { symbol: 'B' },
                // numUnits specifies how many previous units this unit contains.
                { symbol: 'KB', numUnits: 1024 }, { symbol: 'MB', numUnits: 1024 },
                { symbol: 'GB', numUnits: 1024 }, { symbol: 'TB', numUnits: 1024 },
                { symbol: 'PB', numUnits: 1024 }
            ];
            util.TIME_UNITS = [
                // Atomic unit. Finest granularity in TensorFlow stat collection.
                { symbol: 's' },
                // numUnits specifies how many previous units this unit contains.
                { symbol: 'ms', numUnits: 1000 }, { symbol: 's', numUnits: 1000 },
                { symbol: 'min', numUnits: 60 }, { symbol: 'hr', numUnits: 60 },
                { symbol: 'days', numUnits: 24 }
            ];
            /**
             * Returns the human readable version of the unit.
             * (e.g. 1.35 GB, 23 MB, 34 ms, 6.53 min etc).
             */
            function convertUnitsToHumanReadable(value, units, unitIndex) {
                unitIndex = unitIndex == null ? 0 : unitIndex;
                if (unitIndex + 1 < units.length &&
                    value >= units[unitIndex + 1].numUnits) {
                    return tf.graph.util.convertUnitsToHumanReadable(value / units[unitIndex + 1].numUnits, units, unitIndex + 1);
                }
                // toPrecision() has the tendency to return a number in scientific
                // notation and (number - 0) brings it back to normal notation.
                return (value.toPrecision(3) - 0) + ' ' + units[unitIndex].symbol;
            }
            util.convertUnitsToHumanReadable = convertUnitsToHumanReadable;
            function hasDisplayableNodeStats(stats) {
                if (stats &&
                    (stats.totalBytes > 0 || stats.totalMicros > 0 || stats.outputSize)) {
                    return true;
                }
                return false;
            }
            util.hasDisplayableNodeStats = hasDisplayableNodeStats;
        })(util = graph.util || (graph.util = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {}));
</script>
<script>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var scene;
    (function (scene) {
        /** Show minimap when the viewpoint area is less than X% of the whole area. */
        var FRAC_VIEWPOINT_AREA = 0.8;
        var Minimap = (function () {
            /**
             * Constructs a new minimap.
             *
             * @param svg The main svg element.
             * @param zoomG The svg group used for panning and zooming the main svg.
             * @param mainZoom The main zoom behavior.
             * @param minimap The minimap container.
             * @param maxWandH The maximum width/height for the minimap.
             * @param labelPadding Padding in pixels due to the main graph labels.
             */
            function Minimap(svg, zoomG, mainZoom, minimap, maxWandH, labelPadding) {
                var _this = this;
                this.svg = svg;
                this.labelPadding = labelPadding;
                this.zoomG = zoomG;
                this.mainZoom = mainZoom;
                this.maxWandH = maxWandH;
                var $minimap = d3.select(minimap);
                // The minimap will have 2 main components: the canvas showing the content
                // and an svg showing a rectangle of the currently zoomed/panned viewpoint.
                var $minimapSvg = $minimap.select('svg');
                // Make the viewpoint rectangle draggable.
                var $viewpoint = $minimapSvg.select('rect');
                var dragmove = function (d) {
                    _this.viewpointCoord.x = d3.event.x;
                    _this.viewpointCoord.y = d3.event.y;
                    _this.updateViewpoint();
                };
                this.viewpointCoord = { x: 0, y: 0 };
                var drag = d3.behavior.drag().origin(Object).on('drag', dragmove);
                $viewpoint.datum(this.viewpointCoord).call(drag);
                // Make the minimap clickable.
                $minimapSvg.on('click', function () {
                    if (d3.event.defaultPrevented) {
                        // This click was part of a drag event, so suppress it.
                        return;
                    }
                    // Update the coordinates of the viewpoint.
                    var width = Number($viewpoint.attr('width'));
                    var height = Number($viewpoint.attr('height'));
                    var clickCoords = d3.mouse($minimapSvg.node());
                    _this.viewpointCoord.x = clickCoords[0] - width / 2;
                    _this.viewpointCoord.y = clickCoords[1] - height / 2;
                    _this.updateViewpoint();
                });
                this.viewpoint = $viewpoint.node();
                this.minimapSvg = $minimapSvg.node();
                this.minimap = minimap;
                this.canvas = $minimap.select('canvas.first').node();
                this.canvasBuffer =
                    $minimap.select('canvas.second').node();
                this.downloadCanvas =
                    $minimap.select('canvas.download').node();
                d3.select(this.downloadCanvas).style('display', 'none');
                this.update();
            }
            /**
             * Updates the position and the size of the viewpoint rectangle.
             * It also notifies the main svg about the new panned position.
             */
            Minimap.prototype.updateViewpoint = function () {
                // Update the coordinates of the viewpoint rectangle.
                d3.select(this.viewpoint)
                    .attr('x', this.viewpointCoord.x)
                    .attr('y', this.viewpointCoord.y);
                // Update the translation vector of the main svg to reflect the
                // new viewpoint.
                var mainX = -this.viewpointCoord.x * this.scaleMain / this.scaleMinimap;
                var mainY = -this.viewpointCoord.y * this.scaleMain / this.scaleMinimap;
                var zoomEvent = this.mainZoom.translate([mainX, mainY]).event;
                d3.select(this.zoomG).call(zoomEvent);
            };
            /**
             * Redraws the minimap. Should be called whenever the main svg
             * was updated (e.g. when a node was expanded).
             */
            Minimap.prototype.update = function () {
                var _this = this;
                var sceneSize = null;
                try {
                    // Get the size of the entire scene.
                    sceneSize = this.zoomG.getBBox();
                    if (sceneSize.width === 0) {
                        // There is no scene anymore. We have been detached from the dom.
                        return;
                    }
                }
                catch (e) {
                    // Firefox produced NS_ERROR_FAILURE if we have been
                    // detached from the dom.
                    return;
                }
                var $download = d3.select('#graphdownload');
                this.download = $download.node();
                $download.on('click', function (d) {
                    _this.download.href = _this.downloadCanvas.toDataURL('image/png');
                });
                var $svg = d3.select(this.svg);
                // Read all the style rules in the document and embed them into the svg.
                // The svg needs to be self contained, i.e. all the style rules need to be
                // embedded so the canvas output matches the origin.
                var stylesText = '';
                for (var k = 0; k < document.styleSheets.length; k++) {
                    try {
                        var cssRules = document.styleSheets[k].cssRules ||
                            document.styleSheets[k].rules;
                        if (cssRules == null) {
                            continue;
                        }
                        for (var i = 0; i < cssRules.length; i++) {
                            // Remove tf-* selectors from the styles.
                            stylesText +=
                                cssRules[i].cssText.replace(/ ?tf-[\w-]+ ?/g, '') + '\n';
                        }
                    }
                    catch (e) {
                        if (e.name !== 'SecurityError') {
                            throw e;
                        }
                    }
                }
                // Temporarily add the css rules to the main svg.
                var svgStyle = $svg.append('style');
                svgStyle.text(stylesText);
                // Temporarily remove the zoom/pan transform from the main svg since we
                // want the minimap to show a zoomed-out and centered view.
                var $zoomG = d3.select(this.zoomG);
                var zoomTransform = $zoomG.attr('transform');
                $zoomG.attr('transform', null);
                // Since we add padding, account for that here.
                sceneSize.height += this.labelPadding * 2;
                sceneSize.width += this.labelPadding * 2;
                // Temporarily assign an explicit width/height to the main svg, since
                // it doesn't have one (uses flex-box), but we need it for the canvas
                // to work.
                $svg.attr({
                    width: sceneSize.width,
                    height: sceneSize.height,
                });
                // Since the content inside the svg changed (e.g. a node was expanded),
                // the aspect ratio have also changed. Thus, we need to update the scale
                // factor of the minimap. The scale factor is determined such that both
                // the width and height of the minimap are <= maximum specified w/h.
                this.scaleMinimap =
                    this.maxWandH / Math.max(sceneSize.width, sceneSize.height);
                this.minimapSize = {
                    width: sceneSize.width * this.scaleMinimap,
                    height: sceneSize.height * this.scaleMinimap
                };
                // Update the size of the minimap's svg, the buffer canvas and the
                // viewpoint rect.
                d3.select(this.minimapSvg).attr(this.minimapSize);
                d3.select(this.canvasBuffer).attr(this.minimapSize);
                // Download canvas width and height are multiples of the style width and
                // height in order to increase pixel density of the PNG for clarity.
                d3.select(this.downloadCanvas).style({ width: sceneSize.width, height: sceneSize.height });
                d3.select(this.downloadCanvas).attr({ width: sceneSize.width * 3, height: sceneSize.height * 3 });
                if (this.translate != null && this.zoom != null) {
                    // Update the viewpoint rectangle shape since the aspect ratio of the
                    // map has changed.
                    requestAnimationFrame(function () { return _this.zoom(); });
                }
                // Serialize the main svg to a string which will be used as the rendering
                // content for the canvas.
                var svgXml = (new XMLSerializer()).serializeToString(this.svg);
                // Now that the svg is serialized for rendering, remove the temporarily
                // assigned styles, explicit width and height and bring back the pan/zoom
                // transform.
                svgStyle.remove();
                $svg.attr({
                    width: null,
                    height: null
                });
                $zoomG.attr('transform', zoomTransform);
                var image = new Image();
                image.onload = function () {
                    // Draw the svg content onto the buffer canvas.
                    var context = _this.canvasBuffer.getContext('2d');
                    context.clearRect(0, 0, _this.canvasBuffer.width, _this.canvasBuffer.height);
                    context.drawImage(image, 0, 0, _this.minimapSize.width, _this.minimapSize.height);
                    requestAnimationFrame(function () {
                        // Hide the old canvas and show the new buffer canvas.
                        d3.select(_this.canvasBuffer).style('display', null);
                        d3.select(_this.canvas).style('display', 'none');
                        // Swap the two canvases.
                        _a = [_this.canvasBuffer, _this.canvas], _this.canvas = _a[0], _this.canvasBuffer = _a[1];
                        var _a;
                    });
                    var downloadContext = _this.downloadCanvas.getContext('2d');
                    downloadContext.clearRect(0, 0, _this.downloadCanvas.width, _this.downloadCanvas.height);
                    downloadContext.drawImage(image, 0, 0, _this.downloadCanvas.width, _this.downloadCanvas.height);
                };
                image.onerror = function() {
                  var blob = new Blob([svgXml], {type: "image/svg+xml;charset=utf-8"});
                  image.src = URL.createObjectURL(blob);
                };
                image.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgXml);
            };
            /**
             * Handles changes in zooming/panning. Should be called from the main svg
             * to notify that a zoom/pan was performed and this minimap will update it's
             * viewpoint rectangle.
             *
             * @param translate The translate vector, or none to use the last used one.
             * @param scale The scaling factor, or none to use the last used one.
             */
            Minimap.prototype.zoom = function (translate, scale) {
                if (this.scaleMinimap == null) {
                    // Scene is not ready yet.
                    return;
                }
                // Update the new translate and scale params, only if specified.
                this.translate = translate || this.translate;
                this.scaleMain = scale || this.scaleMain;
                // Update the location of the viewpoint rectangle.
                var svgRect = this.svg.getBoundingClientRect();
                var $viewpoint = d3.select(this.viewpoint);
                this.viewpointCoord.x = -this.translate[0] * this.scaleMinimap /
                    this.scaleMain;
                this.viewpointCoord.y = -this.translate[1] * this.scaleMinimap /
                    this.scaleMain;
                var viewpointWidth = svgRect.width * this.scaleMinimap / this.scaleMain;
                var viewpointHeight = svgRect.height * this.scaleMinimap / this.scaleMain;
                $viewpoint.attr({
                    x: this.viewpointCoord.x,
                    y: this.viewpointCoord.y,
                    width: viewpointWidth,
                    height: viewpointHeight
                });
                // Show/hide the minimap depending on the viewpoint area as fraction of the
                // whole minimap.
                var mapWidth = this.minimapSize.width;
                var mapHeight = this.minimapSize.height;
                var x = this.viewpointCoord.x;
                var y = this.viewpointCoord.y;
                var w = Math.min(Math.max(0, x + viewpointWidth), mapWidth) -
                    Math.min(Math.max(0, x), mapWidth);
                var h = Math.min(Math.max(0, y + viewpointHeight), mapHeight) -
                    Math.min(Math.max(0, y), mapHeight);
                var fracIntersect = (w * h) / (mapWidth * mapHeight);
                if (fracIntersect < FRAC_VIEWPOINT_AREA) {
                    this.minimap.classList.remove('hidden');
                }
                else {
                    this.minimap.classList.add('hidden');
                }
            };
            return Minimap;
        }());
        scene.Minimap = Minimap;
    })(scene = tf.scene || (tf.scene = {}));
})(tf || (tf = {})); // close module tf.scene
</script>
<dom-module id="tf-graph-minimap" assetpath="../tf-graph/">
<template>
<style>
:host {
  background-color:white;
  transition: opacity .3s linear;
  pointer-events: auto;
}

:host.hidden {
  opacity: 0;
  pointer-events: none;
}

canvas {
  border: 1px solid #999;
}

rect {
  fill: white;
  stroke: #111111;
  stroke-width: 1px;
  fill-opacity: 0;
  filter: url("#minimapDropShadow");
  cursor: move;
}

svg {
  position: absolute;
}
</style>
<svg>
  <defs>
    <filter id="minimapDropShadow" x="-20%" y="-20%" width="150%" height="150%">
      <feOffset result="offOut" in="SourceGraphic" dx="1" dy="1"></feOffset>
      <feColorMatrix result="matrixOut" in="offOut" type="matrix" values="0.1 0 0 0 0 0 0.1 0 0 0 0 0 0.1 0 0 0 0 0 0.5 0"></feColorMatrix>
      <feGaussianBlur result="blurOut" in="matrixOut" stdDeviation="2"></feGaussianBlur>
      <feBlend in="SourceGraphic" in2="blurOut" mode="normal"></feBlend>
    </filter>
  </defs>
  <rect></rect>
</svg>
<canvas class="first"></canvas>

<canvas class="second"></canvas>
<canvas class="download"></canvas>
</template>
<script>
Polymer({
  is: 'tf-graph-minimap',

  /**
   * Initializes the minimap and returns a minimap object to notify when
   * things update.
   *
   * @param svg The main svg element.
   * @param zoomG The svg group used for panning and zooming the main svg.
   * @param mainZoom The main zoom behavior.
   * @param maxWandH The maximum width/height for the minimap.
   * @param labelPadding Padding in pixels due to the main graph labels.
   */
  init: function(svg, zoomG, mainZoom, maxWAndH, labelPadding) {
    return new tf.scene.Minimap(svg, zoomG, mainZoom, this, maxWAndH,
        labelPadding);
  }
});
</script>
</dom-module>

<dom-module id="tf-graph-scene" assetpath="../tf-graph/">
<template>
<style>
:host {
  display: flex;
  width: 100%;
  font-size: 20px;
}

::content #svg {
  overflow: hidden;
  flex: 1;
}

::content #hidden {
  position: fixed;
  top: 0px;
  visibility: hidden;
}

/* --- Node and annotation-node for Metanode --- */

::content .meta > .nodeshape > rect,
::content .meta > .annotation-node > rect {
  cursor: pointer;
  fill: hsl(0, 0%, 70%);
}

::content .node.meta.highlighted > .nodeshape > rect,
::content .node.meta.highlighted > .annotation-node > rect {
  stroke-width: 2;
}

::content .annotation.meta.highlighted > .nodeshape > rect,
::content .annotation.meta.highlighted > .annotation-node > rect {
  stroke-width: 1;
}

::content .meta.selected > .nodeshape > rect,
::content .meta.selected > .annotation-node > rect {
  stroke: red;
  stroke-width: 2;
}

::content .node.meta.selected.expanded > .nodeshape > rect,
::content .node.meta.selected.expanded > .annotation-node > rect {
  stroke: red;
  stroke-width: 3;
}

:content .annotation.meta.selected > .nodeshape > rect,
:content .annotation.meta.selected > .annotation-node > rect {
  stroke: red;
  stroke-width: 2;
}

::content .node.meta.selected.expanded.highlighted > .nodeshape > rect,
::content .node.meta.selected.expanded.highlighted > .annotation-node > rect {
  stroke: red;
  stroke-width: 4;
}

::content .faded,
::content .faded rect,
::content .faded ellipse,
::content .faded path,
::content #rectHatch line,
::content #ellipseHatch line {
  color: #e0d4b3 !important;
  fill: white;
  stroke: #e0d4b3 !important;
}


::content .faded path {
  stroke-width: 1px !important;
}

::content .faded rect {
  fill: url("#rectHatch") !important;
}

::content .faded ellipse {
  fill: url("#ellipseHatch") !important;
}

::content .faded text {
  opacity: 0;
}


/* --- Op Node --- */

::content .op > .nodeshape > ellipse,
::content .op > .annotation-node > ellipse {
  cursor: pointer;
  fill: #fff;
  stroke: #ccc;
}

::content .op.selected > .nodeshape > ellipse,
::content .op.selected > .annotation-node > ellipse {
  stroke: red;
  stroke-width: 2;
}

::content .op.highlighted > .nodeshape > ellipse,
::content .op.highlighted > .annotation-node > ellipse {
  stroke-width: 2;
}

/* --- Series Node --- */

/* By default, don't show the series background <rect>. */
::content .series > .nodeshape > rect {
  fill: hsl(0, 0%, 70%);
  fill-opacity: 0;
  stroke-dasharray: 5, 5;
  stroke-opacity: 0;
  cursor: pointer;
}

/* Once expanded, show the series background <rect> and hide the <use>. */
::content .series.expanded > .nodeshape > rect {
  fill-opacity: 0.15;
  stroke: hsl(0, 0%, 70%);
  stroke-opacity: 1;
}
::content .series.expanded > .nodeshape > use {
  visibility: hidden;
}

/**
 * TODO(jimbo): Simplify this by applying a stable class name to all <g>
 * elements that currently have either the nodeshape or annotation-node classes.
 */
::content .series > .nodeshape > use ,
::content .series > .annotation-node > use {
  stroke: #ccc;
}
::content .series.highlighted > .nodeshape > use ,
::content .series.highlighted > .annotation-node > use {
  stroke-width: 2;
}
::content .series.selected > .nodeshape > use ,
::content .series.selected > .annotation-node > use {
  stroke: red;
  stroke-width: 2;
}

::content .series.selected > .nodeshape > rect {
  stroke: red;
  stroke-width: 2;
}

::content .annotation.series.selected > .annotation-node > use {
  stroke: red;
  stroke-width: 2;
}

/* --- Bridge Node --- */
::content .bridge > .nodeshape > rect {
  stroke: #f0f;
  opacity: 0.2;
  display: none;
}

/* --- Structural Elements --- */
::content .edge > path.edgeline.structural {
  stroke: #f0f;
  opacity: 0.2;
  display: none;
}

/* --- Series Nodes --- */

/* Hide the rect for a series' annotation. */
::content .series > .annotation-node > rect {
  display: none;
}

/* --- Node label --- */


::content .node > text.nodelabel {
  cursor: pointer;
  fill: #444;
}

::content .meta.expanded > text.nodelabel {
  font-size: 9px;
}

::content .series > text.nodelabel {
  font-size: 8px;
}

::content .op > text.nodelabel {
  font-size: 6px;
}

::content .bridge > text.nodelabel {
  display: none;
}

::content .node.meta.expanded > text.nodelabel{
  cursor: normal;
}

::content .annotation.meta.highlighted > text.annotation-label {
  fill: #50A3F7;
}

::content .annotation.meta.selected > text.annotation-label {
  fill: #4285F4;
}

/* --- Annotation --- */

/* only applied for annotations that are not summary or constant.
(.summary, .constant gets overriden below) */
::content .annotation > .annotation-node > * {
  stroke-width: 0.5;
  stroke-dasharray: 1, 1;
}

::content .annotation.summary > .annotation-node > *,
::content .annotation.constant > .annotation-node > * {
  stroke-width: 1;
  stroke-dasharray: none;
}

::content .annotation > .annotation-edge {
  fill: none;
  stroke: #aaa;
  stroke-width: 0.5;
  marker-end: url("#annotation-arrowhead");
}

::content .faded .annotation > .annotation-edge {
  marker-end: url("#annotation-arrowhead-faded");
}

::content .annotation > .annotation-edge.refline {
  marker-start: url("#ref-annotation-arrowhead");
}

::content .faded .annotation > .annotation-edge.refline {
  marker-start: url("#ref-annotation-arrowhead-faded");
}

::content .annotation > .annotation-control-edge {
  stroke-dasharray: 1, 1;
}

::content #annotation-arrowhead {
  fill: #aaa;
}

::content #annotation-arrowhead-faded {
  fill: #e0d4b3;
}

::content #ref-annotation-arrowhead {
  fill: #aaa;
}

::content #ref-annotation-arrowhead-faded {
  fill: #e0d4b3;
}

::content .annotation > .annotation-label {
  font-size: 5px;
  cursor: pointer;
}
::content .annotation > .annotation-label.annotation-ellipsis {
  cursor: default;
}

/* Hide annotations on expanded meta nodes since they're redundant. */
::content .expanded > .in-annotations,
::content .expanded > .out-annotations {
  display: none;
}

/* --- Annotation: Constant --- */

::content .constant > .annotation-node > ellipse {
  cursor: pointer;
  fill: white;
  stroke: #848484;
}

::content .constant.selected > .annotation-node > ellipse {
  fill: white;
  stroke: red;
}

::content .constant.highlighted > .annotation-node > ellipse {
  stroke-width: 1.5;
}

/* --- Annotation: Summary --- */

::content .summary > .annotation-node > ellipse {
  cursor: pointer;
  fill: #DB4437;
  stroke: #DB4437;
}

::content .summary.selected > .annotation-node > ellipse {
  fill: #A52714;
  stroke: #A52714;
}

::content .summary.highlighted > .annotation-node > ellipse {
  stroke-width: 1.5;
}

/* --- Edge --- */

::content .edge > path.edgeline {
  fill: none;
  stroke: #bbb;
  stroke-linecap: round;
  stroke-width: 0.75;
}

/* Labels showing tensor shapes on edges */
::content .edge > text {
  font-size: 3.5px;
  fill: #666;
}

::content .ref-arrowhead {
  fill: #bbb;
}

::content .edge .control-dep {
  stroke-dasharray: 2, 2;
}

/* --- Group node expand/collapse button --- */

/* Hides expand/collapse buttons when a node isn't expanded or highlighted. Using
   incredibly small opacity so that the bounding box of the <g> parent still takes
   this container into account even when it isn't visible */
::content .node:not(.highlighted):not(.expanded) > .nodeshape > .buttoncontainer {
  opacity: 0.01;
}
::content .node.highlighted > .nodeshape > .buttoncontainer {
  cursor: pointer;
}
::content .buttoncircle {
  fill: #E7811D;
}
::content .buttoncircle:hover {
  fill: #B96717;
}
::content .expandbutton,
::content .collapsebutton {
  stroke: white;
}
/* Do not let the path elements in the button take pointer focus */
::content .node > .nodeshape > .buttoncontainer > .expandbutton,
::content .node > .nodeshape > .buttoncontainer > .collapsebutton {
  pointer-events: none;
}
/* Only show the expand button when a node is collapsed and only show the
   collapse button when a node is expanded. */
::content .node.expanded > .nodeshape > .buttoncontainer > .expandbutton {
  display: none;
}
::content .node:not(.expanded) > .nodeshape > .buttoncontainer > .collapsebutton {
  display: none;
}

.titleContainer {
  position: relative;
}

.title {
  position: absolute;
}

.auxTitle {
  position: absolute;
}

#minimap {
  position: absolute;
  right: 20px;
  bottom: 20px;
}
</style>
<div class="titleContainer">
  <div id="title" class="title">Main Graph</div>
  <div id="auxTitle" class="auxTitle">Auxiliary nodes</div>
</div>
<svg id="svg">
  <defs>

    
    <path id="ref-arrowhead-path" d="M 10,0 L 0,5 L 10,10 C 7,7 7,3 10,0"></path>
    <marker class="ref-arrowhead" id="ref-arrowhead-small" viewBox="0 0 10 10" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="userSpaceOnUse">
      <use xlink:href="#ref-arrowhead-path"></use>
    </marker>
    <marker class="ref-arrowhead" id="ref-arrowhead-medium" viewBox="0 0 10 10" markerWidth="13" markerHeight="13" refX="8" refY="5" orient="auto" markerUnits="userSpaceOnUse">
      <use xlink:href="#ref-arrowhead-path"></use>
    </marker>
    <marker class="ref-arrowhead" id="ref-arrowhead-large" viewBox="0 0 10 10" markerWidth="16" markerHeight="16" refX="8" refY="5" orient="auto" markerUnits="userSpaceOnUse">
      <use xlink:href="#ref-arrowhead-path"></use>
    </marker>
    <marker class="ref-arrowhead" id="ref-arrowhead-xlarge" viewBox="0 0 10 10" markerWidth="20" markerHeight="20" refX="8" refY="5" orient="auto" markerUnits="userSpaceOnUse">
      <use xlink:href="#ref-arrowhead-path"></use>
    </marker>

    
    <marker id="annotation-arrowhead" markerWidth="5" markerHeight="5" refX="5" refY="2.5" orient="auto">
      <path d="M 0,0 L 5,2.5 L 0,5 L 0,0"></path>
    </marker>
    <marker id="annotation-arrowhead-faded" markerWidth="5" markerHeight="5" refX="5" refY="2.5" orient="auto">
      <path d="M 0,0 L 5,2.5 L 0,5 L 0,0"></path>
    </marker>
    <marker id="ref-annotation-arrowhead" markerWidth="5" markerHeight="5" refX="0" refY="2.5" orient="auto">
      <path d="M 5,0 L 0,2.5 L 5,5 L 5,0"></path>
    </marker>
    <marker id="ref-annotation-arrowhead-faded" markerWidth="5" markerHeight="5" refX="0" refY="2.5" orient="auto">
      <path d="M 5,0 L 0,2.5 L 5,5 L 5,0"></path>
    </marker>
    
    <ellipse id="op-node-stamp" rx="7.5" ry="3" stroke="inherit" fill="inherit"></ellipse>
    
    <ellipse id="op-node-annotation-stamp" rx="5" ry="2" stroke="inherit" fill="inherit"></ellipse>
    
    <g id="op-series-vertical-stamp">
      <use xlink:href="#op-node-stamp" x="8" y="9"></use>
      <use xlink:href="#op-node-stamp" x="8" y="6"></use>
      <use xlink:href="#op-node-stamp" x="8" y="3"></use>
    </g>
    
    <g id="op-series-horizontal-stamp">
      <use xlink:href="#op-node-stamp" x="16" y="4"></use>
      <use xlink:href="#op-node-stamp" x="12" y="4"></use>
      <use xlink:href="#op-node-stamp" x="8" y="4"></use>
    </g>
    
    <g id="op-series-annotation-stamp">
      <use xlink:href="#op-node-annotation-stamp" x="9" y="2"></use>
      <use xlink:href="#op-node-annotation-stamp" x="7" y="2"></use>
      <use xlink:href="#op-node-annotation-stamp" x="5" y="2"></use>
    </g>
    <svg id="summary-icon" fill="#848484" height="12" viewBox="0 0 24 24" width="12">
      <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path>
    </svg>
    
    <g id="linearGradients"></g>

    
    <pattern id="rectHatch" patternTransform="rotate(45 0 0)" width="5" height="5" patternUnits="userSpaceOnUse">
      <line x1="0" y1="0" x2="0" y2="5" style="stroke-width: 1"></line>
    </pattern>
    <pattern id="ellipseHatch" patternTransform="rotate(45 0 0)" width="2" height="2" patternUnits="userSpaceOnUse">
      <line x1="0" y1="0" x2="0" y2="2" style="stroke-width: 1"></line>
    </pattern>
  </defs>
  
  <rect fill="white" width="10000" height="10000"></rect>
  <g id="root"></g>
</svg>
<tf-graph-minimap id="minimap"></tf-graph-minimap>
</template>
<script>
Polymer({
  is: 'tf-graph-scene',
  properties: {
    renderHierarchy: Object,
    name: String,
    colorBy: String,
    /** @type {d3_zoom} d3 zoom object */
    _zoom: Object,
    highlightedNode: {
      type: String,
      observer: '_highlightedNodeChanged'
    },
    selectedNode: {
      type: String,
      observer: '_selectedNodeChanged'
    },
    /** Keeps track of if the graph has been zoomed/panned since loading */
    _zoomed: {
      type: Boolean,
      observer: '_onZoomChanged',
      value: false
    },
    /** Keeps track of the starting coordinates of a graph zoom/pan */
    _zoomStartCoords: {
      type: Array,
      value: null
    },
    /** Keeps track of the current coordinates of a graph zoom/pan */
    _zoomCoords: {
      type: Array,
      value: null
    },
    /** Maximum distance of a zoom event for it to be interpreted as a click */
    _maxZoomDistanceForClick: {
      type: Number,
      value: 20
    },
    /**
     * @type {d3.scale.ordinal}
     * Scale mapping from template name to a number between 0 and N-1
     * where N is the number of different template names. Used by
     * tf.graph.scene.node when computing node color by structure.
     */
    templateIndex: Function,
    /**
     * @type {tf.scene.Minimap}
     * A minimap object to notify for zoom events.
     */
    minimap: Object,
    /*
     * Dictionary for easily stylizing nodes when state changes.
     * _nodeGroupIndex[nodeName] = d3_selection of the nodeGroup
     */
    _nodeGroupIndex: {
      type: Object,
      value: function() { return {}; }
    },
    /*
     * Dictionary for easily stylizing annotation nodes when state changes.
     * _annotationGroupIndex[nodeName][hostNodeName] =
     *   d3_selection of the annotationGroup
     */
    _annotationGroupIndex: {
      type: Object,
      value: function() { return {}; }
    },
    /*
     * Dictionary for easily stylizing edges when state changes.
     * _edgeGroupIndex[edgeName] = d3_selection of the edgeGroup
     */
    _edgeGroupIndex: {
      type: Object,
      value: function() { return {}; }
    },
    /**
     * Max font size for metanode label strings.
     */
    maxMetanodeLabelLengthFontSize: {
      type: Number,
      value: 9
    },
    /**
     * Min font size for metanode label strings.
     */
    minMetanodeLabelLengthFontSize: {
      type: Number,
      value: 6
    },
    /**
     * Metanode label strings longer than this are given smaller fonts.
     */
    maxMetanodeLabelLengthLargeFont: {
      type: Number,
      value: 11
    },
    /**
     * Metanode label strings longer than this are truncated with ellipses.
     */
    maxMetanodeLabelLength: {
      type: Number,
      value: 18
    },
    progress: Object
  },
  observers: [
    '_colorByChanged(colorBy)',
    '_buildAndFit(renderHierarchy)'
  ],
  getNode: function(nodeName) {
    return this.renderHierarchy.getRenderNodeByName(nodeName);
  },
  isNodeExpanded: function(node) {
    return node.expanded;
  },
  setNodeExpanded: function(renderNode) {
    this._build(this.renderHierarchy);
    this._updateLabels(!this._zoomed);
  },
  /**
   * Resets the state of the component. Called whenever the whole graph
   * (dataset) changes.
   */
  _resetState: function() {
    // Reset the state of the component.
    this._nodeGroupIndex = {};
    this._annotationGroupIndex = {};
    this._edgeGroupIndex = {};
    this._updateLabels(false);
    // Remove all svg elements under the 'root' svg group.
    d3.select(this.$.svg).select('#root').selectAll('*').remove();
    // And the defs.
    d3.select(this.$.svg).select('defs #linearGradients')
        .selectAll('*').remove();
  },
  /** Main method for building the scene */
  _build: function(renderHierarchy) {
    this.templateIndex = renderHierarchy.hierarchy.getTemplateIndex();
    tf.graph.util.time('tf-graph-scene (layout):', function() {
      // layout the scene for this meta / series node
      tf.graph.layout.layoutScene(renderHierarchy.root, this);
    }.bind(this));

    tf.graph.util.time('tf-graph-scene (build scene):', function() {
      tf.graph.scene.buildGroup(d3.select(this.$.root), renderHierarchy.root, this);
      tf.graph.scene.addGraphClickListener(this.$.svg, this);
    }.bind(this));
    // Update the minimap again when the graph is done animating.
    setTimeout(function() {
      this.minimap.update();
    }.bind(this), tf.graph.layout.PARAMS.animation.duration);
  },
  ready: function() {
    this._zoom = d3.behavior.zoom()
      .on('zoomend', function() {
        if (this._zoomStartCoords) {
          // Calculate the total distance dragged during the zoom event.
          // If it is sufficiently small, then fire an event indicating
          // that zooming has ended. Otherwise wait to fire the zoom end
          // event, so that a mouse click registered as part of this zooming
          // is ignored (as this mouse click was part of a zooming, and should
          // not be used to indicate an actual click on the graph).
          var dragDistance = Math.sqrt(
            Math.pow(this._zoomStartCoords[0] - this._zoomCoords[0], 2) +
            Math.pow(this._zoomStartCoords[1] - this._zoomCoords[1], 2));
          if (dragDistance < this._maxZoomDistanceForClick) {
            this._fireEnableClick();
          } else {
            setTimeout(this._fireEnableClick.bind(this), 50);
          }
        }
        this._zoomStartCoords = null;
      }.bind(this))
      .on('zoom', function() {
        // Store the coordinates of the zoom event
        this._zoomCoords = d3.event.translate;

        // If this is the first zoom event after a zoom-end, then
        // store the coordinates as the start coordinates as well,
        // and fire an event to indicate that zooming has started.
        // This doesn't use the zoomstart event, as d3 sends this
        // event on mouse-down, even if there has been no dragging
        // done to translate the graph around.
        if (!this._zoomStartCoords) {
          this._zoomStartCoords = this._zoomCoords.slice();
          this.fire('disable-click');
        }
        this._zoomed = true;
        d3.select(this.$.root).attr('transform',
                    'translate(' + d3.event.translate + ')' +
                    'scale(' + d3.event.scale + ')');
        // Notify the minimap.
        this.minimap.zoom(d3.event.translate, d3.event.scale);
      }.bind(this));
    d3.select(this.$.svg).call(this._zoom)
      .on('dblclick.zoom', null);
    d3.select(window).on('resize', function() {
      // Notify the minimap that the user's window was resized.
      // The minimap will figure out the new dimensions of the main svg
      // and will use the existing translate and scale params.
      this.minimap.zoom();
    }.bind(this));
    // Initialize the minimap.
    this.minimap = this.$.minimap.init(this.$.svg, this.$.root, this._zoom,
        tf.graph.layout.PARAMS.minimap.size,
        tf.graph.layout.PARAMS.subscene.meta.labelHeight);
  },
  _buildAndFit: function(renderHierarchy) {
    this._resetState();
    this._build(renderHierarchy);
    // Fit to screen after the graph is done animating.
    setTimeout(this.fit.bind(this), tf.graph.layout.PARAMS.animation.duration);
  },
  _updateLabels: function(showLabels) {
    var titleStyle = this.getElementsByClassName('title')[0].style;
    var auxTitleStyle = this.getElementsByClassName('auxTitle')[0].style;
    var core = d3.select("." + tf.graph.scene.Class.Scene.GROUP + ">." +
      tf.graph.scene.Class.Scene.CORE)[0][0];
    // Only show labels if the graph is fully loaded.
    if (showLabels && core && this.progress && this.progress.value === 100) {
      var aux =
        d3.select("." + tf.graph.scene.Class.Scene.GROUP + ">." +
          tf.graph.scene.Class.Scene.INEXTRACT)[0][0] ||
        d3.select("." + tf.graph.scene.Class.Scene.GROUP + ">." +
          tf.graph.scene.Class.Scene.OUTEXTRACT)[0][0];
      var coreX = core.getCTM().e;
      var auxX = aux ? aux.getCTM().e : null;
      titleStyle.display = 'inline';
      titleStyle.left = coreX + 'px';
      if (auxX !== null && auxX !== coreX) {
        auxTitleStyle.display = 'inline';
        auxTitleStyle.left = auxX + 'px';
      } else {
        auxTitleStyle.display = 'none';
      }
    } else {
      titleStyle.display='none';
      auxTitleStyle.display = 'none';
    }
  },
  /**
    * Called whenever the user changed the 'color by' option in the
    * UI controls.
    */
  _colorByChanged: function() {
    if (this.renderHierarchy != null) {
      // We iterate through each svg node and update its state.
      _.each(this._nodeGroupIndex, function(nodeGroup, nodeName) {
        this._updateNodeState(nodeName);
      }, this);
      // Notify also the minimap.
      this.minimap.update();
    }
  },
  fit: function() {
    tf.graph.scene.fit(this.$.svg, this.$.root, this._zoom, function() {
      this._zoomed = false;
    }.bind(this));
  },
  isNodeSelected: function(n) {
    return n === this.selectedNode;
  },
  isNodeHighlighted: function(n) {
    return n === this.highlightedNode;
  },
  addAnnotationGroup: function(a, d, selection) {
    var an = a.node.name;
    this._annotationGroupIndex[an] = this._annotationGroupIndex[an] || {};
    this._annotationGroupIndex[an][d.node.name] = selection;
  },
  getAnnotationGroupsIndex: function(a) {
    return this._annotationGroupIndex[a];
  },
  removeAnnotationGroup: function(a, d) {
    delete this._annotationGroupIndex[a.node.name][d.node.name];
  },
  addNodeGroup: function(n, selection) {
    this._nodeGroupIndex[n] = selection;
  },
  getNodeGroup: function(n) {
    return this._nodeGroupIndex[n];
  },
  removeNodeGroup: function(n) {
    delete this._nodeGroupIndex[n];
  },
  addEdgeGroup: function(n, selection) {
    this._edgeGroupIndex[e] = selection;
  },
  getEdgeGroup: function(e) {
    return this._edgeGroupIndex[e];
  },
  /**
   * Update node and annotation node of the given name.
   * @param  {String} n node name
   */
  _updateNodeState: function(n) {
    var node = this.getNode(n);
    var nodeGroup = this.getNodeGroup(n);

    if (nodeGroup) {
      tf.graph.scene.node.stylize(nodeGroup, node, this);
    }

    var annotationGroupIndex = this.getAnnotationGroupsIndex(n);
    _.each(annotationGroupIndex, function(aGroup, hostName) {
      tf.graph.scene.node.stylize(aGroup, node, this,
          tf.graph.scene.Class.Annotation.NODE);
    }, this);
  },

  _selectedNodeChanged: function(selectedNode, oldSelectedNode) {
    if (selectedNode === oldSelectedNode) {
      return;
    }

    if (selectedNode) {
      this._updateNodeState(selectedNode);
    }
    if (oldSelectedNode) {
      this._updateNodeState(oldSelectedNode);
    }

    if (!selectedNode) {
      return;
    }
    // Update the minimap to reflect the highlighted (selected) node.
    this.minimap.update();
    var node = this.renderHierarchy.hierarchy.node(selectedNode);
    var nodeParents = [];
    // Create list of all metanode parents of the selected node.
    while (node.parentNode != null
        && node.parentNode.name != tf.graph.ROOT_NAME) {
      node = node.parentNode;
      nodeParents.push(node.name);
    }
    // Ensure each parent metanode is built and expanded.
    var topParentNodeToBeExpanded;
    _.forEachRight(nodeParents, function(parentName) {
      this.renderHierarchy.buildSubhierarchy(parentName);
      var renderNode = this.renderHierarchy.getRenderNodeByName(parentName);
      if (renderNode.node.isGroupNode && !renderNode.expanded) {
        renderNode.expanded = true;
        if (!topParentNodeToBeExpanded) {
          topParentNodeToBeExpanded = renderNode;
        }
      }
    }, this);
    // If any expansion was needed to display this selected node, then
    // inform the scene of the top-most expansion.
    if (topParentNodeToBeExpanded) {
      this.setNodeExpanded(topParentNodeToBeExpanded);
      this._zoomed = true;
    }

    if (tf.graph.scene.panToNode(selectedNode, this.$.svg, this.$.root,
        this._zoom)) {
      this._zoomed = true;
    }
  },
  _highlightedNodeChanged: function(highlightedNode, oldHighlightedNode) {
    if (highlightedNode === oldHighlightedNode) {
      return;
    }

    if (highlightedNode) {
      this._updateNodeState(highlightedNode);
    }
    if (oldHighlightedNode) {
      this._updateNodeState(oldHighlightedNode);
    }
  },
  _onZoomChanged: function() {
    this._updateLabels(!this._zoomed);
  },
  _fireEnableClick: function() {
    this.fire('enable-click');
  },
});
</script>
</dom-module>
<dom-module id="tf-graph" assetpath="../tf-graph/">
<template>
<style>
.container {
  width: 100%;
  height: 100%;
  background: white;
  box-shadow: 0 1px 5px rgba(0,0,0,0.2);
}

.vertical {
  width:100%;
  height:100%;
  @apply(--layout-vertical);
}

.auto {
  @apply(--layout-flex-auto);
  @apply(--layout-vertical);
}

h2 {
  text-align: center;
}

paper-button {
  text-transform: none;
}
</style>
<div class="container">
  <div class="vertical">
    <h2>[[title]]</h2>
    <tf-graph-scene id="scene" class="auto" render-hierarchy="[[renderHierarchy]]" highlighted-node="[[_getVisible(highlightedNode)]]" selected-node="[[selectedNode]]" color-by="[[colorBy]]" progress="[[progress]]"></tf-graph-scene>
  </div>
</div>
</template>
</dom-module>

<script>
Polymer({

  is: 'tf-graph',

  properties: {
    graphHierarchy: {
      type: Object,
      notify: true,
      observer: '_graphChanged'
    },
    basicGraph: Object,
    stats: {
      type: Object,
      observer: '_statsChanged'
    },
    hierarchyParams: Object,
    progress: {
      type: Object,
      notify: true,
    },
    title: String,
    selectedNode: {
      type: String,
      notify: true,
    },
    highlightedNode: {
      type: String,
      notify: true
    },
    /** What to color the nodes by (compute time, memory, device etc.) */
    colorBy: String,
    colorByParams: {
      type: Object,
      notify: true,
      readOnly: true, // Produces and doesn't consume.
    },
    renderHierarchy: {
      type: Object,
      readOnly: true,
      notify: true,
    },
    _renderDepth: {
      type: Number,
      value: 1
    },
    _allowGraphSelect: {
      type: Boolean,
      value: true
    },
  },
  observers: [
    '_buildRenderHierarchy(graphHierarchy)'
  ],
  _statsChanged: function(stats) {
    if (this.graphHierarchy) {
      if (stats != null) {
        tf.graph.joinStatsInfoWithGraph(this.basicGraph, stats);
        tf.graph.hierarchy.joinAndAggregateStats(this.graphHierarchy, stats);
      }

      // Recompute the rendering information.
      this._buildRenderHierarchy(this.graphHierarchy);
    }
  },
  _buildRenderHierarchy: function(graphHierarchy) {
    tf.graph.util.time('new tf.graph.render.Hierarchy', function() {
      if (graphHierarchy.root.type !== tf.graph.NodeType.META) {
        // root must be metanode but sometimes Polymer's dom-if has not
        // remove tf-graph element yet in <tf-node-info>
        // and thus mistakenly pass non-metanode to this module.
        return;
      }
      var renderGraph = new tf.graph.render.RenderGraphInfo(
          graphHierarchy, !!this.stats /** displayingStats */);
      // Producing the 'color by' parameters to be consumed
      // by the tf-graph-controls panel. It contains information about the
      // min and max values and their respective colors, as well as list
      // of devices with their respective colors.

      function getColorParamsFromScale(scale) {
        return {
          minValue: scale.domain()[0],
          maxValue: scale.domain()[1],
          startColor: scale.range()[0],
          endColor: scale.range()[1]
        };
      }

      this._setColorByParams({
        compute_time: getColorParamsFromScale(renderGraph.computeTimeScale),
        memory: getColorParamsFromScale(renderGraph.memoryUsageScale),
        device: _.map(renderGraph.deviceColorMap.domain(),
            function(deviceName) {
          return {
            device: deviceName,
            color: renderGraph.deviceColorMap(deviceName)
          };
        })
      });
      this._setRenderHierarchy(renderGraph);
      this.async(function() {
        this.fire("rendered");
      });
    }.bind(this));
  },
  _getVisible: function(name) {
    if (!name) {
      return name;
    }
    return this.renderHierarchy.getNearestVisibleAncestor(name);
  },
  listeners: {
    'graph-select': '_graphSelected',
    'disable-click': '_disableClick',
    'enable-click': '_enableClick',
    // Nodes
    'node-toggle-expand': '_nodeToggleExpand',
    'node-select': '_nodeSelected',
    'node-highlight': '_nodeHighlighted',
    'node-unhighlight': '_nodeUnhighlighted',
    'node-toggle-extract': '_nodeToggleExtract',
    'node-toggle-seriesgroup': '_nodeToggleSeriesGroup',

    // Annotations

    /* Note: currently highlighting/selecting annotation node has the same
      * behavior as highlighting/selecting actual node so we point to the same
      * set of event listeners.  However, we might redesign this to be a bit
      * different.
      */
    'annotation-select': '_nodeSelected',
    'annotation-highlight': '_nodeHighlighted',
    'annotation-unhighlight': '_nodeUnhighlighted',
  },
  _graphChanged: function() {
    // When a new graph is loaded, fire this event so that there is no
    // info-card being displayed for the previously-loaded graph.
    this.fire('graph-select');
  },
  _graphSelected: function(event) {
    // Graph selection is not allowed during an active zoom event, as the
    // click seen during a zoom/pan is part of the zooming and does not
    // indicate a user desire to click on a specific section of the graph.
    if (this._allowGraphSelect) {
      this.set('selectedNode', null);
    }
    // Reset this variable as a bug in d3 zoom behavior can cause zoomend
    // callback not to be called if a right-click happens during a zoom event.
    this._allowGraphSelect = true;
  },
  _disableClick: function(event) {
    this._allowGraphSelect = false;
  },
  _enableClick: function(event) {
    this._allowGraphSelect = true;
  },
  _nodeSelected: function(event) {
    if (this._allowGraphSelect) {
      this.set('selectedNode', event.detail.name);
    }
    // Reset this variable as a bug in d3 zoom behavior can cause zoomend
    // callback not to be called if a right-click happens during a zoom event.
    this._allowGraphSelect = true;
  },
  _nodeHighlighted: function(event) {
    this.set('highlightedNode', event.detail.name);
  },
  _nodeUnhighlighted: function(event) {
    this.set('highlightedNode', null);
  },
  _nodeToggleExpand: function(event) {
    // Immediately select the node that is about to be expanded.
    this._nodeSelected(event);

    // Compute the sub-hierarchy scene.
    var nodeName = event.detail.name;
    var renderNode = this.renderHierarchy.getRenderNodeByName(nodeName);
    // Op nodes are not expandable.
    if (renderNode.node.type === tf.graph.NodeType.OP) {
      return;
    }
    this.renderHierarchy.buildSubhierarchy(nodeName);
    renderNode.expanded = !renderNode.expanded;

    // Expand the node with some delay so that the user can immediately see
    // the visual effect of selecting that node, before the expansion is
    // done.
    this.async(function() {
      this.querySelector('#scene').setNodeExpanded(renderNode);
    }, 75);
  },
  _nodeToggleExtract: function(event) {
    // Toggle the include setting of the specified node appropriately.
    var nodeName = event.detail.name;
    var renderNode = this.renderHierarchy.getRenderNodeByName(nodeName);
    if (renderNode.node.include == tf.graph.InclusionType.INCLUDE) {
      renderNode.node.include = tf.graph.InclusionType.EXCLUDE;
    } else if (renderNode.node.include == tf.graph.InclusionType.EXCLUDE) {
      renderNode.node.include = tf.graph.InclusionType.INCLUDE;
    } else {
      renderNode.node.include =
       this.renderHierarchy.isNodeAuxiliary(renderNode)
          ? tf.graph.InclusionType.INCLUDE : tf.graph.InclusionType.EXCLUDE;
    }

    // Rebuild the render hierarchy.
    this._buildRenderHierarchy(this.graphHierarchy);
  },
  _nodeToggleSeriesGroup: function(event) {
    // Toggle the group setting of the specified node appropriately.
    var nodeName = event.detail.name;
    tf.graph.toggleNodeSeriesGroup(this.hierarchyParams.seriesMap, nodeName);

    // Rebuild the render hierarchy with the updated series grouping map.
    this.set('progress', {
      value: 0,
      msg: ''
    });
    var tracker = tf.graph.util.getTracker(this);
    var hierarchyTracker = tf.graph.util.getSubtaskTracker(tracker, 100,
          'Namespace hierarchy');
    tf.graph.hierarchy.build(this.basicGraph, this.hierarchyParams, hierarchyTracker)
    .then(function(graphHierarchy) {
      this.set('graphHierarchy', graphHierarchy);
      this._buildRenderHierarchy(this.graphHierarchy);
    }.bind(this));
  },
  not: function(x) {
    return !x;
  }
});
</script>
<dom-module id="tf-graph-icon" assetpath="../tf-graph/">
  <style>
    .faded-rect {
      fill: url("#rectHatch");
    }

    .faded-ellipse {
      fill: url("#ellipseHatch");
    }

    .faded-rect, .faded-ellipse, .faded-series {
      stroke:   var(--tb-graph-faded) !important;
    }
  </style>
  <template>
    <template is="dom-if" if="[[_isType(node, type, 'OP')]]">
      <template is="dom-if" if="[[_isConst(node, const)]]">
        <svg height$="[[height]]" preserveAspectRatio="xMinYMid meet" viewBox="0 0 10 10">
          <circle cx="5" cy="5" r="3" fill$="[[_getFill(_computedFill, 'OP')]]" stroke$="[[_getStroke(_computedFill, 'OP')]]"></circle>
        </svg>
      </template>
      <template is="dom-if" if="[[_isSummary(node, summary)]]">
        <svg width$="[[height]]" height$="[[height]]" viewBox="0 0 12 12">
          <use x="0" y="0" xlink:href="#summary-icon"></use>
        </svg>
      </template>
      <template is="dom-if" if="[[_isRegularOp(node, const, summary)]]">
        <svg height$="[[height]]" preserveAspectRatio="xMinYMid meet" viewBox="0 0 16 8">
          <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#op-node-stamp" fill$="[[_getFill(_computedFill, 'OP')]]" stroke$="[[_getStroke(_computedFill, 'OP')]]" class$="{{_fadedClass(renderInfo, 'ellipse')}}" x="8" y="4"></use>
        </svg>
      </template>
    </template>
    <template is="dom-if" if="[[_isType(node, type, 'META')]]">
      <svg height$="[[height]]" preserveAspectRatio="xMinYMid meet" viewBox="0 0 37 16">
        <rect x="1" y="1" fill$="[[_getFill(_computedFill, 'META')]]" stroke$="[[_getStroke(_computedFill, 'META')]]" class$="{{_fadedClass(renderInfo, 'rect')}}" stroke-width="2px" height="14" width="35" rx="5" ry="5"></rect>
      </svg>
    </template>
    <template is="dom-if" if="[[_isType(node, type, 'SERIES')]]">
      <template is="dom-if" if="[[_isVertical(node, vertical)]]">
        <svg height$="[[height]]" preserveAspectRatio="xMinYMid meet" viewBox="0 0 16 15">
          <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#op-series-vertical-stamp" fill$="[[_getFill(_computedFill, 'SERIES')]]" stroke$="[[_getStroke(_computedFill, 'SERIES')]]" class$="{{_fadedClass(renderInfo, 'series')}}" x="0" y="2"></use>
        </svg>
      </template>
      <template is="dom-if" if="[[!_isVertical(node, vertical)]]">
        <svg height$="[[height]]" preserveAspectRatio="xMinYMid meet" viewBox="0 0 24 10">
          <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#op-series-horizontal-stamp" fill$="[[_getFill(_computedFill, 'SERIES')]]" stroke$="[[_getStroke(_computedFill, 'SERIES')]]" class$="{{_fadedClass(renderInfo, 'series')}}" x="0" y="1"></use>
        </svg>
      </template>
    </template>
  </template>

  <script>
    (function() {
      Polymer({
        is: 'tf-graph-icon',

        properties: {
          /**
           * Node to represent with an icon. Optional, but if specified, its
           * properties override those defined in the type, vertical, const and
           * summary properties.
           * @type {tf.graph.Node}
           */
          node: {
            type: Object,
            value: null
          },

          /**
           * Render node information associated with this node. Optional. If
           * specified, this is only used when computing the fill of the icon
           * element.
           * @type {tf.graph.render.RenderNodeInfo}
           */
          renderInfo: {
            type: Object,
            value: null
          },

          /**
           * String indicating the type of coloring to use for this node, used
           * only for determining the fill.
           */
          colorBy: {
            type: Object,
            value: "structural"
          },

          /**
           * Function used by structural coloring algorithm to determine which
           * color to use based on the template ID of the node. Optional.
           */
          templateIndex: {
            type: Function,
            value: null
          },

          /** Type of node to draw (ignored if node is set). */
          type: {
            type: String,
            value: null
          },

          /** Direction for series (ignored for other types). */
          vertical: {
            type: Boolean,
            value: false
          },

          /** Whether the op is Const (ignored for non-ops). */
          const: {
            type: Boolean,
            value: false
          },

          /** Whether the op is a Summary (ignored for non-ops). */
          summary: {
            type: Boolean,
            value: false
          },

          /**
           * Fill for the icon, optional. If fill is specified and node is not
           * specified, then this value will override the default for the
           * element. However, if node is specified, this value will be ignored.
           */
          fill: {
            type: String,
            value: null
          },

          /** Height of the SVG element in pixels, used for scaling. */
          height: {
            type: Number,
            value: 20
          },

          /** The computed fill for the node. **/
          _computedFill: {
            type: String,
            computed:
              "_getComputedFill(node, renderInfo, colorBy, templateIndex, fill)"
          }

        },

        /**
         * Get the computed fill value for the element.
         */
        _getComputedFill: function(inputNode, inputRenderInfo, inputColorBy,
            inputTemplateIndex, inputFill) {
          if (inputNode && inputRenderInfo &&
              inputColorBy && inputTemplateIndex) {
            var ns = tf.graph.scene.node;
            var colorBy = ns.ColorBy[inputColorBy.toUpperCase()];
            return ns.getFillForNode(inputTemplateIndex, colorBy,
                inputRenderInfo, false);
          }
          return inputFill;
        },

        /**
         * Get the fill value for the element, or if that's not possible, return
         * the default fill value for the node type.
         */
        _getFill: function(inputComputedFill, inputNodeType) {
          return inputComputedFill || ({
            OP: tf.graph.render.OpNodeColors.DEFAULT_FILL,
            META: tf.graph.render.MetanodeColors.DEFAULT_FILL,
            SERIES: tf.graph.render.SeriesNodeColors.DEFAULT_FILL
          })[inputNodeType];
        },

        /**
         * Get the stroke value for the element, or if that's not possible,
         * return the default stroke value for the node type.
         */
        _getStroke: function(inputComputedFill, inputNodeType) {
          return inputComputedFill ?
            tf.graph.scene.node.getStrokeForFill(inputComputedFill) :
            ({
              OP: tf.graph.render.OpNodeColors.DEFAULT_STROKE,
              META: tf.graph.render.MetanodeColors.DEFAULT_STROKE,
              SERIES: tf.graph.render.SeriesNodeColors.DEFAULT_STROKE
            })[inputNodeType];
        },

        /**
         * Test whether the specified node's type, or the literal type string,
         * match a particular other type.
         */
        _isType: function(inputNode, inputType, targetType) {
          if (inputNode) {
            return tf.graph.NodeType[inputNode.type] === targetType;
          }
          return inputType === targetType;
        },

        /**
         * Test whether the specified node should be represented as a vertical
         * series. Defaults to the value of the vertical property if node is
         * not specified.
         */
        _isVertical: function(inputNode, inputVertical) {
          if (inputNode) {
            return inputNode.hasNonControlEdges;
          }
          return !!inputVertical;
        },

        /**
         * Test whether the specified node is a constant. Defaults to the value
         * of the const property if node is not specified.
         */
        _isConst: function(inputNode, inputConst) {
          if (inputNode) {
            return inputNode.op === 'Const';
          }
          return !!inputConst;
        },

        /**
         * Test whether the specified node is a summary. Defaults to the value
         * of the summary property if node is not specified.
         */
        _isSummary: function(inputNode, inputSummary) {
          if (inputNode) {
            return this._isType(inputNode, null, 'OP') &&
                inputNode.op.substr(-7) === 'Summary';
          }
          return !!inputSummary;
        },

        /**
         * Test whether the op node is a regular non-summary non-const node.
         */
        _isRegularOp: function(inputNode, inputConst, inputSummary) {
          return !this._isConst(inputNode, inputConst) &&
              !this._isSummary(inputNode, inputSummary);
        },

        _fadedClass: function(itemRenderInfo, shape) {
          return itemRenderInfo && itemRenderInfo.isFadedOut ? 'faded-' + shape : '';
        }
      });
    })();
  </script>
</dom-module>
<dom-module id="tf-node-list-item" assetpath="../tf-graph-info/">
  <style>
  #list-item {
    width: 100%;
    color: #565656;
    font-size: 11pt;
    font-weight: 400;
    position: relative;
    display: inline-block;
  }

  #list-item:hover {
    background-color: var(--google-yellow-100);
  }

  .clickable {
    cursor: pointer;
  }

  #list-item span {
    margin-left: 40px;
  }

  #list-item.excluded span {
    color: #999;
  }

  #list-item span.edge-label {
    float: right;
    font-size: 10px;
    margin-left: 3px;
    margin-right: 5px;
  }

  .node-icon {
    position: absolute;
    top: 1px;
    left: 2px;
  }

  .faded span {
    color: var(--tb-graph-faded);
  }
  </style>
  <template>
    <div id="list-item" on-mouseover="_nodeListener" on-mouseout="_nodeListener" on-click="_nodeListener">
      <div class$="{{_fadedClass(itemRenderInfo)}}">
        <tf-graph-icon class="node-icon" height="12" color-by="[[colorBy]]" color-by-params="[[colorByParams]]" node="[[itemNode]]" render-info="[[itemRenderInfo]]" template-index="[[templateIndex]]"></tf-graph-icon>
        <span title$="[[name]]">[[name]]</span>
        <span class="edge-label">[[edgeLabel]]</span>
      </div>
    </div>
  </template>

  <script>
    (function() {
      Polymer({
        is: 'tf-node-list-item',

        properties: {
          /**
           * The Node for the card itself, on which this item is being drawn.
           * @type {tf.graph.Node}
           */
          cardNode: Object,
          /**
           * The Node for the item within the card, somehow related to cardNode.
           * @type {tf.graph.Node}
           */
          itemNode: Object,
          /** The edge label associated with this item. */
          edgeLabel: String,
          /**
           * The render node information for the item node. Used by the graph
           * icon in determining fill color.
           */
          itemRenderInfo: Object,
          name: String,
          itemType: {
            type: String,
            observer: '_itemTypeChanged'
          },
          colorBy: String,
          colorByParams: Object,
          templateIndex: Function
        },

        _itemTypeChanged: function() {
          if (this.itemType !== 'subnode') {
            this.$['list-item'].classList.add('clickable');
          } else {
            this.$['list-item'].classList.remove('clickable');
          }
        },

        _nodeListener: function(event) {
          // fire node.click/mouseover/mouseout
          this.fire('node-list-item-' + event.type, {
            cardNode: this.cardNode.name,
            nodeName: this.name,
            type: this.itemType
          });
        },

        _fadedClass: function(itemRenderInfo) {
          return itemRenderInfo && itemRenderInfo.isFadedOut ? 'faded' : '';
        }
      });
    })();
  </script>
</dom-module>
<dom-module id="tf-node-info" assetpath="../tf-graph-info/">
  <style>
  .sub-list-group {
    font-weight: 500;
    font-size: 12pt;
    padding-bottom: 8px;
    width: 100%;
  }

  .sub-list {
    max-height: 300px;
    overflow-y: scroll;
  }

  .attr-left {
    float: left;
    width: 30%;
    word-wrap: break-word;
    color: #565656;
    font-size: 11pt;
    font-weight: 400;
  }

  .attr-right {
    margin-left: 30%;
    word-wrap: break-word;
    color: #565656;
    font-weight: 400;
  }

  .sub-list-table {
    display: table;
    width: 100%;
  }

  .sub-list-table-row {
    display: table-row;
  }

  .sub-list-table-row .sub-list-table-cell:last-child {
    text-align: right;
  }

  .sub-list-table-cell {
    color: #565656;
    display: table-cell;
    font-size: 11pt;
    font-weight: 400;
    max-width: 200px;
    padding: 0 4px;
  }

  paper-item {
    padding: 0;
    background: #e9e9e9;
  }

  paper-item-body[two-line] {
    min-height: 0;
    padding: 8px 12px 4px;
  }

  .expandedInfo {
    padding: 8px 12px;
  }

  .controlDeps {
    padding: 0 0 0 8px;
  }

  .node-name {
    white-space: normal;
    word-wrap: break-word;
    font-size: 14pt;
    font-weight: 500;
  }

  .node-icon {
    float: right;
  }

  .subtitle {
    font-size: 12pt;
    color: #5e5e5e;
  }

  .controlLine {
    font-size: 11pt;
    font-weight: 400;
  }

  .toggle-button {
    float: right;
    max-height: 20px;
    max-width: 20px;
    padding: 0;
  }

  .control-toggle-button {
    float: left;
    max-height: 20px;
    max-width: 20px;
    padding: 0;
  }

  .toggle-include-group {
    padding-top: 4px;
  }

  .toggle-include {
    margin: 5px 6px;
    text-transform: none;
    padding: 4px 6px;
    font-size: 10pt;
    background-color: #fafafa;
    color: #666;
  }

  .toggle-include:hover {
    background-color: var(--google-yellow-100);
  }

  .non-control-list-item {
    padding-left: 10px;
  }
  </style>
  <template>
    <paper-item>
      <paper-item-body two-line="">
        <div>
          <paper-icon-button icon="{{_getToggleIcon(_expanded)}}" on-click="_toggleExpanded" class="toggle-button">
          </paper-icon-button>
          <div class="node-name" id="nodetitle"></div>
        </div>
        <div secondary="">
          <tf-graph-icon class="node-icon" node="[[_node]]" render-info="[[_getRenderInfo(nodeName, renderHierarchy)]]" color-by="[[colorBy]]" template-index="[[_templateIndex]]"></tf-graph-icon>
          <template is="dom-if" if="{{_node.op}}">
            <div class="subtitle">
              Operation:
              <span>[[_node.op]]</span>
            </div>
          </template>
          <template is="dom-if" if="{{_node.metagraph}}">
            <div class="subtitle">
              Subgraph:
              <span>[[_node.cardinality]]</span> nodes
            </div>
          </template>
        </div>
      </paper-item-body>
    </paper-item>
    <iron-collapse opened="{{_expanded}}">
    <template is="dom-if" if="{{_expanded}}" restamp="true">
      <div class="expandedInfo">
        <div class="sub-list-group attributes">
          Attributes
          (<span>[[_attributes.length]]</span>)
          <iron-list class="sub-list" id="attributesList" items="[[_attributes]]">
            <template>
              <div>
                <div class="attr-left">[[item.key]]</div>
                <div class="attr-right">[[item.value]]</div>
              </div>
            </template>
          </iron-list>
        </div>

        <template is="dom-if" if="{{_device}}">
          <div class="sub-list-group device">
            <div class="attr-left">Device</div>
            <div class="attr-right">[[_device]]</div>
          </div>
        </template>

        <div class="sub-list-group predecessors">
          Inputs
          (<span>[[_totalPredecessors]]</span>)
          <iron-list class="sub-list" id="inputsList" items="[[_predecessors.regular]]">
            <template>
              <tf-node-list-item class="non-control-list-item" card-node="[[_node]]" item-node="[[item.node]]" edge-label="[[item.edgeLabel]]" item-render-info="[[item.renderInfo]]" name="[[item.name]]" item-type="predecessors" color-by="[[colorBy]]" template-index="[[_templateIndex]]">
              </tf-node-list-item>
            </template>
          </iron-list>
          <template is="dom-if" if="[[_predecessors.control.length]]">
            <div class="controlDeps">
              <div class="controlLine">
                <paper-icon-button icon="{{_getToggleIcon(_openedControlPred)}}" on-click="_toggleControlPred" class="control-toggle-button">
                </paper-icon-button>
                Control dependencies
              </div>
              <iron-collapse opened="{{_openedControlPred}}" no-animation="">
                <template is="dom-if" if="{{_openedControlPred}}" restamp="true">
                  <iron-list class="sub-list" items="[[_predecessors.control]]">
                    <template>
                      <tf-node-list-item card-node="[[_node]]" item-node="[[item.node]]" item-render-info="[[item.renderInfo]]" name="[[item.name]]" item-type="predecessors" color-by="[[colorBy]]" template-index="[[_templateIndex]]">
                      </tf-node-list-item>
                    </template>
                  </iron-list>
                </template>
              </iron-collapse>
            </div>
          </template>
        </div>

        <div class="sub-list-group successors">
          Outputs
          (<span>[[_totalSuccessors]]</span>)
          <iron-list class="sub-list" id="outputsList" items="[[_successors.regular]]">
            <template>
              <tf-node-list-item class="non-control-list-item" card-node="[[_node]]" item-node="[[item.node]]" edge-label="[[item.edgeLabel]]" item-render-info="[[item.renderInfo]]" name="[[item.name]]" item-type="successor" color-by="[[colorBy]]" template-index="[[_templateIndex]]">
              </tf-node-list-item>
            </template>
          </iron-list>
          <template is="dom-if" if="[[_successors.control.length]]">
            <div class="controlDeps">
              <div class="controlLine">
                <paper-icon-button icon="{{_getToggleIcon(_openedControlSucc)}}" on-click="_toggleControlSucc" class="control-toggle-button">
                </paper-icon-button>
                Control dependencies
              </div>
              <iron-collapse opened="{{_openedControlSucc}}" no-animation="">
                <template is="dom-if" if="{{_openedControlSucc}}" restamp="true">
                  <iron-list class="sub-list" items="[[_successors.control]]">
                    <template>
                      <tf-node-list-item card-node="[[_node]]" item-node="[[item.node]]" item-render-info="[[item.renderInfo]]" name="[[item.name]]" item-type="successors" color-by="[[colorBy]]" template-index="[[_templateIndex]]">
                      </tf-node-list-item>
                    </template>
                  </iron-list>
                </template>
              </iron-collapse>
            </div>
          </template>
        </div>
        <template is="dom-if" if="{{_hasDisplayableNodeStats}}">
          <div class="sub-list-group node-stats">
            Node Stats
            <div class="sub-list-table">
              <template is="dom-if" if="{{_nodeStats.totalBytes}}">
                <div class="sub-list-table-row">
                  <div class="sub-list-table-cell">Memory</div>
                  <div class="sub-list-table-cell">[[_nodeStatsFormattedBytes]]</div>
                </div>
              </template>
              <template is="dom-if" if="{{_nodeStats.totalMicros}}">
                <div class="sub-list-table-row">
                  <div class="sub-list-table-cell">Compute Time</div>
                  <div class="sub-list-table-cell">[[_nodeStatsFormattedComputeTime]]</div>
                </div>
              </template>
              <template is="dom-if" if="{{_nodeStats.outputSize}}">
                <div class="sub-list-table-row">
                  <div class="sub-list-table-cell">Tensor Output Sizes</div>
                  <div class="sub-list-table-cell">
                    <template is="dom-repeat" items="{{_nodeStatsFormattedOutputSizes}}">
                      [[item]] <br>
                    </template>
                  </div>
                </div>
              </template>
            </div>
          </div>
        </template>
        <div class="toggle-include-group">
          <paper-button raised="" class="toggle-include" on-click="_toggleInclude">
            <span>[[_auxButtonText]]</span>
          </paper-button>
        </div>
        <template is="dom-if" if="{{_isInSeries(_node)}}">
          <div class="toggle-include-group">
            <paper-button raised="" class="toggle-include" on-click="_toggleGroup">
              <span>[[_groupButtonText]]</span>
            </paper-button>
          </div>
        </template>
      </div>
    </template>
    </iron-collapse>
  </template>

  <script>
    (function() {
      Polymer({
        is: 'tf-node-info',

        properties: {
          nodeName: String,
          graphHierarchy: Object,
          renderHierarchy: Object,
          /** What to color the nodes by (compute time, memory, device etc.) */
          colorBy: String,
          _templateIndex: {
            type: Function,
            computed: '_getTemplateIndex(graphHierarchy)'
          },
          _node: {
            type: Object,
            computed: '_getNode(nodeName, graphHierarchy)',
            observer: '_resetState'
          },
          _nodeStats: {
            type: Object,
            computed: '_getNodeStats(nodeName, graphHierarchy)',
            observer: '_resetState'
          },
          _hasDisplayableNodeStats: {
            type: Object,
            computed: '_getHasDisplayableNodeStats(_nodeStats)',
          },
          _nodeStatsFormattedBytes: {
            type: String,
            computed: '_getNodeStatsFormattedBytes(_nodeStats)',
          },
          _nodeStatsFormattedComputeTime: {
            type: String,
            computed: '_getNodeStatsFormattedComputeTime(_nodeStats)',
          },
          _nodeStatsFormattedOutputSizes: {
            type: Array,
            computed: '_getNodeStatsFormattedOutputSizes(_nodeStats)',
          },
          // The enum value of the include property of the selected node.
          nodeInclude: {
            type: Number,
            observer: '_nodeIncludeStateChanged'
          },
          _attributes: {
            type: Array,
            computed: '_getAttributes(_node)'
          },
          _device: {
            type: String,
            computed: '_getDevice(_node)'
          },
          _successors: {
            type: Object,
            computed: '_getSuccessors(_node, graphHierarchy)'
          },
          _predecessors: {
            type: Object,
            computed: '_getPredecessors(_node, graphHierarchy)'
          },
          _subnodes: {
            type: Array,
            computed: '_getSubnodes(_node)'
          },
          _expanded: {
            type: Boolean,
            value: true
          },
          _totalPredecessors: {
            type: Number,
            computed: '_getTotalPred(_predecessors)'
          },
          _totalSuccessors: {
            type: Number,
            computed: '_getTotalSucc(_successors)'
          },
          _openedControlPred: {
            type: Boolean,
            value: false
          },
          _openedControlSucc: {
            type: Boolean,
            value: false
          },
          _auxButtonText: String,
          _groupButtonText: String
        },
        expandNode: function() {
          this.fire('_node.expand', this.node);
        },
        _getTemplateIndex: function(graphHierarchy) {
          return graphHierarchy.getTemplateIndex();
        },
        _getNode: function(nodeName, graphHierarchy) {
          return graphHierarchy.node(nodeName);
        },
        _getNodeStats: function(nodeName, graphHierarchy) {
          var node = this._getNode(nodeName, graphHierarchy);
          if (node) {
            return node.stats;
          }
          return null;
        },
        _getHasDisplayableNodeStats: function(stats) {
          return tf.graph.util.hasDisplayableNodeStats(stats);
        },
        _getNodeStatsFormattedBytes(stats) {
          if (!stats || !stats.totalBytes) {
            return;
          }

          return tf.graph.util.convertUnitsToHumanReadable(
              stats.totalBytes, tf.graph.util.MEMORY_UNITS);
        },
        _getNodeStatsFormattedComputeTime(stats) {
          if (!stats || !stats.totalMicros) {
            return;
          }

          return tf.graph.util.convertUnitsToHumanReadable(
              stats.totalMicros, tf.graph.util.TIME_UNITS);
        },
        _getNodeStatsFormattedOutputSizes(stats) {
          if (!stats || !stats.outputSize || !stats.outputSize.length) {
            return;
          }

          return _.map(stats.outputSize, function(shape) {
            if (shape.length === 0) {
              return "scalar";
            }
            return "[" + shape.join(", ") + "]";
          });
        },
        _getPrintableHTMLNodeName: function(nodeName) {
          // Insert an optional line break before each slash so that
          // long node names wrap cleanly at path boundaries.
          return (nodeName || '').replace(/\//g, '<wbr>/');
        },
        _getRenderInfo: function(nodeName, renderHierarchy) {
          return this.renderHierarchy.getOrCreateRenderNodeByName(nodeName);
        },
        _getAttributes: function(node) {
          this.async(this._resizeList.bind(this, "#attributesList"));
          if (!node || !node.attr) {
            return [];
          }
          var attrs = [];
          _.each(node.attr, function(entry) {
            // Unpack the "too large" attributes into separate attributes
            // in the info card, with values "too large to show".
            if (entry.key === tf.graph.LARGE_ATTRS_KEY) {
              attrs = attrs.concat(entry.value.list.s.map(function(key) {
                return {key: key, value: "Too large to show..."};
              }));
            } else {
              attrs.push({
                key: entry.key,
                value: JSON.stringify(entry.value)
              });
            }
          });
          return attrs;
        },
        _getDevice: function(node) {
          return node ? node.device : null;
        },
        _getSuccessors: function(node, hierarchy) {
          this.async(this._resizeList.bind(this, "#inputsList"));
          if (!node) {
            return {regular: [], control: []}
          }
          return this._convertEdgeListToEdgeInfoList(
            hierarchy.getSuccessors(node.name), false, node.isGroupNode);
        },
        _getPredecessors: function(node, hierarchy) {
          this.async(this._resizeList.bind(this, "#outputsList"));
          if (!node) {
            return {regular: [], control: []}
          }
          return this._convertEdgeListToEdgeInfoList(
            hierarchy.getPredecessors(node.name), true, node.isGroupNode);
        },
        _convertEdgeListToEdgeInfoList: function(list, isPredecessor, isGroupNode) {

          /**
           * Unpacks the metaedge into a list of base edge information
           * that can be rendered.
           */
          var unpackMetaedge = function(metaedge) {
            return _.map(metaedge.baseEdgeList, function(baseEdge) {
              name = isPredecessor ? baseEdge.v : baseEdge.w;
              return {
                name: name,
                node: this._getNode(name, this.graphHierarchy),
                edgeLabel: tf.graph.scene.edge.getLabelForBaseEdge(baseEdge,
                    this.renderHierarchy),
                renderInfo: this._getRenderInfo(name, this.renderHierarchy)
              };
            }, this);
          }.bind(this);

          /**
           * Converts a list of metaedges to a list of edge information
           * that can be rendered.
           */
          var toEdgeInfoList = function(edges) {
            var edgeInfoList = [];
            _.each(edges, function(metaedge) {
              var name = isPredecessor ? metaedge.v : metaedge.w;
              // Enumerate all the base edges if the node is an OpNode, or the
              // metaedge has only 1 edge in it.
              if (!isGroupNode || metaedge.baseEdgeList.length == 1) {
                edgeInfoList = edgeInfoList.concat(unpackMetaedge(metaedge));
              } else {
                edgeInfoList.push({
                  name: name,
                  node: this._getNode(name, this.graphHierarchy),
                  edgeLabel: tf.graph.scene.edge.getLabelForEdge(metaedge,
                      this.renderHierarchy),
                  renderInfo: this._getRenderInfo(name, this.renderHierarchy)
                });
              }
            }, this);
            return edgeInfoList;
          }.bind(this);

          return {
            regular: toEdgeInfoList(list.regular),
            control: toEdgeInfoList(list.control)
          };
        },
        _getSubnodes: function(node) {
          return node && node.metagraph ? node.metagraph.nodes() : null;
        },
        _getTotalPred: function(predecessors) {
          return predecessors.regular.length + predecessors.control.length;
        },
        _getTotalSucc: function(successors) {
          return successors.regular.length + successors.control.length;
        },
        _toggleControlPred: function() {
          this._openedControlPred = !this._openedControlPred;
        },
        _toggleControlSucc: function() {
          this._openedControlSucc = !this._openedControlSucc;
        },
        _toggleExpanded: function() {
          this._expanded = !this._expanded;
        },
        _getToggleIcon: function(expanded) {
          return expanded ? "expand-less" : "expand-more";
        },
        _resetState: function() {
          this._openedControlPred = false;
          this._openedControlSucc = false;

          this.set("_groupButtonText",
            tf.graph.scene.node.getGroupSettingLabel(this._node));

          if (this._node) {
            Polymer.dom(this.$.nodetitle).innerHTML =
              this._getPrintableHTMLNodeName(this._node.name);
          }
        },
        _resizeList: function(selector) {
          var list = document.querySelector(selector);
          if (list) {
            list.fire('iron-resize');
          }
        },
        _toggleInclude: function() {
          var graphElem = document.querySelector("#graph");
          graphElem.fire("node-toggle-extract", { name: this.nodeName });
          var graphBoardElem = document.querySelector("#graphboard");
          graphBoardElem.fire("node-toggle-extract");
        },
        _nodeIncludeStateChanged: function(include, oldInclude) {
          this.set("_auxButtonText",
            tf.graph.getIncludeNodeButtonString(include));
        },
        _toggleGroup: function() {
          var graphElem = document.querySelector("#graph");
          var seriesName = tf.graph.scene.node.getSeriesName(this._node);
          graphElem.fire("node-toggle-seriesgroup", { name: seriesName });
        },
        _isInSeries: function(node) {
          return tf.graph.scene.node.canBeInSeries(node);
        }
      });
    })();
  </script>
</dom-module>
<dom-module id="tf-graph-info" assetpath="../tf-graph-info/">
<template>
<style>
:host {
  font-size: 12px;
  margin: 0;
  padding: 0;
  display: block;
}

h2 {
  padding: 0;
  text-align: center;
  margin: 0;
}
</style>
<template is="dom-if" if="{{selectedNode}}">
  <paper-material elevation="1" class="card">
    <tf-node-info graph-hierarchy="[[graphHierarchy]]" render-hierarchy="[[renderHierarchy]]" flat-graph="[[graph]]" node-name="[[selectedNode]]" node-include="[[selectedNodeInclude]]" highlighted-node="{{highlightedNode}}" color-by="[[colorBy]]">
    </tf-node-info>
  </paper-material>
</template>
</template>
<script>
(function() {
  Polymer({
    is: 'tf-graph-info',

    properties: {
      title: String,
      graphHierarchy: Object,
      graph: Object,
      renderHierarchy: Object,
      colorBy: String,
      // Two-ways
      selectedNode: {
        type: String,
        notify: true
      },
      highlightedNode: {
        type: String,
        notify: true
      },
      // The enum value of the include property of the selected node.
      selectedNodeInclude: {
        type: Number,
        notify: true
      }
    },
    listeners: {
      'node-list-item-click': '_nodeListItemClicked',
      'node-list-item-mouseover': '_nodeListItemMouseover',
      'node-list-item-mouseout': '_nodeListItemMouseout'
    },
    _nodeListItemClicked: function(event) {
      this.selectedNode = event.detail.nodeName;
    },
    _nodeListItemMouseover: function(event) {
      this.highlightedNode = event.detail.nodeName;
    },
    _nodeListItemMouseout: function() {
      this.highlightedNode = null;
    }
  });
})();
</script>
</dom-module>


<dom-module id="tf-graph-board" assetpath="../tf-graph-board/">
<template>
<style>
::host {
  display: block;
}

/deep/ .close {
  position: absolute;
  cursor: pointer;
  left: 15px;
  bottom: 15px;
}

.container {
  width: 100%;
  height: 100%;
  opacity: 1;
}

.container.loading {
  cursor: progress;
  opacity: 0.1;
}

.container.loading.error {
  cursor: auto;
}

#info {
  position: absolute;
  right: 5px;
  top: 5px;
  padding: 0px;
  max-width: 380px;
  min-width: 320px;
  background-color: rgba(255,255,255,0.9);
  @apply(--shadow-elevation-2dp);
}

#main {
  width: 100%;
  height: 100%;
}

#progress-bar {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  position: absolute;
  top: 40px;
  left: 0;
  font-size: 13px;
}

#progress-msg {
  width: 400px;
  margin-bottom: 5px;
}

paper-progress {
  width: 400px;
  --paper-progress-height: 6px;
  --paper-progress-active-color: #f3913e;
}

.context-menu {
  position: absolute;
  display: none;
  background-color: #e2e2e2;
  border-radius: 2px;
  font-size: 14px;
  min-width: 150px;
  border: 1px solid #d4d4d4;
}

/deep/ .context-menu ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
  cursor: default;
}

/deep/ .context-menu ul li {
  padding: 4px 16px;
}

/deep/ .context-menu ul li:hover {
  background-color: #f3913e;
  color: white;
}
</style>
<template is="dom-if" if="[[_isNotComplete(progress)]]">
  <div id="progress-bar">
    <div id="progress-msg">[[progress.msg]]</div>
    <paper-progress value="[[progress.value]]"></paper-progress>
  </div>
</template>
<div class$="[[_getContainerClass(progress)]]">
  <div id="main">
    <tf-graph id="graph" graph-hierarchy="{{graphHierarchy}}" basic-graph="[[graph]]" hierarchy-params="[[hierarchyParams]]" render-hierarchy="{{_renderHierarchy}}" stats="[[stats]]" selected-node="{{_selectedNode}}" highlighted-node="{{_highlightedNode}}" color-by="[[colorBy]]" color-by-params="{{colorByParams}}" progress="{{progress}}"></tf-graph>
  </div>
  <div id="info">
    <tf-graph-info id="graph-info" title="selected" graph-hierarchy="[[graphHierarchy]]" render-hierarchy="[[_renderHierarchy]]" graph="[[graph]]" selected-node="{{_selectedNode}}" selected-node-include="{{_selectedNodeInclude}}" highlighted-node="{{_highlightedNode}}" color-by="[[colorBy]]" color-by-params="[[colorByParams]]"></tf-graph-info>
  </div>
  <div class="context-menu"></div>
</div>
</template>
</dom-module>

<script>
Polymer({
  is: 'tf-graph-board',
  properties: {
    // Public API.
    graphHierarchy: Object,
    graph: Object,
    stats: Object,
    /**
     * @type {value: number, msg: string}
     *
     * A number between 0 and 100 denoting the % of progress
     * for the progress bar and the displayed message.
     */
    progress: Object,
    colorBy: String,
    colorByParams: {
      type: Object,
      notify: true,
    },
    // Private API: Data routing between child components.
    _selectedNode: String,
    // The enum value of the include property of the selected node.
    _selectedNodeInclude: Number,
    _highlightedNode: String,
    _renderHierarchy: Object,
  },
  listeners: {
    'node-toggle-extract': '_nodeToggleExtract'
  },
  observers: [
    '_updateNodeInclude(_selectedNode)'
  ],
  /** True if the progress is not complete yet (< 100 %). */
  _isNotComplete: function(progress) {
    return progress.value < 100;
  },
  _getContainerClass: function(progress) {
    var result = 'container';
    if (progress.error) {
      result += ' error';
    }
    if (this._isNotComplete(progress)) {
      result += ' loading';
    }
    return result;
  },
  _updateNodeInclude: function(nodeName) {
    var node = this.graphHierarchy.node(nodeName);
    this.set("_selectedNodeInclude",
      node ? node.include : tf.graph.InclusionType.UNSPECIFIED);
  },
  _nodeToggleExtract: function() {
    this._updateNodeInclude(this._selectedNode);
  }
});
</script>
<dom-module id="tf-graph-controls" assetpath="../tf-graph/">
<template>
<style>
:host {
  font-size: 12px;
  color: gray;
  --paper-font-subhead: {
    font-size: 14px;
    color: gray;
  };
  --paper-dropdown-menu-icon: {
    width: 15px;
    height: 15px;
  };
  --paper-dropdown-menu-button: {
    padding: 0;
  };
  --paper-dropdown-menu-input: {
    padding: 0;
  };
  --paper-item-min-height: 30px;
}

paper-button[raised].keyboard-focus {
  font-weight: normal;
}

.run-dropdown {
  --paper-input-container: {
    padding: 9px 0 0 25px;
  };
}

.color-dropdown {
  --paper-input-container: {
    padding: 9px 0 0 13px;
  };
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

table td {
  padding: 0;
  margin: 0;
}

.allcontrols {
  width: 188px;
  padding: 0 30px;
}

.legend-holder {
  position: absolute;
  bottom: 0;
  padding-bottom: 10px;
}

paper-radio-button {
  display: block;
  padding: 5px;
}
svg.icon {
  width: 60px;
  height: 18px;
}
.icon ellipse {
  rx: 10px;
  ry: 5px;
  stroke: #CCC;
  stroke-width: 1px;
  fill: #FFFFFF;
  cy: 10px;
}
.icon rect {
  height: 14px;
  width: 35px;
  rx: 5px;
  ry: 5px;
  stroke: #CCC;
  stroke-width: 2px;
  fill: #D9D9D9;
}
.domainValues {
  margin-bottom: 10px;
  width: 165px;
}
.domainStart {
  float: left;
}
.domainEnd {
  float: right;
}
.colorBox {
  width: 20px;
}

.image-icon {
  width: 24px;
  height: 24px;
}

.gray {
  color: #666;
}

.title {
  font-size: 16px;
  margin: 8px 5px 8px 0;
  color: black;
}
.title small {
  font-weight: normal;
}
.deviceList {
  max-height: 100px;
  overflow-y: auto;
}

#file {
  padding: 8px 0;
}

.color-legend-row {
  clear: both;
  height: 20px;
  margin-top: 5px;
  position: relative;
}

.color-legend-row svg {
  position: absolute;
  top: -1px;
  width: 40px;
}

.color-legend-row span.color-legend-value {
  margin-left: 60px;
}

#grey-rect {
  fill: #eee;
  stroke: #a6a6a6;
}

#faded-rect {
  fill: url("#rectHatch");
  stroke: var(--tb-graph-faded);
}

.button-text {
  text-transform: none;
  padding: 8px 18px 0 18px;
  font-size: 14px
}

.upload-button {
  width: 165px;
  height: 25px;
  text-transform: none;
  margin-top: 4px;
}

.iconbutton {
  padding: 2px;
  width: 30px;
  height: 30px;
  color: var(--paper-orange-500);
}

.hidden-input {
  height: 0px;
  width: 0px;
  overflow:hidden;
}

.allcontrols .control-holder {
  display: flex;
  clear: both;
}

.allcontrols .control-holder paper-radio-group {
  margin-top: 5px;
}

span.counter {
  font-size: 13px;
  color: gray;
}
</style>
<svg width="0" height="0">
  <defs>
    <g id="legend-rect">
      <rect x="1" y="1" stroke-width="2px" height="14" width="35" rx="5" ry="5"></rect>
    </g>
    <g id="grey-rect">
       <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#legend-rect"></use>
     </g>
     <g id="faded-rect">
       <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#legend-rect"></use>
     </g>
  </defs>
</svg>
<div class="allcontrols">
  <div class="control-holder">
    <paper-icon-button icon="aspect-ratio" class="iconbutton" on-click="fit" alt="Fit to screen">
    </paper-icon-button>
    <paper-button class="button-text" on-click="fit">Fit to screen
    </paper-button>
  </div>
  <div class="control-holder">
    <paper-icon-button icon="file-download" class="iconbutton" on-click="download" alt="Download PNG">
    </paper-icon-button>
    <paper-button class="button-text" on-click="download">Download PNG
    </paper-button>
    <a href="#" id="graphdownload" class="title" download="graph.png">
    </a>
  </div>
  <div class="control-holder">
    <div class="title">Run <span class="counter">([[datasets.length]])</span></div>
    <paper-dropdown-menu no-label-float="" no-animations="" noink="" class="run-dropdown">
      <paper-menu id="select" class="dropdown-content" selected="{{selectedDataset}}">
        <template is="dom-repeat" items="[[datasets]]">
          <paper-item>[[item.name]]</paper-item>
        </template>
      </paper-menu>
    </paper-dropdown-menu>
  </div>
  <div class="control-holder">
    <div class="title">Session runs <span class="counter">([[_numSessionRuns(metadataTags)]])</span></div>
    <paper-dropdown-menu no-label-float="" no-animations="" noink="" class="run-dropdown">
      <paper-menu id="select" class="dropdown-content" selected="{{selectedMetadataTag}}">
        <template is="dom-repeat" items="[[metadataTags]]">
          <paper-item>[[item.tag]]</paper-item>
        </template>
        <paper-item>None</paper-item>
      </paper-menu>
    </paper-dropdown-menu>
  </div>
  <div class="control-holder">
    <div class="title">Upload</div>
    <paper-button raised="" class="text-button upload-button" on-click="_getFile">Choose File</paper-button>
    <div class="hidden-input">
      <input type="file" id="file" name="file" on-change="_updateFileInput">
    </div>
  </div>
  <div class="control-holder">
    <div class="title">Color</div>
    <paper-radio-group selected="{{colorBy}}">
      <paper-radio-button name="structure">Structure</paper-radio-button>
      <paper-radio-button name="device">Device</paper-radio-button>
      <template is="dom-if" if="[[_statsNotNull(stats)]]">
        <paper-radio-button name="compute_time">Compute time</paper-radio-button>
        <paper-radio-button name="memory">Memory</paper-radio-button>
      </template>
    </paper-radio-group>
  </div>
  <div>
    <template is="dom-if" if="[[_isGradientColoring(colorBy)]]">
      <svg width="140" height="20" style="margin: 0 5px" class="color-text">
        <defs>
          <linearGradient id="linearGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop class="start" offset="0%" stop-color$="[[_currentGradientParams.startColor]]"></stop>
            <stop class="end" offset="100%" stop-color$="[[_currentGradientParams.endColor]]"></stop>
          </linearGradient>
        </defs>
        <rect x="0" y="0" width="135" height="20" fill="url(#linearGradient)" stroke="black"></rect>
      </svg>
      <div class="domainValues color-text">
        <div class="domainStart">[[_currentGradientParams.minValue]]</div>
        <div class="domainEnd">[[_currentGradientParams.maxValue]]</div>
      </div>
      <br style="clear: both">
    </template>
    <template is="dom-if" if="[[_equals(colorBy, 'structure')]]">
      <div class="color-text">
        <div class="color-legend-row">
          <div style="position: absolute;">
            colors
          </div>
          <span class="color-legend-value">same substructure</span>
        </div>
        <div class="color-legend-row">
          <svg>
            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#grey-rect" x="0" y="0"></use>
          </svg>
          <span class="color-legend-value">unique substructure</span>
        </div>
      </div>
    </template>
    <template is="dom-if" if="[[_equals(colorBy, 'device')]]">
      <div class="color-text">
        <div class="deviceList">
          <table>
          <template is="dom-repeat" items="[[colorByParams.device]]">
            <tr>
              <td style$="[[_getBackgroundColor(item.color)]]">
                <div class="colorBox"></div>
              </td>
              <td>
                <div>[[item.device]]</div>
              </td>
            </tr>
          </template>
          </table>
        </div>
        <br>
        <div class="color-legend-row">
          <svg>
            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#grey-rect" x="0" y="0"></use>
          </svg>
          <span class="color-legend-value">unknown device</span>
        </div>
      </div>
    </template>
    <template is="dom-if" if="[[_statsNotNull(stats)]]">
      <div class="color-legend-row">
        <svg>
          <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#faded-rect" x="0" y="0"></use>
        </svg>
        <span class="color-legend-value">unused substructure</span>
      </div>
    </template>
  </div>
  <div class="legend-holder">
    <table>
      <tbody><tr>
        <td><div class="title">Graph</div></td>
        <td>(* = expandable)</td>
      </tr>
      <tr>
        <td>
          <svg class="icon">
            <rect transform="translate(3, 1)" height="14" width="35" rx="5" ry="5"></rect>
          </svg>
        </td>
        <td>Namespace<span class="gray">*</span></td>
      </tr>
      <tr>
        <td>
          <svg class="icon" preserveAspectRatio="xMinYMid meet" viewBox="0 0 10 10">
            <use xlink:href="#op-node-stamp" fill="white" stroke="#ccc" x="9.5" y="6"></use>
          </svg>
        </td>
        <td>OpNode</td>
      </tr>
      <tr>
        <td>
          <svg class="icon" height="15px" preserveAspectRatio="xMinYMid meet" viewBox="0 0 12 12">
            <use xlink:href="#op-series-horizontal-stamp" fill="white" stroke="#ccc" x="2" y="2"></use>
          </svg>
        </td>
        <td>Unconnected series<span class="gray">*</span></td>
      </tr>
      <tr>
        <td>
          <svg class="icon" height="15px" preserveAspectRatio="xMinYMid meet" viewBox="0 0 15 15">
            <use xlink:href="#op-series-vertical-stamp" fill="white" stroke="#ccc" x="2" y="2"></use>
          </svg>
        </td>
        <td>Connected series<span class="gray">*</span></td>
      </tr>
      <tr>
        <td>
          <svg class="icon">
            <circle fill="white" stroke="#848484" cx="10" cy="10" r="5"></circle>
          </svg>
        </td>
        <td>Constant</td>
      </tr>
      <tr>
        <td>
          <svg class="image-icon" viewBox="0 0 12 12" width="24" height="24">
            <use x="0" y="0" class="image-icon" xlink:href="#summary-icon"></use>
          </svg>
        </td>
        <td>Summary</td>
      </tr>
      <tr>
        <td>
          <svg class="icon" height="15px" preserveAspectRatio="xMinYMid meet" viewBox="0 0 15 15">
            <defs>
              <marker id="ref-arrowhead-legend" fill="#bbb" markerWidth="10" markerHeight="10" refX="1" refY="5" orient="auto">
                <path d="M 10,0 L 0,5 L 10,10 C 7,7 7,3 10,0"></path>
              </marker>
            </defs>
            <path stroke="#bbb" d="M2 9 l 23 0" stroke-linecap="round"></path>
          </svg>
        </td>
        <td>Dataflow edge</td>
      </tr>
      <tr>
        <td>
          <svg class="icon" height="15px" preserveAspectRatio="xMinYMid meet" viewBox="0 0 15 15">
            <path stroke="#bbb" d="M2 9 l 23 0" stroke-linecap="round" stroke-dasharray="2, 2"></path>
          </svg>
        </td>
        <td>Control dependency edge</td>
      </tr>
      <tr>
        <td>
          <svg class="icon" height="15px" preserveAspectRatio="xMinYMid meet" viewBox="0 0 15 15">
            <path marker-start="url(#ref-arrowhead-legend)" stroke="#bbb" d="M2 9 l 23 0" stroke-linecap="round"></path>
          </svg>
        </td>
        <td>Reference edge</td>
      </tr>
    </tbody></table>
  </div>
  </div>
</template>
<script>
(function() { // Private scope.
Polymer({
  is: 'tf-graph-controls',
  properties: {
    // Public API.
    stats: Object,
    colorBy: {
      type: String,
      value: 'structure',
      notify: true,
      readonly: true
    },
    colorByParams: Object,
    datasets: {
      type: Array,
      observer: '_datasetsChanged'
    },
    metadataTags: {
      type: Array,
      computed: '_getMetadataTags(selectedDataset, datasets)'
    },
    selectedDataset: {
      type: Number,
      notify: true,
      value: 0,
      observer: '_selectedDatasetChanged'
    },
    selectedFile: {
      type: Object,
      notify: true
    },
    selectedMetadataTag: {
      type: Number,
      notify: true,
      value: -1
    },
    _currentGradientParams: {
      type: Object,
      computed: '_getCurrentGradientParams(colorByParams, colorBy)'
    }
  },
  _statsNotNull: function(stats) {
    return stats != null;
  },
  _numSessionRuns: function(metadataTags) {
    return metadataTags != null ? metadataTags.length : 0;
  },
  _getBackgroundColor: function(color) {
    return 'background-color:' + color;
  },
  fit: function() {
    document.querySelector('#scene').fit();
  },
  _isGradientColoring: function(colorBy) {
    return ["compute_time", "memory"].indexOf(colorBy) !== -1;
  },
  _equals: function(a, b) {
    return a === b;
  },
  _getCurrentGradientParams: function(colorByParams, colorBy) {
    if (!this._isGradientColoring(colorBy)) {
      return;
    }
    var params = colorByParams[colorBy];
    var minValue = params.minValue;
    var maxValue = params.maxValue;
    if (colorBy === 'memory') {
      minValue = tf.graph.util.convertUnitsToHumanReadable(
          minValue, tf.graph.util.MEMORY_UNITS);
      maxValue = tf.graph.util.convertUnitsToHumanReadable(
          maxValue, tf.graph.util.MEMORY_UNITS);
    } else if (colorBy === 'compute_time') {
      minValue = tf.graph.util.convertUnitsToHumanReadable(
          minValue, tf.graph.util.TIME_UNITS);
      maxValue = tf.graph.util.convertUnitsToHumanReadable(
          maxValue, tf.graph.util.TIME_UNITS);
    }
    return {
      minValue: minValue,
      maxValue: maxValue,
      startColor: params.startColor,
      endColor: params.endColor
    };
  },
  download: function() {
    this.$.graphdownload.click();
  },
  _updateFileInput: function(e) {
    var file = e.target.files[0];
    if (!file) {
      return;
    }
    this._setDownloadFilename(file.name);
    this.set('selectedFile', e);
  },
  _datasetsChanged: function(newDatasets, oldDatasets) {
    if (oldDatasets != null || this.selected == null) {
      // Select the first dataset by default.
      this.set('selectedDataset', 0);
      this._setDownloadFilename(this.datasets[this.selectedDataset].path);
    }
  },
  _getMetadataTags: function(selectedDataset, datasets) {
    return this.datasets[selectedDataset].runMetadata;
  },
  _selectedDatasetChanged: function(newDataset, oldDataset) {
    if (this.datasets) {
      this.set('selectedMetadataTag', -1);
      this.set('colorBy', 'structure');
      this._setDownloadFilename(this.datasets[newDataset].path);
    }
  },
  _getFile: function() {
    this.$.file.click();
  },
  _setDownloadFilename: function(graphPath) {
    // Strip off everything before the last "/" and strip off the file
    // extension in order to get the name of the PNG for the graph.
    var dotIndex = graphPath.lastIndexOf('.');
    if (dotIndex) {
      graphPath = graphPath.substring(0, dotIndex);
    }
    var slashIndex = graphPath.lastIndexOf('/');
    if (slashIndex) {
      graphPath = graphPath.substring(slashIndex + 1);
    }
    this.$.graphdownload.setAttribute('download', graphPath + '.png');
  }
});
})(); // Closing private scope.
</script>
</dom-module>


<dom-module id="tf-graph-dashboard" assetpath="../tf-graph-dashboard/">
<template>
<tf-no-data-warning data-type="graph" show-warning="[[_datasetsEmpty(_datasets)]]"></tf-no-data-warning>
<template is="dom-if" if="[[!_datasetsEmpty(_datasets)]]">
<tf-dashboard-layout>
<div class="sidebar">
  <tf-graph-controls id="controls" color-by-params="[[_colorByParams]]" stats="[[_stats]]" color-by="{{_colorBy}}" ,="" datasets="[[_datasets]]" selected-dataset="{{_selectedDataset}}" selected-file="{{_selectedFile}}" selected-metadata-tag="{{_selectedMetadataTag}}"></tf-graph-controls>
  <tf-graph-loader id="loader" datasets="[[_datasets]]" ,="" selected-dataset="[[_selectedDataset]]" selected-metadata-tag="[[_selectedMetadataTag]]" selected-file="[[_selectedFile]]" out-graph-hierarchy="{{_graphHierarchy}}" out-graph="{{_graph}}" out-stats="{{_stats}}" progress="{{_progress}}" out-hierarchy-params="{{_hierarchyParams}}"></tf-graph-loader>
</div>
<div class="center">
    <tf-graph-board id="graphboard" graph-hierarchy="[[_graphHierarchy]]" graph="[[_graph]]" stats="[[_stats]]" progress="[[_progress]]" color-by="[[_colorBy]]" color-by-params="{{_colorByParams}}" hierarchy-params="[[_hierarchyParams]]">
    </tf-graph-board>
</div>
</tf-dashboard-layout>
</template>
<style>

:host /deep/ {
  font-family: 'Roboto', sans-serif;
}

.center {
  position: relative;
  height: 100%;
}

</style>
</template>
</dom-module>

<script>
(function() {
Polymer({
  is: 'tf-graph-dashboard',
  properties: {
    _datasets: Object,
    backend: {type: Object, observer: 'reload'},
    router: {type: Object},
    runs: Array,
  },
  reload: function() {
    Promise.all([this.backend.graphRuns(), this.backend.runMetadataRuns()])
    .then(function(result) {
      var runsWithGraph = result[0];
      var runToMetadata = result[1];
      var datasets = _.map(runsWithGraph, function(runName) {
        return {
          name: runName,
          path: this.router.graph(runName, tf.graph.LIMIT_ATTR_SIZE,
            tf.graph.LARGE_ATTRS_KEY),
          runMetadata: runToMetadata[runName] ? _.map(runToMetadata[runName].sort(), function(tag) {
            return {
              tag: tag,
              path: this.router.runMetadata(tag, runName)
            };
          }, this) : []
        };
      }, this);
      this.set('_datasets', datasets);
    }.bind(this));
  },
  _datasetsEmpty: function(datasets) {
    return !datasets || !datasets.length;
  }
});
})();
</script>
</div><dom-module id="tf-tensorboard">
  <template>
    <paper-dialog with-backdrop="" id="settings">
      <h2>Settings</h2>
      <paper-checkbox id="auto-reload-checkbox" checked="{{autoReloadEnabled}}">
        Reload data every <span>[[autoReloadIntervalSecs]]</span>s.
      </paper-checkbox>
    </paper-dialog>
    <paper-header-panel>
      <paper-toolbar id="toolbar">
        <div id="toolbar-content">
          <div class="toolbar-title">TensorBoard</div>
          <paper-tabs selected="{{modeIndex}}" noink="" class="tabs" id="tabs">
            <template is="dom-repeat" items="[[tabs]]">
              <paper-tab data-mode="[[item]]">[[item]]</paper-tab>
            </template>
          </paper-tabs>
          <div class="global-actions">
            <paper-icon-button icon="refresh" on-tap="reload" disabled$="[[_modeIsGraphs(mode)]]" id="reload-button"></paper-icon-button>
            <paper-icon-button icon="settings" on-tap="openSettings" id="settings-button"></paper-icon-button>
            <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tensorboard/README.md" tabindex="-1">
              <paper-icon-button icon="help-outline"></paper-icon-button>
            </a>
          </div>
        </div>
      </paper-toolbar>

      <div id="content" class="fit">
        <content id="injected-overview"></content>

        <template is="dom-if" if="[[_modeIsEvents(mode)]]">
          <tf-event-dashboard id="events" backend="[[_backend]]" router="[[router]]"></tf-event-dashboard>
        </template>

        <template is="dom-if" if="[[_modeIsImages(mode)]]">
          <tf-image-dashboard id="images" backend="[[_backend]]"></tf-image-dashboard>
        </template>

        <template is="dom-if" if="[[_modeIsAudio(mode)]]">
          <tf-audio-dashboard id="audio" backend="[[_backend]]"></tf-audio-dashboard>
        </template>

        <template is="dom-if" if="[[_modeIsGraphs(mode)]]">
          <tf-graph-dashboard id="graphs" backend="[[_backend]]" router="[[router]]"></tf-graph-dashboard>
        </template>

        <template is="dom-if" if="[[_modeIsHistograms(mode)]]">
          <tf-histogram-dashboard id="histograms" backend="[[_backend]]"></tf-histogram-dashboard>
        </template>
      </div>
    </paper-header-panel>

    <style>
      :host {
        height: 100%;
        display: block;
        background-color: var(--paper-grey-100);
      }

      #toolbar {
        background-color: var(--tb-toolbar-background-color, --tb-orange-strong);
        -webkit-font-smoothing: antialiased;
      }

      .toolbar-title {
        font-size: 20px;
        margin-left: 10px;
        text-rendering: optimizeLegibility;
        letter-spacing: -0.025em;
        font-weight: 500;
        flex-grow: 2;
        display: var(--tb-toolbar-title-display, block);
      }

      .tabs {
        flex-grow: 1;
        text-transform: uppercase;
        height: 100%;
      }

      paper-tabs {
        --paper-tabs-selection-bar-color: white;
      }

      .global-actions {
        flex-grow: 2;
        display: inline-flex; /* Ensure that icons stay aligned */
        justify-content: flex-end;
        text-align: right;
        color: white;
      }

      .global-actions a {
        color: white;
      }

      #toolbar-content {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }

      #content {
        height: 100%;
      }

      [disabled] {
        opacity: 0.2;
        color: white;
      }

    </style>
  </template>
  <script>
    Polymer({
      is: "tf-tensorboard",
      behaviors: [TF.TensorBoard.AutoReloadBehavior],
      properties: {
        router: {
          type: Object,
          value: function() {return TF.Backend.router()},
        },
        _backend: {
          type: Object,
          computed: "_makeBackend(router)",
        },
        // Which tab is selected (events, graph, images etc).
        mode: {
          type: String,
          computed: '_getModeFromIndex(modeIndex)',
          notify: true,
        },
        // If true, tab switching in TensorBoard will not update
        // location hash. Hash update interferes with selenium tests.
        noHash: {
          type: Boolean,
          value: false
        },
        tabs: {
          type: Array,
          readOnly: true,
          value: TF.TensorBoard.TABS,
        },
      },
      _getModeFromIndex: function(modeIndex) {
        var mode = this.tabs[modeIndex];
        if (!this.noHash) {
          window.location.hash = mode;
        }
        return mode;
      },
      _makeBackend: function(router) {
        return new TF.Backend.Backend(router);
      },
      _modeIsEvents: function(mode) {
        return mode === "events";
      },
      _modeIsImages: function(mode) {
        return mode === "images";
      },
      _modeIsAudio: function(mode) {
        return mode === "audio";
      },
      _modeIsGraphs: function(mode) {
        return mode === "graphs";
      },
      _modeIsHistograms: function(mode) {
        return mode === "histograms";
      },
      selectedDashboard: function() {
        var dashboard = this.$$("#" + this.mode);
        if (dashboard == null) {
          throw new Error(`Unable to find dashboard for mode: ${this.mode}`);
        }
        return dashboard;
      },
      ready: function() {
        this._getModeFromHash();
        window.addEventListener('hashchange', function() {
          this._getModeFromHash();
        }.bind(this));
      },
      _getModeFromHash: function() {
        // Return the mode as it is stored in the hash.
        var tabName = window.location.hash.trim().slice(1);
        var modeIndex = this.tabs.indexOf(tabName);
        if (modeIndex == -1 && this.modeIndex == null) {
          // Selecting the first tab as default.
          this.set('modeIndex', 0);
        }
        if (modeIndex != -1 && modeIndex != this.modeIndex) {
          this.set('modeIndex', modeIndex);
        }
      },
      reload: function() {
        if (this.mode === "graphs") {
          return;
        }
        this.selectedDashboard().reload();
      },
      openSettings: function() {
        this.$.settings.open();
      },
    });
  </script>
</dom-module>
</body></html>